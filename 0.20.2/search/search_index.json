{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ormar","text":""},{"location":"#overview","title":"Overview","text":"<p>The <code>ormar</code> package is an async ORM for Python, with support for Postgres, MySQL, and SQLite.</p> <p>The main benefits of using <code>ormar</code> are:</p> <ul> <li>getting an async ORM that can be used with async frameworks (fastapi, starlette etc.)</li> <li>getting just one model to maintain - you don't have to maintain pydantic and other orm models (sqlalchemy, peewee, gino etc.)</li> </ul> <p>The goal was to create a simple ORM that can be used directly (as request and response models) with <code>fastapi</code> that bases it's data validation on pydantic.</p> <p>Ormar - apart from the obvious \"ORM\" in name - gets its name from ormar in Swedish which means snakes, and ormar(e) in Croatian which means cabinet.</p> <p>And what's a better name for python ORM than snakes cabinet :)</p> <p>If you like ormar remember to star the repository in github!</p> <p>The bigger community we build, the easier it will be to catch bugs and attract contributors ;)</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Check out the documentation for details.</p> <p>Note that for brevity most of the documentation snippets omit the creation of the database and scheduling the execution of functions for asynchronous run.</p> <p>If you want more real life examples than in the documentation you can see the tests folder, since they actually have to create and connect to a database in most of the tests.</p> <p>Yet remember that those are - well - tests and not all solutions are suitable to be used in real life applications.</p>"},{"location":"#part-of-the-fastapi-ecosystem","title":"Part of the <code>fastapi</code> ecosystem","text":"<p>As part of the fastapi ecosystem <code>ormar</code> is supported in selected libraries that somehow work with databases.</p> <p>Ormar remains sql dialect agnostic - so only columns working in all supported backends are implemented.</p> <p>It's relatively easy to implement columns for specific dialects as an extensions of ormar.</p> <p>Postgres specific columns implementation: <code>ormar-postgres-extensions</code></p> <p>If you maintain or use a different library and would like it to support <code>ormar</code> let us know how we can help.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Ormar is built with:</p> <ul> <li><code>sqlalchemy core</code> for query building.</li> <li><code>databases</code> for cross-database async support.</li> <li><code>pydantic</code> for data validation.</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>ormar</code> is built as open-source software and will remain completely free (MIT license).</p> <p>As I write open-source code to solve everyday problems in my work or to promote and build strong python community you can say thank you and buy me a coffee or sponsor me with a monthly amount to help ensure my work remains free and maintained.</p> <p> Sponsor <p></p>"},{"location":"#migrating-from-sqlalchemy-and-existing-databases","title":"Migrating from <code>sqlalchemy</code> and existing databases","text":"<p>If you currently use <code>sqlalchemy</code> and would like to switch to <code>ormar</code> check out the auto-translation tool that can help you with translating existing sqlalchemy orm models so you do not have to do it manually.</p> <p>Beta versions available at github: <code>sqlalchemy-to-ormar</code> or simply <code>pip install sqlalchemy-to-ormar</code></p> <p><code>sqlalchemy-to-ormar</code> can be used in pair with <code>sqlacodegen</code> to auto-map/ generate <code>ormar</code> models from existing database, even if you don't use <code>sqlalchemy</code> for your project.</p>"},{"location":"#migrations-database-creation","title":"Migrations &amp; Database creation","text":"<p>Because ormar is built on SQLAlchemy core, you can use <code>alembic</code> to provide database migrations (and you really should for production code).</p> <p>For tests and basic applications the <code>sqlalchemy</code> is more than enough: <pre><code># note this is just a partial snippet full working example below\n# 1. Imports\nimport sqlalchemy\nimport databases\nimport ormar\n\n# 2. Initialization\nDATABASE_URL = \"sqlite:///db.sqlite\"\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL),\n    engine=sqlalchemy.create_engine(DATABASE_URL),\n)\n\n# Define models here\n\n# 3. Database creation and tables creation\nbase_ormar_config.metadata.create_all(engine)\n</code></pre></p> <p>For a sample configuration of alembic and more information regarding migrations and database creation visit migrations documentation section.</p>"},{"location":"#package-versions","title":"Package versions","text":"<p>ormar is still under development: We recommend pinning any dependencies (with i.e. <code>ormar~=0.9.1</code>)</p> <p><code>ormar</code> also follows the release numeration that breaking changes bump the major number, while other changes and fixes bump minor number, so with the latter you should be safe to update, yet always read the releases docs before. <code>example: (0.5.2 -&gt; 0.6.0 - breaking, 0.5.2 -&gt; 0.5.3 - non breaking)</code>.</p>"},{"location":"#asynchronous-python","title":"Asynchronous Python","text":"<p>Note that <code>ormar</code> is an asynchronous ORM, which means that you have to <code>await</code> the calls to the methods, that are scheduled for execution in an event loop. Python has a builtin module <code>asyncio</code> that allows you to do just that.</p> <p>Note that most \"normal\" python interpreters do not allow execution of <code>await</code> outside of a function (because you actually schedule this function for delayed execution and don't get the result immediately).</p> <p>In a modern web framework (like <code>fastapi</code>), the framework will handle this for you, but if you plan to do this on your own you need to perform this manually like described in the quick start below.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Note that you can find the same script in examples folder on github.</p> <pre><code>from typing import Optional\n\nimport databases\n\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///db.sqlite\"\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL),\n    engine = sqlalchemy.create_engine(DATABASE_URL),\n)\n\n# note that this step is optional -&gt; all ormar cares is a field with name\n# ormar_config # and proper parameters, but this way you do not have to repeat\n# the same parameters if you use only one database\n#\n# Note that all type hints are optional\n# below is a perfectly valid model declaration\n# class Author(ormar.Model):\n#     ormar_config = base_ormar_config.copy(tablename=\"authors\")\n#\n#     id = ormar.Integer(primary_key=True) # &lt;= notice no field types\n#     name = ormar.String(max_length=100)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"authors\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"books\")\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n\n\n# create the database\n# note that in production you should use migrations\n# note that this is not required if you connect to existing database\n# just to be sure we clear the db before\nbase_ormar_config.metadata.drop_all(engine)\nbase_ormar_config.metadata.create_all(engine)\n\n\n# all functions below are divided into functionality categories\n# note how all functions are defined with async - hence can use await AND needs to\n# be awaited on their own\nasync def create():\n    # Create some records to work with through QuerySet.create method.\n    # Note that queryset is exposed on each Model's class as objects\n    tolkien = await Author.objects.create(name=\"J.R.R. Tolkien\")\n    await Book.objects.create(author=tolkien, title=\"The Hobbit\", year=1937)\n    await Book.objects.create(author=tolkien, title=\"The Lord of the Rings\", year=1955)\n    await Book.objects.create(author=tolkien, title=\"The Silmarillion\", year=1977)\n\n    # alternative creation of object divided into 2 steps\n    sapkowski = Author(name=\"Andrzej Sapkowski\")\n    # do some stuff\n    await sapkowski.save()\n\n    # or save() after initialization\n    await Book(author=sapkowski, title=\"The Witcher\", year=1990).save()\n    await Book(author=sapkowski, title=\"The Tower of Fools\", year=2002).save()\n\n    # to read more about inserting data into the database\n    # visit: https://collerek.github.io/ormar/queries/create/\n\n\nasync def read():\n    # Fetch an instance, without loading a foreign key relationship on it.\n    # Django style\n    book = await Book.objects.get(title=\"The Hobbit\")\n    # or python style\n    book = await Book.objects.get(Book.title == \"The Hobbit\")\n    book2 = await Book.objects.first()\n\n    # first() fetch the instance with lower primary key value\n    assert book == book2\n\n    # you can access all fields on loaded model\n    assert book.title == \"The Hobbit\"\n    assert book.year == 1937\n\n    # when no condition is passed to get()\n    # it behaves as last() based on primary key column\n    book3 = await Book.objects.get()\n    assert book3.title == \"The Tower of Fools\"\n\n    # When you have a relation, ormar always defines a related model for you\n    # even when all you loaded is a foreign key value like in this example\n    assert isinstance(book.author, Author)\n    # primary key is populated from foreign key stored in books table\n    assert book.author.pk == 1\n    # since the related model was not loaded all other fields are None\n    assert book.author.name is None\n\n    # Load the relationship from the database when you already have the related model\n    # alternatively see joins section below\n    await book.author.load()\n    assert book.author.name == \"J.R.R. Tolkien\"\n\n    # get all rows for given model\n    authors = await Author.objects.all()\n    assert len(authors) == 2\n\n    # to read more about reading data from the database\n    # visit: https://collerek.github.io/ormar/queries/read/\n\n\nasync def update():\n    # read existing row from db\n    tolkien = await Author.objects.get(name=\"J.R.R. Tolkien\")\n    assert tolkien.name == \"J.R.R. Tolkien\"\n    tolkien_id = tolkien.id\n\n    # change the selected property\n    tolkien.name = \"John Ronald Reuel Tolkien\"\n    # call update on a model instance\n    await tolkien.update()\n\n    # confirm that object was updated\n    tolkien = await Author.objects.get(name=\"John Ronald Reuel Tolkien\")\n    assert tolkien.name == \"John Ronald Reuel Tolkien\"\n    assert tolkien.id == tolkien_id\n\n    # alternatively update data without loading\n    await Author.objects.filter(name__contains=\"Tolkien\").update(name=\"J.R.R. Tolkien\")\n\n    # to read more about updating data in the database\n    # visit: https://collerek.github.io/ormar/queries/update/\n\n\nasync def delete():\n    silmarillion = await Book.objects.get(year=1977)\n    # call delete() on instance\n    await silmarillion.delete()\n\n    # alternatively delete without loading\n    await Book.objects.delete(title=\"The Tower of Fools\")\n\n    # note that when there is no record ormar raises NoMatch exception\n    try:\n        await Book.objects.get(year=1977)\n    except ormar.NoMatch:\n        print(\"No book from 1977!\")\n\n    # to read more about deleting data from the database\n    # visit: https://collerek.github.io/ormar/queries/delete/\n\n    # note that despite the fact that record no longer exists in database\n    # the object above is still accessible and you can use it (and i.e. save()) again.\n    tolkien = silmarillion.author\n    await Book.objects.create(author=tolkien, title=\"The Silmarillion\", year=1977)\n\n\nasync def joins():\n    # Tho join two models use select_related\n\n    # Django style\n    book = await Book.objects.select_related(\"author\").get(title=\"The Hobbit\")\n    # Python style\n    book = await Book.objects.select_related(Book.author).get(\n        Book.title == \"The Hobbit\"\n    )\n\n    # now the author is already prefetched\n    assert book.author.name == \"J.R.R. Tolkien\"\n\n    # By default you also get a second side of the relation\n    # constructed as lowercase source model name +'s' (books in this case)\n    # you can also provide custom name with parameter related_name\n\n    # Django style\n    author = await Author.objects.select_related(\"books\").all(name=\"J.R.R. Tolkien\")\n    # Python style\n    author = await Author.objects.select_related(Author.books).all(\n        Author.name == \"J.R.R. Tolkien\"\n    )\n    assert len(author[0].books) == 3\n\n    # for reverse and many to many relations you can also prefetch_related\n    # that executes a separate query for each of related models\n\n    # Django style\n    author = await Author.objects.prefetch_related(\"books\").get(name=\"J.R.R. Tolkien\")\n    # Python style\n    author = await Author.objects.prefetch_related(Author.books).get(\n        Author.name == \"J.R.R. Tolkien\"\n    )\n    assert len(author.books) == 3\n\n    # to read more about relations\n    # visit: https://collerek.github.io/ormar/relations/\n\n    # to read more about joins and subqueries\n    # visit: https://collerek.github.io/ormar/queries/joins-and-subqueries/\n\n\nasync def filter_and_sort():\n    # to filter the query you can use filter() or pass key-value pars to\n    # get(), all() etc.\n    # to use special methods or access related model fields use double\n    # underscore like to filter by the name of the author use author__name\n    # Django style\n    books = await Book.objects.all(author__name=\"J.R.R. Tolkien\")\n    # python style\n    books = await Book.objects.all(Book.author.name == \"J.R.R. Tolkien\")\n    assert len(books) == 3\n\n    # filter can accept special methods also separated with double underscore\n    # to issue sql query ` where authors.name like \"%tolkien%\"` that is not\n    # case sensitive (hence small t in Tolkien)\n    # Django style\n    books = await Book.objects.filter(author__name__icontains=\"tolkien\").all()\n    # python style\n    books = await Book.objects.filter(Book.author.name.icontains(\"tolkien\")).all()\n    assert len(books) == 3\n\n    # to sort use order_by() function of queryset\n    # to sort decreasing use hyphen before the field name\n    # same as with filter you can use double underscores to access related fields\n    # Django style\n    books = (\n        await Book.objects.filter(author__name__icontains=\"tolkien\")\n        .order_by(\"-year\")\n        .all()\n    )\n    # python style\n    books = (\n        await Book.objects.filter(Book.author.name.icontains(\"tolkien\"))\n        .order_by(Book.year.desc())\n        .all()\n    )\n    assert len(books) == 3\n    assert books[0].title == \"The Silmarillion\"\n    assert books[2].title == \"The Hobbit\"\n\n    # to read more about filtering and ordering\n    # visit: https://collerek.github.io/ormar/queries/filter-and-sort/\n\n\nasync def subset_of_columns():\n    # to exclude some columns from loading when querying the database\n    # you can use fileds() method\n    hobbit = await Book.objects.fields([\"title\"]).get(title=\"The Hobbit\")\n    # note that fields not included in fields are empty (set to None)\n    assert hobbit.year is None\n    assert hobbit.author is None\n\n    # selected field is there\n    assert hobbit.title == \"The Hobbit\"\n\n    # alternatively you can provide columns you want to exclude\n    hobbit = await Book.objects.exclude_fields([\"year\"]).get(title=\"The Hobbit\")\n    # year is still not set\n    assert hobbit.year is None\n    # but author is back\n    assert hobbit.author is not None\n\n    # also you cannot exclude primary key column - it's always there\n    # even if you EXPLICITLY exclude it it will be there\n\n    # note that each model have a shortcut for primary_key column which is pk\n    # and you can filter/access/set the values by this alias like below\n    assert hobbit.pk is not None\n\n    # note that you cannot exclude fields that are not nullable\n    # (required) in model definition\n    try:\n        await Book.objects.exclude_fields([\"title\"]).get(title=\"The Hobbit\")\n    except pydantic.ValidationError:\n        print(\"Cannot exclude non nullable field title\")\n\n    # to read more about selecting subset of columns\n    # visit: https://collerek.github.io/ormar/queries/select-columns/\n\n\nasync def pagination():\n    # to limit number of returned rows use limit()\n    books = await Book.objects.limit(1).all()\n    assert len(books) == 1\n    assert books[0].title == \"The Hobbit\"\n\n    # to offset number of returned rows use offset()\n    books = await Book.objects.limit(1).offset(1).all()\n    assert len(books) == 1\n    assert books[0].title == \"The Lord of the Rings\"\n\n    # alternatively use paginate that combines both\n    books = await Book.objects.paginate(page=2, page_size=2).all()\n    assert len(books) == 2\n    # note that we removed one book of Sapkowski in delete()\n    # and recreated The Silmarillion - by default when no order_by is set\n    # ordering sorts by primary_key column\n    assert books[0].title == \"The Witcher\"\n    assert books[1].title == \"The Silmarillion\"\n\n    # to read more about pagination and number of rows\n    # visit: https://collerek.github.io/ormar/queries/pagination-and-rows-number/\n\n\nasync def aggregations():\n    # count:\n    assert 2 == await Author.objects.count()\n\n    # exists\n    assert await Book.objects.filter(title=\"The Hobbit\").exists()\n\n    # maximum\n    assert 1990 == await Book.objects.max(columns=[\"year\"])\n\n    # minimum\n    assert 1937 == await Book.objects.min(columns=[\"year\"])\n\n    # average\n    assert 1964.75 == await Book.objects.avg(columns=[\"year\"])\n\n    # sum\n    assert 7859 == await Book.objects.sum(columns=[\"year\"])\n\n    # to read more about aggregated functions\n    # visit: https://collerek.github.io/ormar/queries/aggregations/\n\n\nasync def raw_data():\n    # extract raw data in a form of dicts or tuples\n    # note that this skips the validation(!) as models are\n    # not created from parsed data\n\n    # get list of objects as dicts\n    assert await Book.objects.values() == [\n        {\"id\": 1, \"author\": 1, \"title\": \"The Hobbit\", \"year\": 1937},\n        {\"id\": 2, \"author\": 1, \"title\": \"The Lord of the Rings\", \"year\": 1955},\n        {\"id\": 4, \"author\": 2, \"title\": \"The Witcher\", \"year\": 1990},\n        {\"id\": 5, \"author\": 1, \"title\": \"The Silmarillion\", \"year\": 1977},\n    ]\n\n    # get list of objects as tuples\n    assert await Book.objects.values_list() == [\n        (1, 1, \"The Hobbit\", 1937),\n        (2, 1, \"The Lord of the Rings\", 1955),\n        (4, 2, \"The Witcher\", 1990),\n        (5, 1, \"The Silmarillion\", 1977),\n    ]\n\n    # filter data - note how you always get a list\n    assert await Book.objects.filter(title=\"The Hobbit\").values() == [\n        {\"id\": 1, \"author\": 1, \"title\": \"The Hobbit\", \"year\": 1937}\n    ]\n\n    # select only wanted fields\n    assert await Book.objects.filter(title=\"The Hobbit\").values([\"id\", \"title\"]) == [\n        {\"id\": 1, \"title\": \"The Hobbit\"}\n    ]\n\n    # if you select only one column you could flatten it with values_list\n    assert await Book.objects.values_list(\"title\", flatten=True) == [\n        \"The Hobbit\",\n        \"The Lord of the Rings\",\n        \"The Witcher\",\n        \"The Silmarillion\",\n    ]\n\n    # to read more about extracting raw values\n    # visit: https://collerek.github.io/ormar/queries/aggregations/\n\n\nasync def with_connect(function):\n    # note that for any other backend than sqlite you actually need to\n    # connect to the database to perform db operations\n    async with database:\n        await function()\n\n    # note that if you use framework like `fastapi` you shouldn't connect\n    # in your endpoints but have a global connection pool\n    # check https://collerek.github.io/ormar/fastapi/ and section with db connection\n\n\n# gather and execute all functions\n# note - normally import should be at the beginning of the file\nimport asyncio\n\n# note that normally you use gather() function to run several functions\n# concurrently but we actually modify the data and we rely on the order of functions\nfor func in [\n    create,\n    read,\n    update,\n    delete,\n    joins,\n    filter_and_sort,\n    subset_of_columns,\n    pagination,\n    aggregations,\n    raw_data,\n]:\n    print(f\"Executing: {func.__name__}\")\n    asyncio.run(with_connect(func))\n\n# drop the database tables\nmetadata.drop_all(engine)\n</code></pre>"},{"location":"#ormar-specification","title":"Ormar Specification","text":""},{"location":"#queryset-methods","title":"QuerySet methods","text":"<ul> <li><code>create(**kwargs): -&gt; Model</code></li> <li><code>get(*args, **kwargs): -&gt; Model</code></li> <li><code>get_or_none(*args, **kwargs): -&gt; Optional[Model]</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li><code>first(*args, **kwargs): -&gt; Model</code></li> <li><code>update(each: bool = False, **kwargs) -&gt; int</code></li> <li><code>update_or_create(**kwargs) -&gt; Model</code></li> <li><code>bulk_create(objects: List[Model]) -&gt; None</code></li> <li><code>bulk_update(objects: List[Model], columns: List[str] = None) -&gt; None</code></li> <li><code>delete(*args, each: bool = False, **kwargs) -&gt; int</code></li> <li><code>all(*args, **kwargs) -&gt; List[Optional[Model]]</code></li> <li><code>iterate(*args, **kwargs) -&gt; AsyncGenerator[Model]</code></li> <li><code>filter(*args, **kwargs) -&gt; QuerySet</code></li> <li><code>exclude(*args, **kwargs) -&gt; QuerySet</code></li> <li><code>select_related(related: Union[List, str]) -&gt; QuerySet</code></li> <li><code>prefetch_related(related: Union[List, str]) -&gt; QuerySet</code></li> <li><code>limit(limit_count: int) -&gt; QuerySet</code></li> <li><code>offset(offset: int) -&gt; QuerySet</code></li> <li><code>count(distinct: bool = True) -&gt; int</code></li> <li><code>exists() -&gt; bool</code></li> <li><code>max(columns: List[str]) -&gt; Any</code></li> <li><code>min(columns: List[str]) -&gt; Any</code></li> <li><code>avg(columns: List[str]) -&gt; Any</code></li> <li><code>sum(columns: List[str]) -&gt; Any</code></li> <li><code>fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></li> <li><code>exclude_fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></li> <li><code>order_by(columns:Union[List, str]) -&gt; QuerySet</code></li> <li><code>values(fields: Union[List, str, Set, Dict])</code></li> <li><code>values_list(fields: Union[List, str, Set, Dict])</code></li> </ul>"},{"location":"#relation-types","title":"Relation types","text":"<ul> <li>One to many  - with <code>ForeignKey(to: Model)</code></li> <li>Many to many - with <code>ManyToMany(to: Model, Optional[through]: Model)</code></li> </ul>"},{"location":"#model-fields-types","title":"Model fields types","text":"<p>Available Model Fields (with required args - optional ones in docs):</p> <ul> <li><code>String(max_length)</code></li> <li><code>Text()</code></li> <li><code>Boolean()</code></li> <li><code>Integer()</code></li> <li><code>Float()</code></li> <li><code>Date()</code></li> <li><code>Time()</code></li> <li><code>DateTime()</code></li> <li><code>JSON()</code></li> <li><code>BigInteger()</code></li> <li><code>SmallInteger()</code></li> <li><code>Decimal(scale, precision)</code></li> <li><code>UUID()</code></li> <li><code>LargeBinary(max_length)</code></li> <li><code>Enum(enum_class)</code></li> <li><code>Enum</code> like Field - by passing <code>choices</code> to any other Field type</li> <li><code>EncryptedString</code> - by passing <code>encrypt_secret</code> and <code>encrypt_backend</code></li> <li><code>ForeignKey(to)</code></li> <li><code>ManyToMany(to)</code></li> </ul>"},{"location":"#available-fields-options","title":"Available fields options","text":"<p>The following keyword arguments are supported on all field types.</p> <ul> <li><code>primary_key: bool</code></li> <li><code>nullable: bool</code></li> <li><code>default: Any</code></li> <li><code>server_default: Any</code></li> <li><code>index: bool</code></li> <li><code>unique: bool</code></li> <li><code>name: str</code></li> </ul> <p>All fields are required unless one of the following is set:</p> <ul> <li><code>nullable</code> - Creates a nullable column. Sets the default to <code>False</code>. Read the fields common parameters for details.</li> <li><code>sql_nullable</code> - Used to set different setting for pydantic and the database. Sets the default to <code>nullable</code> value. Read the fields common parameters for details.</li> <li><code>default</code> - Set a default value for the field. Not available for relation fields</li> <li><code>server_default</code> - Set a default value for the field on server side (like sqlalchemy's <code>func.now()</code>). Not available for relation fields</li> <li><code>primary key</code> with <code>autoincrement</code> - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys.</li> </ul>"},{"location":"#available-signals","title":"Available signals","text":"<p>Signals allow to trigger your function for a given event on a given Model.</p> <ul> <li><code>pre_save</code></li> <li><code>post_save</code></li> <li><code>pre_update</code></li> <li><code>post_update</code></li> <li><code>pre_delete</code></li> <li><code>post_delete</code></li> <li><code>pre_relation_add</code></li> <li><code>post_relation_add</code></li> <li><code>pre_relation_remove</code></li> <li><code>post_relation_remove</code></li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>All contributions to ormar are welcomed!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>To make it as simple as possible for us to help you, please include the following:</p> <ul> <li>OS </li> <li>python version</li> <li>ormar version</li> <li>database backend (mysql, sqlite or postgresql)</li> </ul> <p>Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be quite straight forward to get started and create a Pull Request.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. </p> <p>You'll need to have python 3.6.2, 3.7, or 3.8, poetry, and git installed.</p> <pre><code># 1. clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/ormar.git\ncd ormar\n\n# 2. Install ormar, dependencies and test dependencies\npoetry install -E dev\n\n# 3. Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# make your changes...\n\n# 4. Formatting and linting\n# ormar uses black for formatting, flake8 for linting and mypy for type hints check\n# run all of the following as all those calls will be run on travis after every push\nblack ormar tests\nflake8 ormar\nmypy ormar tests\n\n# 5. Run tests\n# on localhost all tests are run against sglite backend\n# rest of the backends will be checked after push\npytest -svv --cov=ormar --cov=tests --cov-fail-under=100 --cov-report=term-missing\n\n# 6. Build documentation\nmkdocs build\n# if you have changed the documentation make sure it builds successfully\n# you can also use `mkdocs serve` to serve the documentation at localhost:8000\n\n# ... commit, push, and create your pull request\n</code></pre> <p>Tip</p> <p>For more information on how and why ormar works the way it works  please see the API documentation</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#installation","title":"Installation","text":"<p>Installation is as simple as:</p> <pre><code>pip install ormar\n</code></pre>"},{"location":"install/#dependencies","title":"Dependencies","text":"<p>Ormar uses <code>databases</code> for connectivity issues, <code>pydantic</code> for validation and <code>sqlalchemy-core</code> for queries.</p> <p>All three should install along the installation of ormar if not present at your system before.</p> <ul> <li>databases</li> <li>pydantic</li> <li>sqlalchemy </li> </ul> <p>The required versions are pinned in the pyproject.toml file.</p>"},{"location":"install/#optional-dependencies","title":"Optional dependencies","text":"<p>ormar has three optional dependencies based on database backend you use:</p>"},{"location":"install/#database-backend","title":"Database backend","text":""},{"location":"install/#postgresql","title":"Postgresql","text":"<p><pre><code>pip install ormar[postgresql]\n</code></pre> Will install also <code>asyncpg</code> and <code>psycopg2</code>.</p>"},{"location":"install/#mysql","title":"Mysql","text":"<pre><code>pip install ormar[mysql]\n</code></pre> <p>Will install also <code>aiomysql</code> and <code>pymysql</code>.</p>"},{"location":"install/#sqlite","title":"Sqlite","text":"<pre><code>pip install ormar[sqlite]\n</code></pre> <p>Will install also <code>aiosqlite</code>.</p>"},{"location":"install/#orjson","title":"Orjson","text":"<pre><code>pip install ormar[orjson]\n</code></pre> <p>Will install also <code>orjson</code> that is much faster than builtin json parser.</p>"},{"location":"install/#crypto","title":"Crypto","text":"<pre><code>pip install ormar[crypto]\n</code></pre> <p>Will install also <code>cryptography</code> that is required to work with encrypted columns.</p>"},{"location":"install/#manual-installation-of-dependencies","title":"Manual installation of dependencies","text":"<p>Of course, you can also install these requirements manually with <code>pip install asyncpg</code> etc.</p>"},{"location":"migration/","title":"Migration to 0.20.0 based on pydantic 2.X.X","text":"<p>Version 0.20.0 provides support for pydantic v2.X.X that provides significant speed boost (validation and serialization is written in rust) and cleaner api for developers, at the same time it drops support for pydantic v.1.X.X. There are changes in <code>ormar</code> interface corresponding to changes made in <code>pydantic</code>.</p>"},{"location":"migration/#breaking-changes","title":"Breaking changes","text":"<p>Migration to version &gt;= 0.20.0 requires several changes in order to work properly.</p>"},{"location":"migration/#ormar-model-configuration","title":"<code>ormar</code> Model configuration","text":"<p>Instead of defining a <code>Meta</code> class now each of the ormar models require an ormar_config parameter that is an instance of the <code>OrmarConfig</code> class. Note that the attribute must be named <code>ormar_config</code> and be an instance of the config class.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Album(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n        tablename = \"albums\"\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\n# ormar &gt;= 0.20\nclass AlbumV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n</code></pre>"},{"location":"migration/#ormarconfig-api-parameters","title":"<code>OrmarConfig</code> api/ parameters","text":"<p>The <code>ormar_config</code> expose the same set of settings as <code>Meta</code> class used to provide. That means that you can use any of the following parameters initializing the config:</p> <pre><code>metadata: Optional[sqlalchemy.MetaData]\ndatabase: Optional[databases.Database]\nengine: Optional[sqlalchemy.engine.Engine]\ntablename: Optional[str]\norder_by: Optional[List[str]]\nabstract: bool\nexclude_parent_fields: Optional[List[str]]\nqueryset_class: Type[QuerySet]\nextra: Extra\nconstraints: Optional[List[ColumnCollectionConstraint]]\n</code></pre>"},{"location":"migration/#basemeta-equivalent-best-practice","title":"<code>BaseMeta</code> equivalent - best practice","text":"<p>Note that to reduce the duplication of code and ease of development it's still recommended to create a base config and provide each of the models with a copy. OrmarConfig provides a convenient <code>copy</code> method for that purpose. </p> <p>The <code>copy</code> method accepts the same parameters as <code>OrmarConfig</code> init, so you can overwrite if needed, but by default it will return already existing attributes, except for: <code>tablename</code>, <code>order_by</code> and <code>constraints</code> which by default are cleared.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(\"sqlite:///db.sqlite\"),\n    metadata=sqlalchemy.MetaData()\n)\n\nclass AlbumV20(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        tablename=\"albums_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass TrackV20(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        tablename=\"tracks_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre>"},{"location":"migration/#choices-field-parameter-is-no-longer-supported","title":"<code>choices</code> Field parameter is no longer supported.","text":"<p>Before version 0.20 you could provide <code>choices</code> parameter to any existing ormar Field to limit the accepted values. This functionality was dropped, and you should use <code>ormar.Enum</code> field that was designed for this purpose.  If you want to keep the database field type (i.e. an Integer field) you can always write a custom validator.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Artist(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    country: str = ormar.String(default=False, max_length=50, choices=[\"UK\", \"US\", \"Vietnam\", \"Colombia\"])\n\n# ormar &gt;= 0.20\nfrom enum import Enum\n\nclass Country(str, Enum):\n    UK = \"UK\"\n    US = \"US\"\n    VIETNAM = \"Vietnam\"\n    COLOMBIA = \"Colombia\"\n\nclass ArtistV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"artists_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    country: Country = ormar.Enum(enum_class=Country)\n</code></pre>"},{"location":"migration/#pydantic_only-field-parameter-is-no-longer-supported","title":"<code>pydantic_only</code> Field parameter is no longer supported","text":"<p><code>pydantic_only</code> fields were already deprecated and are removed in v 0.20. Ormar allows defining pydantic fields as in ordinary pydantic model.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Dish(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n        tablename = \"dishes\"\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    cook: str = ormar.String(max_length=40, pydantic_only=True, default=\"sam\")\n\n# ormar &gt;= 0.20\nclass DishV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"dishes_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    cook: str = \"sam\"  # this is normal pydantic field\n</code></pre>"},{"location":"migration/#property_field-decorator-is-no-longer-supported","title":"<code>property_field</code> decorator is no longer supported","text":"<p><code>property_field</code> decorator was used to provide a way to pass calculated fields that were included in dictionary/ serialized json representation of the model. Version 2.X of pydantic introduced such a possibility, so you should now switch to the one native to the pydantic.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\nimport pydantic\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Employee(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=100)\n    last_name: str = ormar.String(max_length=100)\n\n    @ormar.property_field()\n    def full_name(self) -&gt; str:\n        return f\"{self.first_name} {self.last_name}\"\n\n# ormar &gt;= 0.20\nclass EmployeeV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=100)\n    last_name: str = ormar.String(max_length=100)\n\n    @pydantic.computed_field()\n    def full_name(self) -&gt; str:\n        return f\"{self.first_name} {self.last_name}\"\n</code></pre>"},{"location":"migration/#deprecated-methods","title":"Deprecated methods","text":"<p>All methods listed below are deprecated and will be removed in version 0.30 of <code>ormar</code>.</p>"},{"location":"migration/#dict-becomes-the-model_dump","title":"<code>dict()</code> becomes the <code>model_dump()</code>","text":"<pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\nclass Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\nalbum = Album(name=\"Dark Side of the Moon\")\n\n# ormar &lt; 0.20\nalbum_dict = album.dict()\n\n# ormar &gt;= 0.20\nnew_album_dict = album.model_dump() \n</code></pre> <p>Note that parameters remain the same i.e. <code>include</code>, <code>exclude</code> etc.</p>"},{"location":"migration/#json-becomes-the-model_dump_json","title":"<code>json()</code> becomes the <code>model_dump_json()</code>","text":"<pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\nclass Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\nalbum = Album(name=\"Dark Side of the Moon\")\n\n# ormar &lt; 0.20\nalbum_json= album.json()\n\n# ormar &gt;= 0.20\nnew_album_dict = album.model_dump_json() \n</code></pre> <p>Note that parameters remain the same i.e. <code>include</code>, <code>exclude</code> etc.</p>"},{"location":"migration/#construct-becomes-the-model_construct","title":"<code>construct()</code> becomes the <code>model_construct()</code>","text":"<pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\nclass Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\nparams = {\n    \"name\": \"Dark Side of the Moon\",\n    \"favorite\": True,\n}\n# ormar &lt; 0.20\nalbum = Album.construct(**params)\n\n# ormar &gt;= 0.20\nalbum = Album.model_construct(**params)\n</code></pre> <p>To read more about construct please refer to <code>pydantic</code> documentation.</p>"},{"location":"mypy/","title":"Use with mypy","text":"<p>To provide better errors check you should use mypy with pydantic plugin </p> <p>Please use notation introduced in version 0.4.0.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n    completed = ormar.Boolean(default=False)\n</code></pre> <p>Note that above example is not using the type hints, so further operations with mypy might fail, depending on the context.</p> <p>Preferred notation should look liked this:</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre>"},{"location":"plugin/","title":"PyCharm plugin","text":"<p>While <code>ormar</code> will work with any IDE there is a PyCharm <code>pydantic</code> plugin that enhances the user experience for this IDE.</p> <p>Plugin is available on the JetBrains Plugins Repository for PyCharm: plugin page.</p> <p>You can install the plugin for free from the plugin marketplace (PyCharm's Preferences -&gt; Plugin -&gt; Marketplace -&gt; search \"pydantic\").</p> <p>Note</p> <p>For plugin to work properly you need to provide valid type hints for model fields.</p> <p>Info</p> <p>Plugin supports type hints, argument inspection and more but mainly only for init methods</p> <p>More information can be found on the official plugin page and github repository.</p>"},{"location":"releases/","title":"Release notes","text":""},{"location":"releases/#0202","title":"0.20.2","text":""},{"location":"releases/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix mutable default argument in translate list to dict  - thanks @cadlagtrader #1382</li> <li>Fix fastapi docs - thanks @inktrap #1362</li> <li>Fix clashing many to many fields names #1407</li> </ul>"},{"location":"releases/#other","title":"\ud83d\udcac Other","text":"<ul> <li>Add official support for python 3.12 - thanks @ChristopherMacGown #1395</li> <li>Unpin pydantic allowing pydantic versions &lt;2.9.0 - thanks @camillol #1388</li> </ul>"},{"location":"releases/#release-notes_1","title":"Release notes","text":""},{"location":"releases/#0201","title":"0.20.1","text":""},{"location":"releases/#breaking-changes","title":"\u2728 Breaking changes","text":"<ul> <li>Note that this is the first non-beta release of ormar with support for Pydantic v2. Check release notes for 0.20.0 and https://collerek.github.io/ormar/0.20.0b1/migration/</li> </ul>"},{"location":"releases/#fixes_1","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix merging same target models when using <code>select_related</code> with <code>prefetch_related</code> #906</li> <li>Fix saving related with pk only models #812</li> <li>Fix adding the same relation multiple times corrupting relation cache #1335</li> </ul>"},{"location":"releases/#features","title":"\u2728 Features","text":"<ul> <li>Allow adding indexed on foreign keys by @cmflynn #1276</li> </ul>"},{"location":"releases/#other_1","title":"\ud83d\udcac Other","text":"<ul> <li>Some docs fixes by @Chaoyingz, thanks!</li> </ul>"},{"location":"releases/#0200","title":"0.20.0","text":""},{"location":"releases/#breaking-changes_1","title":"\u2728 Breaking changes","text":"<ul> <li> <p><code>ormar</code> Model configuration</p> <p>Instead of defining a <code>Meta</code> class now each of the ormar models require an ormar_config parameter that is an instance of the <code>OrmarConfig</code> class. Note that the attribute must be named <code>ormar_config</code> and be an instance of the config class.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Album(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n        tablename = \"albums\"\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\n# ormar &gt;= 0.20\nclass AlbumV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n</code></pre> </li> <li> <p><code>OrmarConfig</code> api/ parameters</p> <p>The <code>ormar_config</code> expose the same set of settings as <code>Meta</code> class used to provide. That means that you can use any of the following parameters initializing the config:</p> <pre><code>metadata: Optional[sqlalchemy.MetaData]\ndatabase: Optional[databases.Database]\nengine: Optional[sqlalchemy.engine.Engine]\ntablename: Optional[str]\norder_by: Optional[List[str]]\nabstract: bool\nexclude_parent_fields: Optional[List[str]]\nqueryset_class: Type[QuerySet]\nextra: Extra\nconstraints: Optional[List[ColumnCollectionConstraint]]\n</code></pre> </li> <li> <p><code>BaseMeta</code> equivalent - best practice</p> <p>Note that to reduce the duplication of code and ease of development it's still recommended to create a base config and provide each of the models with a copy. OrmarConfig provides a convenient <code>copy</code> method for that purpose. </p> <p>The <code>copy</code> method accepts the same parameters as <code>OrmarConfig</code> init, so you can overwrite if needed, but by default it will return already existing attributes, except for: <code>tablename</code>, <code>order_by</code> and <code>constraints</code> which by default are cleared.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(\"sqlite:///db.sqlite\"),\n    metadata=sqlalchemy.MetaData()\n)\n\nclass AlbumV20(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        tablename=\"albums_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass TrackV20(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        tablename=\"tracks_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre> </li> <li> <p><code>choices</code> Field parameter is no longer supported.</p> <p>Before version 0.20 you could provide <code>choices</code> parameter to any existing ormar Field to limit the accepted values. This functionality was dropped, and you should use <code>ormar.Enum</code> field that was designed for this purpose.  If you want to keep the database field type (i.e. an Integer field) you can always write a custom validator.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Artist(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    country: str = ormar.String(default=False, max_length=50, choices=[\"UK\", \"US\", \"Vietnam\", \"Colombia\"])\n\n# ormar &gt;= 0.20\nfrom enum import Enum\n\nclass Country(str, Enum):\n    UK = \"UK\"\n    US = \"US\"\n    VIETNAM = \"Vietnam\"\n    COLOMBIA = \"Colombia\"\n\nclass ArtistV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"artists_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    country: Country = ormar.Enum(enum_class=Country)\n</code></pre> </li> <li> <p><code>pydantic_only</code> Field parameter is no longer supported</p> <p><code>pydantic_only</code> fields were already deprecated and are removed in v 0.20. Ormar allows defining pydantic fields as in ordinary pydantic model.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Dish(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n        tablename = \"dishes\"\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    cook: str = ormar.String(max_length=40, pydantic_only=True, default=\"sam\")\n\n# ormar &gt;= 0.20\nclass DishV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"dishes_v20\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    cook: str = \"sam\"  # this is normal pydantic field\n</code></pre> </li> <li> <p><code>property_field</code> decorator is no longer supported</p> <p><code>property_field</code> decorator was used to provide a way to pass calculated fields that were included in dictionary/ serialized json representation of the model. Version 2.X of pydantic introduced such a possibility, so you should now switch to the one native to the pydantic.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\nimport pydantic\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n# ormar &lt; 0.20\nclass Employee(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=100)\n    last_name: str = ormar.String(max_length=100)\n\n    @ormar.property_field()\n    def full_name(self) -&gt; str:\n        return f\"{self.first_name} {self.last_name}\"\n\n# ormar &gt;= 0.20\nclass EmployeeV20(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=100)\n    last_name: str = ormar.String(max_length=100)\n\n    @pydantic.computed_field()\n    def full_name(self) -&gt; str:\n        return f\"{self.first_name} {self.last_name}\"\n</code></pre> </li> <li> <p>Deprecated methods</p> <p>All methods listed below are deprecated and will be removed in version 0.30 of <code>ormar</code>.</p> <ul> <li><code>dict()</code> becomes the <code>model_dump()</code></li> </ul> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\nclass Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\nalbum = Album(name=\"Dark Side of the Moon\")\n\n# ormar &lt; 0.20\nalbum_dict = album.dict()\n\n# ormar &gt;= 0.20\nnew_album_dict = album.model_dump() \n</code></pre> <p>Note that parameters remain the same i.e. <code>include</code>, <code>exclude</code> etc.</p> <ul> <li><code>json()</code> becomes the <code>model_dump_json()</code></li> </ul> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\nclass Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\nalbum = Album(name=\"Dark Side of the Moon\")\n\n# ormar &lt; 0.20\nalbum_json= album.json()\n\n# ormar &gt;= 0.20\nnew_album_dict = album.model_dump_json() \n</code></pre> <p>Note that parameters remain the same i.e. <code>include</code>, <code>exclude</code> etc.</p> <ul> <li><code>construct()</code> becomes the <code>model_construct()</code></li> </ul> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\nclass Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"albums\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    favorite: bool = ormar.Boolean(default=False)\n\nparams = {\n    \"name\": \"Dark Side of the Moon\",\n    \"favorite\": True,\n}\n# ormar &lt; 0.20\nalbum = Album.construct(**params)\n\n# ormar &gt;= 0.20\nalbum = Album.model_construct(**params)\n</code></pre> <p>To read more about construct please refer to <code>pydantic</code> documentation.</p> </li> </ul>"},{"location":"releases/#0122","title":"0.12.2","text":""},{"location":"releases/#features_1","title":"\u2728 Features","text":"<ul> <li>Bump support for <code>FastAPI</code> up to the newest version (0.97.0) #1110</li> <li>Add support and tests for <code>Python 3.11</code> #1110</li> </ul>"},{"location":"releases/#0121","title":"0.12.1","text":""},{"location":"releases/#features_2","title":"\u2728 Features","text":"<ul> <li>Massive performance improvements in area of loading the models due to recursive loads and caching of the models and related models. (by @erichaydel - thanks!) #853</li> </ul>"},{"location":"releases/#internals","title":"\ud83d\udcac Internals","text":"<ul> <li>Benchmarks for comparing performance effect of implemented changes in regard of trends (again, by @erichaydel - thanks!) #853</li> </ul>"},{"location":"releases/#0120","title":"0.12.0","text":""},{"location":"releases/#breaking-changes_2","title":"\u2728 Breaking Changes","text":"<ul> <li><code>Queryset.bulk_create</code> will now raise <code>ModelListEmptyError</code> on empty list of models (by @ponytailer - thanks!) #853</li> </ul>"},{"location":"releases/#features_3","title":"\u2728 Features","text":"<ul> <li><code>Model.upsert()</code> now handles a flag <code>__force_save__</code>: <code>bool</code> that allow upserting the models regardless of the fact if they have primary key set or not.  Note that setting this flag will cause two queries for each upserted model -&gt; <code>get</code> to check if model exists and later <code>update/insert</code> accordingly. #889</li> </ul>"},{"location":"releases/#fixes_2","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix for empty relations breaking <code>construct</code> method (by @Abdeldjalil-H - thanks!) #870</li> <li>Fix save related not saving models with already set pks (including uuid) #885</li> <li>Fix for wrong relations exclusions depending on the order of exclusions #779</li> <li>Fix <code>property_fields</code> not being inherited properly #774</li> </ul>"},{"location":"releases/#0113","title":"0.11.3","text":""},{"location":"releases/#features_4","title":"\u2728 Features","text":"<ul> <li>Document <code>onupdate</code> and <code>ondelete</code> referential actions in <code>ForeignKey</code> and provide <code>ReferentialAction</code> enum to specify the behavior of the relationship (by @SepehrBazyar - thanks!) #724</li> <li>Add <code>CheckColumn</code> to supported constraints in models Meta (by @SepehrBazyar - thanks!) #729</li> </ul>"},{"location":"releases/#fixes_3","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix limiting query result to 0 should return empty list (by @SepehrBazyar - thanks!) #766</li> </ul>"},{"location":"releases/#other_2","title":"\ud83d\udcac Other","text":"<ul> <li>Add dark mode to docs (by @SepehrBazyar - thanks!) #717 </li> <li>Update aiomysql dependency #778</li> </ul>"},{"location":"releases/#0112","title":"0.11.2","text":""},{"location":"releases/#fixes_4","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix database drivers being required, while they should be optional #713</li> <li>Fix boolean field problem in <code>limit</code> queries in postgres without <code>limit_raw_sql</code> flag #704</li> <li>Fix enum_class spilling to schema causing errors in OpenAPI #699</li> </ul>"},{"location":"releases/#0111","title":"0.11.1","text":""},{"location":"releases/#fixes_5","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix deepcopy issues introduced in pydantic 1.9 #685</li> </ul>"},{"location":"releases/#0110","title":"0.11.0","text":""},{"location":"releases/#breaking-changes_3","title":"\u2728 Breaking Changes","text":"<ul> <li>Dropped support for python 3.6</li> <li><code>Queryset.get_or_create</code> returns now a tuple with model and bool value indicating if the model was created (by @MojixCoder - thanks!) #554</li> <li><code>Queryset.count()</code> now counts the number of distinct parent model rows by default, counting all rows is possible by setting <code>distinct=False</code> (by @erichaydel - thanks) #588</li> </ul>"},{"location":"releases/#features_5","title":"\u2728 Features","text":"<ul> <li>Added support for python 3.10</li> </ul>"},{"location":"releases/#fixes_6","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix inconsistent <code>JSON</code> fields behaviour in <code>save</code> and <code>bulk_create</code> #584</li> <li>Fix maximum recursion error #580</li> </ul>"},{"location":"releases/#01025","title":"0.10.25","text":""},{"location":"releases/#features_6","title":"\u2728 Features","text":"<ul> <li>Add <code>queryset_class</code> option to <code>Model.Meta</code> that allows you to easily swap <code>QuerySet</code> for your Model (by @ponytailer - thanks!) #538</li> <li>Allow passing extra <code>kwargs</code> to <code>IndexColumns</code> that will be passed to sqlalchemy <code>Index</code> (by @zevisert - thanks) #575</li> </ul>"},{"location":"releases/#fixes_7","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix nullable setting on <code>JSON</code> fields #529</li> <li>Fix bytes/str mismatch in bulk operations when using orjson instead of json (by @ponytailer - thanks!) #538</li> </ul>"},{"location":"releases/#01024","title":"0.10.24","text":""},{"location":"releases/#features_7","title":"\u2728 Features","text":"<ul> <li>Add <code>post_bulk_update</code> signal (by @ponytailer - thanks!) #524</li> </ul>"},{"location":"releases/#fixes_8","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix support for <code>pydantic==1.9.0</code> #502</li> <li>Fix timezone issues with datetime #504</li> <li>Remove literal binds in query generation to unblock postgres arrays #/tophat/ormar-postgres-extensions/9</li> <li>Fix bulk update for <code>JSON</code> fields #519</li> </ul>"},{"location":"releases/#other_3","title":"\ud83d\udcac Other","text":"<ul> <li>Improve performance of <code>bulk_create</code> by bypassing <code>databases</code> <code>execute_many</code> suboptimal implementation. (by @Mng-dev-ai thanks!) #520 </li> <li>Bump min. required <code>databases</code> version to <code>&gt;=5.4</code>.</li> </ul>"},{"location":"releases/#01023","title":"0.10.23","text":""},{"location":"releases/#features_8","title":"\u2728 Features","text":"<ul> <li>Add ability to pass <code>comment</code> to sqlalchemy when creating a column #485</li> </ul>"},{"location":"releases/#fixes_9","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix <code>LargeBinary</code> fields that can be nullable #409</li> <li>Make <code>ormar.Model</code> pickable #413</li> <li>Make <code>first()</code> and <code>get()</code> without arguments respect ordering of main model set by user, fallback to primary key (asc, and desc respectively) #453</li> <li>Fix improper quoting of non-aliased join <code>on</code> clauses in postgress #455</li> </ul>"},{"location":"releases/#01022","title":"0.10.22","text":""},{"location":"releases/#fixes_10","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Hot fix for validators not being inherited when parent <code>ormar</code> model was set #365</li> </ul>"},{"location":"releases/#01021","title":"0.10.21","text":""},{"location":"releases/#fixes_11","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Add <code>ormar</code> implementation of <code>construct</code> classmethod that allows to build <code>Model</code> instances without validating the input to speed up the whole flow, if your data is already validated #318</li> <li>Fix for \"inheriting\" field validators from <code>ormar</code> model when newly created pydanic model is generated with <code>get_pydantic</code> #365</li> </ul>"},{"location":"releases/#01020","title":"0.10.20","text":""},{"location":"releases/#features_9","title":"\u2728 Features","text":"<ul> <li>Add <code>extra</code> parameter in <code>Model.Meta</code> that accepts <code>Extra.ignore</code> and <code>Extra.forbid</code> (default) and either ignores the extra fields passed to <code>ormar</code> model or raises an exception if one is encountered #358</li> </ul>"},{"location":"releases/#fixes_12","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Allow <code>None</code> if field is nullable and have choices set #354</li> <li>Always set <code>primary_key</code> to <code>not null</code> regardless of <code>autoincrement</code> and explicit <code>nullable</code> setting to avoid problems with migrations #348 </li> </ul>"},{"location":"releases/#01019","title":"0.10.19","text":""},{"location":"releases/#features_10","title":"\u2728 Features","text":"<ul> <li>Add support for multi-column non-unique <code>IndexColumns</code> in <code>Meta.constraints</code> #307</li> <li>Add <code>sql_nullable</code> field attribute that allows to set different nullable setting for pydantic model and for underlying sql column #308</li> </ul>"},{"location":"releases/#fixes_13","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Enable caching of relation map to increase performance #337</li> <li>Clarify and fix documentation in regard of nullable fields #339</li> </ul>"},{"location":"releases/#other_4","title":"\ud83d\udcac Other","text":"<ul> <li>Bump supported <code>databases</code> version to <code>&lt;=5.2</code>.</li> </ul>"},{"location":"releases/#01018","title":"0.10.18","text":""},{"location":"releases/#fixes_14","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix order of fields in pydantic models #328</li> <li>Fix databases 0.5.0 support #142</li> </ul>"},{"location":"releases/#01017","title":"0.10.17","text":""},{"location":"releases/#features_11","title":"\u2728 Features","text":"<ul> <li>Allow overwriting the default pydantic type for model fields #312</li> <li>Add support for <code>sqlalchemy</code> &gt;=1.4 (requires <code>databases</code> &gt;= 0.5.0) #142</li> </ul>"},{"location":"releases/#01016","title":"0.10.16","text":""},{"location":"releases/#features_12","title":"\u2728 Features","text":"<ul> <li>Allow passing your own pydantic <code>Config</code> to <code>ormar.Model</code> that will be merged with the default one by @naturalethic (thanks!) #285</li> <li>Add <code>SmallInteger</code> field type by @ProgrammerPlus1998 (thanks!) #297</li> </ul>"},{"location":"releases/#fixes_15","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix generating openapi schema by removing obsolete pydantic field parameters that were directly exposed in schema #291</li> <li>Fix unnecessary warning for auto generated through models #295</li> </ul>"},{"location":"releases/#01015","title":"0.10.15","text":""},{"location":"releases/#fixes_16","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix generating pydantic models tree with nested models (by @pawamoy - thanks!) #278</li> <li>Fix missing f-string in warning about missing primary key field #274</li> <li>Fix passing foreign key value as relation (additional guard, fixed already in the latest release) #270</li> </ul>"},{"location":"releases/#01014","title":"0.10.14","text":""},{"location":"releases/#features_13","title":"\u2728 Features","text":"<ul> <li>Allow passing <code>timezone:bool = False</code> parameter to <code>DateTime</code> and <code>Time</code> fields for timezone aware database columns #264</li> <li>Allow passing datetime, date and time for filter on <code>DateTime</code>, <code>Time</code> and <code>Date</code> fields to allow filtering by datetimes instead of converting the value to string #79</li> </ul>"},{"location":"releases/#fixes_17","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix dependencies from <code>psycopg2</code> to <code>psycopg2-binary</code> #255</li> </ul>"},{"location":"releases/#01013","title":"0.10.13","text":""},{"location":"releases/#features_14","title":"\u2728 Features","text":"<ul> <li>Allow passing field accessors in <code>select_related</code> and <code>prefetch_related</code> aka. python style <code>select_related</code> #225.</li> <li>Previously:    <pre><code>  await Post.objects.select_related([\"author\", \"categories\"]).get()\n  await Author.objects.prefetch_related(\"posts__categories\").get()\n</code></pre></li> <li>Now also:   <pre><code>  await Post.objects.select_related([Post.author, Post.categories]).get()\n  await Author.objects.prefetch_related(Author.posts.categories).get()\n</code></pre></li> </ul>"},{"location":"releases/#fixes_18","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix overwriting default value for inherited primary key #253</li> </ul>"},{"location":"releases/#01012","title":"0.10.12","text":""},{"location":"releases/#fixes_19","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix <code>QuerySet.create</code> method not using init (if custom provided) #245</li> <li>Fix <code>ForwardRef</code> <code>ManyToMany</code> relation setting wrong pydantic type #250</li> </ul>"},{"location":"releases/#01011","title":"0.10.11","text":""},{"location":"releases/#features_15","title":"\u2728 Features","text":"<ul> <li>Add <code>values</code> and <code>values_list</code> to <code>QuerySet</code> and <code>QuerysetProxy</code> that allows to return raw data from query #223.</li> <li>Allow returning list of tuples or list of dictionaries from a query</li> <li>Skips parsing the data to ormar model so skips also the validation</li> <li>Allow excluding models in between in chain of relations, so you can extract only needed columns</li> <li><code>values_list</code> allows you to flatten the result if you extract only one column.</li> </ul>"},{"location":"releases/#fixes_20","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix creation of auto through model for m2m relation with ForwardRef #226</li> </ul>"},{"location":"releases/#01010","title":"0.10.10","text":""},{"location":"releases/#features_16","title":"\u2728 Features","text":"<ul> <li>Add <code>get_pydantic</code> flag that allows you to auto generate equivalent pydantic models tree from ormar.Model. This newly generated model tree can be used in requests and responses to exclude fields you do not want to include in the data.</li> <li>Add <code>exclude_parent_fields</code> parameter to model Meta that allows you to exclude fields from parent models during inheritance. Note that best practice is to combine models and mixins but if you have many similar models and just one that differs it might be useful tool to achieve that. </li> </ul>"},{"location":"releases/#fixes_21","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix is null filter with pagination and relations (by @erichaydel) #214</li> <li>Fix not saving child object on reverse side of the relation if not saved before #216</li> </ul>"},{"location":"releases/#other_5","title":"\ud83d\udcac Other","text":"<ul> <li>Expand fastapi part of the documentation to show samples of using ormar in requests and responses in fastapi.</li> <li>Improve the docs in regard of <code>default</code>, <code>ForeignKey.add</code> etc. </li> </ul>"},{"location":"releases/#0109","title":"0.10.9","text":""},{"location":"releases/#important-security-fix","title":"Important security fix","text":"<ul> <li>Update pin for pydantic to fix security vulnerability CVE-2021-29510</li> </ul> <p>You are advised to update to version of pydantic that was patched.  In 0.10.9 ormar excludes versions with vulnerability in pinned dependencies. </p>"},{"location":"releases/#fixes_22","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix OpenAPi schema for LargeBinary #204</li> </ul>"},{"location":"releases/#0108","title":"0.10.8","text":""},{"location":"releases/#fixes_23","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix populating default values in pk_only child models #202</li> <li>Fix mypy for LargeBinary fields with base64 str representation #199</li> <li>Fix OpenAPI schema format for LargeBinary fields with base64 str representation #199</li> <li>Fix OpenAPI choices encoding for LargeBinary fields with base64 str representation</li> </ul>"},{"location":"releases/#0107","title":"0.10.7","text":""},{"location":"releases/#features_17","title":"\u2728 Features","text":"<ul> <li>Add <code>exclude_primary_keys: bool = False</code> flag to <code>dict()</code> method that allows to exclude all primary key columns in the resulting dictionaru. #164</li> <li>Add <code>exclude_through_models: bool = False</code> flag to <code>dict()</code> that allows excluding all through models from <code>ManyToMany</code> relations #164</li> <li>Add <code>represent_as_base64_str: bool = False</code> parameter that allows conversion of bytes <code>LargeBinary</code> field to base64 encoded string. String is returned in <code>dict()</code>,    on access to attribute and string is converted to bytes on setting. Data in database is stored as bytes. #187</li> <li>Add <code>pk</code> alias to allow field access by <code>Model.pk</code> in filters and order by clauses (python style)</li> </ul>"},{"location":"releases/#fixes_24","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Remove default <code>None</code> option for <code>max_length</code> for <code>LargeBinary</code> field #186</li> <li>Remove default <code>None</code> option for <code>max_length</code> for <code>String</code> field</li> </ul>"},{"location":"releases/#other_6","title":"\ud83d\udcac Other","text":"<ul> <li>Provide a guide and samples of <code>dict()</code> parameters in the docs</li> <li>Major refactor of getting/setting attributes from magic methods into descriptors -&gt; noticeable performance improvement</li> </ul>"},{"location":"releases/#0106","title":"0.10.6","text":""},{"location":"releases/#features_18","title":"\u2728 Features","text":"<ul> <li>Add <code>LargeBinary(max_length)</code> field type #166</li> <li> <p>Add support for normal pydantic fields (including Models) instead of <code>pydantic_only</code>    attribute which is now deprecated #160.   Pydantic fields should be declared normally as in pydantic model next to ormar fields,    note that (obviously) <code>ormar</code> does not save and load the value for this field in    database that mean that ONE of the following has to be true:</p> <ul> <li>pydantic field declared on ormar model has to be <code>Optional</code> (defaults to None)</li> <li>pydantic field has to have a default value set</li> <li>pydantic field has <code>default_factory</code> function set</li> <li>ormar.Model with pydantic field has to overwrite <code>__init__()</code> and provide the value there</li> </ul> <p>If none of the above <code>ormar</code> (or rather pydantic) will fail during loading data from the database, with missing required value for declared pydantic field. * Ormar provides now a meaningful examples in openapi schema, including nested models.   The same algorithm is used to iterate related models without looks    as with <code>dict()</code> and <code>select/load_all</code>. Examples appear also in <code>fastapi</code>. #157</p> </li> </ul>"},{"location":"releases/#fixes_25","title":"\ud83d\udc1b Fixes","text":"<ul> <li>By default <code>pydantic</code> is not validating fields during assignment,    which is not a desirable setting for an ORM, now all <code>ormar.Models</code>    have validation turned-on during assignment (like <code>model.column = 'value'</code>)</li> </ul>"},{"location":"releases/#other_7","title":"\ud83d\udcac Other","text":"<ul> <li>Add connecting to the database in QuickStart in readme #180 </li> <li>OpenAPI schema does no longer include <code>ormar.Model</code> docstring as description,     instead just model name is provided if you do not provide your own docstring.</li> <li>Some performance improvements.</li> </ul>"},{"location":"releases/#0105","title":"0.10.5","text":""},{"location":"releases/#fixes_26","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix bug in <code>fastapi-pagination</code> #73</li> <li>Remove unnecessary <code>Optional</code> in <code>List[Optional[T]]</code> in return value for <code>QuerySet.all()</code> and <code>Querysetproxy.all()</code> return values #174</li> <li>Run tests coverage publish only on internal prs instead of all in github action.</li> </ul>"},{"location":"releases/#0104","title":"0.10.4","text":""},{"location":"releases/#features_19","title":"\u2728 Features","text":"<ul> <li>Add Python style to <code>filter</code> and <code>order_by</code> with field access instead of dunder separated strings. #51</li> <li>Accessing a field with attribute access (chain of dot notation) can be used to construct <code>FilterGroups</code> (<code>ormar.and_</code> and <code>ormar.or_</code>)</li> <li>Field access overloads set of python operators and provide a set of functions to allow same functionality as with dunder separated param names in <code>**kwargs</code>, that means that querying from sample model <code>Track</code> related to model <code>Album</code> now you have more options:<ul> <li>exact - exact match to value, sql <code>column = &lt;VALUE&gt;</code> </li> <li>OLD: <code>album__name__exact='Malibu'</code></li> <li>NEW: can be also written as <code>Track.album.name == 'Malibu</code></li> <li>iexact - exact match sql <code>column = &lt;VALUE&gt;</code> (case insensitive)</li> <li>OLD: <code>album__name__iexact='malibu'</code></li> <li>NEW: can be also written as <code>Track.album.name.iexact('malibu')</code></li> <li>contains - sql <code>column LIKE '%&lt;VALUE&gt;%'</code></li> <li>OLD: <code>album__name__contains='Mal'</code></li> <li>NEW: can be also written as <code>Track.album.name % 'Mal')</code></li> <li>NEW: can be also written as <code>Track.album.name.contains('Mal')</code></li> <li>icontains - sql <code>column LIKE '%&lt;VALUE&gt;%'</code> (case insensitive)</li> <li>OLD: <code>album__name__icontains='mal'</code></li> <li>NEW: can be also written as <code>Track.album.name.icontains('mal')</code></li> <li>in - sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;, ...)</code></li> <li>OLD: <code>album__name__in=['Malibu', 'Barclay']</code></li> <li>NEW: can be also written as <code>Track.album.name &lt;&lt; ['Malibu', 'Barclay']</code></li> <li>NEW: can be also written as <code>Track.album.name.in_(['Malibu', 'Barclay'])</code></li> <li>isnull - sql <code>column IS NULL</code> (and sql <code>column IS NOT NULL</code>) </li> <li>OLD: <code>album__name__isnull=True</code> (isnotnull <code>album__name__isnull=False</code>)</li> <li>NEW: can be also written as <code>Track.album.name &gt;&gt; None</code></li> <li>NEW: can be also written as <code>Track.album.name.isnull(True)</code></li> <li>NEW: not null can be also written as <code>Track.album.name.isnull(False)</code></li> <li>NEW: not null can be also written as <code>~(Track.album.name &gt;&gt; None)</code></li> <li>NEW: not null can be also written as <code>~(Track.album.name.isnull(True))</code></li> <li>gt - sql <code>column &gt; &lt;VALUE&gt;</code> (greater than)</li> <li>OLD: <code>position__gt=3</code></li> <li>NEW: can be also written as <code>Track.album.name &gt; 3</code></li> <li>gte - sql <code>column &gt;= &lt;VALUE&gt;</code> (greater or equal than)</li> <li>OLD: <code>position__gte=3</code></li> <li>NEW: can be also written as <code>Track.album.name &gt;= 3</code></li> <li>lt - sql <code>column &lt; &lt;VALUE&gt;</code> (lower than)</li> <li>OLD: <code>position__lt=3</code></li> <li>NEW: can be also written as <code>Track.album.name &lt; 3</code></li> <li>lte - sql <code>column &lt;= &lt;VALUE&gt;</code> (lower equal than)</li> <li>OLD: <code>position__lte=3</code> </li> <li>NEW: can be also written as <code>Track.album.name &lt;= 3</code></li> <li>startswith - sql <code>column LIKE '&lt;VALUE&gt;%'</code> (exact start match)</li> <li>OLD: <code>album__name__startswith='Mal'</code></li> <li>NEW: can be also written as <code>Track.album.name.startswith('Mal')</code></li> <li>istartswith - sql <code>column LIKE '&lt;VALUE&gt;%'</code> (case insensitive)</li> <li>OLD: <code>album__name__istartswith='mal'</code></li> <li>NEW: can be also written as <code>Track.album.name.istartswith('mal')</code></li> <li>endswith - sql <code>column LIKE '%&lt;VALUE&gt;'</code> (exact end match)</li> <li>OLD: <code>album__name__endswith='ibu'</code></li> <li>NEW: can be also written as <code>Track.album.name.endswith('ibu')</code></li> <li>iendswith - sql <code>column LIKE '%&lt;VALUE&gt;'</code> (case insensitive)</li> <li>OLD: <code>album__name__iendswith='IBU'</code> </li> <li>NEW: can be also written as <code>Track.album.name.iendswith('IBU')</code></li> </ul> </li> <li>You can provide <code>FilterGroups</code> not only in <code>filter()</code> and <code>exclude()</code> but also in:</li> <li><code>get()</code></li> <li><code>get_or_none()</code></li> <li><code>get_or_create()</code></li> <li><code>first()</code></li> <li><code>all()</code></li> <li><code>delete()</code></li> <li>With <code>FilterGroups</code> (<code>ormar.and_</code> and <code>ormar.or_</code>) you can now use: </li> <li><code>&amp;</code> - as <code>and_</code> instead of next level of nesting</li> <li><code>|</code> - as `or_' instead of next level of nesting</li> <li><code>~</code> - as negation of the filter group</li> <li>To combine groups of filters into one set of conditions use <code>&amp;</code> (sql <code>AND</code>) and <code>|</code> (sql <code>OR</code>)   <pre><code># Following queries are equivalent:\n# sql: ( product.name = 'Test'  AND  product.rating &gt;= 3.0 ) \n\n# ormar OPTION 1 - OLD one\nProduct.objects.filter(name='Test', rating__gte=3.0).get()\n\n# ormar OPTION 2 - OLD one\nProduct.objects.filter(ormar.and_(name='Test', rating__gte=3.0)).get()\n\n# ormar OPTION 3 - NEW one (field access)\nProduct.objects.filter((Product.name == 'Test') &amp; (Product.rating &gt;=3.0)).get()\n</code></pre></li> <li>Same applies to nested complicated filters   <pre><code># Following queries are equivalent:\n# sql: ( product.name = 'Test' AND product.rating &gt;= 3.0 ) \n#       OR (categories.name IN ('Toys', 'Books'))\n\n# ormar OPTION 1 - OLD one\nProduct.objects.filter(ormar.or_(\n                          ormar.and_(name='Test', rating__gte=3.0), \n                          categories__name__in=['Toys', 'Books'])\n                      ).get()\n\n# ormar OPTION 2 - NEW one (instead of nested or use `|`)\nProduct.objects.filter(\n                      ormar.and_(name='Test', rating__gte=3.0) | \n                      ormar.and_(categories__name__in=['Toys', 'Books'])\n                      ).get()\n\n# ormar OPTION 3 - NEW one (field access)\nProduct.objects.filter(\n                      ((Product.name='Test') &amp; (Product.rating &gt;= 3.0)) | \n                      (Product.categories.name &lt;&lt; ['Toys', 'Books'])\n                      ).get()\n</code></pre></li> <li>Now you can also use field access to provide OrderActions to <code>order_by()</code></li> <li>Order ascending:<ul> <li>OLD: <code>Product.objects.order_by(\"name\").all()</code></li> <li>NEW: <code>Product.objects.order_by(Product.name.asc()).all()</code> </li> </ul> </li> <li>Order descending:<ul> <li>OLD: <code>Product.objects.order_by(\"-name\").all()</code></li> <li>NEW: <code>Product.objects.order_by(Product.name.desc()).all()</code></li> </ul> </li> <li>You can of course also combine different models and many order_bys:     <code>Product.objects.order_by([Product.category.name.asc(), Product.name.desc()]).all()</code></li> </ul>"},{"location":"releases/#fixes_27","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Not really a bug but rather inconsistency. Providing a filter with nested model i.e. <code>album__category__name = 'AA'</code>     is checking if album and category models are included in <code>select_related()</code> and if not it's auto-adding them there.    The same functionality was not working for <code>FilterGroups</code> (<code>and_</code> and <code>or_</code>), now it works (also for python style filters which return <code>FilterGroups</code>).</li> </ul>"},{"location":"releases/#0103","title":"0.10.3","text":""},{"location":"releases/#features_20","title":"\u2728 Features","text":"<ul> <li><code>ForeignKey</code> and <code>ManyToMany</code> now support <code>skip_reverse: bool = False</code> flag #118.   If you set <code>skip_reverse</code> flag internally the field is still registered on the other    side of the relationship so you can:</li> <li><code>filter</code> by related models fields from reverse model</li> <li><code>order_by</code> by related models fields from reverse model </li> </ul> <p>But you cannot:   * access the related field from reverse model with <code>related_name</code>   * even if you <code>select_related</code> from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can <code>filter</code> and <code>order_by</code>)   * the relation won't be populated in <code>dict()</code> and <code>json()</code>   * you cannot pass the nested related objects when populating from <code>dict()</code> or <code>json()</code> (also through <code>fastapi</code>). It will be either ignored or raise error depending on <code>extra</code> setting in pydantic <code>Config</code>. * <code>Model.save_related()</code> now can save whole data tree in once #148   meaning:   * it knows if it should save main <code>Model</code> or related <code>Model</code> first to preserve the relation   * it saves main <code>Model</code> if      * it's not <code>saved</code>,     * has no <code>pk</code> value      * or <code>save_all=True</code> flag is set </p> <pre><code>in those cases you don't have to split save into two calls (`save()` and `save_related()`)\n</code></pre> <ul> <li>it supports also <code>ManyToMany</code> relations</li> <li>it supports also optional <code>Through</code> model values for m2m relations</li> <li>Add possibility to customize <code>Through</code> model relation field names.</li> <li>By default <code>Through</code> model relation names default to related model name in lowercase.     So in example like this:     <code>python     ... ## course declaration omitted     class Student(ormar.Model):         class Meta:             database = database             metadata = metadata          id: int = ormar.Integer(primary_key=True)         name: str = ormar.String(max_length=100)         courses = ormar.ManyToMany(Course)      ## will produce default Through model like follows (example simplified)     class StudentCourse(ormar.Model):         class Meta:             database = database             metadata = metadata             tablename = \"students_courses\"          id: int = ormar.Integer(primary_key=True)         student = ormar.ForeignKey(Student) ## default name         course = ormar.ForeignKey(Course)  # default name</code></li> <li> <p>To customize the names of fields/relation in Through model now you can use new parameters to <code>ManyToMany</code>:</p> <ul> <li><code>through_relation_name</code> - name of the field leading to the model in which <code>ManyToMany</code> is declared</li> <li><code>through_reverse_relation_name</code> - name of the field leading to the model to which <code>ManyToMany</code> leads to</li> </ul> <p>Example: <pre><code>... # course declaration omitted\nclass Student(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    courses = ormar.ManyToMany(Course,\n                               through_relation_name=\"student_id\",\n                               through_reverse_relation_name=\"course_id\")\n\n# will produce default Through model like follows (example simplified)\nclass StudentCourse(ormar.Model):\n    class Meta:\n        database = database\n        metadata = metadata\n        tablename = \"students_courses\"\n\n    id: int = ormar.Integer(primary_key=True)\n    student_id = ormar.ForeignKey(Student) # set by through_relation_name\n    course_id = ormar.ForeignKey(Course)  # set by through_reverse_relation_name\n</code></pre></p> </li> </ul>"},{"location":"releases/#fixes_28","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix weakref <code>ReferenceError</code> error #118</li> <li>Fix error raised by Through fields when pydantic <code>Config.extra=\"forbid\"</code> is set</li> <li>Fix bug with <code>pydantic.PrivateAttr</code> not being initialized at <code>__init__</code> #149</li> <li>Fix bug with pydantic-type <code>exclude</code> in <code>dict()</code> with <code>__all__</code> key not working</li> </ul>"},{"location":"releases/#other_8","title":"\ud83d\udcac Other","text":"<ul> <li>Introduce link to <code>sqlalchemy-to-ormar</code> auto-translator for models</li> <li>Provide links to fastapi ecosystem libraries that support <code>ormar</code></li> <li>Add transactions to docs (supported with <code>databases</code>)</li> </ul>"},{"location":"releases/#0102","title":"0.10.2","text":""},{"location":"releases/#features_21","title":"\u2728 Features","text":"<ul> <li><code>Model.save_related(follow=False)</code> now accept also two additional arguments: <code>Model.save_related(follow=False, save_all=False, exclude=None)</code>.</li> <li><code>save_all:bool</code> -&gt; By default (so with <code>save_all=False</code>) <code>ormar</code> only upserts models that are not saved (so new or updated ones),    with <code>save_all=True</code> all related models are saved, regardless of <code>saved</code> status, which might be useful if updated   models comes from api call, so are not changed in the backend.</li> <li><code>exclude: Union[Set, Dict, None]</code> -&gt; set/dict of relations to exclude from save, those relation won't be saved even with <code>follow=True</code> and <code>save_all=True</code>.       To exclude nested relations pass a nested dictionary like: <code>exclude={\"child\":{\"sub_child\": {\"exclude_sub_child_realtion\"}}}</code>. The allowed values follow      the <code>fields/exclude_fields</code> (from <code>QuerySet</code>) methods schema so when in doubt you can refer to docs in queries -&gt; selecting subset of fields -&gt; fields.</li> <li><code>Model.update()</code> method now accepts <code>_columns: List[str] = None</code> parameter, that accepts list of column names to update. If passed only those columns will be updated in database.    Note that <code>update()</code> does not refresh the instance of the Model, so if you change more columns than you pass in <code>_columns</code> list your Model instance will have different values than the database!</li> <li><code>Model.model_dump()</code> method previously included only directly related models or nested models if they were not nullable and not virtual,     now all related models not previously visited without loops are included in <code>dict()</code>. This should be not breaking    as just more data will be dumped to dict, but it should not be missing.</li> <li><code>QuerySet.delete(each=False, **kwargs)</code> previously required that you either pass a <code>filter</code> (by <code>**kwargs</code> or as a separate <code>filter()</code> call) or set <code>each=True</code> now also accepts     <code>exclude()</code> calls that generates NOT filter. So either <code>each=True</code> needs to be set to delete whole table or at least one of <code>filter/exclude</code> clauses.</li> <li>Same thing applies to <code>QuerySet.update(each=False, **kwargs)</code> which also previously required that you either pass a <code>filter</code> (by <code>**kwargs</code> or as a separate <code>filter()</code> call) or set <code>each=True</code> now also accepts     <code>exclude()</code> calls that generates NOT filter. So either <code>each=True</code> needs to be set to update whole table or at least one of <code>filter/exclude</code> clauses.</li> <li>Same thing applies to <code>QuerysetProxy.update(each=False, **kwargs)</code> which also previously required that you either pass a <code>filter</code> (by <code>**kwargs</code> or as a separate <code>filter()</code> call) or set <code>each=True</code> now also accepts     <code>exclude()</code> calls that generates NOT filter. So either <code>each=True</code> needs to be set to update whole table or at least one of <code>filter/exclude</code> clauses.</li> </ul>"},{"location":"releases/#fixes_29","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix improper relation field resolution in <code>QuerysetProxy</code> if fk column has different database alias.</li> <li>Fix hitting recursion error with very complicated models structure with loops when calling <code>dict()</code>.</li> <li>Fix bug when two non-relation fields were merged (appended) in query result when they were not relation fields (i.e. JSON)</li> <li>Fix bug when during translation to dict from list the same relation name is used in chain but leads to different models</li> <li>Fix bug when bulk_create would try to save also <code>property_field</code> decorated methods and <code>pydantic</code> fields</li> <li>Fix wrong merging of deeply nested chain of reversed relations</li> </ul>"},{"location":"releases/#other_9","title":"\ud83d\udcac Other","text":"<ul> <li>Performance optimizations</li> <li>Split tests into packages based on tested area</li> </ul>"},{"location":"releases/#0101","title":"0.10.1","text":""},{"location":"releases/#features_22","title":"Features","text":"<ul> <li>add <code>get_or_none(**kwargs)</code> method to <code>QuerySet</code> and <code>QuerysetProxy</code>. It is exact equivalent of <code>get(**kwargs)</code> but instead of raising <code>ormar.NoMatch</code> exception if there is no db record matching the criteria, <code>get_or_none</code> simply returns <code>None</code>.</li> </ul>"},{"location":"releases/#fixes_30","title":"Fixes","text":"<ul> <li>Fix dialect dependent quoting of column and table names in order_by clauses not working    properly in postgres.</li> </ul>"},{"location":"releases/#0100","title":"0.10.0","text":""},{"location":"releases/#breaking","title":"Breaking","text":"<ul> <li>Dropped supported for long deprecated notation of field definition in which you use ormar fields as type hints i.e. <code>test_field: ormar.Integger() = None</code></li> <li>Improved type hints -&gt; <code>mypy</code> can properly resolve related models fields (<code>ForeignKey</code> and <code>ManyToMany</code>) as well as return types of <code>QuerySet</code> methods.     Those mentioned are now returning proper model (i.e. <code>Book</code>) instead or <code>ormar.Model</code> type. There is still problem with reverse sides of relation and <code>QuerysetProxy</code> methods,     to ease type hints now those return <code>Any</code>. Partially fixes #112.</li> </ul>"},{"location":"releases/#features_23","title":"Features","text":"<ul> <li>add <code>select_all(follow: bool = False)</code> method to <code>QuerySet</code> and <code>QuerysetProxy</code>.    It is kind of equivalent of the Model's <code>load_all()</code> method but can be used directly in a query.   By default <code>select_all()</code> adds only directly related models, with <code>follow=True</code> also related models   of related models are added without loops in relations. Note that it's not and end <code>async</code> model   so you still have to issue <code>get()</code>, <code>all()</code> etc. as <code>select_all()</code> returns a QuerySet (or proxy)   like <code>fields()</code> or <code>order_by()</code>.</li> </ul>"},{"location":"releases/#internals_1","title":"Internals","text":"<ul> <li><code>ormar</code> fields are no longer stored as classes in <code>Meta.model_fields</code> dictionary     but instead they are stored as instances.</li> </ul>"},{"location":"releases/#099","title":"0.9.9","text":""},{"location":"releases/#features_24","title":"Features","text":"<ul> <li>Add possibility to change default ordering of relations and models.<ul> <li>To change model sorting pass <code>orders_by = [columns]</code> where <code>columns: List[str]</code> to model <code>Meta</code> class</li> <li>To change relation order_by pass <code>orders_by = [columns]</code> where <code>columns: List[str]</code></li> <li>To change reverse relation order_by pass <code>related_orders_by = [columns]</code> where <code>columns: List[str]</code></li> <li>Arguments can be column names or <code>-{col_name}</code> to sort descending</li> <li>In relations you can sort only by directly related model columns    or for <code>ManyToMany</code> columns also <code>Through</code> model columns <code>\"{through_field_name}__{column_name}\"</code></li> <li>Order in which order_by clauses are applied is as follows:</li> <li>Explicitly passed <code>order_by()</code> calls in query</li> <li>Relation passed <code>orders_by</code> if exists</li> <li>Model <code>Meta</code> class <code>orders_by</code></li> <li>Model primary key column asc (fallback, used if none of above provided)</li> </ul> </li> <li>Add 4 new aggregated functions -&gt; <code>min</code>, <code>max</code>, <code>sum</code> and <code>avg</code> that are their     corresponding sql equivalents. <ul> <li>You can pass one or many column names including related columns.</li> <li>As of now each column passed is aggregated separately (so <code>sum(col1+col2)</code> is not possible,     you can have <code>sum(col1, col2)</code> and later add 2 returned sums in python)</li> <li>You cannot <code>sum</code> and <code>avg</code> non numeric columns</li> <li>If you aggregate on one column, the single value is directly returned as a result</li> <li>If you aggregate on multiple columns a dictionary with column: result pairs is returned</li> </ul> </li> <li>Add 4 new signals -&gt; <code>pre_relation_add</code>, <code>post_relation_add</code>, <code>pre_relation_remove</code> and <code>post_relation_remove</code><ul> <li>The newly added signals are emitted for <code>ManyToMany</code> relations (both sides)     and reverse side of <code>ForeignKey</code> relation (same as <code>QuerysetProxy</code> is exposed).</li> <li>Signals receive following args: <code>sender: Type[Model]</code> - sender class,     <code>instance: Model</code> - instance to which related model is added, <code>child: Model</code> - model being added,    <code>relation_name: str</code> - name of the relation to which child is added,     for add signals also <code>passed_kwargs: Dict</code> - dict of kwargs passed to <code>add()</code></li> </ul> </li> </ul>"},{"location":"releases/#changes","title":"Changes","text":"<ul> <li><code>Through</code> models for ManyToMany relations are now instantiated on creation, deletion and update, so you can provide not only   autoincrement int as a primary key but any column type with default function provided.</li> <li>Since <code>Through</code> models are now instantiated you can also subscribe to <code>Through</code> model    pre/post save/update/delete signals</li> <li><code>pre_update</code> signals receivers now get also passed_args argument which is a    dict of values passed to update function if any (else empty dict)</li> </ul>"},{"location":"releases/#fixes_31","title":"Fixes","text":"<ul> <li><code>pre_update</code> signal now is sent before the extraction of values so you can modify the passed   instance in place and modified fields values will be reflected in database</li> <li><code>bulk_update</code> now works correctly also with <code>UUID</code> primary key column type</li> </ul>"},{"location":"releases/#098","title":"0.9.8","text":""},{"location":"releases/#features_25","title":"Features","text":"<ul> <li>Add possibility to encrypt the selected field(s) in the database</li> <li>As minimum you need to provide <code>encrypt_secret</code> and <code>encrypt_backend</code></li> <li><code>encrypt_backend</code> can be one of the <code>ormar.EncryptBackends</code> enum (<code>NONE, FERNET, HASH, CUSTOM</code>) - default: <code>NONE</code></li> <li>When custom backend is selected you need to provide your backend class that subclasses <code>ormar.fields.EncryptBackend</code></li> <li>You cannot encrypt <code>primary_key</code> column and relation columns (FK and M2M).</li> <li>Provided are 2 backends: HASH and FERNET<ul> <li>HASH is a one-way hash (like for password), never decrypted on retrieval</li> <li>FERNET is a two-way encrypt/decrypt backend</li> </ul> </li> <li>Note that in FERNET backend you loose <code>filtering</code> possibility altogether as part of the encrypted value is a timestamp.</li> <li>Note that in HASH backend you can filter by full value but filters like <code>contain</code> will not work as comparison is make on encrypted values</li> <li>Note that adding <code>encrypt_backend</code> changes the database column type to <code>TEXT</code>, which needs to be reflected in db either by migration or manual change</li> </ul>"},{"location":"releases/#fixes_32","title":"Fixes","text":"<ul> <li>(Advanced/ Internal) Restore custom sqlalchemy types (by <code>types.TypeDecorator</code> subclass) functionality that ceased to working so <code>process_result_value</code> was never called</li> </ul>"},{"location":"releases/#097","title":"0.9.7","text":""},{"location":"releases/#features_26","title":"Features","text":"<ul> <li>Add <code>isnull</code> operator to filter and exclude methods.      <pre><code>album__name__isnull=True #(sql: album.name is null)\nalbum__name__isnull=False #(sql: album.name is not null))\n</code></pre></li> <li>Add <code>ormar.or_</code> and <code>ormar.and_</code> functions that can be used to compose   complex queries with nested conditions.    Sample query:   <pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(\n        ormar.and_(\n            ormar.or_(year__gt=1960, year__lt=1940),\n            author__name=\"J.R.R. Tolkien\",\n        )\n    )\n    .all()\n)\n</code></pre>   Check the updated docs in Queries -&gt; Filtering and sorting -&gt; Complex filters</li> </ul>"},{"location":"releases/#other_10","title":"Other","text":"<ul> <li>Setting default on <code>ForeignKey</code> or <code>ManyToMany</code> raises and <code>ModelDefinition</code> exception as it is (and was) not supported</li> </ul>"},{"location":"releases/#096","title":"0.9.6","text":""},{"location":"releases/#important","title":"Important","text":"<ul> <li><code>Through</code> model for <code>ManyToMany</code> relations now becomes optional. It's not a breaking change   since if you provide it everything works just fine as it used to. So if you don't want or need any additional    fields on <code>Through</code> model you can skip it. Note that it's going to be created for you automatically and    still has to be included in example in <code>alembic</code> migrations.    If you want to delete existing one check the default naming convention to adjust your existing database structure.</li> </ul> <p>Note that you still need to provide it if you want to    customize the <code>Through</code> model name or the database table name.</p>"},{"location":"releases/#features_27","title":"Features","text":"<ul> <li>Add <code>update</code> method to <code>QuerysetProxy</code> so now it's possible to update related models directly from parent model   in <code>ManyToMany</code> relations and in reverse <code>ForeignKey</code> relations. Note that update like in <code>QuerySet</code> <code>update</code> returns number of   updated models and does not update related models in place on parent model. To get the refreshed data on parent model you need to refresh   the related models (i.e. <code>await model_instance.related.all()</code>)</li> <li>Add <code>load_all(follow=False, exclude=None)</code> model method that allows to load current instance of the model   with all related models in one call. By default it loads only directly related models but setting   <code>follow=True</code> causes traversing the tree (avoiding loops). You can also pass <code>exclude</code> parameter   that works the same as <code>QuerySet.exclude_fields()</code> method.</li> <li>Added possibility to add more fields on <code>Through</code> model for <code>ManyToMany</code> relationships:<ul> <li>name of the through model field is the lowercase name of the Through class</li> <li>you can pass additional fields when calling <code>add(child, **kwargs)</code> on relation (on <code>QuerysetProxy</code>)</li> <li>you can pass additional fields when calling <code>create(**kwargs)</code> on relation (on <code>QuerysetProxy</code>)     when one of the keyword arguments should be the through model name with a dict of values</li> <li>you can order by on through model fields</li> <li>you can filter on through model fields</li> <li>you can include and exclude fields on through models</li> <li>through models are attached only to related models (i.e. if you query from A to B -&gt; only on B)</li> <li>note that through models are explicitly loaded without relations -&gt; relation is already populated in ManyToMany field. </li> <li>note that just like before you cannot declare the relation fields on through model, they will be populated for you by <code>ormar</code>,   but now if you try to do so <code>ModelDefinitionError</code> will be thrown</li> <li>check the updated ManyToMany relation docs for more information</li> </ul> </li> </ul>"},{"location":"releases/#other_11","title":"Other","text":"<ul> <li>Updated docs and api docs</li> <li>Refactors and optimisations mainly related to filters, exclusions and order bys</li> </ul>"},{"location":"releases/#095","title":"0.9.5","text":""},{"location":"releases/#fixes_33","title":"Fixes","text":"<ul> <li>Fix creation of <code>pydantic</code> FieldInfo after update of <code>pydantic</code> to version &gt;=1.8</li> <li>Pin required dependency versions to avoid such situations in the future</li> </ul>"},{"location":"releases/#094","title":"0.9.4","text":""},{"location":"releases/#fixes_34","title":"Fixes","text":"<ul> <li>Fix <code>fastapi</code> OpenAPI schema generation for automatic docs when multiple models refer to the same related one</li> </ul>"},{"location":"releases/#093","title":"0.9.3","text":""},{"location":"releases/#fixes_35","title":"Fixes","text":"<ul> <li>Fix <code>JSON</code> field being double escaped when setting value after initialization</li> <li>Fix <code>JSON</code> field not respecting <code>nullable</code> field setting due to <code>pydantic</code> internals </li> <li>Fix <code>choices</code> verification for <code>JSON</code> field</li> <li>Fix <code>choices</code> not being verified when setting the attribute after initialization</li> <li>Fix <code>choices</code> not being verified during <code>update</code> call from <code>QuerySet</code></li> </ul>"},{"location":"releases/#092","title":"0.9.2","text":""},{"location":"releases/#other_12","title":"Other","text":"<ul> <li>Updated the Quick Start in docs/readme</li> <li>Updated docs with links to queries subpage</li> <li>Added badges for code climate and pepy downloads</li> </ul>"},{"location":"releases/#091","title":"0.9.1","text":""},{"location":"releases/#features_28","title":"Features","text":"<ul> <li>Add choices values to <code>OpenAPI</code> specs, so it looks like native <code>Enum</code> field in the result schema.</li> </ul>"},{"location":"releases/#fixes_36","title":"Fixes","text":"<ul> <li>Fix <code>choices</code> behavior with <code>fastapi</code> usage when special fields can be not initialized yet but passed as strings etc.</li> </ul>"},{"location":"releases/#090","title":"0.9.0","text":""},{"location":"releases/#important_1","title":"Important","text":"<ul> <li>Braking Fix: Version 0.8.0 introduced a bug that prevents generation of foreign_keys constraint in the database, both in alembic and during creation through sqlalchemy.engine, this is fixed now.</li> <li>THEREFORE IF YOU USE VERSION &gt;=0.8.0 YOU ARE STRONGLY ADVISED TO UPDATE cause despite that most of the <code>ormar</code> functions are working your database CREATED with ormar (or ormar + alembic)    does not have relations and suffer from perspective of performance and data integrity.</li> <li>If you were using <code>ormar</code> to connect to existing database your performance and integrity    should be fine nevertheless you should update to reflect all future schema updates in your models.</li> </ul>"},{"location":"releases/#breaking_1","title":"Breaking","text":"<ul> <li>Breaking: All foreign_keys and unique constraints now have a name so <code>alembic</code>    can identify them in db and not depend on db</li> <li>Breaking: During model construction if <code>Meta</code> class of the <code>Model</code> does not    include <code>metadata</code> or <code>database</code> now <code>ModelDefinitionError</code> will be raised instead of generic <code>AttributeError</code>.</li> <li>Breaking: <code>encode/databases</code> used for running the queries does not have a connection pool for sqlite backend, meaning that each query is run with a new connection and there is no way to    enable enforcing ForeignKeys constraints as those are by default turned off on every connection.   This is changed in <code>ormar</code> since &gt;=0.9.0 and by default each sqlite3 query has <code>\"PRAGMA foreign_keys=1;\"</code>   run so now each sqlite3 connection by default enforces ForeignKey constraints including cascades.</li> </ul>"},{"location":"releases/#other_13","title":"Other","text":"<ul> <li>Update api docs.</li> <li>Add tests for fk creation in db and for cascades in db</li> </ul>"},{"location":"releases/#081","title":"0.8.1","text":""},{"location":"releases/#features_29","title":"Features","text":"<ul> <li>Introduce processing of <code>ForwardRef</code> in relations.    Now you can create self-referencing models - both <code>ForeignKey</code> and <code>ManyToMany</code> relations.    <code>ForwardRef</code> can be used both for <code>to</code> and <code>through</code> <code>Models</code>.</li> <li>Introduce the possibility to perform two same relation joins in one query, so to process complex relations like:   <pre><code>    B = X = Y\n  //\n A \n  \\\n    C = X = Y &lt;= before you could link from X to Y only once in one query\n                 unless two different relation were used \n                 (two relation fields with different names)\n</code></pre></li> <li>Introduce the <code>paginate</code> method that allows to limit/offset by <code>page</code> and <code>page_size</code>.    Available for <code>QuerySet</code> and <code>QuerysetProxy</code>.</li> </ul>"},{"location":"releases/#other_14","title":"Other","text":"<ul> <li>Refactoring and performance optimization in queries and joins.</li> <li>Add python 3.9 to tests and pypi setup.</li> <li>Update API docs and docs -&gt; i.e. split of queries documentation.</li> </ul>"},{"location":"releases/#080","title":"0.8.0","text":""},{"location":"releases/#breaking_2","title":"Breaking","text":"<ul> <li>Breaking: <code>remove()</code> parent from child side in reverse ForeignKey relation now requires passing a relation <code>name</code>, as the same model can be registered multiple times and <code>ormar</code> needs to know from which relation on the parent you want to remove the child.</li> <li>Breaking: applying <code>limit</code> and <code>offset</code> with <code>select_related</code> is by default applied only on the main table before the join -&gt; meaning that not the total   number of rows is limited but just number of main models (first one in the query, the one used to construct it). You can still limit all rows from db response with <code>limit_raw_sql=True</code> flag on either <code>limit</code> or <code>offset</code> (or both)</li> <li>Breaking: issuing <code>first()</code> now fetches the first row ordered by the primary key asc (so first one inserted (can be different for non number primary keys - i.e. alphabetical order of string))</li> <li>Breaking: issuing <code>get()</code> without any filters now fetches the first row ordered by the primary key desc (so should be last one inserted (can be different for non number primary keys - i.e. alphabetical order of string))</li> <li>Breaking (internal): sqlalchemy columns kept at <code>Meta.columns</code> are no longer bind to table, so you cannot get the column straight from there</li> </ul>"},{"location":"releases/#features_30","title":"Features","text":"<ul> <li>Introduce inheritance. For now two types of inheritance are possible:<ul> <li>Mixins - don't subclass <code>ormar.Model</code>, just define fields that are later used on different models (like <code>created_date</code> and <code>updated_date</code> on each child model), only actual models create tables, but those fields from mixins are added</li> <li>Concrete table inheritance - means that parent is marked as <code>abstract=True</code> in Meta class and each child has its own table with columns from the parent and own child columns, kind of similar to Mixins but parent also is a (an abstract) Model</li> <li>To read more check the docs on models -&gt; inheritance section.</li> </ul> </li> <li>QuerySet <code>first()</code> can be used with <code>prefetch_related</code></li> </ul>"},{"location":"releases/#fixes_37","title":"Fixes","text":"<ul> <li>Fix minor bug in <code>order_by</code> for primary model order bys</li> <li>Fix in <code>prefetch_query</code> for multiple related_names for the same model.</li> <li>Fix using same <code>related_name</code> on different models leading to the same related <code>Model</code> overwriting each other, now <code>ModelDefinitionError</code> is raised and you need to change the name. </li> <li>Fix <code>order_by</code> overwriting conditions when multiple joins to the same table applied.</li> </ul>"},{"location":"releases/#docs","title":"Docs","text":"<ul> <li>Split and cleanup in docs:<ul> <li>Divide models section into subsections</li> <li>Divide relations section into subsections</li> <li>Divide fields section into subsections</li> </ul> </li> <li>Add model inheritance section</li> <li>Add API (BETA) documentation</li> </ul>"},{"location":"releases/#075","title":"0.7.5","text":"<ul> <li>Fix for wrong relation column name in many_to_many relation joins (fix #73)</li> </ul>"},{"location":"releases/#074","title":"0.7.4","text":"<ul> <li>Allow multiple relations to the same related model/table.</li> <li>Fix for wrong relation column used in many_to_many relation joins (fix #73)</li> <li>Fix for wrong relation population for m2m relations when also fk relation present for same model.</li> <li>Add check if user provide related_name if there are multiple relations to same table on one model.</li> <li>More eager cleaning of the dead weak proxy models.</li> </ul>"},{"location":"releases/#073","title":"0.7.3","text":"<ul> <li>Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71)</li> </ul>"},{"location":"releases/#072","title":"0.7.2","text":"<ul> <li>Fix for overwriting related models with pk only in <code>Model.update() with fields passed as parameters</code> (fix #70)</li> </ul>"},{"location":"releases/#071","title":"0.7.1","text":"<ul> <li>Fix for overwriting related models with pk only in <code>Model.save()</code> (fix #68)</li> </ul>"},{"location":"releases/#070","title":"0.7.0","text":"<ul> <li>Breaking: QuerySet <code>bulk_update</code> method now raises <code>ModelPersistenceError</code> for unsaved models passed instead of <code>QueryDefinitionError</code></li> <li>Breaking: Model initialization with unknown field name now raises <code>ModelError</code> instead of <code>KeyError</code></li> <li>Added Signals, with pre-defined list signals and decorators: <code>post_delete</code>, <code>post_save</code>, <code>post_update</code>, <code>pre_delete</code>,  <code>pre_save</code>, <code>pre_update</code></li> <li>Add <code>py.typed</code> and modify <code>setup.py</code> for mypy support </li> <li>Performance optimization</li> <li>Updated docs</li> </ul>"},{"location":"releases/#062","title":"0.6.2","text":"<ul> <li>Performance optimization</li> <li>Fix for bug with <code>pydantic_only</code> fields being required</li> <li>Add <code>property_field</code> decorator that registers a function as a property that will     be included in <code>Model.model_dump()</code> and in <code>fastapi</code> response</li> <li>Update docs</li> </ul>"},{"location":"releases/#061","title":"0.6.1","text":"<ul> <li>Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60). </li> </ul>"},{"location":"releases/#060","title":"0.6.0","text":"<ul> <li>Breaking: calling instance.load() when the instance row was deleted from db now raises <code>NoMatch</code> instead of <code>ValueError</code></li> <li>Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column</li> <li>Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation</li> <li>Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model:<ul> <li>Example: <code>post.categories.first()</code> will set post.categories to list of 1 related model -&gt; the one returned by first()</li> <li>Example 2: if post has 4 categories so <code>len(post.categories) == 4</code> calling <code>post.categories.limit(2).all()</code> -&gt; will load only 2 children and now <code>assert len(post.categories) == 2</code></li> </ul> </li> <li>Added <code>get_or_create</code>, <code>update_or_create</code>, <code>fields</code>, <code>exclude_fields</code>, <code>exclude</code>, <code>prefetch_related</code> and <code>order_by</code> to QuerySetProxy  so now you can use those methods directly from relation  </li> <li>Update docs</li> </ul>"},{"location":"releases/#055","title":"0.5.5","text":"<ul> <li>Fix for alembic autogenaration of migration <code>UUID</code> columns. It should just produce sqlalchemy <code>CHAR(32)</code> or <code>CHAR(36)</code></li> <li>In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.'))</li> </ul>"},{"location":"releases/#054","title":"0.5.4","text":"<ul> <li>Allow to pass <code>uuid_format</code> (allowed 'hex'(default) or 'string') to <code>UUID</code> field to change the format in which it's saved.    By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass     format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries.</li> </ul> <p>Sample:    *  hex value = c616ab438cce49dbbf4380d109251dce    *  string value = c616ab43-8cce-49db-bf43-80d109251dce</p>"},{"location":"releases/#053","title":"0.5.3","text":"<ul> <li>Fixed bug in <code>Model.model_dump()</code> method that was ignoring exclude parameter and not include dictionary argument.</li> </ul>"},{"location":"releases/#052","title":"0.5.2","text":"<ul> <li>Added <code>prefetch_related</code> method to load subsequent models in separate queries.</li> <li>Update docs</li> </ul>"},{"location":"releases/#051","title":"0.5.1","text":"<ul> <li>Switched to github actions instead of travis</li> <li>Update badges in the docs</li> </ul>"},{"location":"releases/#050","title":"0.5.0","text":"<ul> <li>Added save status -&gt; you can check if model is saved with <code>ModelInstance.saved</code> property<ul> <li>Model is saved after <code>save/update/load/upsert</code> method on model</li> <li>Model is saved after <code>create/get/first/all/get_or_create/update_or_create</code> method</li> <li>Model is saved when passed to <code>bulk_update</code> and <code>bulk_create</code></li> <li>Model is saved after adding/removing <code>ManyToMany</code> related objects (through model instance auto saved/deleted)</li> <li>Model is not saved after change of any own field (including pk as <code>Model.pk</code> alias)</li> <li>Model is not saved after adding/removing <code>ForeignKey</code> related object (fk column not saved)</li> <li>Model is not saved after instantiation with <code>__init__</code> (w/o <code>QuerySet.create</code> or before calling <code>save</code>)</li> </ul> </li> <li>Added <code>Model.upsert(**kwargs)</code> that performs <code>save()</code> if pk not set otherwise <code>update(**kwargs)</code></li> <li>Added <code>Model.save_related(follow=False)</code> that iterates all related objects in all relations and checks if they are saved. If not it calls <code>upsert()</code> on each of them.</li> <li>Breaking: added raising exceptions if <code>add</code>-ing/<code>remove</code>-ing not saved (pk is None) models to <code>ManyToMany</code> relation</li> <li>Allow passing dictionaries and sets to fields and exclude_fields</li> <li>Auto translate str and lists to dicts for fields and exclude_fields</li> <li>Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name </li> <li>Performance optimizations - in modelproxy, newbasemodel - &gt; less queries, some properties are cached on models</li> <li>Cleanup of unused relations code</li> <li>Optional performance dependency orjson added (strongly recommended)</li> <li>Updated docs</li> </ul>"},{"location":"releases/#044","title":"0.4.4","text":"<ul> <li>add exclude_fields() method to exclude fields from sql</li> <li>refactor column names setting (aliases)</li> <li>fix ordering by for column with aliases</li> <li>additional tests for fields and exclude_fields</li> <li>update docs</li> </ul>"},{"location":"releases/#043","title":"0.4.3","text":"<ul> <li>include properties in models.model_dump() and model.model_dump_json()</li> </ul>"},{"location":"releases/#042","title":"0.4.2","text":"<ul> <li>modify creation of pydantic models to allow returning related models with only pk populated</li> </ul>"},{"location":"releases/#041","title":"0.4.1","text":"<ul> <li>add order_by method to queryset to allow sorting</li> <li>update docs</li> </ul>"},{"location":"releases/#040","title":"0.4.0","text":"<ul> <li>Changed notation in Model definition -&gt; now use name = ormar.Field() not name: ormar.Field()<ul> <li>Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin</li> </ul> </li> <li>Type hint docs and test</li> <li>Use mypy for tests also not, only ormar package</li> <li>Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field</li> <li>Update docs - add best practices for dependencies</li> <li>Refactor metaclass and model_fields to play nice with type hints</li> <li>Add mypy and pydantic plugin to docs </li> <li>Expand the docs on ManyToMany relation</li> </ul>"},{"location":"releases/#0311","title":"0.3.11","text":"<ul> <li>Fix setting server_default as default field value in python</li> </ul>"},{"location":"releases/#0310","title":"0.3.10","text":"<ul> <li>Fix postgresql check to avoid exceptions with drivers not installed if using different backend</li> </ul>"},{"location":"releases/#039","title":"0.3.9","text":"<ul> <li>Fix json schema generation as of #19</li> <li>Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models</li> <li>Update docs in regard of fastapi use</li> <li>Add tests to verify fastapi/docs proper generation</li> </ul>"},{"location":"releases/#038","title":"0.3.8","text":"<ul> <li>Added possibility to provide alternative database column names with name parameter to all fields.</li> <li>Fix bug with selecting related ManyToMany fields with <code>fields()</code> if they are empty.</li> <li>Updated documentation</li> </ul>"},{"location":"releases/#037","title":"0.3.7","text":"<ul> <li>Publish documentation and update readme</li> </ul>"},{"location":"releases/#036","title":"0.3.6","text":"<ul> <li>Add fields() method to limit the selected columns from database - only nullable columns can be excluded.</li> <li>Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns.</li> <li>Added UUID field type based on Char(32) column type.</li> </ul>"},{"location":"releases/#035","title":"0.3.5","text":"<ul> <li>Added bulk_create and bulk_update for operations on multiple objects.</li> </ul>"},{"location":"releases/#034","title":"0.3.4","text":"<p>Add queryset level methods *  delete *  update *  get_or_create *  update_or_create</p>"},{"location":"releases/#033","title":"0.3.3","text":"<ul> <li>Add additional filters - startswith and endswith</li> </ul>"},{"location":"releases/#032","title":"0.3.2","text":"<ul> <li>Add choices parameter to all fields - limiting the accepted values to ones provided</li> </ul>"},{"location":"releases/#031","title":"0.3.1","text":"<ul> <li>Added exclude to filter where not conditions.</li> <li>Added tests for mysql and postgres with fixes for postgres.</li> <li>Rafactors and cleanup.</li> </ul>"},{"location":"releases/#030","title":"0.3.0","text":"<ul> <li>Added ManyToMany field and support for many to many relations</li> </ul>"},{"location":"signals/","title":"Signals","text":"<p>Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in <code>ormar</code>.</p> <p>To achieve this you need to register your receiver for a given type of signal for selected model(s).</p>"},{"location":"signals/#defining-receivers","title":"Defining receivers","text":"<p>Given a sample model like following:</p> <pre><code>import databases\nimport sqlalchemy\n\nimport ormar\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(\"sqlite:///db.sqlite\"),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n    play_count: int = ormar.Integer(default=0)\n</code></pre> <p>You can for example define a trigger that will set <code>album.is_best_seller</code> status if it will be played more than 50 times.</p> <p>Import <code>pre_update</code> decorator, for list of currently available decorators/ signals check below.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\nfrom ormar import pre_update\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Album(ormar.Model):\n    ormar_config = ormar_base_config.copy(\n        tablename=\"albums\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n    play_count: int = ormar.Integer(default=0)\n\n\n@pre_update(Album)\nasync def before_update(sender, instance, **kwargs):\n    if instance.play_count &gt; 50 and not instance.is_best_seller:\n        instance.is_best_seller = True\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    # here album.play_count ans is_best_seller get default values\n    album = await Album.objects.create(name=\"Venice\")\n    assert not album.is_best_seller\n    assert album.play_count == 0\n\n    album.play_count = 30\n    # here a trigger is called but play_count is too low\n    await album.update()\n    assert not album.is_best_seller\n\n    album.play_count = 60\n    await album.update()\n    assert album.is_best_seller\n\n\nasyncio.run(run_query())\n</code></pre> <p>Define your function. </p> <p>Note that each receiver function:</p> <ul> <li>has to be callable</li> <li>has to accept first <code>sender</code> argument that receives the class of sending object</li> <li>has to accept <code>**kwargs</code> argument as the parameters send in each <code>ormar.Signal</code> can change at any time so your function has to serve them.</li> <li>has to be <code>async</code> cause callbacks are gathered and awaited.</li> </ul> <p><code>pre_update</code> currently sends only one argument apart from <code>sender</code> and it's <code>instance</code> one.</p> <p>Note how <code>pre_update</code> decorator accepts a <code>senders</code> argument that can be a single model or a list of models,  for which you want to run the signal receiver. </p> <p>Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\nfrom ormar import pre_update\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Album(ormar.Model):\n    ormar_config = ormar_base_config.copy(\n        tablename=\"albums\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n    play_count: int = ormar.Integer(default=0)\n\n\n@pre_update(Album)\nasync def before_update(sender, instance, **kwargs):\n    if instance.play_count &gt; 50 and not instance.is_best_seller:\n        instance.is_best_seller = True\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    # here album.play_count ans is_best_seller get default values\n    album = await Album.objects.create(name=\"Venice\")\n    assert not album.is_best_seller\n    assert album.play_count == 0\n\n    album.play_count = 30\n    # here a trigger is called but play_count is too low\n    await album.update()\n    assert not album.is_best_seller\n\n    album.play_count = 60\n    await album.update()\n    assert album.is_best_seller\n\n\nasyncio.run(run_query())\n</code></pre> <p>Note</p> <p>Note that receivers are defined on a class level -&gt; so even if you connect/disconnect function through instance  it will run/ stop running for all operations on that <code>ormar.Model</code> class.</p> <p>Note that our newly created function has instance and class of the instance so you can easily run database  queries inside your receivers if you want to.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\nfrom ormar import pre_update\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Album(ormar.Model):\n    ormar_config = ormar_base_config.copy(\n        tablename=\"albums\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n    play_count: int = ormar.Integer(default=0)\n\n\n@pre_update(Album)\nasync def before_update(sender, instance, **kwargs):\n    if instance.play_count &gt; 50 and not instance.is_best_seller:\n        instance.is_best_seller = True\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    # here album.play_count ans is_best_seller get default values\n    album = await Album.objects.create(name=\"Venice\")\n    assert not album.is_best_seller\n    assert album.play_count == 0\n\n    album.play_count = 30\n    # here a trigger is called but play_count is too low\n    await album.update()\n    assert not album.is_best_seller\n\n    album.play_count = 60\n    await album.update()\n    assert album.is_best_seller\n\n\nasyncio.run(run_query())\n</code></pre> <p>You can define same receiver for multiple models at once by passing a list of models to signal decorator.</p> <pre><code># define a dummy debug function\n@pre_update([Album, Track])\nasync def before_update(sender, instance, **kwargs):\n    print(f\"{sender.get_name()}: {instance.model_dump_json()}: {kwargs}\")\n</code></pre> <p>Of course, you can also create multiple functions for the same signal and model. Each of them will run at each signal.</p> <pre><code>@pre_update(Album)\nasync def before_update(sender, instance, **kwargs):\n    print(f\"{sender.get_name()}: {instance.model_dump_json()}: {kwargs}\")\n\n@pre_update(Album)\nasync def before_update2(sender, instance, **kwargs):\n    print(f'About to update {sender.get_name()} with pk: {instance.pk}')\n</code></pre> <p>Note that <code>ormar</code> decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your <code>receiver</code> function / method.</p> <pre><code>class AlbumAuditor:\n    def __init__(self):\n        self.event_type = \"ALBUM_INSTANCE\"\n\n    async def before_save(self, sender, instance, **kwargs):\n        await AuditLog(\n            event_type=f\"{self.event_type}_SAVE\", event_log=instance.model_dump_json()\n        ).save()\n\nauditor = AlbumAuditor()\npre_save(Album)(auditor.before_save)\n# call above has same result like the one below\nAlbum.ormar_config.signals.pre_save.connect(auditor.before_save)\n# signals are also exposed on instance\nalbum = Album(name='Miami')\nalbum.signals.pre_save.connect(auditor.before_save)\n</code></pre> <p>Warning</p> <p>Note that signals keep the reference to your receiver (not a <code>weakref</code>) so keep that in mind to avoid circular references.</p>"},{"location":"signals/#disconnecting-the-receivers","title":"Disconnecting the receivers","text":"<p>To disconnect the receiver and stop it for running for given model you need to disconnect it.</p> <pre><code>@pre_update(Album)\nasync def before_update(sender, instance, **kwargs):\n    if instance.play_count &gt; 50 and not instance.is_best_seller:\n        instance.is_best_seller = True\n\n# disconnect given function from signal for given Model\nAlbum.ormar_config.signals.pre_save.disconnect(before_save)\n# signals are also exposed on instance\nalbum = Album(name='Miami')\nalbum.signals.pre_save.disconnect(before_save)\n</code></pre>"},{"location":"signals/#available-signals","title":"Available signals","text":"<p>Warning</p> <p>Note that signals are not send for:</p> <ul> <li> <p>bulk operations (<code>QuerySet.bulk_create</code> and <code>QuerySet.bulk_update</code>) as they are designed for speed.</p> </li> <li> <p>queryset table level operations (<code>QuerySet.update</code> and <code>QuerySet.delete</code>) as they run on the underlying tables  (more like raw sql update/delete operations) and do not have specific instance.</p> </li> </ul>"},{"location":"signals/#pre_save","title":"pre_save","text":"<p><code>pre_save(sender: Type[\"Model\"], instance: \"Model\")</code></p> <p>Send for <code>Model.save()</code> and <code>Model.objects.create()</code> methods.</p> <p><code>sender</code> is a <code>ormar.Model</code> class and <code>instance</code> is the model to be saved.</p>"},{"location":"signals/#post_save","title":"post_save","text":"<p><code>post_save(sender: Type[\"Model\"], instance: \"Model\")</code></p> <p>Send for <code>Model.save()</code> and <code>Model.objects.create()</code> methods.</p> <p><code>sender</code> is a <code>ormar.Model</code> class and <code>instance</code> is the model that was saved.</p>"},{"location":"signals/#pre_update","title":"pre_update","text":"<p><code>pre_update(sender: Type[\"Model\"], instance: \"Model\")</code></p> <p>Send for <code>Model.update()</code> method.</p> <p><code>sender</code> is a <code>ormar.Model</code> class and <code>instance</code> is the model to be updated.</p>"},{"location":"signals/#post_update","title":"post_update","text":"<p><code>post_update(sender: Type[\"Model\"], instance: \"Model\")</code></p> <p>Send for <code>Model.update()</code> method.</p> <p><code>sender</code> is a <code>ormar.Model</code> class and <code>instance</code> is the model that was updated.</p>"},{"location":"signals/#pre_delete","title":"pre_delete","text":"<p><code>pre_delete(sender: Type[\"Model\"], instance: \"Model\")</code></p> <p>Send for <code>Model.save()</code> and <code>Model.objects.create()</code> methods.</p> <p><code>sender</code> is a <code>ormar.Model</code> class and <code>instance</code> is the model to be deleted.</p>"},{"location":"signals/#post_delete","title":"post_delete","text":"<p><code>post_delete(sender: Type[\"Model\"], instance: \"Model\")</code></p> <p>Send for <code>Model.update()</code> method.</p> <p><code>sender</code> is a <code>ormar.Model</code> class and <code>instance</code> is the model that was deleted.</p>"},{"location":"signals/#pre_relation_add","title":"pre_relation_add","text":"<p><code>pre_relation_add(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\",  relation_name: str, passed_args: Dict)</code></p> <p>Send for <code>Model.relation_name.add()</code> method for <code>ManyToMany</code> relations and reverse side of <code>ForeignKey</code> relation.</p> <p><code>sender</code> - sender class, <code>instance</code> - instance to which related model is added, <code>child</code> - model being added, <code>relation_name</code> - name of the relation to which child is added, for add signals also <code>passed_kwargs</code> - dict of kwargs passed to <code>add()</code></p>"},{"location":"signals/#post_relation_add","title":"post_relation_add","text":"<p><code>post_relation_add(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\",  relation_name: str, passed_args: Dict)</code></p> <p>Send for <code>Model.relation_name.add()</code> method for <code>ManyToMany</code> relations and reverse side of <code>ForeignKey</code> relation.</p> <p><code>sender</code> - sender class, <code>instance</code> - instance to which related model is added, <code>child</code> - model being added, <code>relation_name</code> - name of the relation to which child is added, for add signals also <code>passed_kwargs</code> - dict of kwargs passed to <code>add()</code></p>"},{"location":"signals/#pre_relation_remove","title":"pre_relation_remove","text":"<p><code>pre_relation_remove(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\",  relation_name: str)</code></p> <p>Send for <code>Model.relation_name.remove()</code> method for <code>ManyToMany</code> relations and reverse side of <code>ForeignKey</code> relation.</p> <p><code>sender</code> - sender class, <code>instance</code> - instance to which related model is added, <code>child</code> - model being added, <code>relation_name</code> - name of the relation to which child is added.</p>"},{"location":"signals/#post_relation_remove","title":"post_relation_remove","text":"<p><code>post_relation_remove(sender: Type[\"Model\"], instance: \"Model\", child: \"Model\",  relation_name: str, passed_args: Dict)</code></p> <p>Send for <code>Model.relation_name.remove()</code> method for <code>ManyToMany</code> relations and reverse side of <code>ForeignKey</code> relation.</p> <p><code>sender</code> - sender class, <code>instance</code> - instance to which related model is added, <code>child</code> - model being added, <code>relation_name</code> - name of the relation to which child is added.</p>"},{"location":"signals/#post_bulk_update","title":"post_bulk_update","text":"<p><code>post_bulk_update(sender: Type[\"Model\"], instances: List[\"Model\"], **kwargs)</code>,  Send for <code>Model.objects.bulk_update(List[objects])</code> method.</p>"},{"location":"signals/#defining-your-own-signals","title":"Defining your own signals","text":"<p>Note that you can create your own signals although you will have to send them manually in your code or subclass <code>ormar.Model</code> and trigger your signals there.</p> <p>Creating new signal is super easy. Following example will set a new signal with name your_custom_signal.</p> <pre><code>import databases\nimport sqlalchemy\n\nimport ormar\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(\"sqlite:///db.sqlite\"),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n    play_count: int = ormar.Integer(default=0)\n\nAlbum.ormar_config.signals.your_custom_signal = ormar.Signal()\nAlbum.ormar_config.signals.your_custom_signal.connect(your_receiver_name)\n</code></pre> <p>Actually under the hood signal is a <code>SignalEmitter</code> instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist <code>SignalEmitter</code> will create one for you.</p> <p>So example above can be simplified to. The <code>Signal</code> will be created for you.</p> <pre><code>Album.ormar_config.signals.your_custom_signal.connect(your_receiver_name)\n</code></pre> <p>Now to trigger this signal you need to call send method of the Signal.</p> <pre><code>await Album.ormar_config.signals.your_custom_signal.send(sender=Album)\n</code></pre> <p>Note that sender is the only required parameter and it should be ormar Model class.</p> <p>Additional parameters have to be passed as keyword arguments.</p> <pre><code>await Album.ormar_config.signals.your_custom_signal.send(sender=Album, my_param=True)\n</code></pre>"},{"location":"transactions/","title":"Transactions","text":"<p>Database transactions are supported thanks to <code>encode/databases</code> which is used to issue async queries.</p>"},{"location":"transactions/#basic-usage","title":"Basic usage","text":"<p>To use transactions use <code>database.transaction</code> as async context manager:</p> <pre><code>async with database.transaction():\n    # everything called here will be one transaction\n    await Model1().save()\n    await Model2().save()\n    ...\n</code></pre> <p>Note</p> <p>Note that it has to be the same <code>database</code> that the one used in Model's <code>ormar_config</code> object.</p> <p>To avoid passing <code>database</code> instance around in your code you can extract the instance from each <code>Model</code>. Database provided during declaration of <code>ormar.Model</code> is available through <code>ormar_config.database</code> and can be reached from both class and instance.</p> <pre><code>import databases\nimport sqlalchemy\nimport ormar\n\n\nbase_ormar_config = OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database = databases.Database(\"sqlite:///\"),\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=255)\n\n# database is accessible from class\ndatabase = Author.ormar_config.database\n\n# as well as from instance\nauthor = Author(name=\"Stephen King\")\ndatabase = author.ormar_config.database\n</code></pre> <p>You can also use <code>.transaction()</code> as a function decorator on any async function:</p> <pre><code>@database.transaction()\nasync def create_users(request):\n    ...\n</code></pre> <p>Transaction blocks are managed as task-local state. Nested transactions are fully supported, and are implemented using database savepoints.</p>"},{"location":"transactions/#manual-commits-rollbacks","title":"Manual commits/ rollbacks","text":"<p>For a lower-level transaction API you can trigger it manually</p> <pre><code>transaction = await database.transaction()\ntry:\n    await transaction.start()\n    ...\nexcept:\n    await transaction.rollback()\nelse:\n    await transaction.commit()\n</code></pre>"},{"location":"transactions/#testing","title":"Testing","text":"<p>Transactions can also be useful during testing when you can apply force rollback  and you do not have to clean the data after each test.</p> <pre><code>@pytest.mark.asyncio\nasync def sample_test():\n    async with database:\n        async with database.transaction(force_rollback=True):\n            # your test code here\n            ...\n</code></pre>"},{"location":"api/","title":"ormar","text":"<p>The <code>ormar</code> package is an async mini ORM for Python, with support for Postgres, MySQL, and SQLite.</p> <p>The main benefit of using <code>ormar</code> are:</p> <ul> <li>getting an async ORM that can be used with async frameworks (fastapi, starlette etc.)</li> <li>getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.)</li> </ul> <p>The goal was to create a simple ORM that can be used directly (as request and response models) with <code>fastapi</code> that bases it's data validation on pydantic.</p> <p>Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet.</p> <p>And what's a better name for python ORM than snakes cabinet :)</p>"},{"location":"api/#ormar.BaseField","title":"<code>BaseField</code>","text":"<p>               Bases: <code>FieldInfo</code></p> <p>BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions.</p> <p>All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr</p> Source code in <code>ormar/fields/base.py</code> <pre><code>class BaseField(FieldInfo):\n    \"\"\"\n    BaseField serves as a parent class for all basic Fields in ormar.\n    It keeps all common parameters available for all fields as well as\n    set of useful functions.\n\n    All values are kept as class variables, ormar Fields are never instantiated.\n    Subclasses pydantic.FieldInfo to keep the fields related\n    to pydantic field types like ConstrainedStr\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        self.__type__: type = kwargs.pop(\"__type__\", None)\n        self.__pydantic_type__: type = kwargs.pop(\"__pydantic_type__\", None)\n        self.__sample__: type = kwargs.pop(\"__sample__\", None)\n        self.related_name = kwargs.pop(\"related_name\", None)\n\n        self.column_type: sqlalchemy.Column = kwargs.pop(\"column_type\", None)\n        self.constraints: List = kwargs.pop(\"constraints\", list())\n        self.name: str = kwargs.pop(\"name\", None)\n        self.db_alias: str = kwargs.pop(\"alias\", None)\n\n        self.primary_key: bool = kwargs.pop(\"primary_key\", False)\n        self.autoincrement: bool = kwargs.pop(\"autoincrement\", False)\n        self.nullable: bool = kwargs.pop(\"nullable\", False)\n        self.sql_nullable: bool = kwargs.pop(\"sql_nullable\", False)\n        self.index: bool = kwargs.pop(\"index\", False)\n        self.unique: bool = kwargs.pop(\"unique\", False)\n\n        self.virtual: bool = kwargs.pop(\n            \"virtual\", None\n        )  # ManyToManyFields and reverse ForeignKeyFields\n        self.is_multi: bool = kwargs.pop(\"is_multi\", None)  # ManyToManyField\n        self.is_relation: bool = kwargs.pop(\n            \"is_relation\", None\n        )  # ForeignKeyField + subclasses\n        self.is_through: bool = kwargs.pop(\"is_through\", False)  # ThroughFields\n\n        self.through_relation_name = kwargs.pop(\"through_relation_name\", None)\n        self.through_reverse_relation_name = kwargs.pop(\n            \"through_reverse_relation_name\", None\n        )\n\n        self.skip_reverse: bool = kwargs.pop(\"skip_reverse\", False)\n        self.skip_field: bool = kwargs.pop(\"skip_field\", False)\n\n        self.owner: Type[\"Model\"] = kwargs.pop(\"owner\", None)\n        self.to: Type[\"Model\"] = kwargs.pop(\"to\", None)\n        self.to_pk_only: Type[\"Model\"] = kwargs.pop(\"to_pk_only\", None)\n        self.through: Type[\"Model\"] = kwargs.pop(\"through\", None)\n        self.self_reference: bool = kwargs.pop(\"self_reference\", False)\n        self.self_reference_primary: Optional[str] = kwargs.pop(\n            \"self_reference_primary\", None\n        )\n        self.orders_by: Optional[List[str]] = kwargs.pop(\"orders_by\", None)\n        self.related_orders_by: Optional[List[str]] = kwargs.pop(\n            \"related_orders_by\", None\n        )\n\n        self.encrypt_secret: str = kwargs.pop(\"encrypt_secret\", None)\n        self.encrypt_backend: EncryptBackends = kwargs.pop(\n            \"encrypt_backend\", EncryptBackends.NONE\n        )\n        self.encrypt_custom_backend: Optional[Type[EncryptBackend]] = kwargs.pop(\n            \"encrypt_custom_backend\", None\n        )\n\n        self.ormar_default: Any = kwargs.pop(\"default\", None)\n        self.server_default: Any = kwargs.pop(\"server_default\", None)\n\n        self.comment: str = kwargs.pop(\"comment\", None)\n\n        self.represent_as_base64_str: bool = kwargs.pop(\n            \"represent_as_base64_str\", False\n        )\n\n        for name, value in kwargs.items():\n            setattr(self, name, value)\n\n        kwargs.update(self.get_pydantic_default())\n        super().__init__(**kwargs)\n\n    def is_valid_uni_relation(self) -&gt; bool:\n        \"\"\"\n        Checks if field is a relation definition but only for ForeignKey relation,\n        so excludes ManyToMany fields, as well as virtual ForeignKey\n        (second side of FK relation).\n\n        Is used to define if a field is a db ForeignKey column that\n        should be saved/populated when dealing with internal/own\n        Model columns only.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return not self.is_multi and not self.virtual\n\n    def get_alias(self) -&gt; str:\n        \"\"\"\n        Used to translate Model column names to database column names during db queries.\n\n        :return: returns custom database column name if defined by user,\n        otherwise field name in ormar/pydantic\n        :rtype: str\n        \"\"\"\n        return self.db_alias if self.db_alias else self.name\n\n    def get_pydantic_default(self) -&gt; Dict:\n        \"\"\"\n        Generates base pydantic.FieldInfo with only default and optionally\n        required to fix pydantic Json field being set to required=False.\n        Used in an ormar Model Metaclass.\n\n        :return: instance of base pydantic.FieldInfo\n        :rtype: pydantic.FieldInfo\n        \"\"\"\n        base = self.default_value()\n        if base is None:\n            base = dict(default=None) if self.nullable else dict(default=_Unset)\n        return base\n\n    def default_value(self, use_server: bool = False) -&gt; Optional[Dict]:\n        \"\"\"\n        Returns a FieldInfo instance with populated default\n        (static) or default_factory (function).\n        If the field is a autoincrement primary key the default is None.\n        Otherwise field have to has either default, or default_factory populated.\n\n        If all default conditions fail None is returned.\n\n        Used in converting to pydantic FieldInfo.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: returns a call to pydantic.Field\n        which is returning a FieldInfo instance\n        :rtype: Optional[pydantic.FieldInfo]\n        \"\"\"\n        if self.is_auto_primary_key():\n            return dict(default=None)\n        if self.has_default(use_server=use_server):\n            default = (\n                self.ormar_default\n                if self.ormar_default is not None\n                else self.server_default\n            )\n            if callable(default):\n                return dict(default_factory=default)\n            return dict(default=default)\n        return None\n\n    def get_default(\n        self, use_server: bool = False, call_default_factory: bool = True\n    ) -&gt; Any:  # noqa CCR001\n        \"\"\"\n        Return default value for a field.\n        If the field is Callable the function is called and actual result is returned.\n        Used to populate default_values for pydantic Model in ormar Model Metaclass.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: default value for the field if set, otherwise implicit None\n        :rtype: Any\n        \"\"\"\n        if self.has_default():\n            default = (\n                self.ormar_default\n                if self.ormar_default is not None\n                else self._get_default_server_value(use_server=use_server)\n            )\n            return self._get_default_callable_value(\n                default=default,\n                call_default_factory=call_default_factory,\n            )\n\n    def _get_default_server_value(self, use_server: bool) -&gt; Any:\n        \"\"\"\n        Return default value for a server side if use_server is True\n        \"\"\"\n        return self.server_default if use_server else None\n\n    @staticmethod\n    def _get_default_callable_value(default: Any, call_default_factory: bool) -&gt; Any:\n        \"\"\"\n        Return default factory value if call_default_factory is True\n        and default is a callable.\n        \"\"\"\n        return default() if (callable(default) and call_default_factory) else default\n\n    def has_default(self, use_server: bool = True) -&gt; bool:\n        \"\"\"\n        Checks if the field has default value set.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: result of the check if default value is set\n        :rtype: bool\n        \"\"\"\n        return self.ormar_default is not None or (\n            self.server_default is not None and use_server\n        )\n\n    def is_auto_primary_key(self) -&gt; bool:\n        \"\"\"\n        Checks if field is first a primary key and if it,\n        it's than check if it's set to autoincrement.\n        Autoincrement primary_key is nullable/optional.\n\n        :return: result of the check for primary key and autoincrement\n        :rtype: bool\n        \"\"\"\n        if self.primary_key:\n            return self.autoincrement\n        return False\n\n    def construct_constraints(self) -&gt; List:\n        \"\"\"\n        Converts list of ormar constraints into sqlalchemy ForeignKeys.\n        Has to be done dynamically as sqlalchemy binds ForeignKey to the table.\n        And we need a new ForeignKey for subclasses of current model\n\n        :return: List of sqlalchemy foreign keys - by default one.\n        :rtype: List[sqlalchemy.schema.ForeignKey]\n        \"\"\"\n        constraints = [\n            sqlalchemy.ForeignKey(\n                con.reference,\n                ondelete=con.ondelete,\n                onupdate=con.onupdate,\n                name=f\"fk_{self.owner.ormar_config.tablename}_{self.to.ormar_config.tablename}\"\n                f\"_{self.to.get_column_alias(self.to.ormar_config.pkname)}_{self.name}\",\n            )\n            for con in self.constraints\n        ]\n        return constraints\n\n    def get_column(self, name: str) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table.\n        Populates name, column type constraints, as well as a number of parameters like\n        primary_key, index, unique, nullable, default and server_default.\n\n        :param name: name of the db column - used if alias is not set\n        :type name: str\n        :return: actual definition of the database column as sqlalchemy requires.\n        :rtype: sqlalchemy.Column\n        \"\"\"\n        if self.encrypt_backend == EncryptBackends.NONE:\n            column = sqlalchemy.Column(\n                self.db_alias or name,\n                self.column_type,\n                *self.construct_constraints(),\n                primary_key=self.primary_key,\n                nullable=self.sql_nullable,\n                index=self.index,\n                unique=self.unique,\n                default=self.ormar_default,\n                server_default=self.server_default,\n                comment=self.comment,\n            )\n        else:\n            column = self._get_encrypted_column(name=name)\n        return column\n\n    def _get_encrypted_column(self, name: str) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Returns EncryptedString column type instead of actual column.\n\n        :param name: column name\n        :type name: str\n        :return: newly defined column\n        :rtype:  sqlalchemy.Column\n        \"\"\"\n        if self.primary_key or self.is_relation:\n            raise ModelDefinitionError(\n                \"Primary key field and relations fields\" \"cannot be encrypted!\"\n            )\n        column = sqlalchemy.Column(\n            self.db_alias or name,\n            EncryptedString(\n                _field_type=self,\n                encrypt_secret=self.encrypt_secret,\n                encrypt_backend=self.encrypt_backend,\n                encrypt_custom_backend=self.encrypt_custom_backend,\n            ),\n            nullable=self.nullable,\n            index=self.index,\n            unique=self.unique,\n            default=self.ormar_default,\n            server_default=self.server_default,\n        )\n        return column\n\n    def expand_relationship(\n        self,\n        value: Any,\n        child: Union[\"Model\", \"NewBaseModel\"],\n        to_register: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Function overwritten for relations, in basic field the value is returned as is.\n        For relations the child model is first constructed (if needed),\n        registered in relation and returned.\n        For relation fields the value can be a pk value (Any type of field),\n        dict (from Model) or actual instance/list of a \"Model\".\n\n        :param value: a Model field value, returned untouched for non relation fields.\n        :type value: Any\n        :param child: a child Model to register\n        :type child: Union[\"Model\", \"NewBaseModel\"]\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: returns untouched value for normal fields, expands only for relations\n        :rtype: Any\n        \"\"\"\n        return value\n\n    def set_self_reference_flag(self) -&gt; None:\n        \"\"\"\n        Sets `self_reference` to True if field to and owner are same model.\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.owner is not None and (\n            self.owner == self.to or self.owner.ormar_config == self.to.ormar_config\n        ):\n            self.self_reference = True\n            self.self_reference_primary = self.name\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return False\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n\n    def get_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for reverse relation.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return \"\"  # pragma: no cover\n</code></pre>"},{"location":"api/#ormar.BaseField.construct_constraints","title":"<code>construct_constraints()</code>","text":"<p>Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model</p> <p>:return: List of sqlalchemy foreign keys - by default one. :rtype: List[sqlalchemy.schema.ForeignKey]</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def construct_constraints(self) -&gt; List:\n    \"\"\"\n    Converts list of ormar constraints into sqlalchemy ForeignKeys.\n    Has to be done dynamically as sqlalchemy binds ForeignKey to the table.\n    And we need a new ForeignKey for subclasses of current model\n\n    :return: List of sqlalchemy foreign keys - by default one.\n    :rtype: List[sqlalchemy.schema.ForeignKey]\n    \"\"\"\n    constraints = [\n        sqlalchemy.ForeignKey(\n            con.reference,\n            ondelete=con.ondelete,\n            onupdate=con.onupdate,\n            name=f\"fk_{self.owner.ormar_config.tablename}_{self.to.ormar_config.tablename}\"\n            f\"_{self.to.get_column_alias(self.to.ormar_config.pkname)}_{self.name}\",\n        )\n        for con in self.constraints\n    ]\n    return constraints\n</code></pre>"},{"location":"api/#ormar.BaseField.default_value","title":"<code>default_value(use_server=False)</code>","text":"<p>Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated.</p> <p>If all default conditions fail None is returned.</p> <p>Used in converting to pydantic FieldInfo.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: returns a call to pydantic.Field which is returning a FieldInfo instance :rtype: Optional[pydantic.FieldInfo]</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def default_value(self, use_server: bool = False) -&gt; Optional[Dict]:\n    \"\"\"\n    Returns a FieldInfo instance with populated default\n    (static) or default_factory (function).\n    If the field is a autoincrement primary key the default is None.\n    Otherwise field have to has either default, or default_factory populated.\n\n    If all default conditions fail None is returned.\n\n    Used in converting to pydantic FieldInfo.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: returns a call to pydantic.Field\n    which is returning a FieldInfo instance\n    :rtype: Optional[pydantic.FieldInfo]\n    \"\"\"\n    if self.is_auto_primary_key():\n        return dict(default=None)\n    if self.has_default(use_server=use_server):\n        default = (\n            self.ormar_default\n            if self.ormar_default is not None\n            else self.server_default\n        )\n        if callable(default):\n            return dict(default_factory=default)\n        return dict(default=default)\n    return None\n</code></pre>"},{"location":"api/#ormar.BaseField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n</code></pre>"},{"location":"api/#ormar.BaseField.expand_relationship","title":"<code>expand_relationship(value, child, to_register=True)</code>","text":"<p>Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\".</p> <p>:param value: a Model field value, returned untouched for non relation fields. :type value: Any :param child: a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] :param to_register: flag if the relation should be set in RelationshipManager :type to_register: bool :return: returns untouched value for normal fields, expands only for relations :rtype: Any</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def expand_relationship(\n    self,\n    value: Any,\n    child: Union[\"Model\", \"NewBaseModel\"],\n    to_register: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Function overwritten for relations, in basic field the value is returned as is.\n    For relations the child model is first constructed (if needed),\n    registered in relation and returned.\n    For relation fields the value can be a pk value (Any type of field),\n    dict (from Model) or actual instance/list of a \"Model\".\n\n    :param value: a Model field value, returned untouched for non relation fields.\n    :type value: Any\n    :param child: a child Model to register\n    :type child: Union[\"Model\", \"NewBaseModel\"]\n    :param to_register: flag if the relation should be set in RelationshipManager\n    :type to_register: bool\n    :return: returns untouched value for normal fields, expands only for relations\n    :rtype: Any\n    \"\"\"\n    return value\n</code></pre>"},{"location":"api/#ormar.BaseField.get_alias","title":"<code>get_alias()</code>","text":"<p>Used to translate Model column names to database column names during db queries.</p> <p>:return: returns custom database column name if defined by user, otherwise field name in ormar/pydantic :rtype: str</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_alias(self) -&gt; str:\n    \"\"\"\n    Used to translate Model column names to database column names during db queries.\n\n    :return: returns custom database column name if defined by user,\n    otherwise field name in ormar/pydantic\n    :rtype: str\n    \"\"\"\n    return self.db_alias if self.db_alias else self.name\n</code></pre>"},{"location":"api/#ormar.BaseField.get_column","title":"<code>get_column(name)</code>","text":"<p>Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default.</p> <p>:param name: name of the db column - used if alias is not set :type name: str :return: actual definition of the database column as sqlalchemy requires. :rtype: sqlalchemy.Column</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_column(self, name: str) -&gt; sqlalchemy.Column:\n    \"\"\"\n    Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table.\n    Populates name, column type constraints, as well as a number of parameters like\n    primary_key, index, unique, nullable, default and server_default.\n\n    :param name: name of the db column - used if alias is not set\n    :type name: str\n    :return: actual definition of the database column as sqlalchemy requires.\n    :rtype: sqlalchemy.Column\n    \"\"\"\n    if self.encrypt_backend == EncryptBackends.NONE:\n        column = sqlalchemy.Column(\n            self.db_alias or name,\n            self.column_type,\n            *self.construct_constraints(),\n            primary_key=self.primary_key,\n            nullable=self.sql_nullable,\n            index=self.index,\n            unique=self.unique,\n            default=self.ormar_default,\n            server_default=self.server_default,\n            comment=self.comment,\n        )\n    else:\n        column = self._get_encrypted_column(name=name)\n    return column\n</code></pre>"},{"location":"api/#ormar.BaseField.get_default","title":"<code>get_default(use_server=False, call_default_factory=True)</code>","text":"<p>Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: default value for the field if set, otherwise implicit None :rtype: Any</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_default(\n    self, use_server: bool = False, call_default_factory: bool = True\n) -&gt; Any:  # noqa CCR001\n    \"\"\"\n    Return default value for a field.\n    If the field is Callable the function is called and actual result is returned.\n    Used to populate default_values for pydantic Model in ormar Model Metaclass.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: default value for the field if set, otherwise implicit None\n    :rtype: Any\n    \"\"\"\n    if self.has_default():\n        default = (\n            self.ormar_default\n            if self.ormar_default is not None\n            else self._get_default_server_value(use_server=use_server)\n        )\n        return self._get_default_callable_value(\n            default=default,\n            call_default_factory=call_default_factory,\n        )\n</code></pre>"},{"location":"api/#ormar.BaseField.get_pydantic_default","title":"<code>get_pydantic_default()</code>","text":"<p>Generates base pydantic.FieldInfo with only default and optionally required to fix pydantic Json field being set to required=False. Used in an ormar Model Metaclass.</p> <p>:return: instance of base pydantic.FieldInfo :rtype: pydantic.FieldInfo</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_pydantic_default(self) -&gt; Dict:\n    \"\"\"\n    Generates base pydantic.FieldInfo with only default and optionally\n    required to fix pydantic Json field being set to required=False.\n    Used in an ormar Model Metaclass.\n\n    :return: instance of base pydantic.FieldInfo\n    :rtype: pydantic.FieldInfo\n    \"\"\"\n    base = self.default_value()\n    if base is None:\n        base = dict(default=None) if self.nullable else dict(default=_Unset)\n    return base\n</code></pre>"},{"location":"api/#ormar.BaseField.get_related_name","title":"<code>get_related_name()</code>","text":"<p>Returns name to use for reverse relation. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for reverse relation.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return \"\"  # pragma: no cover\n</code></pre>"},{"location":"api/#ormar.BaseField.has_default","title":"<code>has_default(use_server=True)</code>","text":"<p>Checks if the field has default value set.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: result of the check if default value is set :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def has_default(self, use_server: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if the field has default value set.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: result of the check if default value is set\n    :rtype: bool\n    \"\"\"\n    return self.ormar_default is not None or (\n        self.server_default is not None and use_server\n    )\n</code></pre>"},{"location":"api/#ormar.BaseField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/#ormar.BaseField.is_auto_primary_key","title":"<code>is_auto_primary_key()</code>","text":"<p>Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional.</p> <p>:return: result of the check for primary key and autoincrement :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def is_auto_primary_key(self) -&gt; bool:\n    \"\"\"\n    Checks if field is first a primary key and if it,\n    it's than check if it's set to autoincrement.\n    Autoincrement primary_key is nullable/optional.\n\n    :return: result of the check for primary key and autoincrement\n    :rtype: bool\n    \"\"\"\n    if self.primary_key:\n        return self.autoincrement\n    return False\n</code></pre>"},{"location":"api/#ormar.BaseField.is_valid_uni_relation","title":"<code>is_valid_uni_relation()</code>","text":"<p>Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation).</p> <p>Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def is_valid_uni_relation(self) -&gt; bool:\n    \"\"\"\n    Checks if field is a relation definition but only for ForeignKey relation,\n    so excludes ManyToMany fields, as well as virtual ForeignKey\n    (second side of FK relation).\n\n    Is used to define if a field is a db ForeignKey column that\n    should be saved/populated when dealing with internal/own\n    Model columns only.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return not self.is_multi and not self.virtual\n</code></pre>"},{"location":"api/#ormar.BaseField.set_self_reference_flag","title":"<code>set_self_reference_flag()</code>","text":"<p>Sets <code>self_reference</code> to True if field to and owner are same model. :return: None :rtype: None</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def set_self_reference_flag(self) -&gt; None:\n    \"\"\"\n    Sets `self_reference` to True if field to and owner are same model.\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.owner is not None and (\n        self.owner == self.to or self.owner.ormar_config == self.to.ormar_config\n    ):\n        self.self_reference = True\n        self.self_reference_primary = self.name\n</code></pre>"},{"location":"api/#ormar.BigInteger","title":"<code>BigInteger</code>","text":"<p>               Bases: <code>Integer</code>, <code>int</code></p> <p>BigInteger field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class BigInteger(Integer, int):\n    \"\"\"\n    BigInteger field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.BigInteger()\n</code></pre>"},{"location":"api/#ormar.BigInteger.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.BigInteger()\n</code></pre>"},{"location":"api/#ormar.Boolean","title":"<code>Boolean</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>int</code></p> <p>Boolean field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Boolean(ModelFieldFactory, int):\n    \"\"\"\n    Boolean field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = bool\n    _sample = True\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Boolean()\n</code></pre>"},{"location":"api/#ormar.Boolean.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Boolean()\n</code></pre>"},{"location":"api/#ormar.CheckColumns","title":"<code>CheckColumns</code>","text":"<p>               Bases: <code>CheckConstraint</code></p> <p>Subclass of sqlalchemy.CheckConstraint. Used to avoid importing anything from sqlalchemy by user.</p> <p>Note that some databases do not actively support check constraints such as MySQL.</p> Source code in <code>ormar/fields/constraints.py</code> <pre><code>class CheckColumns(CheckConstraint):\n    \"\"\"\n    Subclass of sqlalchemy.CheckConstraint.\n    Used to avoid importing anything from sqlalchemy by user.\n\n    Note that some databases do not actively support check constraints such as MySQL.\n    \"\"\"\n</code></pre>"},{"location":"api/#ormar.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>date</code></p> <p>Date field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Date(ModelFieldFactory, datetime.date):\n    \"\"\"\n    Date field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.date\n    _sample = \"date\"\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Date()\n</code></pre>"},{"location":"api/#ormar.Date.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Date()\n</code></pre>"},{"location":"api/#ormar.DateTime","title":"<code>DateTime</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>datetime</code></p> <p>DateTime field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class DateTime(ModelFieldFactory, datetime.datetime):\n    \"\"\"\n    DateTime field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.datetime\n    _sample = \"datetime\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, timezone: bool = False, **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.DateTime(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/#ormar.DateTime.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.DateTime(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/#ormar.Decimal","title":"<code>Decimal</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>Decimal</code></p> <p>Decimal field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Decimal(ModelFieldFactory, decimal.Decimal):\n    \"\"\"\n    Decimal field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = decimal.Decimal\n    _sample = 0.0\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        minimum: Optional[float] = None,\n        maximum: Optional[float] = None,\n        multiple_of: Optional[int] = None,\n        precision: Optional[int] = None,\n        scale: Optional[int] = None,\n        max_digits: Optional[int] = None,\n        decimal_places: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n\n        if kwargs.get(\"max_digits\"):\n            kwargs[\"precision\"] = kwargs[\"max_digits\"]\n        elif kwargs.get(\"precision\"):\n            kwargs[\"max_digits\"] = kwargs[\"precision\"]\n\n        if kwargs.get(\"decimal_places\"):\n            kwargs[\"scale\"] = kwargs[\"decimal_places\"]\n        elif kwargs.get(\"scale\"):\n            kwargs[\"decimal_places\"] = kwargs[\"scale\"]\n\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        precision = kwargs.get(\"precision\")\n        scale = kwargs.get(\"scale\")\n        return sqlalchemy.DECIMAL(precision=precision, scale=scale)\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        precision = kwargs.get(\"precision\")\n        scale = kwargs.get(\"scale\")\n        if precision is None or precision &lt; 0 or scale is None or scale &lt; 0:\n            raise ModelDefinitionError(\n                \"Parameters scale and precision are required for field Decimal\"\n            )\n</code></pre>"},{"location":"api/#ormar.Decimal.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    precision = kwargs.get(\"precision\")\n    scale = kwargs.get(\"scale\")\n    return sqlalchemy.DECIMAL(precision=precision, scale=scale)\n</code></pre>"},{"location":"api/#ormar.Decimal.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    precision = kwargs.get(\"precision\")\n    scale = kwargs.get(\"scale\")\n    if precision is None or precision &lt; 0 or scale is None or scale &lt; 0:\n        raise ModelDefinitionError(\n            \"Parameters scale and precision are required for field Decimal\"\n        )\n</code></pre>"},{"location":"api/#ormar.Enum","title":"<code>Enum</code>","text":"<p>               Bases: <code>ModelFieldFactory</code></p> <p>Enum field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Enum(ModelFieldFactory):\n    \"\"\"\n    Enum field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = E\n    _sample = None\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, enum_class: Type[E], **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        enum_class = kwargs.get(\"enum_class\")\n        if enum_class is None or not isinstance(enum_class, EnumMeta):\n            raise ModelDefinitionError(\"Enum Field choices must be EnumType\")\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        enum_cls = kwargs.get(\"enum_class\")\n        return sqlalchemy.Enum(enum_cls)\n</code></pre>"},{"location":"api/#ormar.ExcludableItems","title":"<code>ExcludableItems</code>","text":"<p>Keeps a dictionary of Excludables by alias + model_name keys to allow quick lookup by nested models without need to travers deeply nested dictionaries and passing include/exclude around</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>class ExcludableItems:\n    \"\"\"\n    Keeps a dictionary of Excludables by alias + model_name keys\n    to allow quick lookup by nested models without need to travers\n    deeply nested dictionaries and passing include/exclude around\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.items: Dict[str, Excludable] = dict()\n\n    @classmethod\n    def from_excludable(cls, other: \"ExcludableItems\") -&gt; \"ExcludableItems\":\n        \"\"\"\n        Copy passed ExcludableItems to avoid inplace modifications.\n\n        :param other: other excludable items to be copied\n        :type other: ormar.models.excludable.ExcludableItems\n        :return: copy of other\n        :rtype: ormar.models.excludable.ExcludableItems\n        \"\"\"\n        new_excludable = cls()\n        for key, value in other.items.items():\n            new_excludable.items[key] = value.get_copy()\n        return new_excludable\n\n    def include_entry_count(self) -&gt; int:\n        \"\"\"\n        Returns count of include items inside\n        \"\"\"\n        count = 0\n        for key in self.items.keys():\n            count += len(self.items[key].include)\n        return count\n\n    def get(self, model_cls: Type[\"Model\"], alias: str = \"\") -&gt; Excludable:\n        \"\"\"\n        Return Excludable for given model and alias.\n\n        :param model_cls: target model to check\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param alias: table alias from relation manager\n        :type alias: str\n        :return: Excludable for given model and alias\n        :rtype: ormar.models.excludable.Excludable\n        \"\"\"\n        key = f\"{alias + '_' if alias else ''}{model_cls.get_name(lower=True)}\"\n        excludable = self.items.get(key)\n        if not excludable:\n            excludable = Excludable()\n            self.items[key] = excludable\n        return excludable\n\n    def build(\n        self,\n        items: Union[List[str], str, Tuple[str], Set[str], Dict],\n        model_cls: Type[\"Model\"],\n        is_exclude: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Receives the one of the types of items and parses them as to achieve\n        a end situation with one excludable per alias/model in relation.\n\n        Each excludable has two sets of values - one to include, one to exclude.\n\n        :param items: values to be included or excluded\n        :type items: Union[List[str], str, Tuple[str], Set[str], Dict]\n        :param model_cls: source model from which relations are constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if items should be included or excluded\n        :type is_exclude: bool\n        \"\"\"\n        if isinstance(items, str):\n            items = {items}\n\n        if isinstance(items, Dict):\n            self._traverse_dict(\n                values=items,\n                source_model=model_cls,\n                model_cls=model_cls,\n                is_exclude=is_exclude,\n            )\n\n        else:\n            items = set(items)\n            nested_items = set(x for x in items if \"__\" in x)\n            items.difference_update(nested_items)\n            self._set_excludes(\n                items=items,\n                model_name=model_cls.get_name(lower=True),\n                is_exclude=is_exclude,\n            )\n            if nested_items:\n                self._traverse_list(\n                    values=nested_items, model_cls=model_cls, is_exclude=is_exclude\n                )\n\n    def _set_excludes(\n        self, items: Set, model_name: str, is_exclude: bool, alias: str = \"\"\n    ) -&gt; None:\n        \"\"\"\n        Sets set of values to be included or excluded for given key and model.\n\n        :param items: items to include/exclude\n        :type items: set\n        :param model_name: name of model to construct key\n        :type model_name: str\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        :param alias:\n        :type alias: str\n        \"\"\"\n        key = f\"{alias + '_' if alias else ''}{model_name}\"\n        excludable = self.items.get(key)\n        if not excludable:\n            excludable = Excludable()\n        excludable.set_values(value=items, is_exclude=is_exclude)\n        self.items[key] = excludable\n\n    def _traverse_dict(  # noqa: CFQ002\n        self,\n        values: Dict,\n        source_model: Type[\"Model\"],\n        model_cls: Type[\"Model\"],\n        is_exclude: bool,\n        related_items: Optional[List] = None,\n        alias: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Goes through dict of nested values and construct/update Excludables.\n\n        :param values: items to include/exclude\n        :type values: Dict\n        :param source_model: source model from which relations are constructed\n        :type source_model: ormar.models.metaclass.ModelMetaclass\n        :param model_cls: model from which current relation is constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        :param related_items: list of names of related fields chain\n        :type related_items: List\n        :param alias: alias of relation\n        :type alias: str\n        \"\"\"\n        self_fields = set()\n        related_items = related_items[:] if related_items else []\n        for key, value in values.items():\n            if value is ...:\n                self_fields.add(key)\n            elif isinstance(value, set):\n                (\n                    table_prefix,\n                    target_model,\n                    _,\n                    _,\n                ) = get_relationship_alias_model_and_str(\n                    source_model=source_model, related_parts=related_items + [key]\n                )\n                self._set_excludes(\n                    items=value,\n                    model_name=target_model.get_name(),\n                    is_exclude=is_exclude,\n                    alias=table_prefix,\n                )\n            else:\n                # dict\n                related_items.append(key)\n                (\n                    table_prefix,\n                    target_model,\n                    _,\n                    _,\n                ) = get_relationship_alias_model_and_str(\n                    source_model=source_model, related_parts=related_items\n                )\n                self._traverse_dict(\n                    values=value,\n                    source_model=source_model,\n                    model_cls=target_model,\n                    is_exclude=is_exclude,\n                    related_items=related_items,\n                    alias=table_prefix,\n                )\n        if self_fields:\n            self._set_excludes(\n                items=self_fields,\n                model_name=model_cls.get_name(),\n                is_exclude=is_exclude,\n                alias=alias,\n            )\n\n    def _traverse_list(\n        self, values: Set[str], model_cls: Type[\"Model\"], is_exclude: bool\n    ) -&gt; None:\n        \"\"\"\n        Goes through list of values and construct/update Excludables.\n\n        :param values: items to include/exclude\n        :type values: set\n        :param model_cls: model from which current relation is constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        \"\"\"\n        # here we have only nested related keys\n        for key in values:\n            key_split = key.split(\"__\")\n            related_items, field_name = key_split[:-1], key_split[-1]\n            (table_prefix, target_model, _, _) = get_relationship_alias_model_and_str(\n                source_model=model_cls, related_parts=related_items\n            )\n            self._set_excludes(\n                items={field_name},\n                model_name=target_model.get_name(),\n                is_exclude=is_exclude,\n                alias=table_prefix,\n            )\n</code></pre>"},{"location":"api/#ormar.ExcludableItems.build","title":"<code>build(items, model_cls, is_exclude=False)</code>","text":"<p>Receives the one of the types of items and parses them as to achieve a end situation with one excludable per alias/model in relation.</p> <p>Each excludable has two sets of values - one to include, one to exclude.</p> <p>:param items: values to be included or excluded :type items: Union[List[str], str, Tuple[str], Set[str], Dict] :param model_cls: source model from which relations are constructed :type model_cls: ormar.models.metaclass.ModelMetaclass :param is_exclude: flag if items should be included or excluded :type is_exclude: bool</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def build(\n    self,\n    items: Union[List[str], str, Tuple[str], Set[str], Dict],\n    model_cls: Type[\"Model\"],\n    is_exclude: bool = False,\n) -&gt; None:\n    \"\"\"\n    Receives the one of the types of items and parses them as to achieve\n    a end situation with one excludable per alias/model in relation.\n\n    Each excludable has two sets of values - one to include, one to exclude.\n\n    :param items: values to be included or excluded\n    :type items: Union[List[str], str, Tuple[str], Set[str], Dict]\n    :param model_cls: source model from which relations are constructed\n    :type model_cls: ormar.models.metaclass.ModelMetaclass\n    :param is_exclude: flag if items should be included or excluded\n    :type is_exclude: bool\n    \"\"\"\n    if isinstance(items, str):\n        items = {items}\n\n    if isinstance(items, Dict):\n        self._traverse_dict(\n            values=items,\n            source_model=model_cls,\n            model_cls=model_cls,\n            is_exclude=is_exclude,\n        )\n\n    else:\n        items = set(items)\n        nested_items = set(x for x in items if \"__\" in x)\n        items.difference_update(nested_items)\n        self._set_excludes(\n            items=items,\n            model_name=model_cls.get_name(lower=True),\n            is_exclude=is_exclude,\n        )\n        if nested_items:\n            self._traverse_list(\n                values=nested_items, model_cls=model_cls, is_exclude=is_exclude\n            )\n</code></pre>"},{"location":"api/#ormar.ExcludableItems.from_excludable","title":"<code>from_excludable(other)</code>  <code>classmethod</code>","text":"<p>Copy passed ExcludableItems to avoid inplace modifications.</p> <p>:param other: other excludable items to be copied :type other: ormar.models.excludable.ExcludableItems :return: copy of other :rtype: ormar.models.excludable.ExcludableItems</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>@classmethod\ndef from_excludable(cls, other: \"ExcludableItems\") -&gt; \"ExcludableItems\":\n    \"\"\"\n    Copy passed ExcludableItems to avoid inplace modifications.\n\n    :param other: other excludable items to be copied\n    :type other: ormar.models.excludable.ExcludableItems\n    :return: copy of other\n    :rtype: ormar.models.excludable.ExcludableItems\n    \"\"\"\n    new_excludable = cls()\n    for key, value in other.items.items():\n        new_excludable.items[key] = value.get_copy()\n    return new_excludable\n</code></pre>"},{"location":"api/#ormar.ExcludableItems.get","title":"<code>get(model_cls, alias='')</code>","text":"<p>Return Excludable for given model and alias.</p> <p>:param model_cls: target model to check :type model_cls: ormar.models.metaclass.ModelMetaclass :param alias: table alias from relation manager :type alias: str :return: Excludable for given model and alias :rtype: ormar.models.excludable.Excludable</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def get(self, model_cls: Type[\"Model\"], alias: str = \"\") -&gt; Excludable:\n    \"\"\"\n    Return Excludable for given model and alias.\n\n    :param model_cls: target model to check\n    :type model_cls: ormar.models.metaclass.ModelMetaclass\n    :param alias: table alias from relation manager\n    :type alias: str\n    :return: Excludable for given model and alias\n    :rtype: ormar.models.excludable.Excludable\n    \"\"\"\n    key = f\"{alias + '_' if alias else ''}{model_cls.get_name(lower=True)}\"\n    excludable = self.items.get(key)\n    if not excludable:\n        excludable = Excludable()\n        self.items[key] = excludable\n    return excludable\n</code></pre>"},{"location":"api/#ormar.ExcludableItems.include_entry_count","title":"<code>include_entry_count()</code>","text":"<p>Returns count of include items inside</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def include_entry_count(self) -&gt; int:\n    \"\"\"\n    Returns count of include items inside\n    \"\"\"\n    count = 0\n    for key in self.items.keys():\n        count += len(self.items[key].include)\n    return count\n</code></pre>"},{"location":"api/#ormar.Float","title":"<code>Float</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>float</code></p> <p>Float field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Float(ModelFieldFactory, float):\n    \"\"\"\n    Float field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = float\n    _sample = 0.0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[float] = None,\n        maximum: Optional[float] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Float()\n</code></pre>"},{"location":"api/#ormar.Float.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Float()\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField","title":"<code>ForeignKeyField</code>","text":"<p>               Bases: <code>BaseField</code></p> <p>Actual class returned from ForeignKey function call and stored in model_fields.</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>class ForeignKeyField(BaseField):\n    \"\"\"\n    Actual class returned from ForeignKey function call and stored in model_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        if TYPE_CHECKING:  # pragma: no cover\n            self.__type__: type\n            self.to: Type[\"Model\"]\n        self.ondelete: str = kwargs.pop(\"ondelete\", None)\n        self.onupdate: str = kwargs.pop(\"onupdate\", None)\n        super().__init__(**kwargs)\n\n    def get_source_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for source relation name.\n        For FK it's the same, differs for m2m fields.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return self.get_related_name()\n\n    def get_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for reverse relation.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return self.related_name or self.owner.get_name() + \"s\"\n\n    def default_target_field_name(self) -&gt; str:\n        \"\"\"\n        Returns default target model name on through model.\n        :return: name of the field\n        :rtype: str\n        \"\"\"\n        prefix = \"from_\" if self.self_reference else \"\"\n        return self.through_reverse_relation_name or f\"{prefix}{self.to.get_name()}\"\n\n    def default_source_field_name(self) -&gt; str:\n        \"\"\"\n        Returns default target model name on through model.\n        :return: name of the field\n        :rtype: str\n        \"\"\"\n        prefix = \"to_\" if self.self_reference else \"\"\n        return self.through_relation_name or f\"{prefix}{self.owner.get_name()}\"\n\n    def get_filter_clause_target(self) -&gt; Type[\"Model\"]:\n        return self.to\n\n    def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n        \"\"\"\n        Extract names of the database columns or model fields that are connected\n        with given relation based on use_alias switch and which side of the relation\n        the current field is - reverse or normal.\n\n        :param use_alias: use db names aliases or model fields\n        :type use_alias: bool\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if use_alias:\n            return self._get_model_relation_fields_alias()\n        return self._get_model_relation_fields_name()\n\n    def _get_model_relation_fields_name(self) -&gt; str:\n        if self.virtual:\n            return self.owner.ormar_config.pkname\n        return self.name\n\n    def _get_model_relation_fields_alias(self) -&gt; str:\n        if self.virtual:\n            return self.owner.ormar_config.model_fields[\n                self.owner.ormar_config.pkname\n            ].get_alias()\n        return self.get_alias()\n\n    def get_related_field_alias(self) -&gt; str:\n        \"\"\"\n        Extract names of the related database columns or that are connected\n        with given relation based to use as a target in filter clause.\n\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, Dict[str, str]]\n        \"\"\"\n        if self.virtual:\n            field_name = self.get_related_name()\n            field = self.to.ormar_config.model_fields[field_name]\n            return field.get_alias()\n        target_field = self.to.get_column_alias(self.to.ormar_config.pkname)\n        return target_field\n\n    def get_related_field_name(self) -&gt; Union[str, List[str]]:\n        \"\"\"\n        Returns name of the relation field that should be used in prefetch query.\n        This field is later used to register relation in prefetch query,\n        populate relations dict, and populate nested model in prefetch query.\n\n        :return: name(s) of the field\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if self.virtual:\n            return self.get_related_name()\n        return self.to.ormar_config.pkname\n\n    def _evaluate_forward_ref(\n        self, globalns: Any, localns: Any, is_through: bool = False\n    ) -&gt; None:\n        target = \"through\" if is_through else \"to\"\n        target_obj = getattr(self, target)\n        if sys.version_info.minor &lt;= 8:  # pragma: no cover\n            evaluated = target_obj._evaluate(globalns, localns)\n        else:  # pragma: no cover\n            evaluated = target_obj._evaluate(globalns, localns, recursive_guard=set())\n        setattr(self, target, evaluated)\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.to.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns)\n            (\n                self.__type__,\n                self.constraints,\n                self.column_type,\n                self.to_pk_only,\n            ) = populate_fk_params_based_on_to_model(\n                to=self.to,\n                nullable=self.nullable,\n                ondelete=self.ondelete,\n                onupdate=self.onupdate,\n            )\n\n    def _extract_model_from_sequence(\n        self, value: List, child: \"Model\", to_register: bool\n    ) -&gt; List[\"Model\"]:\n        \"\"\"\n        Takes a list of Models and registers them on parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in reverse FK relations.\n\n        :param value: list of Model\n        :type value: List\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: list (if needed) registered Models\n        :rtype: List[\"Model\"]\n        \"\"\"\n        return [\n            self.expand_relationship(  # type: ignore\n                value=val, child=child, to_register=to_register\n            )\n            for val in value\n        ]\n\n    def _register_existing_model(\n        self, value: \"Model\", child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes already created instance and registers it for parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in reverse FK relations and normal FK for single models.\n\n        :param value: already instantiated Model\n        :type value: Model\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        if to_register:\n            self.register_relation(model=value, child=child)\n        return value\n\n    def _construct_model_from_dict(\n        self, value: dict, child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes a dictionary, creates a instance and registers it for parent.\n        If dictionary contains only one field and it's a pk it is a __pk_only__ model.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in normal FK for dictionaries.\n\n        :param value: dictionary of a Model\n        :type value: dict\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        pk_only_model = None\n        keys = set(value.keys())\n        own_keys = keys - self.to.extract_related_names()\n        if (\n            len(own_keys) == 1\n            and list(own_keys)[0] == self.to.ormar_config.pkname\n            and value.get(self.to.ormar_config.pkname) is not None\n            and not self.is_through\n        ):\n            value[\"__pk_only__\"] = True\n            pk_only_model = self.to_pk_only(**value)\n        model = self.to(**value)\n        if to_register:\n            self.register_relation(model=model, child=child)\n        return pk_only_model if pk_only_model is not None else model\n\n    def _construct_model_from_pk(\n        self, value: Any, child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes a pk value, creates a dummy instance and registers it for parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in normal FK for dictionaries.\n\n        :param value: value of a related pk / fk column\n        :type value: Any\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        if self.to.pk_type() == uuid.UUID and isinstance(value, str):  # pragma: nocover\n            value = uuid.UUID(value)\n        if not isinstance(value, self.to.pk_type()):\n            if isinstance(value, self.to_pk_only):\n                value = getattr(value, self.to.ormar_config.pkname)\n            else:\n                raise RelationshipInstanceError(\n                    f\"Relationship error - ForeignKey {self.to.__name__} \"\n                    f\"is of type {self.to.pk_type()} \"\n                    f\"while {type(value)} passed as a parameter.\"\n                )\n        model = create_dummy_instance(fk=self.to, pk=value)\n        if to_register:\n            self.register_relation(model=model, child=child)\n        return model\n\n    def register_relation(self, model: \"Model\", child: \"Model\") -&gt; None:\n        \"\"\"\n        Registers relation between parent and child in relation manager.\n        Relation manager is kep on each model (different instance).\n\n        Used in Metaclass and sometimes some relations are missing\n        (i.e. cloned Models in fastapi might miss one).\n\n        :param model: parent model (with relation definition)\n        :type model: Model class\n        :param child: child model\n        :type child: Model class\n        \"\"\"\n        model._orm.add(parent=model, child=child, field=self)\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.to.__class__ == ForwardRef\n\n    def expand_relationship(\n        self,\n        value: Any,\n        child: Union[\"Model\", \"NewBaseModel\"],\n        to_register: bool = True,\n    ) -&gt; Optional[Union[\"Model\", List[\"Model\"]]]:\n        \"\"\"\n        For relations the child model is first constructed (if needed),\n        registered in relation and returned.\n        For relation fields the value can be a pk value (Any type of field),\n        dict (from Model) or actual instance/list of a \"Model\".\n\n        Selects the appropriate constructor based on a passed value.\n\n        :param value: a Model field value, returned untouched for non relation fields.\n        :type value: Any\n        :param child: a child Model to register\n        :type child: Union[\"Model\", \"NewBaseModel\"]\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: returns a Model or a list of Models\n        :rtype: Optional[Union[\"Model\", List[\"Model\"]]]\n        \"\"\"\n        if value is None:\n            return None if not self.virtual else []\n        constructors = {\n            f\"{self.to.__name__}\": self._register_existing_model,\n            \"dict\": self._construct_model_from_dict,\n            \"list\": self._extract_model_from_sequence,\n        }\n\n        model = constructors.get(  # type: ignore\n            value.__class__.__name__, self._construct_model_from_pk\n        )(value, child, to_register)\n        return model\n\n    def get_relation_name(self) -&gt; str:  # pragma: no cover\n        \"\"\"\n        Returns name of the relation, which can be a own name or through model\n        names for m2m models\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.name\n\n    def get_source_model(self) -&gt; Type[\"Model\"]:  # pragma: no cover\n        \"\"\"\n        Returns model from which the relation comes -&gt; either owner or through model\n\n        :return: source model\n        :rtype: Type[\"Model\"]\n        \"\"\"\n        return self.owner\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.default_source_field_name","title":"<code>default_source_field_name()</code>","text":"<p>Returns default target model name on through model. :return: name of the field :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def default_source_field_name(self) -&gt; str:\n    \"\"\"\n    Returns default target model name on through model.\n    :return: name of the field\n    :rtype: str\n    \"\"\"\n    prefix = \"to_\" if self.self_reference else \"\"\n    return self.through_relation_name or f\"{prefix}{self.owner.get_name()}\"\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.default_target_field_name","title":"<code>default_target_field_name()</code>","text":"<p>Returns default target model name on through model. :return: name of the field :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def default_target_field_name(self) -&gt; str:\n    \"\"\"\n    Returns default target model name on through model.\n    :return: name of the field\n    :rtype: str\n    \"\"\"\n    prefix = \"from_\" if self.self_reference else \"\"\n    return self.through_reverse_relation_name or f\"{prefix}{self.to.get_name()}\"\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.to.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns)\n        (\n            self.__type__,\n            self.constraints,\n            self.column_type,\n            self.to_pk_only,\n        ) = populate_fk_params_based_on_to_model(\n            to=self.to,\n            nullable=self.nullable,\n            ondelete=self.ondelete,\n            onupdate=self.onupdate,\n        )\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.expand_relationship","title":"<code>expand_relationship(value, child, to_register=True)</code>","text":"<p>For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\".</p> <p>Selects the appropriate constructor based on a passed value.</p> <p>:param value: a Model field value, returned untouched for non relation fields. :type value: Any :param child: a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] :param to_register: flag if the relation should be set in RelationshipManager :type to_register: bool :return: returns a Model or a list of Models :rtype: Optional[Union[\"Model\", List[\"Model\"]]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def expand_relationship(\n    self,\n    value: Any,\n    child: Union[\"Model\", \"NewBaseModel\"],\n    to_register: bool = True,\n) -&gt; Optional[Union[\"Model\", List[\"Model\"]]]:\n    \"\"\"\n    For relations the child model is first constructed (if needed),\n    registered in relation and returned.\n    For relation fields the value can be a pk value (Any type of field),\n    dict (from Model) or actual instance/list of a \"Model\".\n\n    Selects the appropriate constructor based on a passed value.\n\n    :param value: a Model field value, returned untouched for non relation fields.\n    :type value: Any\n    :param child: a child Model to register\n    :type child: Union[\"Model\", \"NewBaseModel\"]\n    :param to_register: flag if the relation should be set in RelationshipManager\n    :type to_register: bool\n    :return: returns a Model or a list of Models\n    :rtype: Optional[Union[\"Model\", List[\"Model\"]]]\n    \"\"\"\n    if value is None:\n        return None if not self.virtual else []\n    constructors = {\n        f\"{self.to.__name__}\": self._register_existing_model,\n        \"dict\": self._construct_model_from_dict,\n        \"list\": self._extract_model_from_sequence,\n    }\n\n    model = constructors.get(  # type: ignore\n        value.__class__.__name__, self._construct_model_from_pk\n    )(value, child, to_register)\n    return model\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_model_relation_fields","title":"<code>get_model_relation_fields(use_alias=False)</code>","text":"<p>Extract names of the database columns or model fields that are connected with given relation based on use_alias switch and which side of the relation the current field is - reverse or normal.</p> <p>:param use_alias: use db names aliases or model fields :type use_alias: bool :return: name or names of the related columns/ fields :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n    \"\"\"\n    Extract names of the database columns or model fields that are connected\n    with given relation based on use_alias switch and which side of the relation\n    the current field is - reverse or normal.\n\n    :param use_alias: use db names aliases or model fields\n    :type use_alias: bool\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if use_alias:\n        return self._get_model_relation_fields_alias()\n    return self._get_model_relation_fields_name()\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_related_field_alias","title":"<code>get_related_field_alias()</code>","text":"<p>Extract names of the related database columns or that are connected with given relation based to use as a target in filter clause.</p> <p>:return: name or names of the related columns/ fields :rtype: Union[str, Dict[str, str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_field_alias(self) -&gt; str:\n    \"\"\"\n    Extract names of the related database columns or that are connected\n    with given relation based to use as a target in filter clause.\n\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, Dict[str, str]]\n    \"\"\"\n    if self.virtual:\n        field_name = self.get_related_name()\n        field = self.to.ormar_config.model_fields[field_name]\n        return field.get_alias()\n    target_field = self.to.get_column_alias(self.to.ormar_config.pkname)\n    return target_field\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_related_field_name","title":"<code>get_related_field_name()</code>","text":"<p>Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query.</p> <p>:return: name(s) of the field :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_field_name(self) -&gt; Union[str, List[str]]:\n    \"\"\"\n    Returns name of the relation field that should be used in prefetch query.\n    This field is later used to register relation in prefetch query,\n    populate relations dict, and populate nested model in prefetch query.\n\n    :return: name(s) of the field\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if self.virtual:\n        return self.get_related_name()\n    return self.to.ormar_config.pkname\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_related_name","title":"<code>get_related_name()</code>","text":"<p>Returns name to use for reverse relation. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for reverse relation.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return self.related_name or self.owner.get_name() + \"s\"\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_relation_name","title":"<code>get_relation_name()</code>","text":"<p>Returns name of the relation, which can be a own name or through model names for m2m models</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_relation_name(self) -&gt; str:  # pragma: no cover\n    \"\"\"\n    Returns name of the relation, which can be a own name or through model\n    names for m2m models\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_source_model","title":"<code>get_source_model()</code>","text":"<p>Returns model from which the relation comes -&gt; either owner or through model</p> <p>:return: source model :rtype: Type[\"Model\"]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_source_model(self) -&gt; Type[\"Model\"]:  # pragma: no cover\n    \"\"\"\n    Returns model from which the relation comes -&gt; either owner or through model\n\n    :return: source model\n    :rtype: Type[\"Model\"]\n    \"\"\"\n    return self.owner\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.get_source_related_name","title":"<code>get_source_related_name()</code>","text":"<p>Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_source_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for source relation name.\n    For FK it's the same, differs for m2m fields.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return self.get_related_name()\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.to.__class__ == ForwardRef\n</code></pre>"},{"location":"api/#ormar.ForeignKeyField.register_relation","title":"<code>register_relation(model, child)</code>","text":"<p>Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance).</p> <p>Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one).</p> <p>:param model: parent model (with relation definition) :type model: Model class :param child: child model :type child: Model class</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def register_relation(self, model: \"Model\", child: \"Model\") -&gt; None:\n    \"\"\"\n    Registers relation between parent and child in relation manager.\n    Relation manager is kep on each model (different instance).\n\n    Used in Metaclass and sometimes some relations are missing\n    (i.e. cloned Models in fastapi might miss one).\n\n    :param model: parent model (with relation definition)\n    :type model: Model class\n    :param child: child model\n    :type child: Model class\n    \"\"\"\n    model._orm.add(parent=model, child=child, field=self)\n</code></pre>"},{"location":"api/#ormar.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>int</code></p> <p>Integer field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Integer(ModelFieldFactory, int):\n    \"\"\"\n    Integer field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Integer()\n</code></pre>"},{"location":"api/#ormar.Integer.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Integer()\n</code></pre>"},{"location":"api/#ormar.JSON","title":"<code>JSON</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>Json</code></p> <p>JSON field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class JSON(ModelFieldFactory, pydantic.Json):\n    \"\"\"\n    JSON field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = pydantic.Json\n    _sample = '{\"json\": \"json\"}'\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.JSON(none_as_null=kwargs.get(\"sql_nullable\", False))\n</code></pre>"},{"location":"api/#ormar.JSON.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.JSON(none_as_null=kwargs.get(\"sql_nullable\", False))\n</code></pre>"},{"location":"api/#ormar.LargeBinary","title":"<code>LargeBinary</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>bytes</code></p> <p>LargeBinary field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class LargeBinary(ModelFieldFactory, bytes):\n    \"\"\"\n    LargeBinary field factory that construct Field classes\n    and populated their values.\n    \"\"\"\n\n    _type = bytes\n    _sample = \"bytes\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        max_length: int,\n        represent_as_base64_str: bool = False,\n        **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.LargeBinary(length=kwargs.get(\"max_length\"))\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        max_length = kwargs.get(\"max_length\", None)\n        if max_length &lt;= 0:\n            raise ModelDefinitionError(\n                \"Parameter max_length is required for field LargeBinary\"\n            )\n</code></pre>"},{"location":"api/#ormar.LargeBinary.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.LargeBinary(length=kwargs.get(\"max_length\"))\n</code></pre>"},{"location":"api/#ormar.LargeBinary.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    max_length = kwargs.get(\"max_length\", None)\n    if max_length &lt;= 0:\n        raise ModelDefinitionError(\n            \"Parameter max_length is required for field LargeBinary\"\n        )\n</code></pre>"},{"location":"api/#ormar.ManyToManyField","title":"<code>ManyToManyField</code>","text":"<p>               Bases: <code>ForeignKeyField</code>, <code>QuerySetProtocol</code>, <code>RelationProtocol</code></p> <p>Actual class returned from ManyToMany function call and stored in model_fields.</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>class ManyToManyField(  # type: ignore\n    ForeignKeyField,\n    ormar.QuerySetProtocol,\n    ormar.RelationProtocol,\n):\n    \"\"\"\n    Actual class returned from ManyToMany function call and stored in model_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        if TYPE_CHECKING:  # pragma: no cover\n            self.__type__: type\n            self.to: Type[\"Model\"]\n            self.through: Type[\"Model\"]\n        super().__init__(**kwargs)\n\n    def get_source_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for source relation name.\n        For FK it's the same, differs for m2m fields.\n        It's either set as `related_name` or by default it's field name.\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return (\n            self.through.ormar_config.model_fields[\n                self.default_source_field_name()\n            ].related_name\n            or self.name\n        )\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.to.__class__ == ForwardRef or self.through.__class__ == ForwardRef\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.to.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns)\n            (\n                self.__type__,\n                self.column_type,\n                pk_only_model,\n            ) = populate_m2m_params_based_on_to_model(\n                to=self.to, nullable=self.nullable\n            )\n            self.to_pk_only = pk_only_model\n\n        if self.through.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns, is_through=True)\n\n            forbid_through_relations(self.through)\n\n    def get_relation_name(self) -&gt; str:\n        \"\"\"\n        Returns name of the relation, which can be a own name or through model\n        names for m2m models\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        if self.self_reference and self.name == self.self_reference_primary:\n            return self.default_source_field_name()\n        return self.default_target_field_name()\n\n    def get_source_model(self) -&gt; Type[\"Model\"]:\n        \"\"\"\n        Returns model from which the relation comes -&gt; either owner or through model\n\n        :return: source model\n        :rtype: Type[\"Model\"]\n        \"\"\"\n        return self.through\n\n    def get_filter_clause_target(self) -&gt; Type[\"Model\"]:\n        return self.through\n\n    def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n        \"\"\"\n        Extract names of the database columns or model fields that are connected\n        with given relation based on use_alias switch.\n\n        :param use_alias: use db names aliases or model fields\n        :type use_alias: bool\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        pk_field = self.owner.ormar_config.model_fields[self.owner.ormar_config.pkname]\n        result = pk_field.get_alias() if use_alias else pk_field.name\n        return result\n\n    def get_related_field_alias(self) -&gt; str:\n        \"\"\"\n        Extract names of the related database columns or that are connected\n        with given relation based to use as a target in filter clause.\n\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, Dict[str, str]]\n        \"\"\"\n        if self.self_reference and self.self_reference_primary == self.name:\n            field_name = self.default_target_field_name()\n        else:\n            field_name = self.default_source_field_name()\n        sub_field = self.through.ormar_config.model_fields[field_name]\n        return sub_field.get_alias()\n\n    def get_related_field_name(self) -&gt; Union[str, List[str]]:\n        \"\"\"\n        Returns name of the relation field that should be used in prefetch query.\n        This field is later used to register relation in prefetch query,\n        populate relations dict, and populate nested model in prefetch query.\n\n        :return: name(s) of the field\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if self.self_reference and self.self_reference_primary == self.name:\n            return self.default_target_field_name()\n        return self.default_source_field_name()\n\n    def create_default_through_model(self) -&gt; None:\n        \"\"\"\n        Creates default empty through model if no additional fields are required.\n        \"\"\"\n        owner_name = self.owner.get_name(lower=False)\n        to_name = self.to.get_name(lower=False)\n        class_name = f\"{owner_name}{to_name}\"\n        table_name = f\"{owner_name.lower()}s_{to_name.lower()}s\"\n        base_namespace = {\n            \"__module__\": self.owner.__module__,\n            \"__qualname__\": f\"{self.owner.__qualname__}.{class_name}\",\n        }\n        new_config = ormar.models.ormar_config.OrmarConfig(\n            tablename=table_name,\n            database=self.owner.ormar_config.database,\n            metadata=self.owner.ormar_config.metadata,\n        )\n        through_model = type(\n            class_name,\n            (ormar.Model,),\n            {\n                **base_namespace,\n                \"ormar_config\": new_config,\n                \"id\": ormar.Integer(name=\"id\", primary_key=True),\n            },\n        )\n        self.through = cast(Type[\"Model\"], through_model)\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.create_default_through_model","title":"<code>create_default_through_model()</code>","text":"<p>Creates default empty through model if no additional fields are required.</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def create_default_through_model(self) -&gt; None:\n    \"\"\"\n    Creates default empty through model if no additional fields are required.\n    \"\"\"\n    owner_name = self.owner.get_name(lower=False)\n    to_name = self.to.get_name(lower=False)\n    class_name = f\"{owner_name}{to_name}\"\n    table_name = f\"{owner_name.lower()}s_{to_name.lower()}s\"\n    base_namespace = {\n        \"__module__\": self.owner.__module__,\n        \"__qualname__\": f\"{self.owner.__qualname__}.{class_name}\",\n    }\n    new_config = ormar.models.ormar_config.OrmarConfig(\n        tablename=table_name,\n        database=self.owner.ormar_config.database,\n        metadata=self.owner.ormar_config.metadata,\n    )\n    through_model = type(\n        class_name,\n        (ormar.Model,),\n        {\n            **base_namespace,\n            \"ormar_config\": new_config,\n            \"id\": ormar.Integer(name=\"id\", primary_key=True),\n        },\n    )\n    self.through = cast(Type[\"Model\"], through_model)\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.to.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns)\n        (\n            self.__type__,\n            self.column_type,\n            pk_only_model,\n        ) = populate_m2m_params_based_on_to_model(\n            to=self.to, nullable=self.nullable\n        )\n        self.to_pk_only = pk_only_model\n\n    if self.through.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns, is_through=True)\n\n        forbid_through_relations(self.through)\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.get_model_relation_fields","title":"<code>get_model_relation_fields(use_alias=False)</code>","text":"<p>Extract names of the database columns or model fields that are connected with given relation based on use_alias switch.</p> <p>:param use_alias: use db names aliases or model fields :type use_alias: bool :return: name or names of the related columns/ fields :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n    \"\"\"\n    Extract names of the database columns or model fields that are connected\n    with given relation based on use_alias switch.\n\n    :param use_alias: use db names aliases or model fields\n    :type use_alias: bool\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    pk_field = self.owner.ormar_config.model_fields[self.owner.ormar_config.pkname]\n    result = pk_field.get_alias() if use_alias else pk_field.name\n    return result\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.get_related_field_alias","title":"<code>get_related_field_alias()</code>","text":"<p>Extract names of the related database columns or that are connected with given relation based to use as a target in filter clause.</p> <p>:return: name or names of the related columns/ fields :rtype: Union[str, Dict[str, str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_related_field_alias(self) -&gt; str:\n    \"\"\"\n    Extract names of the related database columns or that are connected\n    with given relation based to use as a target in filter clause.\n\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, Dict[str, str]]\n    \"\"\"\n    if self.self_reference and self.self_reference_primary == self.name:\n        field_name = self.default_target_field_name()\n    else:\n        field_name = self.default_source_field_name()\n    sub_field = self.through.ormar_config.model_fields[field_name]\n    return sub_field.get_alias()\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.get_related_field_name","title":"<code>get_related_field_name()</code>","text":"<p>Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query.</p> <p>:return: name(s) of the field :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_related_field_name(self) -&gt; Union[str, List[str]]:\n    \"\"\"\n    Returns name of the relation field that should be used in prefetch query.\n    This field is later used to register relation in prefetch query,\n    populate relations dict, and populate nested model in prefetch query.\n\n    :return: name(s) of the field\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if self.self_reference and self.self_reference_primary == self.name:\n        return self.default_target_field_name()\n    return self.default_source_field_name()\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.get_relation_name","title":"<code>get_relation_name()</code>","text":"<p>Returns name of the relation, which can be a own name or through model names for m2m models</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_relation_name(self) -&gt; str:\n    \"\"\"\n    Returns name of the relation, which can be a own name or through model\n    names for m2m models\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    if self.self_reference and self.name == self.self_reference_primary:\n        return self.default_source_field_name()\n    return self.default_target_field_name()\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.get_source_model","title":"<code>get_source_model()</code>","text":"<p>Returns model from which the relation comes -&gt; either owner or through model</p> <p>:return: source model :rtype: Type[\"Model\"]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_source_model(self) -&gt; Type[\"Model\"]:\n    \"\"\"\n    Returns model from which the relation comes -&gt; either owner or through model\n\n    :return: source model\n    :rtype: Type[\"Model\"]\n    \"\"\"\n    return self.through\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.get_source_related_name","title":"<code>get_source_related_name()</code>","text":"<p>Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as <code>related_name</code> or by default it's field name. :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_source_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for source relation name.\n    For FK it's the same, differs for m2m fields.\n    It's either set as `related_name` or by default it's field name.\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return (\n        self.through.ormar_config.model_fields[\n            self.default_source_field_name()\n        ].related_name\n        or self.name\n    )\n</code></pre>"},{"location":"api/#ormar.ManyToManyField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.to.__class__ == ForwardRef or self.through.__class__ == ForwardRef\n</code></pre>"},{"location":"api/#ormar.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>ModelRow</code></p> Source code in <code>ormar/models/model.py</code> <pre><code>class Model(ModelRow):\n    __abstract__ = False\n    if TYPE_CHECKING:  # pragma nocover\n        ormar_config: OrmarConfig\n\n    def __repr__(self) -&gt; str:  # pragma nocover\n        _repr = {\n            k: getattr(self, k)\n            for k, v in self.ormar_config.model_fields.items()\n            if not v.skip_field\n        }\n        return f\"{self.__class__.__name__}({str(_repr)})\"\n\n    async def upsert(self: T, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Performs either a save or an update depending on the presence of the pk.\n        If the pk field is filled it's an update, otherwise the save is performed.\n        For save kwargs are ignored, used only in update if provided.\n\n        :param kwargs: list of fields to update\n        :type kwargs: Any\n        :return: saved Model\n        :rtype: Model\n        \"\"\"\n\n        force_save = kwargs.pop(\"__force_save__\", False)\n        if force_save:\n            expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n            row = await self.ormar_config.database.fetch_one(expr)\n            if not row:\n                return await self.save()\n            return await self.update(**kwargs)\n\n        if not self.pk:\n            return await self.save()\n        return await self.update(**kwargs)\n\n    async def save(self: T) -&gt; T:\n        \"\"\"\n        Performs a save of given Model instance.\n        If primary key is already saved, db backend will throw integrity error.\n\n        Related models are saved by pk number, reverse relation and many to many fields\n        are not saved - use corresponding relations methods.\n\n        If there are fields with server_default set and those fields\n        are not already filled save will trigger also a second query\n        to refreshed the fields populated server side.\n\n        Does not recognize if model was previously saved.\n        If you want to perform update or insert depending on the pk\n        fields presence use upsert.\n\n        Sends pre_save and post_save signals.\n\n        Sets model save status to True.\n\n        :return: saved Model\n        :rtype: Model\n        \"\"\"\n        await self.signals.pre_save.send(sender=self.__class__, instance=self)\n        self_fields = self._extract_model_db_fields()\n\n        if (\n            not self.pk\n            and self.ormar_config.model_fields[self.ormar_config.pkname].autoincrement\n        ):\n            self_fields.pop(self.ormar_config.pkname, None)\n        self_fields = self.populate_default_values(self_fields)\n        self.update_from_dict(\n            {\n                k: v\n                for k, v in self_fields.items()\n                if k not in self.extract_related_names()\n            }\n        )\n\n        self_fields = self.translate_columns_to_aliases(self_fields)\n        expr = self.ormar_config.table.insert()\n        expr = expr.values(**self_fields)\n\n        pk = await self.ormar_config.database.execute(expr)\n        if pk and isinstance(pk, self.pk_type()):\n            setattr(self, self.ormar_config.pkname, pk)\n\n        self.set_save_status(True)\n        # refresh server side defaults\n        if any(\n            field.server_default is not None\n            for name, field in self.ormar_config.model_fields.items()\n            if name not in self_fields\n        ):\n            await self.load()\n\n        await self.signals.post_save.send(sender=self.__class__, instance=self)\n        return self\n\n    async def save_related(  # noqa: CCR001, CFQ002\n        self,\n        follow: bool = False,\n        save_all: bool = False,\n        relation_map: Optional[Dict] = None,\n        exclude: Union[Set, Dict, None] = None,\n        update_count: int = 0,\n        previous_model: Optional[\"Model\"] = None,\n        relation_field: Optional[\"ForeignKeyField\"] = None,\n    ) -&gt; int:\n        \"\"\"\n        Triggers a upsert method on all related models\n        if the instances are not already saved.\n        By default saves only the directly related ones.\n\n        If follow=True is set it saves also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are saved, but the save do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second\n        Model A but will never follow into Model C.\n        Nested relations of those kind need to be persisted manually.\n\n        :param relation_field: field with relation leading to this model\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        :param exclude: items to exclude during saving of relations\n        :type exclude: Union[Set, Dict]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :param save_all: flag if all models should be saved or only not saved ones\n        :type save_all: bool\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :param update_count: internal parameter for recursive calls -\n        number of updated instances\n        :type update_count: int\n        :return: number of updated/saved models\n        :rtype: int\n        \"\"\"\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(self._iterate_related_models())\n        )\n        if exclude and isinstance(exclude, Set):\n            exclude = translate_list_to_dict(exclude)\n        relation_map = subtract_dict(relation_map, exclude or {})\n\n        if relation_map:\n            fields_to_visit = {\n                field\n                for field in self.extract_related_fields()\n                if field.name in relation_map\n            }\n            pre_save = {\n                field\n                for field in fields_to_visit\n                if not field.virtual and not field.is_multi\n            }\n\n            update_count = await self._update_relation_list(\n                fields_list=pre_save,\n                follow=follow,\n                save_all=save_all,\n                relation_map=relation_map,\n                update_count=update_count,\n            )\n\n            update_count = await self._upsert_model(\n                instance=self,\n                save_all=save_all,\n                previous_model=previous_model,\n                relation_field=relation_field,\n                update_count=update_count,\n            )\n\n            post_save = fields_to_visit - pre_save\n\n            update_count = await self._update_relation_list(\n                fields_list=post_save,\n                follow=follow,\n                save_all=save_all,\n                relation_map=relation_map,\n                update_count=update_count,\n            )\n\n        else:\n            update_count = await self._upsert_model(\n                instance=self,\n                save_all=save_all,\n                previous_model=previous_model,\n                relation_field=relation_field,\n                update_count=update_count,\n            )\n\n        return update_count\n\n    async def update(self: T, _columns: Optional[List[str]] = None, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Performs update of Model instance in the database.\n        Fields can be updated before or you can pass them as kwargs.\n\n        Sends pre_update and post_update signals.\n\n        Sets model save status to True.\n\n        :param _columns: list of columns to update, if None all are updated\n        :type _columns: List\n        :raises ModelPersistenceError: If the pk column is not set\n\n        :param kwargs: list of fields to update as field=value pairs\n        :type kwargs: Any\n        :return: updated Model\n        :rtype: Model\n        \"\"\"\n        if kwargs:\n            self.update_from_dict(kwargs)\n\n        if not self.pk:\n            raise ModelPersistenceError(\n                \"You cannot update not saved model! Use save or upsert method.\"\n            )\n\n        await self.signals.pre_update.send(\n            sender=self.__class__, instance=self, passed_args=kwargs\n        )\n        self_fields = self._extract_model_db_fields()\n        self_fields.pop(self.get_column_name_from_alias(self.ormar_config.pkname))\n        if _columns:\n            self_fields = {k: v for k, v in self_fields.items() if k in _columns}\n        if self_fields:\n            self_fields = self.translate_columns_to_aliases(self_fields)\n            expr = self.ormar_config.table.update().values(**self_fields)\n            expr = expr.where(self.pk_column == getattr(self, self.ormar_config.pkname))\n\n            await self.ormar_config.database.execute(expr)\n        self.set_save_status(True)\n        await self.signals.post_update.send(sender=self.__class__, instance=self)\n        return self\n\n    async def delete(self) -&gt; int:\n        \"\"\"\n        Removes the Model instance from the database.\n\n        Sends pre_delete and post_delete signals.\n\n        Sets model save status to False.\n\n        Note it does not delete the Model itself (python object).\n        So you can delete and later save (since pk is deleted no conflict will arise)\n        or update and the Model will be saved in database again.\n\n        :return: number of deleted rows (for some backends)\n        :rtype: int\n        \"\"\"\n        await self.signals.pre_delete.send(sender=self.__class__, instance=self)\n        expr = self.ormar_config.table.delete()\n        expr = expr.where(self.pk_column == (getattr(self, self.ormar_config.pkname)))\n        result = await self.ormar_config.database.execute(expr)\n        self.set_save_status(False)\n        await self.signals.post_delete.send(sender=self.__class__, instance=self)\n        return result\n\n    async def load(self: T) -&gt; T:\n        \"\"\"\n        Allow to refresh existing Models fields from database.\n        Be careful as the related models can be overwritten by pk_only models in load.\n        Does NOT refresh the related models fields if they were loaded before.\n\n        :raises NoMatch: If given pk is not found in database.\n\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n        row = await self.ormar_config.database.fetch_one(expr)\n        if not row:  # pragma nocover\n            raise NoMatch(\"Instance was deleted from database and cannot be refreshed\")\n        kwargs = dict(row)\n        kwargs = self.translate_aliases_to_columns(kwargs)\n        self.update_from_dict(kwargs)\n        self.set_save_status(True)\n        return self\n\n    async def load_all(\n        self: T,\n        follow: bool = False,\n        exclude: Union[List, str, Set, Dict, None] = None,\n        order_by: Union[List, str, None] = None,\n    ) -&gt; T:\n        \"\"\"\n        Allow to refresh existing Models fields from database.\n        Performs refresh of the related models fields.\n\n        By default, loads only self and the directly related ones.\n\n        If follow=True is set it loads also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param order_by: columns by which models should be sorted\n        :type order_by: Union[List, str]\n        :raises NoMatch: If given pk is not found in database.\n\n        :param exclude: related models to exclude\n        :type exclude: Union[List, str, Set, Dict]\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        relations = list(self.extract_related_names())\n        if follow:\n            relations = self._iterate_related_models()\n        queryset = self.__class__.objects\n        if exclude:\n            queryset = queryset.exclude_fields(exclude)\n        if order_by:\n            queryset = queryset.order_by(order_by)\n        instance = await queryset.select_related(relations).get(pk=self.pk)\n        self._orm.clear()\n        self.update_from_dict(instance.model_dump())\n        return self\n</code></pre>"},{"location":"api/#ormar.Model.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Removes the Model instance from the database.</p> <p>Sends pre_delete and post_delete signals.</p> <p>Sets model save status to False.</p> <p>Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again.</p> <p>:return: number of deleted rows (for some backends) :rtype: int</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def delete(self) -&gt; int:\n    \"\"\"\n    Removes the Model instance from the database.\n\n    Sends pre_delete and post_delete signals.\n\n    Sets model save status to False.\n\n    Note it does not delete the Model itself (python object).\n    So you can delete and later save (since pk is deleted no conflict will arise)\n    or update and the Model will be saved in database again.\n\n    :return: number of deleted rows (for some backends)\n    :rtype: int\n    \"\"\"\n    await self.signals.pre_delete.send(sender=self.__class__, instance=self)\n    expr = self.ormar_config.table.delete()\n    expr = expr.where(self.pk_column == (getattr(self, self.ormar_config.pkname)))\n    result = await self.ormar_config.database.execute(expr)\n    self.set_save_status(False)\n    await self.signals.post_delete.send(sender=self.__class__, instance=self)\n    return result\n</code></pre>"},{"location":"api/#ormar.Model.load","title":"<code>load()</code>  <code>async</code>","text":"<p>Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before.</p> <p>:raises NoMatch: If given pk is not found in database.</p> <p>:return: reloaded Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def load(self: T) -&gt; T:\n    \"\"\"\n    Allow to refresh existing Models fields from database.\n    Be careful as the related models can be overwritten by pk_only models in load.\n    Does NOT refresh the related models fields if they were loaded before.\n\n    :raises NoMatch: If given pk is not found in database.\n\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n    row = await self.ormar_config.database.fetch_one(expr)\n    if not row:  # pragma nocover\n        raise NoMatch(\"Instance was deleted from database and cannot be refreshed\")\n    kwargs = dict(row)\n    kwargs = self.translate_aliases_to_columns(kwargs)\n    self.update_from_dict(kwargs)\n    self.set_save_status(True)\n    return self\n</code></pre>"},{"location":"api/#ormar.Model.load_all","title":"<code>load_all(follow=False, exclude=None, order_by=None)</code>  <code>async</code>","text":"<p>Allow to refresh existing Models fields from database. Performs refresh of the related models fields.</p> <p>By default, loads only self and the directly related ones.</p> <p>If follow=True is set it loads also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param order_by: columns by which models should be sorted :type order_by: Union[List, str] :raises NoMatch: If given pk is not found in database.</p> <p>:param exclude: related models to exclude :type exclude: Union[List, str, Set, Dict] :param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def load_all(\n    self: T,\n    follow: bool = False,\n    exclude: Union[List, str, Set, Dict, None] = None,\n    order_by: Union[List, str, None] = None,\n) -&gt; T:\n    \"\"\"\n    Allow to refresh existing Models fields from database.\n    Performs refresh of the related models fields.\n\n    By default, loads only self and the directly related ones.\n\n    If follow=True is set it loads also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param order_by: columns by which models should be sorted\n    :type order_by: Union[List, str]\n    :raises NoMatch: If given pk is not found in database.\n\n    :param exclude: related models to exclude\n    :type exclude: Union[List, str, Set, Dict]\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    relations = list(self.extract_related_names())\n    if follow:\n        relations = self._iterate_related_models()\n    queryset = self.__class__.objects\n    if exclude:\n        queryset = queryset.exclude_fields(exclude)\n    if order_by:\n        queryset = queryset.order_by(order_by)\n    instance = await queryset.select_related(relations).get(pk=self.pk)\n    self._orm.clear()\n    self.update_from_dict(instance.model_dump())\n    return self\n</code></pre>"},{"location":"api/#ormar.Model.save","title":"<code>save()</code>  <code>async</code>","text":"<p>Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error.</p> <p>Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods.</p> <p>If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side.</p> <p>Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert.</p> <p>Sends pre_save and post_save signals.</p> <p>Sets model save status to True.</p> <p>:return: saved Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def save(self: T) -&gt; T:\n    \"\"\"\n    Performs a save of given Model instance.\n    If primary key is already saved, db backend will throw integrity error.\n\n    Related models are saved by pk number, reverse relation and many to many fields\n    are not saved - use corresponding relations methods.\n\n    If there are fields with server_default set and those fields\n    are not already filled save will trigger also a second query\n    to refreshed the fields populated server side.\n\n    Does not recognize if model was previously saved.\n    If you want to perform update or insert depending on the pk\n    fields presence use upsert.\n\n    Sends pre_save and post_save signals.\n\n    Sets model save status to True.\n\n    :return: saved Model\n    :rtype: Model\n    \"\"\"\n    await self.signals.pre_save.send(sender=self.__class__, instance=self)\n    self_fields = self._extract_model_db_fields()\n\n    if (\n        not self.pk\n        and self.ormar_config.model_fields[self.ormar_config.pkname].autoincrement\n    ):\n        self_fields.pop(self.ormar_config.pkname, None)\n    self_fields = self.populate_default_values(self_fields)\n    self.update_from_dict(\n        {\n            k: v\n            for k, v in self_fields.items()\n            if k not in self.extract_related_names()\n        }\n    )\n\n    self_fields = self.translate_columns_to_aliases(self_fields)\n    expr = self.ormar_config.table.insert()\n    expr = expr.values(**self_fields)\n\n    pk = await self.ormar_config.database.execute(expr)\n    if pk and isinstance(pk, self.pk_type()):\n        setattr(self, self.ormar_config.pkname, pk)\n\n    self.set_save_status(True)\n    # refresh server side defaults\n    if any(\n        field.server_default is not None\n        for name, field in self.ormar_config.model_fields.items()\n        if name not in self_fields\n    ):\n        await self.load()\n\n    await self.signals.post_save.send(sender=self.__class__, instance=self)\n    return self\n</code></pre>"},{"location":"api/#ormar.Model.save_related","title":"<code>save_related(follow=False, save_all=False, relation_map=None, exclude=None, update_count=0, previous_model=None, relation_field=None)</code>  <code>async</code>","text":"<p>Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones.</p> <p>If follow=True is set it saves also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually.</p> <p>:param relation_field: field with relation leading to this model :type relation_field: Optional[ForeignKeyField] :param previous_model: previous model from which method came :type previous_model: Model :param exclude: items to exclude during saving of relations :type exclude: Union[Set, Dict] :param relation_map: map of relations to follow :type relation_map: Dict :param save_all: flag if all models should be saved or only not saved ones :type save_all: bool :param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :param update_count: internal parameter for recursive calls - number of updated instances :type update_count: int :return: number of updated/saved models :rtype: int</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def save_related(  # noqa: CCR001, CFQ002\n    self,\n    follow: bool = False,\n    save_all: bool = False,\n    relation_map: Optional[Dict] = None,\n    exclude: Union[Set, Dict, None] = None,\n    update_count: int = 0,\n    previous_model: Optional[\"Model\"] = None,\n    relation_field: Optional[\"ForeignKeyField\"] = None,\n) -&gt; int:\n    \"\"\"\n    Triggers a upsert method on all related models\n    if the instances are not already saved.\n    By default saves only the directly related ones.\n\n    If follow=True is set it saves also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are saved, but the save do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second\n    Model A but will never follow into Model C.\n    Nested relations of those kind need to be persisted manually.\n\n    :param relation_field: field with relation leading to this model\n    :type relation_field: Optional[ForeignKeyField]\n    :param previous_model: previous model from which method came\n    :type previous_model: Model\n    :param exclude: items to exclude during saving of relations\n    :type exclude: Union[Set, Dict]\n    :param relation_map: map of relations to follow\n    :type relation_map: Dict\n    :param save_all: flag if all models should be saved or only not saved ones\n    :type save_all: bool\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :param update_count: internal parameter for recursive calls -\n    number of updated instances\n    :type update_count: int\n    :return: number of updated/saved models\n    :rtype: int\n    \"\"\"\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(self._iterate_related_models())\n    )\n    if exclude and isinstance(exclude, Set):\n        exclude = translate_list_to_dict(exclude)\n    relation_map = subtract_dict(relation_map, exclude or {})\n\n    if relation_map:\n        fields_to_visit = {\n            field\n            for field in self.extract_related_fields()\n            if field.name in relation_map\n        }\n        pre_save = {\n            field\n            for field in fields_to_visit\n            if not field.virtual and not field.is_multi\n        }\n\n        update_count = await self._update_relation_list(\n            fields_list=pre_save,\n            follow=follow,\n            save_all=save_all,\n            relation_map=relation_map,\n            update_count=update_count,\n        )\n\n        update_count = await self._upsert_model(\n            instance=self,\n            save_all=save_all,\n            previous_model=previous_model,\n            relation_field=relation_field,\n            update_count=update_count,\n        )\n\n        post_save = fields_to_visit - pre_save\n\n        update_count = await self._update_relation_list(\n            fields_list=post_save,\n            follow=follow,\n            save_all=save_all,\n            relation_map=relation_map,\n            update_count=update_count,\n        )\n\n    else:\n        update_count = await self._upsert_model(\n            instance=self,\n            save_all=save_all,\n            previous_model=previous_model,\n            relation_field=relation_field,\n            update_count=update_count,\n        )\n\n    return update_count\n</code></pre>"},{"location":"api/#ormar.Model.update","title":"<code>update(_columns=None, **kwargs)</code>  <code>async</code>","text":"<p>Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs.</p> <p>Sends pre_update and post_update signals.</p> <p>Sets model save status to True.</p> <p>:param _columns: list of columns to update, if None all are updated :type _columns: List :raises ModelPersistenceError: If the pk column is not set</p> <p>:param kwargs: list of fields to update as field=value pairs :type kwargs: Any :return: updated Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def update(self: T, _columns: Optional[List[str]] = None, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Performs update of Model instance in the database.\n    Fields can be updated before or you can pass them as kwargs.\n\n    Sends pre_update and post_update signals.\n\n    Sets model save status to True.\n\n    :param _columns: list of columns to update, if None all are updated\n    :type _columns: List\n    :raises ModelPersistenceError: If the pk column is not set\n\n    :param kwargs: list of fields to update as field=value pairs\n    :type kwargs: Any\n    :return: updated Model\n    :rtype: Model\n    \"\"\"\n    if kwargs:\n        self.update_from_dict(kwargs)\n\n    if not self.pk:\n        raise ModelPersistenceError(\n            \"You cannot update not saved model! Use save or upsert method.\"\n        )\n\n    await self.signals.pre_update.send(\n        sender=self.__class__, instance=self, passed_args=kwargs\n    )\n    self_fields = self._extract_model_db_fields()\n    self_fields.pop(self.get_column_name_from_alias(self.ormar_config.pkname))\n    if _columns:\n        self_fields = {k: v for k, v in self_fields.items() if k in _columns}\n    if self_fields:\n        self_fields = self.translate_columns_to_aliases(self_fields)\n        expr = self.ormar_config.table.update().values(**self_fields)\n        expr = expr.where(self.pk_column == getattr(self, self.ormar_config.pkname))\n\n        await self.ormar_config.database.execute(expr)\n    self.set_save_status(True)\n    await self.signals.post_update.send(sender=self.__class__, instance=self)\n    return self\n</code></pre>"},{"location":"api/#ormar.Model.upsert","title":"<code>upsert(**kwargs)</code>  <code>async</code>","text":"<p>Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided.</p> <p>:param kwargs: list of fields to update :type kwargs: Any :return: saved Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def upsert(self: T, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Performs either a save or an update depending on the presence of the pk.\n    If the pk field is filled it's an update, otherwise the save is performed.\n    For save kwargs are ignored, used only in update if provided.\n\n    :param kwargs: list of fields to update\n    :type kwargs: Any\n    :return: saved Model\n    :rtype: Model\n    \"\"\"\n\n    force_save = kwargs.pop(\"__force_save__\", False)\n    if force_save:\n        expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n        row = await self.ormar_config.database.fetch_one(expr)\n        if not row:\n            return await self.save()\n        return await self.update(**kwargs)\n\n    if not self.pk:\n        return await self.save()\n    return await self.update(**kwargs)\n</code></pre>"},{"location":"api/#ormar.ModelDefinitionError","title":"<code>ModelDefinitionError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for errors related to the model definition itself:</p> <ul> <li>defining a Field without required parameters</li> <li>defining a model with more than one primary_key</li> <li>defining a model without primary_key</li> </ul> Source code in <code>ormar/exceptions.py</code> <pre><code>class ModelDefinitionError(AsyncOrmException):\n    \"\"\"\n    Raised for errors related to the model definition itself:\n\n    * defining a Field without required parameters\n    * defining a model with more than one primary_key\n    * defining a model without primary_key\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#ormar.MultipleMatches","title":"<code>MultipleMatches</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for database queries that should return one row (i.e. get, first etc.) but has multiple matching results in response.</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class MultipleMatches(AsyncOrmException):\n    \"\"\"\n    Raised for database queries that should return one row (i.e. get, first etc.)\n    but has multiple matching results in response.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#ormar.NoMatch","title":"<code>NoMatch</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for database queries that has no matching result (empty result).</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class NoMatch(AsyncOrmException):\n    \"\"\"\n    Raised for database queries that has no matching result (empty result).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/#ormar.OrderAction","title":"<code>OrderAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>class OrderAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, order_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        self.direction: str = \"\"\n        super().__init__(query_str=order_str, model_cls=model_cls)\n        self.is_source_model_order = False\n        if alias:\n            self.table_prefix = alias\n        if self.source_model == self.target_model and \"__\" not in self.related_str:\n            self.is_source_model_order = True\n\n    @property\n    def field_alias(self) -&gt; str:\n        return self.target_model.get_column_alias(self.field_name)\n\n    @property\n    def is_postgres_bool(self) -&gt; bool:\n        dialect = self.target_model.ormar_config.database._backend._dialect.name\n        field_type = self.target_model.ormar_config.model_fields[\n            self.field_name\n        ].__type__\n        return dialect == \"postgresql\" and field_type is bool\n\n    def get_field_name_text(self) -&gt; str:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n\n    def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Used in limit sub queries where you need to use aggregated functions\n        in order to order by columns not included in group by. For postgres bool\n        field it's using bool_or function as aggregates does not work with this type\n        of columns.\n\n        :return: min or max function to order\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        if self.direction == \"\":\n            function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n            return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n        function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        dialect = self.target_model.ormar_config.database._backend._dialect\n        quoter = dialect.identifier_preparer.quote\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        table_name = self.table.name\n        field_name = self.field_alias\n        if not prefix:\n            table_name = quoter(table_name)\n        else:\n            table_name = quoter(f\"{prefix}{table_name}\")\n        field_name = quoter(field_name)\n        return text(f\"{table_name}.{field_name} {self.direction}\")\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        if order_str.startswith(\"-\"):\n            self.direction = \"desc\"\n            order_str = order_str[1:]\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n        \"\"\"\n        Checks filter conditions to find if they apply to current join.\n\n        :param target_model: model which is now processed\n        :type target_model: Type[\"Model\"]\n        :param alias: prefix of the relation\n        :type alias: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/#ormar.OrderAction.check_if_filter_apply","title":"<code>check_if_filter_apply(target_model, alias)</code>","text":"<p>Checks filter conditions to find if they apply to current join.</p> <p>:param target_model: model which is now processed :type target_model: Type[\"Model\"] :param alias: prefix of the relation :type alias: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n    \"\"\"\n    Checks filter conditions to find if they apply to current join.\n\n    :param target_model: model which is now processed\n    :type target_model: Type[\"Model\"]\n    :param alias: prefix of the relation\n    :type alias: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/#ormar.OrderAction.get_field_name_text","title":"<code>get_field_name_text()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_field_name_text(self) -&gt; str:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n</code></pre>"},{"location":"api/#ormar.OrderAction.get_min_or_max","title":"<code>get_min_or_max()</code>","text":"<p>Used in limit sub queries where you need to use aggregated functions in order to order by columns not included in group by. For postgres bool field it's using bool_or function as aggregates does not work with this type of columns.</p> <p>:return: min or max function to order :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Used in limit sub queries where you need to use aggregated functions\n    in order to order by columns not included in group by. For postgres bool\n    field it's using bool_or function as aggregates does not work with this type\n    of columns.\n\n    :return: min or max function to order\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    if self.direction == \"\":\n        function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n    function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n    return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n</code></pre>"},{"location":"api/#ormar.OrderAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    dialect = self.target_model.ormar_config.database._backend._dialect\n    quoter = dialect.identifier_preparer.quote\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    table_name = self.table.name\n    field_name = self.field_alias\n    if not prefix:\n        table_name = quoter(table_name)\n    else:\n        table_name = quoter(f\"{prefix}{table_name}\")\n    field_name = quoter(field_name)\n    return text(f\"{table_name}.{field_name} {self.direction}\")\n</code></pre>"},{"location":"api/#ormar.QuerySet","title":"<code>QuerySet</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Main class to perform database queries, exposed on each model as objects attribute.</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>class QuerySet(Generic[T]):\n    \"\"\"\n    Main class to perform database queries, exposed on each model as objects attribute.\n    \"\"\"\n\n    def __init__(  # noqa CFQ002\n        self,\n        model_cls: Optional[Type[\"T\"]] = None,\n        filter_clauses: Optional[List] = None,\n        exclude_clauses: Optional[List] = None,\n        select_related: Optional[List] = None,\n        limit_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        excludable: Optional[\"ExcludableItems\"] = None,\n        order_bys: Optional[List] = None,\n        prefetch_related: Optional[List] = None,\n        limit_raw_sql: bool = False,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; None:\n        self.proxy_source_model = proxy_source_model\n        self.model_cls = model_cls\n        self.filter_clauses = [] if filter_clauses is None else filter_clauses\n        self.exclude_clauses = [] if exclude_clauses is None else exclude_clauses\n        self._select_related = [] if select_related is None else select_related\n        self._prefetch_related = [] if prefetch_related is None else prefetch_related\n        self.limit_count = limit_count\n        self.query_offset = offset\n        self._excludable = excludable or ormar.ExcludableItems()\n        self.order_bys = order_bys or []\n        self.limit_sql_raw = limit_raw_sql\n\n    @property\n    def model_config(self) -&gt; \"OrmarConfig\":\n        \"\"\"\n        Shortcut to model class OrmarConfig set on QuerySet model.\n\n        :return: OrmarConfig of the model\n        :rtype: model's OrmarConfig\n        \"\"\"\n        if not self.model_cls:  # pragma nocover\n            raise ValueError(\"Model class of QuerySet is not initialized\")\n        return self.model_cls.ormar_config\n\n    @property\n    def model(self) -&gt; Type[\"T\"]:\n        \"\"\"\n        Shortcut to model class set on QuerySet.\n\n        :return: model class\n        :rtype: Type[Model]\n        \"\"\"\n        if not self.model_cls:  # pragma nocover\n            raise ValueError(\"Model class of QuerySet is not initialized\")\n        return self.model_cls\n\n    def rebuild_self(  # noqa: CFQ002\n        self,\n        filter_clauses: Optional[List] = None,\n        exclude_clauses: Optional[List] = None,\n        select_related: Optional[List] = None,\n        limit_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        excludable: Optional[\"ExcludableItems\"] = None,\n        order_bys: Optional[List] = None,\n        prefetch_related: Optional[List] = None,\n        limit_raw_sql: Optional[bool] = None,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; \"QuerySet\":\n        \"\"\"\n        Method that returns new instance of queryset based on passed params,\n        all not passed params are taken from current values.\n        \"\"\"\n        overwrites = {\n            \"select_related\": \"_select_related\",\n            \"offset\": \"query_offset\",\n            \"excludable\": \"_excludable\",\n            \"prefetch_related\": \"_prefetch_related\",\n            \"limit_raw_sql\": \"limit_sql_raw\",\n        }\n        passed_args = locals()\n\n        def replace_if_none(arg_name: str) -&gt; Any:\n            if passed_args.get(arg_name) is None:\n                return getattr(self, overwrites.get(arg_name, arg_name))\n            return passed_args.get(arg_name)\n\n        return self.__class__(\n            model_cls=self.model_cls,\n            filter_clauses=replace_if_none(\"filter_clauses\"),\n            exclude_clauses=replace_if_none(\"exclude_clauses\"),\n            select_related=replace_if_none(\"select_related\"),\n            limit_count=replace_if_none(\"limit_count\"),\n            offset=replace_if_none(\"offset\"),\n            excludable=replace_if_none(\"excludable\"),\n            order_bys=replace_if_none(\"order_bys\"),\n            prefetch_related=replace_if_none(\"prefetch_related\"),\n            limit_raw_sql=replace_if_none(\"limit_raw_sql\"),\n            proxy_source_model=replace_if_none(\"proxy_source_model\"),\n        )\n\n    async def _prefetch_related_models(\n        self, models: List[\"T\"], rows: List\n    ) -&gt; List[\"T\"]:\n        \"\"\"\n        Performs prefetch query for selected models names.\n\n        :param models: list of already parsed main Models from main query\n        :type models: List[Model]\n        :param rows: database rows from main query\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models with prefetch models populated\n        :rtype: List[Model]\n        \"\"\"\n        query = PrefetchQuery(\n            model_cls=self.model,\n            excludable=self._excludable,\n            prefetch_related=self._prefetch_related,\n            select_related=self._select_related,\n            orders_by=self.order_bys,\n        )\n        return await query.prefetch_related(models=models)  # type: ignore\n\n    async def _process_query_result_rows(self, rows: List) -&gt; List[\"T\"]:\n        \"\"\"\n        Process database rows and initialize ormar Model from each of the rows.\n\n        :param rows: list of database rows from query result\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models\n        :rtype: List[Model]\n        \"\"\"\n        result_rows = []\n        for row in rows:\n            result_rows.append(\n                self.model.from_row(\n                    row=row,\n                    select_related=self._select_related,\n                    excludable=self._excludable,\n                    source_model=self.model,\n                    proxy_source_model=self.proxy_source_model,\n                )\n            )\n            await asyncio.sleep(0)\n\n        if result_rows:\n            return self.model.merge_instances_list(result_rows)  # type: ignore\n        return cast(List[\"T\"], result_rows)\n\n    def _resolve_filter_groups(\n        self, groups: Any\n    ) -&gt; Tuple[List[FilterGroup], List[str]]:\n        \"\"\"\n        Resolves filter groups to populate FilterAction params in group tree.\n\n        :param groups: tuple of FilterGroups\n        :type groups: Any\n        :return: list of resolver groups\n        :rtype: Tuple[List[FilterGroup], List[str]]\n        \"\"\"\n        filter_groups = []\n        select_related = self._select_related\n        if groups:\n            for group in groups:\n                if not isinstance(group, FilterGroup):\n                    raise QueryDefinitionError(\n                        \"Only ormar.and_ and ormar.or_ \"\n                        \"can be passed as filter positional\"\n                        \" arguments,\"\n                        \"other values need to be passed by\"\n                        \"keyword arguments\"\n                    )\n                _, select_related = group.resolve(\n                    model_cls=self.model,\n                    select_related=self._select_related,\n                    filter_clauses=self.filter_clauses,\n                )\n                filter_groups.append(group)\n        return filter_groups, select_related\n\n    @staticmethod\n    def check_single_result_rows_count(rows: Sequence[Optional[\"T\"]]) -&gt; None:\n        \"\"\"\n        Verifies if the result has one and only one row.\n\n        :param rows: one element list of Models\n        :type rows: List[Model]\n        \"\"\"\n        if not rows or rows[0] is None:\n            raise NoMatch()\n        if len(rows) &gt; 1:\n            raise MultipleMatches()\n\n    @property\n    def database(self) -&gt; databases.Database:\n        \"\"\"\n        Shortcut to models database from OrmarConfig class.\n\n        :return: database\n        :rtype: databases.Database\n        \"\"\"\n        return self.model_config.database\n\n    @property\n    def table(self) -&gt; sqlalchemy.Table:\n        \"\"\"\n        Shortcut to models table from OrmarConfig.\n\n        :return: database table\n        :rtype: sqlalchemy.Table\n        \"\"\"\n        return self.model_config.table\n\n    def build_select_expression(\n        self,\n        limit: Optional[int] = None,\n        offset: Optional[int] = None,\n        order_bys: Optional[List] = None,\n    ) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Constructs the actual database query used in the QuerySet.\n        If any of the params is not passed the QuerySet own value is used.\n\n        :param limit: number to limit the query\n        :type limit: int\n        :param offset: number to offset by\n        :type offset: int\n        :param order_bys: list of order-by fields names\n        :type order_bys: List\n        :return: built sqlalchemy select expression\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        qry = Query(\n            model_cls=self.model,\n            select_related=self._select_related,\n            filter_clauses=self.filter_clauses,\n            exclude_clauses=self.exclude_clauses,\n            offset=offset or self.query_offset,\n            excludable=self._excludable,\n            order_bys=order_bys or self.order_bys,\n            limit_raw_sql=self.limit_sql_raw,\n            limit_count=limit if limit is not None else self.limit_count,\n        )\n        exp = qry.build_select_expression()\n        # print(\"\\n\", exp.compile(compile_kwargs={\"literal_binds\": True}))\n        return exp\n\n    def filter(  # noqa: A003\n        self, *args: Any, _exclude: bool = False, **kwargs: Any\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows you to filter by any `Model` attribute/field\n        as well as to fetch instances, with a filter across an FK relationship.\n\n        You can use special filter suffix to change the filter operands:\n\n        *  exact - like `album__name__exact='Malibu'` (exact match)\n        *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n        *  contains - like `album__name__contains='Mal'` (sql like)\n        *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n        *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n        *  isnull - like `album__name__isnull=True` (sql is null)\n           (isnotnull `album__name__isnull=False` (sql is not null))\n        *  gt - like `position__gt=3` (sql &gt;)\n        *  gte - like `position__gte=3` (sql &gt;=)\n        *  lt - like `position__lt=3` (sql &lt;)\n        *  lte - like `position__lte=3` (sql &lt;=)\n        *  startswith - like `album__name__startswith='Mal'` (exact start match)\n        *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n        *  endswith - like `album__name__endswith='ibu'` (exact end match)\n        *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n        Note that you can also use python style filters - check the docs!\n\n        :param _exclude: flag if it should be exclude or filter\n        :type _exclude: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        filter_groups, select_related = self._resolve_filter_groups(groups=args)\n        qryclause = QueryClause(\n            model_cls=self.model,\n            select_related=select_related,\n            filter_clauses=self.filter_clauses,\n        )\n        filter_clauses, select_related = qryclause.prepare_filter(**kwargs)\n        filter_clauses = filter_clauses + filter_groups  # type: ignore\n        if _exclude:\n            exclude_clauses = filter_clauses\n            filter_clauses = self.filter_clauses\n        else:\n            exclude_clauses = self.exclude_clauses\n            filter_clauses = filter_clauses\n\n        return self.rebuild_self(\n            filter_clauses=filter_clauses,\n            exclude_clauses=exclude_clauses,\n            select_related=select_related,\n        )\n\n    def exclude(self, *args: Any, **kwargs: Any) -&gt; \"QuerySet[T]\":  # noqa: A003\n        \"\"\"\n        Works exactly the same as filter and all modifiers (suffixes) are the same,\n        but returns a *not* condition.\n\n        So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n        the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n        Note that all conditions are joined so if you pass multiple values it\n        becomes a union of conditions.\n\n        `exclude(name='John', age&gt;=35)` will become\n        `where not (name='John' and age&gt;=35)`\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        return self.filter(_exclude=True, *args, **kwargs)\n\n    def select_related(self, related: Union[List, str, FieldAccessor]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows to prefetch related models during the same query.\n\n        **With `select_related` always only one query is run against the database**,\n        meaning that one (sometimes complicated) join is generated and later nested\n        models are processed in python.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(related, list):\n            related = [related]\n        related = [\n            rel._access_chain if isinstance(rel, FieldAccessor) else rel\n            for rel in related\n        ]\n\n        related = sorted(list(set(list(self._select_related) + related)))\n        return self.rebuild_self(select_related=related)\n\n    def select_all(self, follow: bool = False) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        By default adds only directly related models.\n\n        If follow=True is set it adds also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        relations = list(self.model.extract_related_names())\n        if follow:\n            relations = self.model._iterate_related_models()\n        return self.rebuild_self(select_related=relations)\n\n    def prefetch_related(\n        self, related: Union[List, str, FieldAccessor]\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows to prefetch related models during query - but opposite to\n        `select_related` each subsequent model is fetched in a separate database query.\n\n        **With `prefetch_related` always one query per Model is run against the\n        database**, meaning that you will have multiple queries executed one\n        after another.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(related, list):\n            related = [related]\n        related = [\n            rel._access_chain if isinstance(rel, FieldAccessor) else rel\n            for rel in related\n        ]\n\n        related = list(set(list(self._prefetch_related) + related))\n        return self.rebuild_self(prefetch_related=related)\n\n    def fields(\n        self, columns: Union[List, str, Set, Dict], _is_exclude: bool = False\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `fields()` you can select subset of model columns to limit the data load.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related`\n        models (with nested notation).\n\n        You can select specified fields by passing a `str, List[str], Set[str] or\n        dict` with nested definition.\n\n        To include related models use notation\n        `{related_name}__{column}[__{optional_next} etc.]`.\n\n        `fields()` can be called several times, building up the columns to select.\n\n        If you include related models into `select_related()` call but you won't specify\n        columns for those models in fields - implies a list of all fields for\n        those nested models.\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even if\n        not explicitly included.\n\n        You can also pass fields to include as dictionary or set.\n\n        To mark a field as included in a dictionary use it's name as key\n        and ellipsis as value.\n\n        To traverse nested models use nested dictionaries.\n\n        To include fields at last level instead of nested dictionary a set can be used.\n\n        To include whole nested model specify model related field name and ellipsis.\n\n        :param _is_exclude: flag if it's exclude or include operation\n        :type _is_exclude: bool\n        :param columns: columns to include\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        excludable = ormar.ExcludableItems.from_excludable(self._excludable)\n        excludable.build(\n            items=columns,\n            model_cls=self.model_cls,  # type: ignore\n            is_exclude=_is_exclude,\n        )\n\n        return self.rebuild_self(excludable=excludable)\n\n    def exclude_fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `exclude_fields()` you can select subset of model columns that will\n        be excluded to limit the data load.\n\n        It's the opposite of `fields()` method so check documentation above\n        to see what options are available.\n\n        Especially check above how you can pass also nested dictionaries\n        and sets as a mask to exclude fields from whole hierarchy.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related` models\n        (with nested notation).\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even\n        if explicitly excluded.\n\n        :param columns: columns to exclude\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        return self.fields(columns=columns, _is_exclude=True)\n\n    def order_by(self, columns: Union[List, str, OrderAction]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `order_by()` you can order the results from database based on your\n        choice of fields.\n\n        You can provide a string with field name or list of strings with fields names.\n\n        Ordering in sql will be applied in order of names you provide in order_by.\n\n        By default if you do not provide ordering `ormar` explicitly orders by\n        all primary keys\n\n        If you are sorting by nested models that causes that the result rows are\n        unsorted by the main model `ormar` will combine those children rows into\n        one main model.\n\n        The main model will never duplicate in the result\n\n        To order by main model field just provide a field name\n\n        To sort on nested models separate field names with dunder '__'.\n\n        You can sort this way across all relation types -&gt; `ForeignKey`,\n        reverse virtual FK and `ManyToMany` fields.\n\n        To sort in descending order provide a hyphen in front of the field name\n\n        :param columns: columns by which models should be sorted\n        :type columns: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n\n        orders_by = [\n            (\n                OrderAction(order_str=x, model_cls=self.model_cls)  # type: ignore\n                if not isinstance(x, OrderAction)\n                else x\n            )\n            for x in columns\n        ]\n\n        order_bys = self.order_bys + [x for x in orders_by if x not in self.order_bys]\n        return self.rebuild_self(order_bys=order_bys)\n\n    async def values(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        exclude_through: bool = False,\n        _as_dict: bool = True,\n        _flatten: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of dictionaries with column values in order of the fields\n        passed or all fields from queried models.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param _flatten: internal parameter to flatten one element tuples\n        :type _flatten: bool\n        :param _as_dict: internal parameter if return dict or tuples\n        :type _as_dict: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields:  Union[List, str, Set, Dict]\n        \"\"\"\n        if fields:\n            return await self.fields(columns=fields).values(\n                _as_dict=_as_dict, _flatten=_flatten, exclude_through=exclude_through\n            )\n        expr = self.build_select_expression()\n        rows = await self.database.fetch_all(expr)\n        if not rows:\n            return []\n        alias_resolver = ReverseAliasResolver(\n            select_related=self._select_related,\n            excludable=self._excludable,\n            model_cls=self.model_cls,  # type: ignore\n            exclude_through=exclude_through,\n        )\n        column_map = alias_resolver.resolve_columns(\n            columns_names=list(cast(LegacyRow, rows[0]).keys())\n        )\n        result = [\n            {column_map.get(k): v for k, v in dict(x).items() if k in column_map}\n            for x in rows\n        ]\n        if _as_dict:\n            return result\n        if _flatten and self._excludable.include_entry_count() != 1:\n            raise QueryDefinitionError(\n                \"You cannot flatten values_list if more than one field is selected!\"\n            )\n        tuple_result = [tuple(x.values()) for x in result]\n        return tuple_result if not _flatten else [x[0] for x in tuple_result]\n\n    async def values_list(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        flatten: bool = False,\n        exclude_through: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of tuples with column values in order of the fields passed or\n        all fields from queried models.\n\n        When one field is passed you can flatten the list of tuples into list of values\n        of that single field.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields: Union[str, List[str]]\n        :param flatten: when one field is passed you can flatten the list of tuples\n        :type flatten: bool\n        \"\"\"\n        return await self.values(\n            fields=fields,\n            exclude_through=exclude_through,\n            _as_dict=False,\n            _flatten=flatten,\n        )\n\n    async def exists(self) -&gt; bool:\n        \"\"\"\n        Returns a bool value to confirm if there are rows matching the given criteria\n        (applied with `filter` and `exclude` if set).\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        expr = self.build_select_expression()\n        expr = sqlalchemy.exists(expr).select()\n        return await self.database.fetch_val(expr)\n\n    async def count(self, distinct: bool = True) -&gt; int:\n        \"\"\"\n        Returns number of rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n        If `distinct` is `True` (the default), this will return\n        the number of primary rows selected. If `False`,\n        the count will be the total number of rows returned\n        (including extra rows for `one-to-many` or `many-to-many`\n        left `select_related` table joins).\n        `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n        :param distinct: flag if the primary table rows should be distinct or not\n\n        :return: number of rows\n        :rtype: int\n        \"\"\"\n        expr = self.build_select_expression().alias(\"subquery_for_count\")\n        expr = sqlalchemy.func.count().select().select_from(expr)\n        if distinct:\n            pk_column_name = self.model.get_column_alias(self.model_config.pkname)\n            expr_distinct = expr.group_by(pk_column_name).alias(\"subquery_for_group\")\n            expr = sqlalchemy.func.count().select().select_from(expr_distinct)\n        return await self.database.fetch_val(expr)\n\n    async def _query_aggr_function(self, func_name: str, columns: List) -&gt; Any:\n        func = getattr(sqlalchemy.func, func_name)\n        select_actions = [\n            SelectAction(select_str=column, model_cls=self.model) for column in columns\n        ]\n        if func_name in [\"sum\", \"avg\"]:\n            if any(not x.is_numeric for x in select_actions):\n                raise QueryDefinitionError(\n                    \"You can use sum and svg only with\" \"numeric types of columns\"\n                )\n        select_columns = [x.apply_func(func, use_label=True) for x in select_actions]\n        expr = self.build_select_expression().alias(f\"subquery_for_{func_name}\")\n        expr = sqlalchemy.select(select_columns).select_from(expr)\n        # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n        result = await self.database.fetch_one(expr)\n        return dict(result) if len(result) &gt; 1 else result[0]  # type: ignore\n\n    async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns max value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: max value of column(s)\n        :rtype: Any\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"max\", columns=columns)\n\n    async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns min value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: min value of column(s)\n        :rtype: Any\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"min\", columns=columns)\n\n    async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns sum value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: sum value of columns\n        :rtype: int\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"sum\", columns=columns)\n\n    async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n        \"\"\"\n        Returns avg value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: avg value of columns\n        :rtype: Union[int, float, List]\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"avg\", columns=columns)\n\n    async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Updates the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of updated rows\n        :rtype: int\n        \"\"\"\n        if not each and not (self.filter_clauses or self.exclude_clauses):\n            raise QueryDefinitionError(\n                \"You cannot update without filtering the queryset first. \"\n                \"If you want to update all rows use update(each=True, **kwargs)\"\n            )\n\n        self_fields = self.model.extract_db_own_fields().union(\n            self.model.extract_related_names()\n        )\n        updates = {k: v for k, v in kwargs.items() if k in self_fields}\n        updates = self.model.validate_enums(updates)\n        updates = self.model.translate_columns_to_aliases(updates)\n\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n            self.table.update().values(**updates)\n        )\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        return await self.database.execute(expr)\n\n    async def delete(self, *args: Any, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Deletes from the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of deleted rows\n        :rtype:int\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).delete()\n        if not each and not (self.filter_clauses or self.exclude_clauses):\n            raise QueryDefinitionError(\n                \"You cannot delete without filtering the queryset first. \"\n                \"If you want to delete all rows use delete(each=True)\"\n            )\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n            self.table.delete()\n        )\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        return await self.database.execute(expr)\n\n    def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can paginate the result which is a combination of offset and limit clauses.\n        Limit is set to page size and offset is set to (page-1) * page_size.\n\n        :param page_size: numbers of items per page\n        :type page_size: int\n        :param page: page number\n        :type page: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if page &lt; 1 or page_size &lt; 1:\n            raise QueryDefinitionError(\"Page size and page have to be greater than 0.\")\n\n        limit_count = page_size\n        query_offset = (page - 1) * page_size\n        return self.rebuild_self(limit_count=limit_count, offset=query_offset)\n\n    def limit(\n        self, limit_count: int, limit_raw_sql: Optional[bool] = None\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can limit the results to desired number of parent models.\n\n        To limit the actual number of database query rows instead of number of main\n        models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n        :param limit_raw_sql: flag if raw sql should be limited\n        :type limit_raw_sql: bool\n        :param limit_count: number of models to limit\n        :type limit_count: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n        return self.rebuild_self(limit_count=limit_count, limit_raw_sql=limit_raw_sql)\n\n    def offset(\n        self, offset: int, limit_raw_sql: Optional[bool] = None\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can also offset the results by desired number of main models.\n\n        To offset the actual number of database query rows instead of number of main\n        models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n        :param limit_raw_sql: flag if raw sql should be offset\n        :type limit_raw_sql: bool\n        :param offset: numbers of models to offset\n        :type offset: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n        return self.rebuild_self(offset=offset, limit_raw_sql=limit_raw_sql)\n\n    async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).first()\n\n        expr = self.build_select_expression(\n            limit=1,\n            order_bys=(\n                [\n                    OrderAction(\n                        order_str=f\"{self.model.ormar_config.pkname}\",\n                        model_cls=self.model_cls,  # type: ignore\n                    )\n                ]\n                if not any([x.is_source_model_order for x in self.order_bys])\n                else []\n            )\n            + self.order_bys,\n        )\n        rows = await self.database.fetch_all(expr)\n        processed_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and processed_rows:\n            processed_rows = await self._prefetch_related_models(processed_rows, rows)\n        self.check_single_result_rows_count(processed_rows)\n        return processed_rows[0]  # type: ignore\n\n    async def first_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        If no match is found None will be returned.\n\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            return await self.first(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n    async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        If no match is found None will be returned.\n\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n    async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":  # noqa: CCR001\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).get()\n\n        if not self.filter_clauses:\n            expr = self.build_select_expression(\n                limit=1,\n                order_bys=(\n                    [\n                        OrderAction(\n                            order_str=f\"-{self.model.ormar_config.pkname}\",\n                            model_cls=self.model_cls,  # type: ignore\n                        )\n                    ]\n                    if not any([x.is_source_model_order for x in self.order_bys])\n                    else []\n                )\n                + self.order_bys,\n            )\n        else:\n            expr = self.build_select_expression()\n\n        rows = await self.database.fetch_all(expr)\n        processed_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and processed_rows:\n            processed_rows = await self._prefetch_related_models(processed_rows, rows)\n        self.check_single_result_rows_count(processed_rows)\n        return processed_rows[0]  # type: ignore\n\n    async def get_or_create(\n        self,\n        _defaults: Optional[Dict[str, Any]] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Tuple[\"T\", bool]:\n        \"\"\"\n        Combination of create and get methods.\n\n        Tries to get a row meeting the criteria for kwargs\n        and if `NoMatch` exception is raised\n        it creates a new one with given kwargs and _defaults.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :param _defaults: default values for creating object\n        :type _defaults: Optional[Dict[str, Any]]\n        :return: model instance and a boolean\n        :rtype: Tuple(\"T\", bool)\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs), False\n        except NoMatch:\n            _defaults = _defaults or {}\n            return await self.create(**{**kwargs, **_defaults}), True\n\n    async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Updates the model, or in case there is no match in database creates a new one.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: updated or created model\n        :rtype: Model\n        \"\"\"\n        pk_name = self.model_config.pkname\n        if \"pk\" in kwargs:\n            kwargs[pk_name] = kwargs.pop(\"pk\")\n        if pk_name not in kwargs or kwargs.get(pk_name) is None:\n            return await self.create(**kwargs)\n        model = await self.get(pk=kwargs[pk_name])\n        return await model.update(**kwargs)\n\n    async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n        \"\"\"\n        Returns all rows from a database for given model for set filter options.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).all()`.\n\n        If there are no rows meeting the criteria an empty list is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: list of returned models\n        :rtype: List[Model]\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).all()\n\n        expr = self.build_select_expression()\n        rows = await self.database.fetch_all(expr)\n        result_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and result_rows:\n            result_rows = await self._prefetch_related_models(result_rows, rows)\n\n        return result_rows\n\n    async def iterate(  # noqa: A003\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; AsyncGenerator[\"T\", None]:\n        \"\"\"\n        Return async iterable generator for all rows from a database for given model.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).iterate()`.\n\n        If there are no rows meeting the criteria an empty async generator is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: asynchronous iterable generator of returned models\n        :rtype: AsyncGenerator[Model]\n        \"\"\"\n\n        if self._prefetch_related:\n            raise QueryDefinitionError(\n                \"Prefetch related queries are not supported in iterators\"\n            )\n\n        if kwargs or args:\n            async for result in self.filter(*args, **kwargs).iterate():\n                yield result\n            return\n\n        expr = self.build_select_expression()\n\n        rows: list = []\n        last_primary_key = None\n        pk_alias = self.model.get_column_alias(self.model_config.pkname)\n\n        async for row in self.database.iterate(query=expr):\n            current_primary_key = row[pk_alias]\n            if last_primary_key == current_primary_key or last_primary_key is None:\n                last_primary_key = current_primary_key\n                rows.append(row)\n                continue\n\n            yield (await self._process_query_result_rows(rows))[0]\n            last_primary_key = current_primary_key\n            rows = [row]\n\n        if rows:\n            yield (await self._process_query_result_rows(rows))[0]\n\n    async def create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Creates the model instance, saves it in a database and returns the updates model\n        (with pk populated if not passed and autoincrement is set).\n\n        The allowed kwargs are `Model` fields names and proper value types.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: created model\n        :rtype: Model\n        \"\"\"\n        instance = self.model(**kwargs)\n        instance = await instance.save()\n        return instance\n\n    async def bulk_create(self, objects: List[\"T\"]) -&gt; None:\n        \"\"\"\n        Performs a bulk create in one database session to speed up the process.\n\n        Allows you to create multiple objects at once.\n\n        A valid list of `Model` objects needs to be passed.\n\n        Bulk operations do not send signals.\n\n        :param objects: list of ormar models already initialized and ready to save.\n        :type objects: List[Model]\n        \"\"\"\n\n        if not objects:\n            raise ModelListEmptyError(\"Bulk create objects are empty!\")\n\n        ready_objects = []\n        for obj in objects:\n            ready_objects.append(obj.prepare_model_to_save(obj.model_dump()))\n            await asyncio.sleep(0)  # Allow context switching to prevent blocking\n\n        # don't use execute_many, as in databases it's executed in a loop\n        # instead of using execute_many from drivers\n        expr = self.table.insert().values(ready_objects)\n        await self.database.execute(expr)\n\n        for obj in objects:\n            obj.set_save_status(True)\n\n    async def bulk_update(  # noqa:  CCR001\n        self, objects: List[\"T\"], columns: Optional[List[str]] = None\n    ) -&gt; None:\n        \"\"\"\n        Performs bulk update in one database session to speed up the process.\n\n        Allows you to update multiple instance at once.\n\n        All `Models` passed need to have primary key column populated.\n\n        You can also select which fields to update by passing `columns` list\n        as a list of string names.\n\n        Bulk operations do not send signals.\n\n        :param objects: list of ormar models\n        :type objects: List[Model]\n        :param columns: list of columns to update\n        :type columns: List[str]\n        \"\"\"\n        if not objects:\n            raise ModelListEmptyError(\"Bulk update objects are empty!\")\n\n        ready_objects = []\n        pk_name = self.model_config.pkname\n        if not columns:\n            columns = list(\n                self.model.extract_db_own_fields().union(\n                    self.model.extract_related_names()\n                )\n            )\n\n        if pk_name not in columns:\n            columns.append(pk_name)\n\n        columns = [self.model.get_column_alias(k) for k in columns]\n\n        for obj in objects:\n            new_kwargs = obj.model_dump()\n            if new_kwargs.get(pk_name) is None:\n                raise ModelPersistenceError(\n                    \"You cannot update unsaved objects. \"\n                    f\"{self.model.__name__} has to have {pk_name} filled.\"\n                )\n            new_kwargs = obj.prepare_model_to_update(new_kwargs)\n            ready_objects.append(\n                {\"new_\" + k: v for k, v in new_kwargs.items() if k in columns}\n            )\n            await asyncio.sleep(0)\n\n        pk_column = self.model_config.table.c.get(self.model.get_column_alias(pk_name))\n        pk_column_name = self.model.get_column_alias(pk_name)\n        table_columns = [c.name for c in self.model_config.table.c]\n        expr = self.table.update().where(\n            pk_column == bindparam(\"new_\" + pk_column_name)\n        )\n        expr = expr.values(\n            **{\n                k: bindparam(\"new_\" + k)\n                for k in columns\n                if k != pk_column_name and k in table_columns\n            }\n        )\n        # databases bind params only where query is passed as string\n        # otherwise it just passes all data to values and results in unconsumed columns\n        expr = str(expr)\n        await self.database.execute_many(expr, ready_objects)\n\n        for obj in objects:\n            obj.set_save_status(True)\n\n        await cast(\n            Type[\"Model\"], self.model_cls\n        ).ormar_config.signals.post_bulk_update.send(\n            sender=self.model_cls, instances=objects  # type: ignore\n        )\n</code></pre>"},{"location":"api/#ormar.QuerySet.database","title":"<code>database: databases.Database</code>  <code>property</code>","text":"<p>Shortcut to models database from OrmarConfig class.</p> <p>:return: database :rtype: databases.Database</p>"},{"location":"api/#ormar.QuerySet.model","title":"<code>model: Type[T]</code>  <code>property</code>","text":"<p>Shortcut to model class set on QuerySet.</p> <p>:return: model class :rtype: Type[Model]</p>"},{"location":"api/#ormar.QuerySet.model_config","title":"<code>model_config: OrmarConfig</code>  <code>property</code>","text":"<p>Shortcut to model class OrmarConfig set on QuerySet model.</p> <p>:return: OrmarConfig of the model :rtype: model's OrmarConfig</p>"},{"location":"api/#ormar.QuerySet.table","title":"<code>table: sqlalchemy.Table</code>  <code>property</code>","text":"<p>Shortcut to models table from OrmarConfig.</p> <p>:return: database table :rtype: sqlalchemy.Table</p>"},{"location":"api/#ormar.QuerySet.all","title":"<code>all(*args, **kwargs)</code>  <code>async</code>","text":"<p>Returns all rows from a database for given model for set filter options.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).all()</code>.</p> <p>If there are no rows meeting the criteria an empty list is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: list of returned models :rtype: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n    \"\"\"\n    Returns all rows from a database for given model for set filter options.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).all()`.\n\n    If there are no rows meeting the criteria an empty list is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: list of returned models\n    :rtype: List[Model]\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).all()\n\n    expr = self.build_select_expression()\n    rows = await self.database.fetch_all(expr)\n    result_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and result_rows:\n        result_rows = await self._prefetch_related_models(result_rows, rows)\n\n    return result_rows\n</code></pre>"},{"location":"api/#ormar.QuerySet.avg","title":"<code>avg(columns)</code>  <code>async</code>","text":"<p>Returns avg value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: avg value of columns :rtype: Union[int, float, List]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n    \"\"\"\n    Returns avg value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: avg value of columns\n    :rtype: Union[int, float, List]\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"avg\", columns=columns)\n</code></pre>"},{"location":"api/#ormar.QuerySet.build_select_expression","title":"<code>build_select_expression(limit=None, offset=None, order_bys=None)</code>","text":"<p>Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used.</p> <p>:param limit: number to limit the query :type limit: int :param offset: number to offset by :type offset: int :param order_bys: list of order-by fields names :type order_bys: List :return: built sqlalchemy select expression :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def build_select_expression(\n    self,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None,\n    order_bys: Optional[List] = None,\n) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Constructs the actual database query used in the QuerySet.\n    If any of the params is not passed the QuerySet own value is used.\n\n    :param limit: number to limit the query\n    :type limit: int\n    :param offset: number to offset by\n    :type offset: int\n    :param order_bys: list of order-by fields names\n    :type order_bys: List\n    :return: built sqlalchemy select expression\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    qry = Query(\n        model_cls=self.model,\n        select_related=self._select_related,\n        filter_clauses=self.filter_clauses,\n        exclude_clauses=self.exclude_clauses,\n        offset=offset or self.query_offset,\n        excludable=self._excludable,\n        order_bys=order_bys or self.order_bys,\n        limit_raw_sql=self.limit_sql_raw,\n        limit_count=limit if limit is not None else self.limit_count,\n    )\n    exp = qry.build_select_expression()\n    # print(\"\\n\", exp.compile(compile_kwargs={\"literal_binds\": True}))\n    return exp\n</code></pre>"},{"location":"api/#ormar.QuerySet.bulk_create","title":"<code>bulk_create(objects)</code>  <code>async</code>","text":"<p>Performs a bulk create in one database session to speed up the process.</p> <p>Allows you to create multiple objects at once.</p> <p>A valid list of <code>Model</code> objects needs to be passed.</p> <p>Bulk operations do not send signals.</p> <p>:param objects: list of ormar models already initialized and ready to save. :type objects: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def bulk_create(self, objects: List[\"T\"]) -&gt; None:\n    \"\"\"\n    Performs a bulk create in one database session to speed up the process.\n\n    Allows you to create multiple objects at once.\n\n    A valid list of `Model` objects needs to be passed.\n\n    Bulk operations do not send signals.\n\n    :param objects: list of ormar models already initialized and ready to save.\n    :type objects: List[Model]\n    \"\"\"\n\n    if not objects:\n        raise ModelListEmptyError(\"Bulk create objects are empty!\")\n\n    ready_objects = []\n    for obj in objects:\n        ready_objects.append(obj.prepare_model_to_save(obj.model_dump()))\n        await asyncio.sleep(0)  # Allow context switching to prevent blocking\n\n    # don't use execute_many, as in databases it's executed in a loop\n    # instead of using execute_many from drivers\n    expr = self.table.insert().values(ready_objects)\n    await self.database.execute(expr)\n\n    for obj in objects:\n        obj.set_save_status(True)\n</code></pre>"},{"location":"api/#ormar.QuerySet.bulk_update","title":"<code>bulk_update(objects, columns=None)</code>  <code>async</code>","text":"<p>Performs bulk update in one database session to speed up the process.</p> <p>Allows you to update multiple instance at once.</p> <p>All <code>Models</code> passed need to have primary key column populated.</p> <p>You can also select which fields to update by passing <code>columns</code> list as a list of string names.</p> <p>Bulk operations do not send signals.</p> <p>:param objects: list of ormar models :type objects: List[Model] :param columns: list of columns to update :type columns: List[str]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def bulk_update(  # noqa:  CCR001\n    self, objects: List[\"T\"], columns: Optional[List[str]] = None\n) -&gt; None:\n    \"\"\"\n    Performs bulk update in one database session to speed up the process.\n\n    Allows you to update multiple instance at once.\n\n    All `Models` passed need to have primary key column populated.\n\n    You can also select which fields to update by passing `columns` list\n    as a list of string names.\n\n    Bulk operations do not send signals.\n\n    :param objects: list of ormar models\n    :type objects: List[Model]\n    :param columns: list of columns to update\n    :type columns: List[str]\n    \"\"\"\n    if not objects:\n        raise ModelListEmptyError(\"Bulk update objects are empty!\")\n\n    ready_objects = []\n    pk_name = self.model_config.pkname\n    if not columns:\n        columns = list(\n            self.model.extract_db_own_fields().union(\n                self.model.extract_related_names()\n            )\n        )\n\n    if pk_name not in columns:\n        columns.append(pk_name)\n\n    columns = [self.model.get_column_alias(k) for k in columns]\n\n    for obj in objects:\n        new_kwargs = obj.model_dump()\n        if new_kwargs.get(pk_name) is None:\n            raise ModelPersistenceError(\n                \"You cannot update unsaved objects. \"\n                f\"{self.model.__name__} has to have {pk_name} filled.\"\n            )\n        new_kwargs = obj.prepare_model_to_update(new_kwargs)\n        ready_objects.append(\n            {\"new_\" + k: v for k, v in new_kwargs.items() if k in columns}\n        )\n        await asyncio.sleep(0)\n\n    pk_column = self.model_config.table.c.get(self.model.get_column_alias(pk_name))\n    pk_column_name = self.model.get_column_alias(pk_name)\n    table_columns = [c.name for c in self.model_config.table.c]\n    expr = self.table.update().where(\n        pk_column == bindparam(\"new_\" + pk_column_name)\n    )\n    expr = expr.values(\n        **{\n            k: bindparam(\"new_\" + k)\n            for k in columns\n            if k != pk_column_name and k in table_columns\n        }\n    )\n    # databases bind params only where query is passed as string\n    # otherwise it just passes all data to values and results in unconsumed columns\n    expr = str(expr)\n    await self.database.execute_many(expr, ready_objects)\n\n    for obj in objects:\n        obj.set_save_status(True)\n\n    await cast(\n        Type[\"Model\"], self.model_cls\n    ).ormar_config.signals.post_bulk_update.send(\n        sender=self.model_cls, instances=objects  # type: ignore\n    )\n</code></pre>"},{"location":"api/#ormar.QuerySet.check_single_result_rows_count","title":"<code>check_single_result_rows_count(rows)</code>  <code>staticmethod</code>","text":"<p>Verifies if the result has one and only one row.</p> <p>:param rows: one element list of Models :type rows: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>@staticmethod\ndef check_single_result_rows_count(rows: Sequence[Optional[\"T\"]]) -&gt; None:\n    \"\"\"\n    Verifies if the result has one and only one row.\n\n    :param rows: one element list of Models\n    :type rows: List[Model]\n    \"\"\"\n    if not rows or rows[0] is None:\n        raise NoMatch()\n    if len(rows) &gt; 1:\n        raise MultipleMatches()\n</code></pre>"},{"location":"api/#ormar.QuerySet.count","title":"<code>count(distinct=True)</code>  <code>async</code>","text":"<p>Returns number of rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before). If <code>distinct</code> is <code>True</code> (the default), this will return the number of primary rows selected. If <code>False</code>, the count will be the total number of rows returned (including extra rows for <code>one-to-many</code> or <code>many-to-many</code> left <code>select_related</code> table joins). <code>False</code> is the legacy (buggy) behavior for workflows that depend on it.</p> <p>:param distinct: flag if the primary table rows should be distinct or not</p> <p>:return: number of rows :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def count(self, distinct: bool = True) -&gt; int:\n    \"\"\"\n    Returns number of rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n    If `distinct` is `True` (the default), this will return\n    the number of primary rows selected. If `False`,\n    the count will be the total number of rows returned\n    (including extra rows for `one-to-many` or `many-to-many`\n    left `select_related` table joins).\n    `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n    :param distinct: flag if the primary table rows should be distinct or not\n\n    :return: number of rows\n    :rtype: int\n    \"\"\"\n    expr = self.build_select_expression().alias(\"subquery_for_count\")\n    expr = sqlalchemy.func.count().select().select_from(expr)\n    if distinct:\n        pk_column_name = self.model.get_column_alias(self.model_config.pkname)\n        expr_distinct = expr.group_by(pk_column_name).alias(\"subquery_for_group\")\n        expr = sqlalchemy.func.count().select().select_from(expr_distinct)\n    return await self.database.fetch_val(expr)\n</code></pre>"},{"location":"api/#ormar.QuerySet.create","title":"<code>create(**kwargs)</code>  <code>async</code>","text":"<p>Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set).</p> <p>The allowed kwargs are <code>Model</code> fields names and proper value types.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: created model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Creates the model instance, saves it in a database and returns the updates model\n    (with pk populated if not passed and autoincrement is set).\n\n    The allowed kwargs are `Model` fields names and proper value types.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: created model\n    :rtype: Model\n    \"\"\"\n    instance = self.model(**kwargs)\n    instance = await instance.save()\n    return instance\n</code></pre>"},{"location":"api/#ormar.QuerySet.delete","title":"<code>delete(*args, each=False, **kwargs)</code>  <code>async</code>","text":"<p>Deletes from the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of deleted rows :rtype:int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def delete(self, *args: Any, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Deletes from the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of deleted rows\n    :rtype:int\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).delete()\n    if not each and not (self.filter_clauses or self.exclude_clauses):\n        raise QueryDefinitionError(\n            \"You cannot delete without filtering the queryset first. \"\n            \"If you want to delete all rows use delete(each=True)\"\n        )\n    expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n        self.table.delete()\n    )\n    expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n        expr\n    )\n    return await self.database.execute(expr)\n</code></pre>"},{"location":"api/#ormar.QuerySet.exclude","title":"<code>exclude(*args, **kwargs)</code>","text":"<p>Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition.</p> <p>So if you use <code>filter(name='John')</code> which is <code>where name = 'John'</code> in SQL, the <code>exclude(name='John')</code> equals to <code>where name &lt;&gt; 'John'</code></p> <p>Note that all conditions are joined so if you pass multiple values it becomes a union of conditions.</p> <p><code>exclude(name='John', age&gt;=35)</code> will become <code>where not (name='John' and age&gt;=35)</code></p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def exclude(self, *args: Any, **kwargs: Any) -&gt; \"QuerySet[T]\":  # noqa: A003\n    \"\"\"\n    Works exactly the same as filter and all modifiers (suffixes) are the same,\n    but returns a *not* condition.\n\n    So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n    the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n    Note that all conditions are joined so if you pass multiple values it\n    becomes a union of conditions.\n\n    `exclude(name='John', age&gt;=35)` will become\n    `where not (name='John' and age&gt;=35)`\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    return self.filter(_exclude=True, *args, **kwargs)\n</code></pre>"},{"location":"api/#ormar.QuerySet.exclude_fields","title":"<code>exclude_fields(columns)</code>","text":"<p>With <code>exclude_fields()</code> you can select subset of model columns that will be excluded to limit the data load.</p> <p>It's the opposite of <code>fields()</code> method so check documentation above to see what options are available.</p> <p>Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if explicitly excluded.</p> <p>:param columns: columns to exclude :type columns: Union[List, str, Set, Dict] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def exclude_fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `exclude_fields()` you can select subset of model columns that will\n    be excluded to limit the data load.\n\n    It's the opposite of `fields()` method so check documentation above\n    to see what options are available.\n\n    Especially check above how you can pass also nested dictionaries\n    and sets as a mask to exclude fields from whole hierarchy.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related` models\n    (with nested notation).\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even\n    if explicitly excluded.\n\n    :param columns: columns to exclude\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    return self.fields(columns=columns, _is_exclude=True)\n</code></pre>"},{"location":"api/#ormar.QuerySet.exists","title":"<code>exists()</code>  <code>async</code>","text":"<p>Returns a bool value to confirm if there are rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set).</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def exists(self) -&gt; bool:\n    \"\"\"\n    Returns a bool value to confirm if there are rows matching the given criteria\n    (applied with `filter` and `exclude` if set).\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    expr = self.build_select_expression()\n    expr = sqlalchemy.exists(expr).select()\n    return await self.database.fetch_val(expr)\n</code></pre>"},{"location":"api/#ormar.QuerySet.fields","title":"<code>fields(columns, _is_exclude=False)</code>","text":"<p>With <code>fields()</code> you can select subset of model columns to limit the data load.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>You can select specified fields by passing a <code>str, List[str], Set[str] or dict</code> with nested definition.</p> <p>To include related models use notation <code>{related_name}__{column}[__{optional_next} etc.]</code>.</p> <p><code>fields()</code> can be called several times, building up the columns to select.</p> <p>If you include related models into <code>select_related()</code> call but you won't specify columns for those models in fields - implies a list of all fields for those nested models.</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if not explicitly included.</p> <p>You can also pass fields to include as dictionary or set.</p> <p>To mark a field as included in a dictionary use it's name as key and ellipsis as value.</p> <p>To traverse nested models use nested dictionaries.</p> <p>To include fields at last level instead of nested dictionary a set can be used.</p> <p>To include whole nested model specify model related field name and ellipsis.</p> <p>:param _is_exclude: flag if it's exclude or include operation :type _is_exclude: bool :param columns: columns to include :type columns: Union[List, str, Set, Dict] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def fields(\n    self, columns: Union[List, str, Set, Dict], _is_exclude: bool = False\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `fields()` you can select subset of model columns to limit the data load.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related`\n    models (with nested notation).\n\n    You can select specified fields by passing a `str, List[str], Set[str] or\n    dict` with nested definition.\n\n    To include related models use notation\n    `{related_name}__{column}[__{optional_next} etc.]`.\n\n    `fields()` can be called several times, building up the columns to select.\n\n    If you include related models into `select_related()` call but you won't specify\n    columns for those models in fields - implies a list of all fields for\n    those nested models.\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even if\n    not explicitly included.\n\n    You can also pass fields to include as dictionary or set.\n\n    To mark a field as included in a dictionary use it's name as key\n    and ellipsis as value.\n\n    To traverse nested models use nested dictionaries.\n\n    To include fields at last level instead of nested dictionary a set can be used.\n\n    To include whole nested model specify model related field name and ellipsis.\n\n    :param _is_exclude: flag if it's exclude or include operation\n    :type _is_exclude: bool\n    :param columns: columns to include\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    excludable = ormar.ExcludableItems.from_excludable(self._excludable)\n    excludable.build(\n        items=columns,\n        model_cls=self.model_cls,  # type: ignore\n        is_exclude=_is_exclude,\n    )\n\n    return self.rebuild_self(excludable=excludable)\n</code></pre>"},{"location":"api/#ormar.QuerySet.filter","title":"<code>filter(*args, _exclude=False, **kwargs)</code>","text":"<p>Allows you to filter by any <code>Model</code> attribute/field as well as to fetch instances, with a filter across an FK relationship.</p> <p>You can use special filter suffix to change the filter operands:</p> <ul> <li>exact - like <code>album__name__exact='Malibu'</code> (exact match)</li> <li>iexact - like <code>album__name__iexact='malibu'</code> (exact match case insensitive)</li> <li>contains - like <code>album__name__contains='Mal'</code> (sql like)</li> <li>icontains - like <code>album__name__icontains='mal'</code> (sql like case insensitive)</li> <li>in - like <code>album__name__in=['Malibu', 'Barclay']</code> (sql in)</li> <li>isnull - like <code>album__name__isnull=True</code> (sql is null)    (isnotnull <code>album__name__isnull=False</code> (sql is not null))</li> <li>gt - like <code>position__gt=3</code> (sql &gt;)</li> <li>gte - like <code>position__gte=3</code> (sql &gt;=)</li> <li>lt - like <code>position__lt=3</code> (sql &lt;)</li> <li>lte - like <code>position__lte=3</code> (sql &lt;=)</li> <li>startswith - like <code>album__name__startswith='Mal'</code> (exact start match)</li> <li>istartswith - like <code>album__name__istartswith='mal'</code> (case insensitive)</li> <li>endswith - like <code>album__name__endswith='ibu'</code> (exact end match)</li> <li>iendswith - like <code>album__name__iendswith='IBU'</code> (case insensitive)</li> </ul> <p>Note that you can also use python style filters - check the docs!</p> <p>:param _exclude: flag if it should be exclude or filter :type _exclude: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def filter(  # noqa: A003\n    self, *args: Any, _exclude: bool = False, **kwargs: Any\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows you to filter by any `Model` attribute/field\n    as well as to fetch instances, with a filter across an FK relationship.\n\n    You can use special filter suffix to change the filter operands:\n\n    *  exact - like `album__name__exact='Malibu'` (exact match)\n    *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n    *  contains - like `album__name__contains='Mal'` (sql like)\n    *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n    *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n    *  isnull - like `album__name__isnull=True` (sql is null)\n       (isnotnull `album__name__isnull=False` (sql is not null))\n    *  gt - like `position__gt=3` (sql &gt;)\n    *  gte - like `position__gte=3` (sql &gt;=)\n    *  lt - like `position__lt=3` (sql &lt;)\n    *  lte - like `position__lte=3` (sql &lt;=)\n    *  startswith - like `album__name__startswith='Mal'` (exact start match)\n    *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n    *  endswith - like `album__name__endswith='ibu'` (exact end match)\n    *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n    Note that you can also use python style filters - check the docs!\n\n    :param _exclude: flag if it should be exclude or filter\n    :type _exclude: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    filter_groups, select_related = self._resolve_filter_groups(groups=args)\n    qryclause = QueryClause(\n        model_cls=self.model,\n        select_related=select_related,\n        filter_clauses=self.filter_clauses,\n    )\n    filter_clauses, select_related = qryclause.prepare_filter(**kwargs)\n    filter_clauses = filter_clauses + filter_groups  # type: ignore\n    if _exclude:\n        exclude_clauses = filter_clauses\n        filter_clauses = self.filter_clauses\n    else:\n        exclude_clauses = self.exclude_clauses\n        filter_clauses = filter_clauses\n\n    return self.rebuild_self(\n        filter_clauses=filter_clauses,\n        exclude_clauses=exclude_clauses,\n        select_related=select_related,\n    )\n</code></pre>"},{"location":"api/#ormar.QuerySet.first","title":"<code>first(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).first()\n\n    expr = self.build_select_expression(\n        limit=1,\n        order_bys=(\n            [\n                OrderAction(\n                    order_str=f\"{self.model.ormar_config.pkname}\",\n                    model_cls=self.model_cls,  # type: ignore\n                )\n            ]\n            if not any([x.is_source_model_order for x in self.order_bys])\n            else []\n        )\n        + self.order_bys,\n    )\n    rows = await self.database.fetch_all(expr)\n    processed_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and processed_rows:\n        processed_rows = await self._prefetch_related_models(processed_rows, rows)\n    self.check_single_result_rows_count(processed_rows)\n    return processed_rows[0]  # type: ignore\n</code></pre>"},{"location":"api/#ormar.QuerySet.first_or_none","title":"<code>first_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>If no match is found None will be returned.</p> <p>:raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def first_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    If no match is found None will be returned.\n\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        return await self.first(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n</code></pre>"},{"location":"api/#ormar.QuerySet.get","title":"<code>get(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":  # noqa: CCR001\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).get()\n\n    if not self.filter_clauses:\n        expr = self.build_select_expression(\n            limit=1,\n            order_bys=(\n                [\n                    OrderAction(\n                        order_str=f\"-{self.model.ormar_config.pkname}\",\n                        model_cls=self.model_cls,  # type: ignore\n                    )\n                ]\n                if not any([x.is_source_model_order for x in self.order_bys])\n                else []\n            )\n            + self.order_bys,\n        )\n    else:\n        expr = self.build_select_expression()\n\n    rows = await self.database.fetch_all(expr)\n    processed_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and processed_rows:\n        processed_rows = await self._prefetch_related_models(processed_rows, rows)\n    self.check_single_result_rows_count(processed_rows)\n    return processed_rows[0]  # type: ignore\n</code></pre>"},{"location":"api/#ormar.QuerySet.get_or_create","title":"<code>get_or_create(_defaults=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Combination of create and get methods.</p> <p>Tries to get a row meeting the criteria for kwargs and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :param _defaults: default values for creating object :type _defaults: Optional[Dict[str, Any]] :return: model instance and a boolean :rtype: Tuple(\"T\", bool)</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get_or_create(\n    self,\n    _defaults: Optional[Dict[str, Any]] = None,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Tuple[\"T\", bool]:\n    \"\"\"\n    Combination of create and get methods.\n\n    Tries to get a row meeting the criteria for kwargs\n    and if `NoMatch` exception is raised\n    it creates a new one with given kwargs and _defaults.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :param _defaults: default values for creating object\n    :type _defaults: Optional[Dict[str, Any]]\n    :return: model instance and a boolean\n    :rtype: Tuple(\"T\", bool)\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs), False\n    except NoMatch:\n        _defaults = _defaults or {}\n        return await self.create(**{**kwargs, **_defaults}), True\n</code></pre>"},{"location":"api/#ormar.QuerySet.get_or_none","title":"<code>get_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>If no match is found None will be returned.</p> <p>:raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    If no match is found None will be returned.\n\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n</code></pre>"},{"location":"api/#ormar.QuerySet.iterate","title":"<code>iterate(*args, **kwargs)</code>  <code>async</code>","text":"<p>Return async iterable generator for all rows from a database for given model.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).iterate()</code>.</p> <p>If there are no rows meeting the criteria an empty async generator is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: asynchronous iterable generator of returned models :rtype: AsyncGenerator[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def iterate(  # noqa: A003\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; AsyncGenerator[\"T\", None]:\n    \"\"\"\n    Return async iterable generator for all rows from a database for given model.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).iterate()`.\n\n    If there are no rows meeting the criteria an empty async generator is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: asynchronous iterable generator of returned models\n    :rtype: AsyncGenerator[Model]\n    \"\"\"\n\n    if self._prefetch_related:\n        raise QueryDefinitionError(\n            \"Prefetch related queries are not supported in iterators\"\n        )\n\n    if kwargs or args:\n        async for result in self.filter(*args, **kwargs).iterate():\n            yield result\n        return\n\n    expr = self.build_select_expression()\n\n    rows: list = []\n    last_primary_key = None\n    pk_alias = self.model.get_column_alias(self.model_config.pkname)\n\n    async for row in self.database.iterate(query=expr):\n        current_primary_key = row[pk_alias]\n        if last_primary_key == current_primary_key or last_primary_key is None:\n            last_primary_key = current_primary_key\n            rows.append(row)\n            continue\n\n        yield (await self._process_query_result_rows(rows))[0]\n        last_primary_key = current_primary_key\n        rows = [row]\n\n    if rows:\n        yield (await self._process_query_result_rows(rows))[0]\n</code></pre>"},{"location":"api/#ormar.QuerySet.limit","title":"<code>limit(limit_count, limit_raw_sql=None)</code>","text":"<p>You can limit the results to desired number of parent models.</p> <p>To limit the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <p>:param limit_raw_sql: flag if raw sql should be limited :type limit_raw_sql: bool :param limit_count: number of models to limit :type limit_count: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def limit(\n    self, limit_count: int, limit_raw_sql: Optional[bool] = None\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can limit the results to desired number of parent models.\n\n    To limit the actual number of database query rows instead of number of main\n    models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n    :param limit_raw_sql: flag if raw sql should be limited\n    :type limit_raw_sql: bool\n    :param limit_count: number of models to limit\n    :type limit_count: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n    return self.rebuild_self(limit_count=limit_count, limit_raw_sql=limit_raw_sql)\n</code></pre>"},{"location":"api/#ormar.QuerySet.max","title":"<code>max(columns)</code>  <code>async</code>","text":"<p>Returns max value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: max value of column(s) :rtype: Any</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns max value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: max value of column(s)\n    :rtype: Any\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"max\", columns=columns)\n</code></pre>"},{"location":"api/#ormar.QuerySet.min","title":"<code>min(columns)</code>  <code>async</code>","text":"<p>Returns min value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: min value of column(s) :rtype: Any</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns min value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: min value of column(s)\n    :rtype: Any\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"min\", columns=columns)\n</code></pre>"},{"location":"api/#ormar.QuerySet.offset","title":"<code>offset(offset, limit_raw_sql=None)</code>","text":"<p>You can also offset the results by desired number of main models.</p> <p>To offset the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <p>:param limit_raw_sql: flag if raw sql should be offset :type limit_raw_sql: bool :param offset: numbers of models to offset :type offset: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def offset(\n    self, offset: int, limit_raw_sql: Optional[bool] = None\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can also offset the results by desired number of main models.\n\n    To offset the actual number of database query rows instead of number of main\n    models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n    :param limit_raw_sql: flag if raw sql should be offset\n    :type limit_raw_sql: bool\n    :param offset: numbers of models to offset\n    :type offset: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n    return self.rebuild_self(offset=offset, limit_raw_sql=limit_raw_sql)\n</code></pre>"},{"location":"api/#ormar.QuerySet.order_by","title":"<code>order_by(columns)</code>","text":"<p>With <code>order_by()</code> you can order the results from database based on your choice of fields.</p> <p>You can provide a string with field name or list of strings with fields names.</p> <p>Ordering in sql will be applied in order of names you provide in order_by.</p> <p>By default if you do not provide ordering <code>ormar</code> explicitly orders by all primary keys</p> <p>If you are sorting by nested models that causes that the result rows are unsorted by the main model <code>ormar</code> will combine those children rows into one main model.</p> <p>The main model will never duplicate in the result</p> <p>To order by main model field just provide a field name</p> <p>To sort on nested models separate field names with dunder '__'.</p> <p>You can sort this way across all relation types -&gt; <code>ForeignKey</code>, reverse virtual FK and <code>ManyToMany</code> fields.</p> <p>To sort in descending order provide a hyphen in front of the field name</p> <p>:param columns: columns by which models should be sorted :type columns: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def order_by(self, columns: Union[List, str, OrderAction]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `order_by()` you can order the results from database based on your\n    choice of fields.\n\n    You can provide a string with field name or list of strings with fields names.\n\n    Ordering in sql will be applied in order of names you provide in order_by.\n\n    By default if you do not provide ordering `ormar` explicitly orders by\n    all primary keys\n\n    If you are sorting by nested models that causes that the result rows are\n    unsorted by the main model `ormar` will combine those children rows into\n    one main model.\n\n    The main model will never duplicate in the result\n\n    To order by main model field just provide a field name\n\n    To sort on nested models separate field names with dunder '__'.\n\n    You can sort this way across all relation types -&gt; `ForeignKey`,\n    reverse virtual FK and `ManyToMany` fields.\n\n    To sort in descending order provide a hyphen in front of the field name\n\n    :param columns: columns by which models should be sorted\n    :type columns: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n\n    orders_by = [\n        (\n            OrderAction(order_str=x, model_cls=self.model_cls)  # type: ignore\n            if not isinstance(x, OrderAction)\n            else x\n        )\n        for x in columns\n    ]\n\n    order_bys = self.order_bys + [x for x in orders_by if x not in self.order_bys]\n    return self.rebuild_self(order_bys=order_bys)\n</code></pre>"},{"location":"api/#ormar.QuerySet.paginate","title":"<code>paginate(page, page_size=20)</code>","text":"<p>You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size.</p> <p>:param page_size: numbers of items per page :type page_size: int :param page: page number :type page: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can paginate the result which is a combination of offset and limit clauses.\n    Limit is set to page size and offset is set to (page-1) * page_size.\n\n    :param page_size: numbers of items per page\n    :type page_size: int\n    :param page: page number\n    :type page: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if page &lt; 1 or page_size &lt; 1:\n        raise QueryDefinitionError(\"Page size and page have to be greater than 0.\")\n\n    limit_count = page_size\n    query_offset = (page - 1) * page_size\n    return self.rebuild_self(limit_count=limit_count, offset=query_offset)\n</code></pre>"},{"location":"api/#ormar.QuerySet.prefetch_related","title":"<code>prefetch_related(related)</code>","text":"<p>Allows to prefetch related models during query - but opposite to <code>select_related</code> each subsequent model is fetched in a separate database query.</p> <p>With <code>prefetch_related</code> always one query per Model is run against the database, meaning that you will have multiple queries executed one after another.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def prefetch_related(\n    self, related: Union[List, str, FieldAccessor]\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows to prefetch related models during query - but opposite to\n    `select_related` each subsequent model is fetched in a separate database query.\n\n    **With `prefetch_related` always one query per Model is run against the\n    database**, meaning that you will have multiple queries executed one\n    after another.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(related, list):\n        related = [related]\n    related = [\n        rel._access_chain if isinstance(rel, FieldAccessor) else rel\n        for rel in related\n    ]\n\n    related = list(set(list(self._prefetch_related) + related))\n    return self.rebuild_self(prefetch_related=related)\n</code></pre>"},{"location":"api/#ormar.QuerySet.rebuild_self","title":"<code>rebuild_self(filter_clauses=None, exclude_clauses=None, select_related=None, limit_count=None, offset=None, excludable=None, order_bys=None, prefetch_related=None, limit_raw_sql=None, proxy_source_model=None)</code>","text":"<p>Method that returns new instance of queryset based on passed params, all not passed params are taken from current values.</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def rebuild_self(  # noqa: CFQ002\n    self,\n    filter_clauses: Optional[List] = None,\n    exclude_clauses: Optional[List] = None,\n    select_related: Optional[List] = None,\n    limit_count: Optional[int] = None,\n    offset: Optional[int] = None,\n    excludable: Optional[\"ExcludableItems\"] = None,\n    order_bys: Optional[List] = None,\n    prefetch_related: Optional[List] = None,\n    limit_raw_sql: Optional[bool] = None,\n    proxy_source_model: Optional[Type[\"Model\"]] = None,\n) -&gt; \"QuerySet\":\n    \"\"\"\n    Method that returns new instance of queryset based on passed params,\n    all not passed params are taken from current values.\n    \"\"\"\n    overwrites = {\n        \"select_related\": \"_select_related\",\n        \"offset\": \"query_offset\",\n        \"excludable\": \"_excludable\",\n        \"prefetch_related\": \"_prefetch_related\",\n        \"limit_raw_sql\": \"limit_sql_raw\",\n    }\n    passed_args = locals()\n\n    def replace_if_none(arg_name: str) -&gt; Any:\n        if passed_args.get(arg_name) is None:\n            return getattr(self, overwrites.get(arg_name, arg_name))\n        return passed_args.get(arg_name)\n\n    return self.__class__(\n        model_cls=self.model_cls,\n        filter_clauses=replace_if_none(\"filter_clauses\"),\n        exclude_clauses=replace_if_none(\"exclude_clauses\"),\n        select_related=replace_if_none(\"select_related\"),\n        limit_count=replace_if_none(\"limit_count\"),\n        offset=replace_if_none(\"offset\"),\n        excludable=replace_if_none(\"excludable\"),\n        order_bys=replace_if_none(\"order_bys\"),\n        prefetch_related=replace_if_none(\"prefetch_related\"),\n        limit_raw_sql=replace_if_none(\"limit_raw_sql\"),\n        proxy_source_model=replace_if_none(\"proxy_source_model\"),\n    )\n</code></pre>"},{"location":"api/#ormar.QuerySet.select_all","title":"<code>select_all(follow=False)</code>","text":"<p>By default adds only directly related models.</p> <p>If follow=True is set it adds also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def select_all(self, follow: bool = False) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    By default adds only directly related models.\n\n    If follow=True is set it adds also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    relations = list(self.model.extract_related_names())\n    if follow:\n        relations = self.model._iterate_related_models()\n    return self.rebuild_self(select_related=relations)\n</code></pre>"},{"location":"api/#ormar.QuerySet.select_related","title":"<code>select_related(related)</code>","text":"<p>Allows to prefetch related models during the same query.</p> <p>With <code>select_related</code> always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def select_related(self, related: Union[List, str, FieldAccessor]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows to prefetch related models during the same query.\n\n    **With `select_related` always only one query is run against the database**,\n    meaning that one (sometimes complicated) join is generated and later nested\n    models are processed in python.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(related, list):\n        related = [related]\n    related = [\n        rel._access_chain if isinstance(rel, FieldAccessor) else rel\n        for rel in related\n    ]\n\n    related = sorted(list(set(list(self._select_related) + related)))\n    return self.rebuild_self(select_related=related)\n</code></pre>"},{"location":"api/#ormar.QuerySet.sum","title":"<code>sum(columns)</code>  <code>async</code>","text":"<p>Returns sum value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: sum value of columns :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns sum value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: sum value of columns\n    :rtype: int\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"sum\", columns=columns)\n</code></pre>"},{"location":"api/#ormar.QuerySet.update","title":"<code>update(each=False, **kwargs)</code>  <code>async</code>","text":"<p>Updates the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of updated rows :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Updates the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of updated rows\n    :rtype: int\n    \"\"\"\n    if not each and not (self.filter_clauses or self.exclude_clauses):\n        raise QueryDefinitionError(\n            \"You cannot update without filtering the queryset first. \"\n            \"If you want to update all rows use update(each=True, **kwargs)\"\n        )\n\n    self_fields = self.model.extract_db_own_fields().union(\n        self.model.extract_related_names()\n    )\n    updates = {k: v for k, v in kwargs.items() if k in self_fields}\n    updates = self.model.validate_enums(updates)\n    updates = self.model.translate_columns_to_aliases(updates)\n\n    expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n        self.table.update().values(**updates)\n    )\n    expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n        expr\n    )\n    return await self.database.execute(expr)\n</code></pre>"},{"location":"api/#ormar.QuerySet.update_or_create","title":"<code>update_or_create(**kwargs)</code>  <code>async</code>","text":"<p>Updates the model, or in case there is no match in database creates a new one.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: updated or created model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Updates the model, or in case there is no match in database creates a new one.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: updated or created model\n    :rtype: Model\n    \"\"\"\n    pk_name = self.model_config.pkname\n    if \"pk\" in kwargs:\n        kwargs[pk_name] = kwargs.pop(\"pk\")\n    if pk_name not in kwargs or kwargs.get(pk_name) is None:\n        return await self.create(**kwargs)\n    model = await self.get(pk=kwargs[pk_name])\n    return await model.update(**kwargs)\n</code></pre>"},{"location":"api/#ormar.QuerySet.values","title":"<code>values(fields=None, exclude_through=False, _as_dict=True, _flatten=False)</code>  <code>async</code>","text":"<p>Return a list of dictionaries with column values in order of the fields passed or all fields from queried models.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param _flatten: internal parameter to flatten one element tuples :type _flatten: bool :param _as_dict: internal parameter if return dict or tuples :type _as_dict: bool :param fields: field name or list of field names to extract from db :type fields:  Union[List, str, Set, Dict]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def values(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    exclude_through: bool = False,\n    _as_dict: bool = True,\n    _flatten: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of dictionaries with column values in order of the fields\n    passed or all fields from queried models.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param _flatten: internal parameter to flatten one element tuples\n    :type _flatten: bool\n    :param _as_dict: internal parameter if return dict or tuples\n    :type _as_dict: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields:  Union[List, str, Set, Dict]\n    \"\"\"\n    if fields:\n        return await self.fields(columns=fields).values(\n            _as_dict=_as_dict, _flatten=_flatten, exclude_through=exclude_through\n        )\n    expr = self.build_select_expression()\n    rows = await self.database.fetch_all(expr)\n    if not rows:\n        return []\n    alias_resolver = ReverseAliasResolver(\n        select_related=self._select_related,\n        excludable=self._excludable,\n        model_cls=self.model_cls,  # type: ignore\n        exclude_through=exclude_through,\n    )\n    column_map = alias_resolver.resolve_columns(\n        columns_names=list(cast(LegacyRow, rows[0]).keys())\n    )\n    result = [\n        {column_map.get(k): v for k, v in dict(x).items() if k in column_map}\n        for x in rows\n    ]\n    if _as_dict:\n        return result\n    if _flatten and self._excludable.include_entry_count() != 1:\n        raise QueryDefinitionError(\n            \"You cannot flatten values_list if more than one field is selected!\"\n        )\n    tuple_result = [tuple(x.values()) for x in result]\n    return tuple_result if not _flatten else [x[0] for x in tuple_result]\n</code></pre>"},{"location":"api/#ormar.QuerySet.values_list","title":"<code>values_list(fields=None, flatten=False, exclude_through=False)</code>  <code>async</code>","text":"<p>Return a list of tuples with column values in order of the fields passed or all fields from queried models.</p> <p>When one field is passed you can flatten the list of tuples into list of values of that single field.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param fields: field name or list of field names to extract from db :type fields: Union[str, List[str]] :param flatten: when one field is passed you can flatten the list of tuples :type flatten: bool</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def values_list(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    flatten: bool = False,\n    exclude_through: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of tuples with column values in order of the fields passed or\n    all fields from queried models.\n\n    When one field is passed you can flatten the list of tuples into list of values\n    of that single field.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields: Union[str, List[str]]\n    :param flatten: when one field is passed you can flatten the list of tuples\n    :type flatten: bool\n    \"\"\"\n    return await self.values(\n        fields=fields,\n        exclude_through=exclude_through,\n        _as_dict=False,\n        _flatten=flatten,\n    )\n</code></pre>"},{"location":"api/#ormar.ReferentialAction","title":"<code>ReferentialAction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Because the database management system(DBMS) enforces referential constraints, it must ensure data integrity if rows in a referenced table are to be deleted (or updated).</p> <p>If dependent rows in referencing tables still exist, those references have to be considered.</p> <p>SQL specifies 5 different referential actions that shall take place in such occurrences.</p> Source code in <code>ormar/fields/referential_actions.py</code> <pre><code>class ReferentialAction(Enum):\n    \"\"\"\n    Because the database management system(DBMS) enforces referential constraints,\n    it must ensure data integrity\n    if rows in a referenced table are to be deleted (or updated).\n\n    If dependent rows in referencing tables still exist,\n    those references have to be considered.\n\n    SQL specifies 5 different referential actions\n    that shall take place in such occurrences.\n    \"\"\"\n\n    CASCADE: str = \"CASCADE\"\n    RESTRICT: str = \"RESTRICT\"\n    SET_NULL: str = \"SET NULL\"\n    SET_DEFAULT: str = \"SET DEFAULT\"\n    DO_NOTHING: str = \"NO ACTION\"\n</code></pre>"},{"location":"api/#ormar.RelationType","title":"<code>RelationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of relations supported by ormar:</p> <ul> <li>ForeignKey = PRIMARY</li> <li>reverse ForeignKey = REVERSE</li> <li>ManyToMany = MULTIPLE</li> </ul> Source code in <code>ormar/relations/relation.py</code> <pre><code>class RelationType(Enum):\n    \"\"\"\n    Different types of relations supported by ormar:\n\n    *  ForeignKey = PRIMARY\n    *  reverse ForeignKey = REVERSE\n    *  ManyToMany = MULTIPLE\n    \"\"\"\n\n    PRIMARY = 1\n    REVERSE = 2\n    MULTIPLE = 3\n    THROUGH = 4\n</code></pre>"},{"location":"api/#ormar.Signal","title":"<code>Signal</code>","text":"<p>Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals.</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>class Signal:\n    \"\"\"\n    Signal that notifies all receiver functions.\n    In ormar used by models to send pre_save, post_save etc. signals.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._receivers: Dict[Union[int, Tuple[int, int]], Callable] = {}\n\n    def connect(self, receiver: Callable) -&gt; None:\n        \"\"\"\n        Connects given receiver function to the signal.\n\n        :raises SignalDefinitionError: if receiver is not callable\n        or not accept **kwargs\n        :param receiver: receiver function\n        :type receiver: Callable\n        \"\"\"\n        if not callable(receiver):\n            raise SignalDefinitionError(\"Signal receivers must be callable.\")\n        if not callable_accepts_kwargs(receiver):\n            raise SignalDefinitionError(\n                \"Signal receivers must accept **kwargs argument.\"\n            )\n        new_receiver_key = make_id(receiver)\n        if new_receiver_key not in self._receivers:\n            self._receivers[new_receiver_key] = receiver\n\n    def disconnect(self, receiver: Callable) -&gt; bool:\n        \"\"\"\n        Removes the receiver function from the signal.\n\n        :param receiver: receiver function\n        :type receiver: Callable\n        :return: flag if receiver was removed\n        :rtype: bool\n        \"\"\"\n        new_receiver_key = make_id(receiver)\n        receiver_func: Union[Callable, None] = self._receivers.pop(\n            new_receiver_key, None\n        )\n        return True if receiver_func is not None else False\n\n    async def send(self, sender: Type[\"Model\"], **kwargs: Any) -&gt; None:\n        \"\"\"\n        Notifies all receiver functions with given kwargs\n        :param sender: model that sends the signal\n        :type sender: Type[\"Model\"]\n        :param kwargs: arguments passed to receivers\n        :type kwargs: Any\n        \"\"\"\n        receivers = [\n            receiver_func(sender=sender, **kwargs)\n            for receiver_func in self._receivers.values()\n        ]\n        await asyncio.gather(*receivers)\n</code></pre>"},{"location":"api/#ormar.Signal.connect","title":"<code>connect(receiver)</code>","text":"<p>Connects given receiver function to the signal.</p> <p>:raises SignalDefinitionError: if receiver is not callable or not accept **kwargs :param receiver: receiver function :type receiver: Callable</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def connect(self, receiver: Callable) -&gt; None:\n    \"\"\"\n    Connects given receiver function to the signal.\n\n    :raises SignalDefinitionError: if receiver is not callable\n    or not accept **kwargs\n    :param receiver: receiver function\n    :type receiver: Callable\n    \"\"\"\n    if not callable(receiver):\n        raise SignalDefinitionError(\"Signal receivers must be callable.\")\n    if not callable_accepts_kwargs(receiver):\n        raise SignalDefinitionError(\n            \"Signal receivers must accept **kwargs argument.\"\n        )\n    new_receiver_key = make_id(receiver)\n    if new_receiver_key not in self._receivers:\n        self._receivers[new_receiver_key] = receiver\n</code></pre>"},{"location":"api/#ormar.Signal.disconnect","title":"<code>disconnect(receiver)</code>","text":"<p>Removes the receiver function from the signal.</p> <p>:param receiver: receiver function :type receiver: Callable :return: flag if receiver was removed :rtype: bool</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def disconnect(self, receiver: Callable) -&gt; bool:\n    \"\"\"\n    Removes the receiver function from the signal.\n\n    :param receiver: receiver function\n    :type receiver: Callable\n    :return: flag if receiver was removed\n    :rtype: bool\n    \"\"\"\n    new_receiver_key = make_id(receiver)\n    receiver_func: Union[Callable, None] = self._receivers.pop(\n        new_receiver_key, None\n    )\n    return True if receiver_func is not None else False\n</code></pre>"},{"location":"api/#ormar.Signal.send","title":"<code>send(sender, **kwargs)</code>  <code>async</code>","text":"<p>Notifies all receiver functions with given kwargs :param sender: model that sends the signal :type sender: Type[\"Model\"] :param kwargs: arguments passed to receivers :type kwargs: Any</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>async def send(self, sender: Type[\"Model\"], **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notifies all receiver functions with given kwargs\n    :param sender: model that sends the signal\n    :type sender: Type[\"Model\"]\n    :param kwargs: arguments passed to receivers\n    :type kwargs: Any\n    \"\"\"\n    receivers = [\n        receiver_func(sender=sender, **kwargs)\n        for receiver_func in self._receivers.values()\n    ]\n    await asyncio.gather(*receivers)\n</code></pre>"},{"location":"api/#ormar.SmallInteger","title":"<code>SmallInteger</code>","text":"<p>               Bases: <code>Integer</code>, <code>int</code></p> <p>SmallInteger field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class SmallInteger(Integer, int):\n    \"\"\"\n    SmallInteger field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.SmallInteger()\n</code></pre>"},{"location":"api/#ormar.SmallInteger.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.SmallInteger()\n</code></pre>"},{"location":"api/#ormar.String","title":"<code>String</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>str</code></p> <p>String field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class String(ModelFieldFactory, str):\n    \"\"\"\n    String field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = str\n    _sample = \"string\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        max_length: int,\n        min_length: Optional[int] = None,\n        regex: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.String(length=kwargs.get(\"max_length\"))\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        max_length = kwargs.get(\"max_length\", None)\n        if max_length &lt;= 0:\n            raise ModelDefinitionError(\n                \"Parameter max_length is required for field String\"\n            )\n</code></pre>"},{"location":"api/#ormar.String.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.String(length=kwargs.get(\"max_length\"))\n</code></pre>"},{"location":"api/#ormar.String.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    max_length = kwargs.get(\"max_length\", None)\n    if max_length &lt;= 0:\n        raise ModelDefinitionError(\n            \"Parameter max_length is required for field String\"\n        )\n</code></pre>"},{"location":"api/#ormar.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>str</code></p> <p>Text field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Text(ModelFieldFactory, str):\n    \"\"\"\n    Text field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = str\n    _sample = \"text\"\n\n    def __new__(cls, **kwargs: Any) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Text()\n</code></pre>"},{"location":"api/#ormar.Text.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Text()\n</code></pre>"},{"location":"api/#ormar.Time","title":"<code>Time</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>time</code></p> <p>Time field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Time(ModelFieldFactory, datetime.time):\n    \"\"\"\n    Time field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.time\n    _sample = \"time\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, timezone: bool = False, **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Time(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/#ormar.Time.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Time(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/#ormar.UUID","title":"<code>UUID</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>UUID</code></p> <p>UUID field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class UUID(ModelFieldFactory, uuid.UUID):\n    \"\"\"\n    UUID field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = uuid.UUID\n    _sample = \"uuid\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, uuid_format: str = \"hex\", **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        uuid_format = kwargs.get(\"uuid_format\", \"hex\")\n        return sqlalchemy_uuid.UUID(uuid_format=uuid_format)\n</code></pre>"},{"location":"api/#ormar.UUID.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    uuid_format = kwargs.get(\"uuid_format\", \"hex\")\n    return sqlalchemy_uuid.UUID(uuid_format=uuid_format)\n</code></pre>"},{"location":"api/#ormar.UniqueColumns","title":"<code>UniqueColumns</code>","text":"<p>               Bases: <code>UniqueConstraint</code></p> <p>Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user.</p> Source code in <code>ormar/fields/constraints.py</code> <pre><code>class UniqueColumns(UniqueConstraint):\n    \"\"\"\n    Subclass of sqlalchemy.UniqueConstraint.\n    Used to avoid importing anything from sqlalchemy by user.\n    \"\"\"\n</code></pre>"},{"location":"api/#ormar.ForeignKey","title":"<code>ForeignKey(to, *, name=None, unique=False, nullable=True, related_name=None, virtual=False, onupdate=None, ondelete=None, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)).</p> <p>Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param name: name of the database field - later called alias :type name: str :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool :param nullable: marks field as optional/ required :type nullable: bool :param related_name: name of reversed FK relation populated for you on to model :type related_name: str :param virtual: marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool :param onupdate: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: Union[ReferentialAction, str] :param ondelete: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: Union[ReferentialAction, str] :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def ForeignKey(  # type: ignore # noqa CFQ002\n    to: Union[Type[\"T\"], \"ForwardRef\"],\n    *,\n    name: Optional[str] = None,\n    unique: bool = False,\n    nullable: bool = True,\n    related_name: Optional[str] = None,\n    virtual: bool = False,\n    onupdate: Union[ReferentialAction, str, None] = None,\n    ondelete: Union[ReferentialAction, str, None] = None,\n    **kwargs: Any,\n) -&gt; \"T\":\n    \"\"\"\n    Despite a name it's a function that returns constructed ForeignKeyField.\n    This function is actually used in model declaration (as ormar.ForeignKey(ToModel)).\n\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag\n    :type unique: bool\n    :param nullable: marks field as optional/ required\n    :type nullable: bool\n    :param related_name: name of reversed FK relation populated for you on to model\n    :type related_name: str\n    :param virtual: marks if relation is virtual.\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :type virtual: bool\n    :param onupdate: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on update of parent (the one where FK is defined) model.\n    :type onupdate: Union[ReferentialAction, str]\n    :param ondelete: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on delete of parent (the one where FK is defined) model.\n    :type ondelete: Union[ReferentialAction, str]\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ForeignKeyField with relation to selected model\n    :rtype: ForeignKeyField\n    \"\"\"\n\n    onupdate = validate_referential_action(action=onupdate)\n    ondelete = validate_referential_action(action=ondelete)\n\n    owner = kwargs.pop(\"owner\", None)\n    self_reference = kwargs.pop(\"self_reference\", False)\n\n    orders_by = kwargs.pop(\"orders_by\", None)\n    related_orders_by = kwargs.pop(\"related_orders_by\", None)\n\n    skip_reverse = kwargs.pop(\"skip_reverse\", False)\n    skip_field = kwargs.pop(\"skip_field\", False)\n\n    sql_nullable = kwargs.pop(\"sql_nullable\", None)\n    sql_nullable = nullable if sql_nullable is None else sql_nullable\n\n    index = kwargs.pop(\"index\", False)\n\n    validate_not_allowed_fields(kwargs)\n    pk_only_model = None\n    if to.__class__ == ForwardRef:\n        __type__ = to if not nullable else Optional[to]\n        constraints: List = []\n        column_type = None\n    else:\n        (\n            __type__,\n            constraints,\n            column_type,\n            pk_only_model,\n        ) = populate_fk_params_based_on_to_model(\n            to=to,  # type: ignore\n            nullable=nullable,\n            ondelete=ondelete,\n            onupdate=onupdate,\n        )\n\n    namespace = dict(\n        __type__=__type__,\n        to=to,\n        to_pk_only=pk_only_model,\n        through=None,\n        alias=name,\n        name=kwargs.pop(\"real_name\", None),\n        nullable=nullable,\n        sql_nullable=sql_nullable,\n        constraints=constraints,\n        unique=unique,\n        column_type=column_type,\n        related_name=related_name,\n        virtual=virtual,\n        primary_key=False,\n        index=index,\n        default=None,\n        server_default=None,\n        onupdate=onupdate,\n        ondelete=ondelete,\n        owner=owner,\n        self_reference=self_reference,\n        is_relation=True,\n        orders_by=orders_by,\n        related_orders_by=related_orders_by,\n        skip_reverse=skip_reverse,\n        skip_field=skip_field,\n    )\n\n    Field = type(\"ForeignKey\", (ForeignKeyField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/#ormar.ManyToMany","title":"<code>ManyToMany(to, through=None, *, name=None, unique=False, virtual=False, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)).</p> <p>Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param through: through model for m2m relation :type through: Model class :param name: name of the database field - later called alias :type name: str :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool :param virtual: marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ManyToManyField with m2m relation to selected model :rtype: ManyToManyField</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def ManyToMany(  # type: ignore\n    to: Union[Type[\"T\"], \"ForwardRef\"],\n    through: Optional[Union[Type[\"T\"], \"ForwardRef\"]] = None,\n    *,\n    name: Optional[str] = None,\n    unique: bool = False,\n    virtual: bool = False,\n    **kwargs: Any,\n) -&gt; \"RelationProxy[T]\":\n    \"\"\"\n    Despite a name it's a function that returns constructed ManyToManyField.\n    This function is actually used in model declaration\n    (as ormar.ManyToMany(ToModel, through=ThroughModel)).\n\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param through: through model for m2m relation\n    :type through: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag\n    :type unique: bool\n    :param virtual: marks if relation is virtual.\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :type virtual: bool\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ManyToManyField with m2m relation to selected model\n    :rtype: ManyToManyField\n    \"\"\"\n    related_name = kwargs.pop(\"related_name\", None)\n    nullable = kwargs.pop(\"nullable\", True)\n\n    owner = kwargs.pop(\"owner\", None)\n    self_reference = kwargs.pop(\"self_reference\", False)\n\n    orders_by = kwargs.pop(\"orders_by\", None)\n    related_orders_by = kwargs.pop(\"related_orders_by\", None)\n\n    skip_reverse = kwargs.pop(\"skip_reverse\", False)\n    skip_field = kwargs.pop(\"skip_field\", False)\n\n    through_relation_name = kwargs.pop(\"through_relation_name\", None)\n    through_reverse_relation_name = kwargs.pop(\"through_reverse_relation_name\", None)\n\n    if through is not None and through.__class__ != ForwardRef:\n        forbid_through_relations(cast(Type[\"Model\"], through))\n\n    validate_not_allowed_fields(kwargs)\n    pk_only_model = None\n    if to.__class__ == ForwardRef:\n        __type__ = (\n            Union[to, List[to]]  # type: ignore\n            if not nullable\n            else Optional[Union[to, List[to]]]  # type: ignore\n        )\n        column_type = None\n    else:\n        __type__, column_type, pk_only_model = populate_m2m_params_based_on_to_model(\n            to=to, nullable=nullable  # type: ignore\n        )\n    namespace = dict(\n        __type__=__type__,\n        to=to,\n        to_pk_only=pk_only_model,\n        through=through,\n        alias=name,\n        name=name,\n        nullable=nullable,\n        unique=unique,\n        column_type=column_type,\n        related_name=related_name,\n        virtual=virtual,\n        primary_key=False,\n        index=False,\n        default=None,\n        server_default=None,\n        owner=owner,\n        self_reference=self_reference,\n        is_relation=True,\n        is_multi=True,\n        orders_by=orders_by,\n        related_orders_by=related_orders_by,\n        skip_reverse=skip_reverse,\n        skip_field=skip_field,\n        through_relation_name=through_relation_name,\n        through_reverse_relation_name=through_reverse_relation_name,\n    )\n\n    Field = type(\"ManyToMany\", (ManyToManyField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/#ormar.and_","title":"<code>and_(*args, **kwargs)</code>","text":"<p>Construct and filter from nested groups and keyword arguments</p> <p>:param args: nested filter groups :type args: Tuple[FilterGroup] :param kwargs: fields names and proper value types :type kwargs: Any :return: FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def and_(*args: FilterGroup, **kwargs: Any) -&gt; FilterGroup:\n    \"\"\"\n    Construct and filter from nested groups and keyword arguments\n\n    :param args: nested filter groups\n    :type args: Tuple[FilterGroup]\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: FilterGroup ready to be resolved\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return FilterGroup(_filter_type=FilterType.AND, *args, **kwargs)\n</code></pre>"},{"location":"api/#ormar.or_","title":"<code>or_(*args, **kwargs)</code>","text":"<p>Construct or filter from nested groups and keyword arguments</p> <p>:param args: nested filter groups :type args: Tuple[FilterGroup] :param kwargs: fields names and proper value types :type kwargs: Any :return: FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def or_(*args: FilterGroup, **kwargs: Any) -&gt; FilterGroup:\n    \"\"\"\n    Construct or filter from nested groups and keyword arguments\n\n    :param args: nested filter groups\n    :type args: Tuple[FilterGroup]\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: FilterGroup ready to be resolved\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return FilterGroup(_filter_type=FilterType.OR, *args, **kwargs)\n</code></pre>"},{"location":"api/#ormar.post_bulk_update","title":"<code>post_bulk_update(senders)</code>","text":"<p>Connect given function to all senders for post_bulk_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_bulk_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_bulk_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_bulk_update\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.post_delete","title":"<code>post_delete(senders)</code>","text":"<p>Connect given function to all senders for post_delete signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_delete(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_delete signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_delete\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.post_relation_add","title":"<code>post_relation_add(senders)</code>","text":"<p>Connect given function to all senders for post_relation_add signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_relation_add(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_relation_add signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_relation_add\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.post_relation_remove","title":"<code>post_relation_remove(senders)</code>","text":"<p>Connect given function to all senders for post_relation_remove signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_relation_remove(\n    senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_relation_remove signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_relation_remove\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.post_save","title":"<code>post_save(senders)</code>","text":"<p>Connect given function to all senders for post_save signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_save(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_save signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_save\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.post_update","title":"<code>post_update(senders)</code>","text":"<p>Connect given function to all senders for post_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_update\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.pre_delete","title":"<code>pre_delete(senders)</code>","text":"<p>Connect given function to all senders for pre_delete signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_delete(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_delete signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_delete\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.pre_relation_add","title":"<code>pre_relation_add(senders)</code>","text":"<p>Connect given function to all senders for pre_relation_add signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_relation_add(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_relation_add signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_relation_add\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.pre_relation_remove","title":"<code>pre_relation_remove(senders)</code>","text":"<p>Connect given function to all senders for pre_relation_remove signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_relation_remove(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_relation_remove signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_relation_remove\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.pre_save","title":"<code>pre_save(senders)</code>","text":"<p>Connect given function to all senders for pre_save signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_save(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_save signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_save\", senders=senders)\n</code></pre>"},{"location":"api/#ormar.pre_update","title":"<code>pre_update(senders)</code>","text":"<p>Connect given function to all senders for pre_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_update\", senders=senders)\n</code></pre>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li>ormar<ul> <li>decorators<ul> <li>signals</li> </ul> </li> <li>exceptions</li> <li>fields<ul> <li>base</li> <li>constraints</li> <li>foreign_key</li> <li>many_to_many</li> <li>model_fields</li> <li>parsers</li> <li>referential_actions</li> <li>sqlalchemy_encrypted</li> <li>sqlalchemy_uuid</li> <li>through_field</li> </ul> </li> <li>models<ul> <li>descriptors<ul> <li>descriptors</li> </ul> </li> <li>excludable</li> <li>helpers<ul> <li>models</li> <li>pydantic</li> <li>related_names_validation</li> <li>relations</li> <li>sqlalchemy</li> <li>validation</li> </ul> </li> <li>metaclass</li> <li>mixins<ul> <li>alias_mixin</li> <li>excludable_mixin</li> <li>merge_mixin</li> <li>pydantic_mixin</li> <li>relation_mixin</li> <li>save_mixin</li> </ul> </li> <li>model</li> <li>model_row</li> <li>modelproxy</li> <li>newbasemodel</li> <li>ormar_config</li> <li>quick_access_views</li> <li>traversible</li> <li>utils</li> </ul> </li> <li>protocols<ul> <li>queryset_protocol</li> <li>relation_protocol</li> </ul> </li> <li>queryset<ul> <li>actions<ul> <li>filter_action</li> <li>order_action</li> <li>query_action</li> <li>select_action</li> </ul> </li> <li>clause</li> <li>field_accessor</li> <li>join</li> <li>queries<ul> <li>filter_query</li> <li>limit_query</li> <li>offset_query</li> <li>order_query</li> <li>prefetch_query</li> <li>query</li> </ul> </li> <li>queryset</li> <li>reverse_alias_resolver</li> <li>utils</li> </ul> </li> <li>relations<ul> <li>alias_manager</li> <li>querysetproxy</li> <li>relation</li> <li>relation_manager</li> <li>relation_proxy</li> <li>utils</li> </ul> </li> <li>signals<ul> <li>signal</li> </ul> </li> <li>warnings</li> </ul> </li> </ul>"},{"location":"api/exceptions/","title":"exceptions","text":"<p>Gathers all exceptions thrown by ormar.</p>"},{"location":"api/exceptions/#ormar.exceptions.AsyncOrmException","title":"<code>AsyncOrmException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base ormar Exception</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class AsyncOrmException(Exception):\n    \"\"\"\n    Base ormar Exception\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.ModelDefinitionError","title":"<code>ModelDefinitionError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for errors related to the model definition itself:</p> <ul> <li>defining a Field without required parameters</li> <li>defining a model with more than one primary_key</li> <li>defining a model without primary_key</li> </ul> Source code in <code>ormar/exceptions.py</code> <pre><code>class ModelDefinitionError(AsyncOrmException):\n    \"\"\"\n    Raised for errors related to the model definition itself:\n\n    * defining a Field without required parameters\n    * defining a model with more than one primary_key\n    * defining a model without primary_key\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.ModelError","title":"<code>ModelError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for initialization of model with non-existing field keyword.</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class ModelError(AsyncOrmException):\n    \"\"\"\n    Raised for initialization of model with non-existing field keyword.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.ModelListEmptyError","title":"<code>ModelListEmptyError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for objects is empty when bulk_update</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class ModelListEmptyError(AsyncOrmException):\n    \"\"\"\n    Raised for objects is empty when bulk_update\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.ModelPersistenceError","title":"<code>ModelPersistenceError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for update of models without primary_key set (cannot retrieve from db) or for saving a model with relation to unsaved model (cannot extract fk value).</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class ModelPersistenceError(AsyncOrmException):\n    \"\"\"\n    Raised for update of models without primary_key set (cannot retrieve from db)\n    or for saving a model with relation to unsaved model (cannot extract fk value).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.MultipleMatches","title":"<code>MultipleMatches</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for database queries that should return one row (i.e. get, first etc.) but has multiple matching results in response.</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class MultipleMatches(AsyncOrmException):\n    \"\"\"\n    Raised for database queries that should return one row (i.e. get, first etc.)\n    but has multiple matching results in response.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.NoMatch","title":"<code>NoMatch</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for database queries that has no matching result (empty result).</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class NoMatch(AsyncOrmException):\n    \"\"\"\n    Raised for database queries that has no matching result (empty result).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.QueryDefinitionError","title":"<code>QueryDefinitionError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised for errors in query definition:</p> <ul> <li>using contains or icontains filter with instance of the Model</li> <li>using Queryset.update() without filter and setting each flag to True</li> <li>using Queryset.delete() without filter and setting each flag to True</li> </ul> Source code in <code>ormar/exceptions.py</code> <pre><code>class QueryDefinitionError(AsyncOrmException):\n    \"\"\"\n    Raised for errors in query definition:\n\n    * using contains or icontains filter with instance of the Model\n    * using Queryset.update() without filter and setting each flag to True\n    * using Queryset.delete() without filter and setting each flag to True\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#ormar.exceptions.SignalDefinitionError","title":"<code>SignalDefinitionError</code>","text":"<p>               Bases: <code>AsyncOrmException</code></p> <p>Raised when non callable receiver is passed as signal callback.</p> Source code in <code>ormar/exceptions.py</code> <pre><code>class SignalDefinitionError(AsyncOrmException):\n    \"\"\"\n    Raised when non callable receiver is passed as signal callback.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/warnings/","title":"warnings","text":""},{"location":"api/warnings/#ormar.warnings.OrmarDeprecatedSince020","title":"<code>OrmarDeprecatedSince020</code>","text":"<p>               Bases: <code>OrmarDeprecationWarning</code></p> <p>A specific <code>OrmarDeprecationWarning</code> subclass defining functionality deprecated since Ormar 0.20.</p> Source code in <code>ormar/warnings.py</code> <pre><code>class OrmarDeprecatedSince020(OrmarDeprecationWarning):\n    \"\"\"A specific `OrmarDeprecationWarning` subclass defining\n    functionality deprecated since Ormar 0.20.\"\"\"\n\n    def __init__(self, message: str, *args: object) -&gt; None:  # pragma: no cover\n        super().__init__(message, *args, since=(0, 20), expected_removal=(0, 30))\n</code></pre>"},{"location":"api/warnings/#ormar.warnings.OrmarDeprecationWarning","title":"<code>OrmarDeprecationWarning</code>","text":"<p>               Bases: <code>DeprecationWarning</code></p> <p>A Pydantic specific deprecation warning.</p> <p>This warning is raised when using deprecated functionality in Ormar. It provides information on when the deprecation was introduced and the expected version in which the corresponding functionality will be removed.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Description of the warning</p> <code>since</code> <code>Tuple[int, int]</code> <p>Ormar version in what the deprecation was introduced</p> <code>expected_removal</code> <code>Tuple[int, int]</code> <p>Ormar version in what the functionality will be removed</p> Source code in <code>ormar/warnings.py</code> <pre><code>class OrmarDeprecationWarning(DeprecationWarning):\n    \"\"\"A Pydantic specific deprecation warning.\n\n    This warning is raised when using deprecated functionality in Ormar.\n    It provides information on when the deprecation was introduced and\n    the expected version in which the corresponding functionality will be removed.\n\n    Attributes:\n        message: Description of the warning\n        since: Ormar version in what the deprecation was introduced\n        expected_removal: Ormar version in what the functionality will be removed\n    \"\"\"\n\n    message: str\n    since: Tuple[int, int]\n    expected_removal: Tuple[int, int]\n\n    def __init__(\n        self,\n        message: str,\n        *args: object,\n        since: Tuple[int, int],\n        expected_removal: Optional[Tuple[int, int]] = None,\n    ) -&gt; None:  # pragma: no cover\n        super().__init__(message, *args)\n        self.message = message.rstrip(\".\")\n        self.since = since\n        self.expected_removal = (\n            expected_removal if expected_removal is not None else (since[0] + 1, 0)\n        )\n\n    def __str__(self) -&gt; str:  # pragma: no cover\n        message = (\n            f\"{self.message}. Deprecated in Ormar V{self.since[0]}.{self.since[1]}\"\n            f\" to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.\"\n        )\n        if self.since == (0, 20):\n            message += \" See Ormar V0.20 Migration Guide at https://collerek.github.io/ormar/migration/\"\n        return message\n</code></pre>"},{"location":"api/decorators/","title":"decorators","text":"<p>Module with all decorators that are exposed for users.</p> <p>Currently only:</p> <ul> <li>predefined signals decorators (pre/post + save/update/delete)</li> </ul>"},{"location":"api/decorators/#ormar.decorators.post_bulk_update","title":"<code>post_bulk_update(senders)</code>","text":"<p>Connect given function to all senders for post_bulk_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_bulk_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_bulk_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_bulk_update\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.post_delete","title":"<code>post_delete(senders)</code>","text":"<p>Connect given function to all senders for post_delete signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_delete(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_delete signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_delete\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.post_relation_add","title":"<code>post_relation_add(senders)</code>","text":"<p>Connect given function to all senders for post_relation_add signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_relation_add(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_relation_add signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_relation_add\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.post_relation_remove","title":"<code>post_relation_remove(senders)</code>","text":"<p>Connect given function to all senders for post_relation_remove signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_relation_remove(\n    senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_relation_remove signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_relation_remove\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.post_save","title":"<code>post_save(senders)</code>","text":"<p>Connect given function to all senders for post_save signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_save(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_save signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_save\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.post_update","title":"<code>post_update(senders)</code>","text":"<p>Connect given function to all senders for post_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_update\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.pre_delete","title":"<code>pre_delete(senders)</code>","text":"<p>Connect given function to all senders for pre_delete signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_delete(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_delete signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_delete\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.pre_relation_add","title":"<code>pre_relation_add(senders)</code>","text":"<p>Connect given function to all senders for pre_relation_add signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_relation_add(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_relation_add signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_relation_add\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.pre_relation_remove","title":"<code>pre_relation_remove(senders)</code>","text":"<p>Connect given function to all senders for pre_relation_remove signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_relation_remove(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_relation_remove signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_relation_remove\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.pre_save","title":"<code>pre_save(senders)</code>","text":"<p>Connect given function to all senders for pre_save signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_save(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_save signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_save\", senders=senders)\n</code></pre>"},{"location":"api/decorators/#ormar.decorators.pre_update","title":"<code>pre_update(senders)</code>","text":"<p>Connect given function to all senders for pre_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_update\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/","title":"signals","text":""},{"location":"api/decorators/signals/#ormar.decorators.signals.post_bulk_update","title":"<code>post_bulk_update(senders)</code>","text":"<p>Connect given function to all senders for post_bulk_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_bulk_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_bulk_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_bulk_update\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.post_delete","title":"<code>post_delete(senders)</code>","text":"<p>Connect given function to all senders for post_delete signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_delete(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_delete signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_delete\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.post_relation_add","title":"<code>post_relation_add(senders)</code>","text":"<p>Connect given function to all senders for post_relation_add signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_relation_add(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_relation_add signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_relation_add\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.post_relation_remove","title":"<code>post_relation_remove(senders)</code>","text":"<p>Connect given function to all senders for post_relation_remove signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_relation_remove(\n    senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_relation_remove signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_relation_remove\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.post_save","title":"<code>post_save(senders)</code>","text":"<p>Connect given function to all senders for post_save signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_save(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_save signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_save\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.post_update","title":"<code>post_update(senders)</code>","text":"<p>Connect given function to all senders for post_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def post_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for post_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"post_update\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.pre_delete","title":"<code>pre_delete(senders)</code>","text":"<p>Connect given function to all senders for pre_delete signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_delete(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_delete signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_delete\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.pre_relation_add","title":"<code>pre_relation_add(senders)</code>","text":"<p>Connect given function to all senders for pre_relation_add signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_relation_add(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_relation_add signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_relation_add\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.pre_relation_remove","title":"<code>pre_relation_remove(senders)</code>","text":"<p>Connect given function to all senders for pre_relation_remove signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_relation_remove(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_relation_remove signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_relation_remove\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.pre_save","title":"<code>pre_save(senders)</code>","text":"<p>Connect given function to all senders for pre_save signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_save(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_save signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_save\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.pre_update","title":"<code>pre_update(senders)</code>","text":"<p>Connect given function to all senders for pre_update signal.</p> <p>:param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def pre_update(senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for pre_update signal.\n\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n    return receiver(signal=\"pre_update\", senders=senders)\n</code></pre>"},{"location":"api/decorators/signals/#ormar.decorators.signals.receiver","title":"<code>receiver(signal, senders)</code>","text":"<p>Connect given function to all senders for given signal name.</p> <p>:param signal: name of the signal to register to :type signal: str :param senders: one or a list of \"Model\" classes that should have the signal receiver registered :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]] :return: returns the original function untouched :rtype: Callable</p> Source code in <code>ormar/decorators/signals.py</code> <pre><code>def receiver(\n    signal: str, senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n) -&gt; Callable:\n    \"\"\"\n    Connect given function to all senders for given signal name.\n\n    :param signal: name of the signal to register to\n    :type signal: str\n    :param senders: one or a list of \"Model\" classes\n    that should have the signal receiver registered\n    :type senders: Union[Type[\"Model\"], List[Type[\"Model\"]]]\n    :return: returns the original function untouched\n    :rtype: Callable\n    \"\"\"\n\n    def _decorator(func: Callable) -&gt; Callable:\n        \"\"\"\n\n        Internal decorator that does all the registering.\n\n        :param func: function to register as receiver\n        :type func: Callable\n        :return: untouched function already registered for given signal\n        :rtype: Callable\n        \"\"\"\n        if not isinstance(senders, list):\n            _senders = [senders]\n        else:\n            _senders = senders\n        for sender in _senders:\n            signals = getattr(sender.ormar_config.signals, signal)\n            signals.connect(func)\n        return func\n\n    return _decorator\n</code></pre>"},{"location":"api/fields/","title":"fields","text":"<p>Module with classes and constructors for ormar Fields. Base Fields types (like String, Integer etc.) as well as relation Fields (ForeignKey, ManyToMany). Also a definition for custom CHAR based sqlalchemy UUID field</p>"},{"location":"api/fields/#ormar.fields.BaseField","title":"<code>BaseField</code>","text":"<p>               Bases: <code>FieldInfo</code></p> <p>BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions.</p> <p>All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr</p> Source code in <code>ormar/fields/base.py</code> <pre><code>class BaseField(FieldInfo):\n    \"\"\"\n    BaseField serves as a parent class for all basic Fields in ormar.\n    It keeps all common parameters available for all fields as well as\n    set of useful functions.\n\n    All values are kept as class variables, ormar Fields are never instantiated.\n    Subclasses pydantic.FieldInfo to keep the fields related\n    to pydantic field types like ConstrainedStr\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        self.__type__: type = kwargs.pop(\"__type__\", None)\n        self.__pydantic_type__: type = kwargs.pop(\"__pydantic_type__\", None)\n        self.__sample__: type = kwargs.pop(\"__sample__\", None)\n        self.related_name = kwargs.pop(\"related_name\", None)\n\n        self.column_type: sqlalchemy.Column = kwargs.pop(\"column_type\", None)\n        self.constraints: List = kwargs.pop(\"constraints\", list())\n        self.name: str = kwargs.pop(\"name\", None)\n        self.db_alias: str = kwargs.pop(\"alias\", None)\n\n        self.primary_key: bool = kwargs.pop(\"primary_key\", False)\n        self.autoincrement: bool = kwargs.pop(\"autoincrement\", False)\n        self.nullable: bool = kwargs.pop(\"nullable\", False)\n        self.sql_nullable: bool = kwargs.pop(\"sql_nullable\", False)\n        self.index: bool = kwargs.pop(\"index\", False)\n        self.unique: bool = kwargs.pop(\"unique\", False)\n\n        self.virtual: bool = kwargs.pop(\n            \"virtual\", None\n        )  # ManyToManyFields and reverse ForeignKeyFields\n        self.is_multi: bool = kwargs.pop(\"is_multi\", None)  # ManyToManyField\n        self.is_relation: bool = kwargs.pop(\n            \"is_relation\", None\n        )  # ForeignKeyField + subclasses\n        self.is_through: bool = kwargs.pop(\"is_through\", False)  # ThroughFields\n\n        self.through_relation_name = kwargs.pop(\"through_relation_name\", None)\n        self.through_reverse_relation_name = kwargs.pop(\n            \"through_reverse_relation_name\", None\n        )\n\n        self.skip_reverse: bool = kwargs.pop(\"skip_reverse\", False)\n        self.skip_field: bool = kwargs.pop(\"skip_field\", False)\n\n        self.owner: Type[\"Model\"] = kwargs.pop(\"owner\", None)\n        self.to: Type[\"Model\"] = kwargs.pop(\"to\", None)\n        self.to_pk_only: Type[\"Model\"] = kwargs.pop(\"to_pk_only\", None)\n        self.through: Type[\"Model\"] = kwargs.pop(\"through\", None)\n        self.self_reference: bool = kwargs.pop(\"self_reference\", False)\n        self.self_reference_primary: Optional[str] = kwargs.pop(\n            \"self_reference_primary\", None\n        )\n        self.orders_by: Optional[List[str]] = kwargs.pop(\"orders_by\", None)\n        self.related_orders_by: Optional[List[str]] = kwargs.pop(\n            \"related_orders_by\", None\n        )\n\n        self.encrypt_secret: str = kwargs.pop(\"encrypt_secret\", None)\n        self.encrypt_backend: EncryptBackends = kwargs.pop(\n            \"encrypt_backend\", EncryptBackends.NONE\n        )\n        self.encrypt_custom_backend: Optional[Type[EncryptBackend]] = kwargs.pop(\n            \"encrypt_custom_backend\", None\n        )\n\n        self.ormar_default: Any = kwargs.pop(\"default\", None)\n        self.server_default: Any = kwargs.pop(\"server_default\", None)\n\n        self.comment: str = kwargs.pop(\"comment\", None)\n\n        self.represent_as_base64_str: bool = kwargs.pop(\n            \"represent_as_base64_str\", False\n        )\n\n        for name, value in kwargs.items():\n            setattr(self, name, value)\n\n        kwargs.update(self.get_pydantic_default())\n        super().__init__(**kwargs)\n\n    def is_valid_uni_relation(self) -&gt; bool:\n        \"\"\"\n        Checks if field is a relation definition but only for ForeignKey relation,\n        so excludes ManyToMany fields, as well as virtual ForeignKey\n        (second side of FK relation).\n\n        Is used to define if a field is a db ForeignKey column that\n        should be saved/populated when dealing with internal/own\n        Model columns only.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return not self.is_multi and not self.virtual\n\n    def get_alias(self) -&gt; str:\n        \"\"\"\n        Used to translate Model column names to database column names during db queries.\n\n        :return: returns custom database column name if defined by user,\n        otherwise field name in ormar/pydantic\n        :rtype: str\n        \"\"\"\n        return self.db_alias if self.db_alias else self.name\n\n    def get_pydantic_default(self) -&gt; Dict:\n        \"\"\"\n        Generates base pydantic.FieldInfo with only default and optionally\n        required to fix pydantic Json field being set to required=False.\n        Used in an ormar Model Metaclass.\n\n        :return: instance of base pydantic.FieldInfo\n        :rtype: pydantic.FieldInfo\n        \"\"\"\n        base = self.default_value()\n        if base is None:\n            base = dict(default=None) if self.nullable else dict(default=_Unset)\n        return base\n\n    def default_value(self, use_server: bool = False) -&gt; Optional[Dict]:\n        \"\"\"\n        Returns a FieldInfo instance with populated default\n        (static) or default_factory (function).\n        If the field is a autoincrement primary key the default is None.\n        Otherwise field have to has either default, or default_factory populated.\n\n        If all default conditions fail None is returned.\n\n        Used in converting to pydantic FieldInfo.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: returns a call to pydantic.Field\n        which is returning a FieldInfo instance\n        :rtype: Optional[pydantic.FieldInfo]\n        \"\"\"\n        if self.is_auto_primary_key():\n            return dict(default=None)\n        if self.has_default(use_server=use_server):\n            default = (\n                self.ormar_default\n                if self.ormar_default is not None\n                else self.server_default\n            )\n            if callable(default):\n                return dict(default_factory=default)\n            return dict(default=default)\n        return None\n\n    def get_default(\n        self, use_server: bool = False, call_default_factory: bool = True\n    ) -&gt; Any:  # noqa CCR001\n        \"\"\"\n        Return default value for a field.\n        If the field is Callable the function is called and actual result is returned.\n        Used to populate default_values for pydantic Model in ormar Model Metaclass.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: default value for the field if set, otherwise implicit None\n        :rtype: Any\n        \"\"\"\n        if self.has_default():\n            default = (\n                self.ormar_default\n                if self.ormar_default is not None\n                else self._get_default_server_value(use_server=use_server)\n            )\n            return self._get_default_callable_value(\n                default=default,\n                call_default_factory=call_default_factory,\n            )\n\n    def _get_default_server_value(self, use_server: bool) -&gt; Any:\n        \"\"\"\n        Return default value for a server side if use_server is True\n        \"\"\"\n        return self.server_default if use_server else None\n\n    @staticmethod\n    def _get_default_callable_value(default: Any, call_default_factory: bool) -&gt; Any:\n        \"\"\"\n        Return default factory value if call_default_factory is True\n        and default is a callable.\n        \"\"\"\n        return default() if (callable(default) and call_default_factory) else default\n\n    def has_default(self, use_server: bool = True) -&gt; bool:\n        \"\"\"\n        Checks if the field has default value set.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: result of the check if default value is set\n        :rtype: bool\n        \"\"\"\n        return self.ormar_default is not None or (\n            self.server_default is not None and use_server\n        )\n\n    def is_auto_primary_key(self) -&gt; bool:\n        \"\"\"\n        Checks if field is first a primary key and if it,\n        it's than check if it's set to autoincrement.\n        Autoincrement primary_key is nullable/optional.\n\n        :return: result of the check for primary key and autoincrement\n        :rtype: bool\n        \"\"\"\n        if self.primary_key:\n            return self.autoincrement\n        return False\n\n    def construct_constraints(self) -&gt; List:\n        \"\"\"\n        Converts list of ormar constraints into sqlalchemy ForeignKeys.\n        Has to be done dynamically as sqlalchemy binds ForeignKey to the table.\n        And we need a new ForeignKey for subclasses of current model\n\n        :return: List of sqlalchemy foreign keys - by default one.\n        :rtype: List[sqlalchemy.schema.ForeignKey]\n        \"\"\"\n        constraints = [\n            sqlalchemy.ForeignKey(\n                con.reference,\n                ondelete=con.ondelete,\n                onupdate=con.onupdate,\n                name=f\"fk_{self.owner.ormar_config.tablename}_{self.to.ormar_config.tablename}\"\n                f\"_{self.to.get_column_alias(self.to.ormar_config.pkname)}_{self.name}\",\n            )\n            for con in self.constraints\n        ]\n        return constraints\n\n    def get_column(self, name: str) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table.\n        Populates name, column type constraints, as well as a number of parameters like\n        primary_key, index, unique, nullable, default and server_default.\n\n        :param name: name of the db column - used if alias is not set\n        :type name: str\n        :return: actual definition of the database column as sqlalchemy requires.\n        :rtype: sqlalchemy.Column\n        \"\"\"\n        if self.encrypt_backend == EncryptBackends.NONE:\n            column = sqlalchemy.Column(\n                self.db_alias or name,\n                self.column_type,\n                *self.construct_constraints(),\n                primary_key=self.primary_key,\n                nullable=self.sql_nullable,\n                index=self.index,\n                unique=self.unique,\n                default=self.ormar_default,\n                server_default=self.server_default,\n                comment=self.comment,\n            )\n        else:\n            column = self._get_encrypted_column(name=name)\n        return column\n\n    def _get_encrypted_column(self, name: str) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Returns EncryptedString column type instead of actual column.\n\n        :param name: column name\n        :type name: str\n        :return: newly defined column\n        :rtype:  sqlalchemy.Column\n        \"\"\"\n        if self.primary_key or self.is_relation:\n            raise ModelDefinitionError(\n                \"Primary key field and relations fields\" \"cannot be encrypted!\"\n            )\n        column = sqlalchemy.Column(\n            self.db_alias or name,\n            EncryptedString(\n                _field_type=self,\n                encrypt_secret=self.encrypt_secret,\n                encrypt_backend=self.encrypt_backend,\n                encrypt_custom_backend=self.encrypt_custom_backend,\n            ),\n            nullable=self.nullable,\n            index=self.index,\n            unique=self.unique,\n            default=self.ormar_default,\n            server_default=self.server_default,\n        )\n        return column\n\n    def expand_relationship(\n        self,\n        value: Any,\n        child: Union[\"Model\", \"NewBaseModel\"],\n        to_register: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Function overwritten for relations, in basic field the value is returned as is.\n        For relations the child model is first constructed (if needed),\n        registered in relation and returned.\n        For relation fields the value can be a pk value (Any type of field),\n        dict (from Model) or actual instance/list of a \"Model\".\n\n        :param value: a Model field value, returned untouched for non relation fields.\n        :type value: Any\n        :param child: a child Model to register\n        :type child: Union[\"Model\", \"NewBaseModel\"]\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: returns untouched value for normal fields, expands only for relations\n        :rtype: Any\n        \"\"\"\n        return value\n\n    def set_self_reference_flag(self) -&gt; None:\n        \"\"\"\n        Sets `self_reference` to True if field to and owner are same model.\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.owner is not None and (\n            self.owner == self.to or self.owner.ormar_config == self.to.ormar_config\n        ):\n            self.self_reference = True\n            self.self_reference_primary = self.name\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return False\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n\n    def get_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for reverse relation.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return \"\"  # pragma: no cover\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.construct_constraints","title":"<code>construct_constraints()</code>","text":"<p>Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model</p> <p>:return: List of sqlalchemy foreign keys - by default one. :rtype: List[sqlalchemy.schema.ForeignKey]</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def construct_constraints(self) -&gt; List:\n    \"\"\"\n    Converts list of ormar constraints into sqlalchemy ForeignKeys.\n    Has to be done dynamically as sqlalchemy binds ForeignKey to the table.\n    And we need a new ForeignKey for subclasses of current model\n\n    :return: List of sqlalchemy foreign keys - by default one.\n    :rtype: List[sqlalchemy.schema.ForeignKey]\n    \"\"\"\n    constraints = [\n        sqlalchemy.ForeignKey(\n            con.reference,\n            ondelete=con.ondelete,\n            onupdate=con.onupdate,\n            name=f\"fk_{self.owner.ormar_config.tablename}_{self.to.ormar_config.tablename}\"\n            f\"_{self.to.get_column_alias(self.to.ormar_config.pkname)}_{self.name}\",\n        )\n        for con in self.constraints\n    ]\n    return constraints\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.default_value","title":"<code>default_value(use_server=False)</code>","text":"<p>Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated.</p> <p>If all default conditions fail None is returned.</p> <p>Used in converting to pydantic FieldInfo.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: returns a call to pydantic.Field which is returning a FieldInfo instance :rtype: Optional[pydantic.FieldInfo]</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def default_value(self, use_server: bool = False) -&gt; Optional[Dict]:\n    \"\"\"\n    Returns a FieldInfo instance with populated default\n    (static) or default_factory (function).\n    If the field is a autoincrement primary key the default is None.\n    Otherwise field have to has either default, or default_factory populated.\n\n    If all default conditions fail None is returned.\n\n    Used in converting to pydantic FieldInfo.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: returns a call to pydantic.Field\n    which is returning a FieldInfo instance\n    :rtype: Optional[pydantic.FieldInfo]\n    \"\"\"\n    if self.is_auto_primary_key():\n        return dict(default=None)\n    if self.has_default(use_server=use_server):\n        default = (\n            self.ormar_default\n            if self.ormar_default is not None\n            else self.server_default\n        )\n        if callable(default):\n            return dict(default_factory=default)\n        return dict(default=default)\n    return None\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.expand_relationship","title":"<code>expand_relationship(value, child, to_register=True)</code>","text":"<p>Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\".</p> <p>:param value: a Model field value, returned untouched for non relation fields. :type value: Any :param child: a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] :param to_register: flag if the relation should be set in RelationshipManager :type to_register: bool :return: returns untouched value for normal fields, expands only for relations :rtype: Any</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def expand_relationship(\n    self,\n    value: Any,\n    child: Union[\"Model\", \"NewBaseModel\"],\n    to_register: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Function overwritten for relations, in basic field the value is returned as is.\n    For relations the child model is first constructed (if needed),\n    registered in relation and returned.\n    For relation fields the value can be a pk value (Any type of field),\n    dict (from Model) or actual instance/list of a \"Model\".\n\n    :param value: a Model field value, returned untouched for non relation fields.\n    :type value: Any\n    :param child: a child Model to register\n    :type child: Union[\"Model\", \"NewBaseModel\"]\n    :param to_register: flag if the relation should be set in RelationshipManager\n    :type to_register: bool\n    :return: returns untouched value for normal fields, expands only for relations\n    :rtype: Any\n    \"\"\"\n    return value\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.get_alias","title":"<code>get_alias()</code>","text":"<p>Used to translate Model column names to database column names during db queries.</p> <p>:return: returns custom database column name if defined by user, otherwise field name in ormar/pydantic :rtype: str</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_alias(self) -&gt; str:\n    \"\"\"\n    Used to translate Model column names to database column names during db queries.\n\n    :return: returns custom database column name if defined by user,\n    otherwise field name in ormar/pydantic\n    :rtype: str\n    \"\"\"\n    return self.db_alias if self.db_alias else self.name\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.get_column","title":"<code>get_column(name)</code>","text":"<p>Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default.</p> <p>:param name: name of the db column - used if alias is not set :type name: str :return: actual definition of the database column as sqlalchemy requires. :rtype: sqlalchemy.Column</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_column(self, name: str) -&gt; sqlalchemy.Column:\n    \"\"\"\n    Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table.\n    Populates name, column type constraints, as well as a number of parameters like\n    primary_key, index, unique, nullable, default and server_default.\n\n    :param name: name of the db column - used if alias is not set\n    :type name: str\n    :return: actual definition of the database column as sqlalchemy requires.\n    :rtype: sqlalchemy.Column\n    \"\"\"\n    if self.encrypt_backend == EncryptBackends.NONE:\n        column = sqlalchemy.Column(\n            self.db_alias or name,\n            self.column_type,\n            *self.construct_constraints(),\n            primary_key=self.primary_key,\n            nullable=self.sql_nullable,\n            index=self.index,\n            unique=self.unique,\n            default=self.ormar_default,\n            server_default=self.server_default,\n            comment=self.comment,\n        )\n    else:\n        column = self._get_encrypted_column(name=name)\n    return column\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.get_default","title":"<code>get_default(use_server=False, call_default_factory=True)</code>","text":"<p>Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: default value for the field if set, otherwise implicit None :rtype: Any</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_default(\n    self, use_server: bool = False, call_default_factory: bool = True\n) -&gt; Any:  # noqa CCR001\n    \"\"\"\n    Return default value for a field.\n    If the field is Callable the function is called and actual result is returned.\n    Used to populate default_values for pydantic Model in ormar Model Metaclass.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: default value for the field if set, otherwise implicit None\n    :rtype: Any\n    \"\"\"\n    if self.has_default():\n        default = (\n            self.ormar_default\n            if self.ormar_default is not None\n            else self._get_default_server_value(use_server=use_server)\n        )\n        return self._get_default_callable_value(\n            default=default,\n            call_default_factory=call_default_factory,\n        )\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.get_pydantic_default","title":"<code>get_pydantic_default()</code>","text":"<p>Generates base pydantic.FieldInfo with only default and optionally required to fix pydantic Json field being set to required=False. Used in an ormar Model Metaclass.</p> <p>:return: instance of base pydantic.FieldInfo :rtype: pydantic.FieldInfo</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_pydantic_default(self) -&gt; Dict:\n    \"\"\"\n    Generates base pydantic.FieldInfo with only default and optionally\n    required to fix pydantic Json field being set to required=False.\n    Used in an ormar Model Metaclass.\n\n    :return: instance of base pydantic.FieldInfo\n    :rtype: pydantic.FieldInfo\n    \"\"\"\n    base = self.default_value()\n    if base is None:\n        base = dict(default=None) if self.nullable else dict(default=_Unset)\n    return base\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.get_related_name","title":"<code>get_related_name()</code>","text":"<p>Returns name to use for reverse relation. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for reverse relation.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return \"\"  # pragma: no cover\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.has_default","title":"<code>has_default(use_server=True)</code>","text":"<p>Checks if the field has default value set.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: result of the check if default value is set :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def has_default(self, use_server: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if the field has default value set.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: result of the check if default value is set\n    :rtype: bool\n    \"\"\"\n    return self.ormar_default is not None or (\n        self.server_default is not None and use_server\n    )\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.is_auto_primary_key","title":"<code>is_auto_primary_key()</code>","text":"<p>Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional.</p> <p>:return: result of the check for primary key and autoincrement :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def is_auto_primary_key(self) -&gt; bool:\n    \"\"\"\n    Checks if field is first a primary key and if it,\n    it's than check if it's set to autoincrement.\n    Autoincrement primary_key is nullable/optional.\n\n    :return: result of the check for primary key and autoincrement\n    :rtype: bool\n    \"\"\"\n    if self.primary_key:\n        return self.autoincrement\n    return False\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.is_valid_uni_relation","title":"<code>is_valid_uni_relation()</code>","text":"<p>Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation).</p> <p>Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def is_valid_uni_relation(self) -&gt; bool:\n    \"\"\"\n    Checks if field is a relation definition but only for ForeignKey relation,\n    so excludes ManyToMany fields, as well as virtual ForeignKey\n    (second side of FK relation).\n\n    Is used to define if a field is a db ForeignKey column that\n    should be saved/populated when dealing with internal/own\n    Model columns only.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return not self.is_multi and not self.virtual\n</code></pre>"},{"location":"api/fields/#ormar.fields.BaseField.set_self_reference_flag","title":"<code>set_self_reference_flag()</code>","text":"<p>Sets <code>self_reference</code> to True if field to and owner are same model. :return: None :rtype: None</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def set_self_reference_flag(self) -&gt; None:\n    \"\"\"\n    Sets `self_reference` to True if field to and owner are same model.\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.owner is not None and (\n        self.owner == self.to or self.owner.ormar_config == self.to.ormar_config\n    ):\n        self.self_reference = True\n        self.self_reference_primary = self.name\n</code></pre>"},{"location":"api/fields/#ormar.fields.BigInteger","title":"<code>BigInteger</code>","text":"<p>               Bases: <code>Integer</code>, <code>int</code></p> <p>BigInteger field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class BigInteger(Integer, int):\n    \"\"\"\n    BigInteger field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.BigInteger()\n</code></pre>"},{"location":"api/fields/#ormar.fields.BigInteger.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.BigInteger()\n</code></pre>"},{"location":"api/fields/#ormar.fields.Boolean","title":"<code>Boolean</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>int</code></p> <p>Boolean field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Boolean(ModelFieldFactory, int):\n    \"\"\"\n    Boolean field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = bool\n    _sample = True\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Boolean()\n</code></pre>"},{"location":"api/fields/#ormar.fields.Boolean.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Boolean()\n</code></pre>"},{"location":"api/fields/#ormar.fields.CheckColumns","title":"<code>CheckColumns</code>","text":"<p>               Bases: <code>CheckConstraint</code></p> <p>Subclass of sqlalchemy.CheckConstraint. Used to avoid importing anything from sqlalchemy by user.</p> <p>Note that some databases do not actively support check constraints such as MySQL.</p> Source code in <code>ormar/fields/constraints.py</code> <pre><code>class CheckColumns(CheckConstraint):\n    \"\"\"\n    Subclass of sqlalchemy.CheckConstraint.\n    Used to avoid importing anything from sqlalchemy by user.\n\n    Note that some databases do not actively support check constraints such as MySQL.\n    \"\"\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>date</code></p> <p>Date field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Date(ModelFieldFactory, datetime.date):\n    \"\"\"\n    Date field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.date\n    _sample = \"date\"\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Date()\n</code></pre>"},{"location":"api/fields/#ormar.fields.Date.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Date()\n</code></pre>"},{"location":"api/fields/#ormar.fields.DateTime","title":"<code>DateTime</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>datetime</code></p> <p>DateTime field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class DateTime(ModelFieldFactory, datetime.datetime):\n    \"\"\"\n    DateTime field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.datetime\n    _sample = \"datetime\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, timezone: bool = False, **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.DateTime(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/#ormar.fields.DateTime.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.DateTime(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/#ormar.fields.Decimal","title":"<code>Decimal</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>Decimal</code></p> <p>Decimal field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Decimal(ModelFieldFactory, decimal.Decimal):\n    \"\"\"\n    Decimal field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = decimal.Decimal\n    _sample = 0.0\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        minimum: Optional[float] = None,\n        maximum: Optional[float] = None,\n        multiple_of: Optional[int] = None,\n        precision: Optional[int] = None,\n        scale: Optional[int] = None,\n        max_digits: Optional[int] = None,\n        decimal_places: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n\n        if kwargs.get(\"max_digits\"):\n            kwargs[\"precision\"] = kwargs[\"max_digits\"]\n        elif kwargs.get(\"precision\"):\n            kwargs[\"max_digits\"] = kwargs[\"precision\"]\n\n        if kwargs.get(\"decimal_places\"):\n            kwargs[\"scale\"] = kwargs[\"decimal_places\"]\n        elif kwargs.get(\"scale\"):\n            kwargs[\"decimal_places\"] = kwargs[\"scale\"]\n\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        precision = kwargs.get(\"precision\")\n        scale = kwargs.get(\"scale\")\n        return sqlalchemy.DECIMAL(precision=precision, scale=scale)\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        precision = kwargs.get(\"precision\")\n        scale = kwargs.get(\"scale\")\n        if precision is None or precision &lt; 0 or scale is None or scale &lt; 0:\n            raise ModelDefinitionError(\n                \"Parameters scale and precision are required for field Decimal\"\n            )\n</code></pre>"},{"location":"api/fields/#ormar.fields.Decimal.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    precision = kwargs.get(\"precision\")\n    scale = kwargs.get(\"scale\")\n    return sqlalchemy.DECIMAL(precision=precision, scale=scale)\n</code></pre>"},{"location":"api/fields/#ormar.fields.Decimal.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    precision = kwargs.get(\"precision\")\n    scale = kwargs.get(\"scale\")\n    if precision is None or precision &lt; 0 or scale is None or scale &lt; 0:\n        raise ModelDefinitionError(\n            \"Parameters scale and precision are required for field Decimal\"\n        )\n</code></pre>"},{"location":"api/fields/#ormar.fields.Enum","title":"<code>Enum</code>","text":"<p>               Bases: <code>ModelFieldFactory</code></p> <p>Enum field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Enum(ModelFieldFactory):\n    \"\"\"\n    Enum field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = E\n    _sample = None\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, enum_class: Type[E], **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        enum_class = kwargs.get(\"enum_class\")\n        if enum_class is None or not isinstance(enum_class, EnumMeta):\n            raise ModelDefinitionError(\"Enum Field choices must be EnumType\")\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        enum_cls = kwargs.get(\"enum_class\")\n        return sqlalchemy.Enum(enum_cls)\n</code></pre>"},{"location":"api/fields/#ormar.fields.Float","title":"<code>Float</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>float</code></p> <p>Float field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Float(ModelFieldFactory, float):\n    \"\"\"\n    Float field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = float\n    _sample = 0.0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[float] = None,\n        maximum: Optional[float] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Float()\n</code></pre>"},{"location":"api/fields/#ormar.fields.Float.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Float()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField","title":"<code>ForeignKeyField</code>","text":"<p>               Bases: <code>BaseField</code></p> <p>Actual class returned from ForeignKey function call and stored in model_fields.</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>class ForeignKeyField(BaseField):\n    \"\"\"\n    Actual class returned from ForeignKey function call and stored in model_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        if TYPE_CHECKING:  # pragma: no cover\n            self.__type__: type\n            self.to: Type[\"Model\"]\n        self.ondelete: str = kwargs.pop(\"ondelete\", None)\n        self.onupdate: str = kwargs.pop(\"onupdate\", None)\n        super().__init__(**kwargs)\n\n    def get_source_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for source relation name.\n        For FK it's the same, differs for m2m fields.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return self.get_related_name()\n\n    def get_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for reverse relation.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return self.related_name or self.owner.get_name() + \"s\"\n\n    def default_target_field_name(self) -&gt; str:\n        \"\"\"\n        Returns default target model name on through model.\n        :return: name of the field\n        :rtype: str\n        \"\"\"\n        prefix = \"from_\" if self.self_reference else \"\"\n        return self.through_reverse_relation_name or f\"{prefix}{self.to.get_name()}\"\n\n    def default_source_field_name(self) -&gt; str:\n        \"\"\"\n        Returns default target model name on through model.\n        :return: name of the field\n        :rtype: str\n        \"\"\"\n        prefix = \"to_\" if self.self_reference else \"\"\n        return self.through_relation_name or f\"{prefix}{self.owner.get_name()}\"\n\n    def get_filter_clause_target(self) -&gt; Type[\"Model\"]:\n        return self.to\n\n    def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n        \"\"\"\n        Extract names of the database columns or model fields that are connected\n        with given relation based on use_alias switch and which side of the relation\n        the current field is - reverse or normal.\n\n        :param use_alias: use db names aliases or model fields\n        :type use_alias: bool\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if use_alias:\n            return self._get_model_relation_fields_alias()\n        return self._get_model_relation_fields_name()\n\n    def _get_model_relation_fields_name(self) -&gt; str:\n        if self.virtual:\n            return self.owner.ormar_config.pkname\n        return self.name\n\n    def _get_model_relation_fields_alias(self) -&gt; str:\n        if self.virtual:\n            return self.owner.ormar_config.model_fields[\n                self.owner.ormar_config.pkname\n            ].get_alias()\n        return self.get_alias()\n\n    def get_related_field_alias(self) -&gt; str:\n        \"\"\"\n        Extract names of the related database columns or that are connected\n        with given relation based to use as a target in filter clause.\n\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, Dict[str, str]]\n        \"\"\"\n        if self.virtual:\n            field_name = self.get_related_name()\n            field = self.to.ormar_config.model_fields[field_name]\n            return field.get_alias()\n        target_field = self.to.get_column_alias(self.to.ormar_config.pkname)\n        return target_field\n\n    def get_related_field_name(self) -&gt; Union[str, List[str]]:\n        \"\"\"\n        Returns name of the relation field that should be used in prefetch query.\n        This field is later used to register relation in prefetch query,\n        populate relations dict, and populate nested model in prefetch query.\n\n        :return: name(s) of the field\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if self.virtual:\n            return self.get_related_name()\n        return self.to.ormar_config.pkname\n\n    def _evaluate_forward_ref(\n        self, globalns: Any, localns: Any, is_through: bool = False\n    ) -&gt; None:\n        target = \"through\" if is_through else \"to\"\n        target_obj = getattr(self, target)\n        if sys.version_info.minor &lt;= 8:  # pragma: no cover\n            evaluated = target_obj._evaluate(globalns, localns)\n        else:  # pragma: no cover\n            evaluated = target_obj._evaluate(globalns, localns, recursive_guard=set())\n        setattr(self, target, evaluated)\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.to.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns)\n            (\n                self.__type__,\n                self.constraints,\n                self.column_type,\n                self.to_pk_only,\n            ) = populate_fk_params_based_on_to_model(\n                to=self.to,\n                nullable=self.nullable,\n                ondelete=self.ondelete,\n                onupdate=self.onupdate,\n            )\n\n    def _extract_model_from_sequence(\n        self, value: List, child: \"Model\", to_register: bool\n    ) -&gt; List[\"Model\"]:\n        \"\"\"\n        Takes a list of Models and registers them on parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in reverse FK relations.\n\n        :param value: list of Model\n        :type value: List\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: list (if needed) registered Models\n        :rtype: List[\"Model\"]\n        \"\"\"\n        return [\n            self.expand_relationship(  # type: ignore\n                value=val, child=child, to_register=to_register\n            )\n            for val in value\n        ]\n\n    def _register_existing_model(\n        self, value: \"Model\", child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes already created instance and registers it for parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in reverse FK relations and normal FK for single models.\n\n        :param value: already instantiated Model\n        :type value: Model\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        if to_register:\n            self.register_relation(model=value, child=child)\n        return value\n\n    def _construct_model_from_dict(\n        self, value: dict, child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes a dictionary, creates a instance and registers it for parent.\n        If dictionary contains only one field and it's a pk it is a __pk_only__ model.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in normal FK for dictionaries.\n\n        :param value: dictionary of a Model\n        :type value: dict\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        pk_only_model = None\n        keys = set(value.keys())\n        own_keys = keys - self.to.extract_related_names()\n        if (\n            len(own_keys) == 1\n            and list(own_keys)[0] == self.to.ormar_config.pkname\n            and value.get(self.to.ormar_config.pkname) is not None\n            and not self.is_through\n        ):\n            value[\"__pk_only__\"] = True\n            pk_only_model = self.to_pk_only(**value)\n        model = self.to(**value)\n        if to_register:\n            self.register_relation(model=model, child=child)\n        return pk_only_model if pk_only_model is not None else model\n\n    def _construct_model_from_pk(\n        self, value: Any, child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes a pk value, creates a dummy instance and registers it for parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in normal FK for dictionaries.\n\n        :param value: value of a related pk / fk column\n        :type value: Any\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        if self.to.pk_type() == uuid.UUID and isinstance(value, str):  # pragma: nocover\n            value = uuid.UUID(value)\n        if not isinstance(value, self.to.pk_type()):\n            if isinstance(value, self.to_pk_only):\n                value = getattr(value, self.to.ormar_config.pkname)\n            else:\n                raise RelationshipInstanceError(\n                    f\"Relationship error - ForeignKey {self.to.__name__} \"\n                    f\"is of type {self.to.pk_type()} \"\n                    f\"while {type(value)} passed as a parameter.\"\n                )\n        model = create_dummy_instance(fk=self.to, pk=value)\n        if to_register:\n            self.register_relation(model=model, child=child)\n        return model\n\n    def register_relation(self, model: \"Model\", child: \"Model\") -&gt; None:\n        \"\"\"\n        Registers relation between parent and child in relation manager.\n        Relation manager is kep on each model (different instance).\n\n        Used in Metaclass and sometimes some relations are missing\n        (i.e. cloned Models in fastapi might miss one).\n\n        :param model: parent model (with relation definition)\n        :type model: Model class\n        :param child: child model\n        :type child: Model class\n        \"\"\"\n        model._orm.add(parent=model, child=child, field=self)\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.to.__class__ == ForwardRef\n\n    def expand_relationship(\n        self,\n        value: Any,\n        child: Union[\"Model\", \"NewBaseModel\"],\n        to_register: bool = True,\n    ) -&gt; Optional[Union[\"Model\", List[\"Model\"]]]:\n        \"\"\"\n        For relations the child model is first constructed (if needed),\n        registered in relation and returned.\n        For relation fields the value can be a pk value (Any type of field),\n        dict (from Model) or actual instance/list of a \"Model\".\n\n        Selects the appropriate constructor based on a passed value.\n\n        :param value: a Model field value, returned untouched for non relation fields.\n        :type value: Any\n        :param child: a child Model to register\n        :type child: Union[\"Model\", \"NewBaseModel\"]\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: returns a Model or a list of Models\n        :rtype: Optional[Union[\"Model\", List[\"Model\"]]]\n        \"\"\"\n        if value is None:\n            return None if not self.virtual else []\n        constructors = {\n            f\"{self.to.__name__}\": self._register_existing_model,\n            \"dict\": self._construct_model_from_dict,\n            \"list\": self._extract_model_from_sequence,\n        }\n\n        model = constructors.get(  # type: ignore\n            value.__class__.__name__, self._construct_model_from_pk\n        )(value, child, to_register)\n        return model\n\n    def get_relation_name(self) -&gt; str:  # pragma: no cover\n        \"\"\"\n        Returns name of the relation, which can be a own name or through model\n        names for m2m models\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.name\n\n    def get_source_model(self) -&gt; Type[\"Model\"]:  # pragma: no cover\n        \"\"\"\n        Returns model from which the relation comes -&gt; either owner or through model\n\n        :return: source model\n        :rtype: Type[\"Model\"]\n        \"\"\"\n        return self.owner\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.default_source_field_name","title":"<code>default_source_field_name()</code>","text":"<p>Returns default target model name on through model. :return: name of the field :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def default_source_field_name(self) -&gt; str:\n    \"\"\"\n    Returns default target model name on through model.\n    :return: name of the field\n    :rtype: str\n    \"\"\"\n    prefix = \"to_\" if self.self_reference else \"\"\n    return self.through_relation_name or f\"{prefix}{self.owner.get_name()}\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.default_target_field_name","title":"<code>default_target_field_name()</code>","text":"<p>Returns default target model name on through model. :return: name of the field :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def default_target_field_name(self) -&gt; str:\n    \"\"\"\n    Returns default target model name on through model.\n    :return: name of the field\n    :rtype: str\n    \"\"\"\n    prefix = \"from_\" if self.self_reference else \"\"\n    return self.through_reverse_relation_name or f\"{prefix}{self.to.get_name()}\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.to.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns)\n        (\n            self.__type__,\n            self.constraints,\n            self.column_type,\n            self.to_pk_only,\n        ) = populate_fk_params_based_on_to_model(\n            to=self.to,\n            nullable=self.nullable,\n            ondelete=self.ondelete,\n            onupdate=self.onupdate,\n        )\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.expand_relationship","title":"<code>expand_relationship(value, child, to_register=True)</code>","text":"<p>For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\".</p> <p>Selects the appropriate constructor based on a passed value.</p> <p>:param value: a Model field value, returned untouched for non relation fields. :type value: Any :param child: a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] :param to_register: flag if the relation should be set in RelationshipManager :type to_register: bool :return: returns a Model or a list of Models :rtype: Optional[Union[\"Model\", List[\"Model\"]]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def expand_relationship(\n    self,\n    value: Any,\n    child: Union[\"Model\", \"NewBaseModel\"],\n    to_register: bool = True,\n) -&gt; Optional[Union[\"Model\", List[\"Model\"]]]:\n    \"\"\"\n    For relations the child model is first constructed (if needed),\n    registered in relation and returned.\n    For relation fields the value can be a pk value (Any type of field),\n    dict (from Model) or actual instance/list of a \"Model\".\n\n    Selects the appropriate constructor based on a passed value.\n\n    :param value: a Model field value, returned untouched for non relation fields.\n    :type value: Any\n    :param child: a child Model to register\n    :type child: Union[\"Model\", \"NewBaseModel\"]\n    :param to_register: flag if the relation should be set in RelationshipManager\n    :type to_register: bool\n    :return: returns a Model or a list of Models\n    :rtype: Optional[Union[\"Model\", List[\"Model\"]]]\n    \"\"\"\n    if value is None:\n        return None if not self.virtual else []\n    constructors = {\n        f\"{self.to.__name__}\": self._register_existing_model,\n        \"dict\": self._construct_model_from_dict,\n        \"list\": self._extract_model_from_sequence,\n    }\n\n    model = constructors.get(  # type: ignore\n        value.__class__.__name__, self._construct_model_from_pk\n    )(value, child, to_register)\n    return model\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_model_relation_fields","title":"<code>get_model_relation_fields(use_alias=False)</code>","text":"<p>Extract names of the database columns or model fields that are connected with given relation based on use_alias switch and which side of the relation the current field is - reverse or normal.</p> <p>:param use_alias: use db names aliases or model fields :type use_alias: bool :return: name or names of the related columns/ fields :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n    \"\"\"\n    Extract names of the database columns or model fields that are connected\n    with given relation based on use_alias switch and which side of the relation\n    the current field is - reverse or normal.\n\n    :param use_alias: use db names aliases or model fields\n    :type use_alias: bool\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if use_alias:\n        return self._get_model_relation_fields_alias()\n    return self._get_model_relation_fields_name()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_related_field_alias","title":"<code>get_related_field_alias()</code>","text":"<p>Extract names of the related database columns or that are connected with given relation based to use as a target in filter clause.</p> <p>:return: name or names of the related columns/ fields :rtype: Union[str, Dict[str, str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_field_alias(self) -&gt; str:\n    \"\"\"\n    Extract names of the related database columns or that are connected\n    with given relation based to use as a target in filter clause.\n\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, Dict[str, str]]\n    \"\"\"\n    if self.virtual:\n        field_name = self.get_related_name()\n        field = self.to.ormar_config.model_fields[field_name]\n        return field.get_alias()\n    target_field = self.to.get_column_alias(self.to.ormar_config.pkname)\n    return target_field\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_related_field_name","title":"<code>get_related_field_name()</code>","text":"<p>Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query.</p> <p>:return: name(s) of the field :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_field_name(self) -&gt; Union[str, List[str]]:\n    \"\"\"\n    Returns name of the relation field that should be used in prefetch query.\n    This field is later used to register relation in prefetch query,\n    populate relations dict, and populate nested model in prefetch query.\n\n    :return: name(s) of the field\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if self.virtual:\n        return self.get_related_name()\n    return self.to.ormar_config.pkname\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_related_name","title":"<code>get_related_name()</code>","text":"<p>Returns name to use for reverse relation. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for reverse relation.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return self.related_name or self.owner.get_name() + \"s\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_relation_name","title":"<code>get_relation_name()</code>","text":"<p>Returns name of the relation, which can be a own name or through model names for m2m models</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_relation_name(self) -&gt; str:  # pragma: no cover\n    \"\"\"\n    Returns name of the relation, which can be a own name or through model\n    names for m2m models\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_source_model","title":"<code>get_source_model()</code>","text":"<p>Returns model from which the relation comes -&gt; either owner or through model</p> <p>:return: source model :rtype: Type[\"Model\"]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_source_model(self) -&gt; Type[\"Model\"]:  # pragma: no cover\n    \"\"\"\n    Returns model from which the relation comes -&gt; either owner or through model\n\n    :return: source model\n    :rtype: Type[\"Model\"]\n    \"\"\"\n    return self.owner\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.get_source_related_name","title":"<code>get_source_related_name()</code>","text":"<p>Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_source_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for source relation name.\n    For FK it's the same, differs for m2m fields.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return self.get_related_name()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.to.__class__ == ForwardRef\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKeyField.register_relation","title":"<code>register_relation(model, child)</code>","text":"<p>Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance).</p> <p>Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one).</p> <p>:param model: parent model (with relation definition) :type model: Model class :param child: child model :type child: Model class</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def register_relation(self, model: \"Model\", child: \"Model\") -&gt; None:\n    \"\"\"\n    Registers relation between parent and child in relation manager.\n    Relation manager is kep on each model (different instance).\n\n    Used in Metaclass and sometimes some relations are missing\n    (i.e. cloned Models in fastapi might miss one).\n\n    :param model: parent model (with relation definition)\n    :type model: Model class\n    :param child: child model\n    :type child: Model class\n    \"\"\"\n    model._orm.add(parent=model, child=child, field=self)\n</code></pre>"},{"location":"api/fields/#ormar.fields.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>int</code></p> <p>Integer field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Integer(ModelFieldFactory, int):\n    \"\"\"\n    Integer field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Integer()\n</code></pre>"},{"location":"api/fields/#ormar.fields.Integer.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Integer()\n</code></pre>"},{"location":"api/fields/#ormar.fields.JSON","title":"<code>JSON</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>Json</code></p> <p>JSON field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class JSON(ModelFieldFactory, pydantic.Json):\n    \"\"\"\n    JSON field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = pydantic.Json\n    _sample = '{\"json\": \"json\"}'\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.JSON(none_as_null=kwargs.get(\"sql_nullable\", False))\n</code></pre>"},{"location":"api/fields/#ormar.fields.JSON.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.JSON(none_as_null=kwargs.get(\"sql_nullable\", False))\n</code></pre>"},{"location":"api/fields/#ormar.fields.LargeBinary","title":"<code>LargeBinary</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>bytes</code></p> <p>LargeBinary field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class LargeBinary(ModelFieldFactory, bytes):\n    \"\"\"\n    LargeBinary field factory that construct Field classes\n    and populated their values.\n    \"\"\"\n\n    _type = bytes\n    _sample = \"bytes\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        max_length: int,\n        represent_as_base64_str: bool = False,\n        **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.LargeBinary(length=kwargs.get(\"max_length\"))\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        max_length = kwargs.get(\"max_length\", None)\n        if max_length &lt;= 0:\n            raise ModelDefinitionError(\n                \"Parameter max_length is required for field LargeBinary\"\n            )\n</code></pre>"},{"location":"api/fields/#ormar.fields.LargeBinary.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.LargeBinary(length=kwargs.get(\"max_length\"))\n</code></pre>"},{"location":"api/fields/#ormar.fields.LargeBinary.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    max_length = kwargs.get(\"max_length\", None)\n    if max_length &lt;= 0:\n        raise ModelDefinitionError(\n            \"Parameter max_length is required for field LargeBinary\"\n        )\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField","title":"<code>ManyToManyField</code>","text":"<p>               Bases: <code>ForeignKeyField</code>, <code>QuerySetProtocol</code>, <code>RelationProtocol</code></p> <p>Actual class returned from ManyToMany function call and stored in model_fields.</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>class ManyToManyField(  # type: ignore\n    ForeignKeyField,\n    ormar.QuerySetProtocol,\n    ormar.RelationProtocol,\n):\n    \"\"\"\n    Actual class returned from ManyToMany function call and stored in model_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        if TYPE_CHECKING:  # pragma: no cover\n            self.__type__: type\n            self.to: Type[\"Model\"]\n            self.through: Type[\"Model\"]\n        super().__init__(**kwargs)\n\n    def get_source_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for source relation name.\n        For FK it's the same, differs for m2m fields.\n        It's either set as `related_name` or by default it's field name.\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return (\n            self.through.ormar_config.model_fields[\n                self.default_source_field_name()\n            ].related_name\n            or self.name\n        )\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.to.__class__ == ForwardRef or self.through.__class__ == ForwardRef\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.to.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns)\n            (\n                self.__type__,\n                self.column_type,\n                pk_only_model,\n            ) = populate_m2m_params_based_on_to_model(\n                to=self.to, nullable=self.nullable\n            )\n            self.to_pk_only = pk_only_model\n\n        if self.through.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns, is_through=True)\n\n            forbid_through_relations(self.through)\n\n    def get_relation_name(self) -&gt; str:\n        \"\"\"\n        Returns name of the relation, which can be a own name or through model\n        names for m2m models\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        if self.self_reference and self.name == self.self_reference_primary:\n            return self.default_source_field_name()\n        return self.default_target_field_name()\n\n    def get_source_model(self) -&gt; Type[\"Model\"]:\n        \"\"\"\n        Returns model from which the relation comes -&gt; either owner or through model\n\n        :return: source model\n        :rtype: Type[\"Model\"]\n        \"\"\"\n        return self.through\n\n    def get_filter_clause_target(self) -&gt; Type[\"Model\"]:\n        return self.through\n\n    def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n        \"\"\"\n        Extract names of the database columns or model fields that are connected\n        with given relation based on use_alias switch.\n\n        :param use_alias: use db names aliases or model fields\n        :type use_alias: bool\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        pk_field = self.owner.ormar_config.model_fields[self.owner.ormar_config.pkname]\n        result = pk_field.get_alias() if use_alias else pk_field.name\n        return result\n\n    def get_related_field_alias(self) -&gt; str:\n        \"\"\"\n        Extract names of the related database columns or that are connected\n        with given relation based to use as a target in filter clause.\n\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, Dict[str, str]]\n        \"\"\"\n        if self.self_reference and self.self_reference_primary == self.name:\n            field_name = self.default_target_field_name()\n        else:\n            field_name = self.default_source_field_name()\n        sub_field = self.through.ormar_config.model_fields[field_name]\n        return sub_field.get_alias()\n\n    def get_related_field_name(self) -&gt; Union[str, List[str]]:\n        \"\"\"\n        Returns name of the relation field that should be used in prefetch query.\n        This field is later used to register relation in prefetch query,\n        populate relations dict, and populate nested model in prefetch query.\n\n        :return: name(s) of the field\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if self.self_reference and self.self_reference_primary == self.name:\n            return self.default_target_field_name()\n        return self.default_source_field_name()\n\n    def create_default_through_model(self) -&gt; None:\n        \"\"\"\n        Creates default empty through model if no additional fields are required.\n        \"\"\"\n        owner_name = self.owner.get_name(lower=False)\n        to_name = self.to.get_name(lower=False)\n        class_name = f\"{owner_name}{to_name}\"\n        table_name = f\"{owner_name.lower()}s_{to_name.lower()}s\"\n        base_namespace = {\n            \"__module__\": self.owner.__module__,\n            \"__qualname__\": f\"{self.owner.__qualname__}.{class_name}\",\n        }\n        new_config = ormar.models.ormar_config.OrmarConfig(\n            tablename=table_name,\n            database=self.owner.ormar_config.database,\n            metadata=self.owner.ormar_config.metadata,\n        )\n        through_model = type(\n            class_name,\n            (ormar.Model,),\n            {\n                **base_namespace,\n                \"ormar_config\": new_config,\n                \"id\": ormar.Integer(name=\"id\", primary_key=True),\n            },\n        )\n        self.through = cast(Type[\"Model\"], through_model)\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.create_default_through_model","title":"<code>create_default_through_model()</code>","text":"<p>Creates default empty through model if no additional fields are required.</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def create_default_through_model(self) -&gt; None:\n    \"\"\"\n    Creates default empty through model if no additional fields are required.\n    \"\"\"\n    owner_name = self.owner.get_name(lower=False)\n    to_name = self.to.get_name(lower=False)\n    class_name = f\"{owner_name}{to_name}\"\n    table_name = f\"{owner_name.lower()}s_{to_name.lower()}s\"\n    base_namespace = {\n        \"__module__\": self.owner.__module__,\n        \"__qualname__\": f\"{self.owner.__qualname__}.{class_name}\",\n    }\n    new_config = ormar.models.ormar_config.OrmarConfig(\n        tablename=table_name,\n        database=self.owner.ormar_config.database,\n        metadata=self.owner.ormar_config.metadata,\n    )\n    through_model = type(\n        class_name,\n        (ormar.Model,),\n        {\n            **base_namespace,\n            \"ormar_config\": new_config,\n            \"id\": ormar.Integer(name=\"id\", primary_key=True),\n        },\n    )\n    self.through = cast(Type[\"Model\"], through_model)\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.to.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns)\n        (\n            self.__type__,\n            self.column_type,\n            pk_only_model,\n        ) = populate_m2m_params_based_on_to_model(\n            to=self.to, nullable=self.nullable\n        )\n        self.to_pk_only = pk_only_model\n\n    if self.through.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns, is_through=True)\n\n        forbid_through_relations(self.through)\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.get_model_relation_fields","title":"<code>get_model_relation_fields(use_alias=False)</code>","text":"<p>Extract names of the database columns or model fields that are connected with given relation based on use_alias switch.</p> <p>:param use_alias: use db names aliases or model fields :type use_alias: bool :return: name or names of the related columns/ fields :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n    \"\"\"\n    Extract names of the database columns or model fields that are connected\n    with given relation based on use_alias switch.\n\n    :param use_alias: use db names aliases or model fields\n    :type use_alias: bool\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    pk_field = self.owner.ormar_config.model_fields[self.owner.ormar_config.pkname]\n    result = pk_field.get_alias() if use_alias else pk_field.name\n    return result\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.get_related_field_alias","title":"<code>get_related_field_alias()</code>","text":"<p>Extract names of the related database columns or that are connected with given relation based to use as a target in filter clause.</p> <p>:return: name or names of the related columns/ fields :rtype: Union[str, Dict[str, str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_related_field_alias(self) -&gt; str:\n    \"\"\"\n    Extract names of the related database columns or that are connected\n    with given relation based to use as a target in filter clause.\n\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, Dict[str, str]]\n    \"\"\"\n    if self.self_reference and self.self_reference_primary == self.name:\n        field_name = self.default_target_field_name()\n    else:\n        field_name = self.default_source_field_name()\n    sub_field = self.through.ormar_config.model_fields[field_name]\n    return sub_field.get_alias()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.get_related_field_name","title":"<code>get_related_field_name()</code>","text":"<p>Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query.</p> <p>:return: name(s) of the field :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_related_field_name(self) -&gt; Union[str, List[str]]:\n    \"\"\"\n    Returns name of the relation field that should be used in prefetch query.\n    This field is later used to register relation in prefetch query,\n    populate relations dict, and populate nested model in prefetch query.\n\n    :return: name(s) of the field\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if self.self_reference and self.self_reference_primary == self.name:\n        return self.default_target_field_name()\n    return self.default_source_field_name()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.get_relation_name","title":"<code>get_relation_name()</code>","text":"<p>Returns name of the relation, which can be a own name or through model names for m2m models</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_relation_name(self) -&gt; str:\n    \"\"\"\n    Returns name of the relation, which can be a own name or through model\n    names for m2m models\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    if self.self_reference and self.name == self.self_reference_primary:\n        return self.default_source_field_name()\n    return self.default_target_field_name()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.get_source_model","title":"<code>get_source_model()</code>","text":"<p>Returns model from which the relation comes -&gt; either owner or through model</p> <p>:return: source model :rtype: Type[\"Model\"]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_source_model(self) -&gt; Type[\"Model\"]:\n    \"\"\"\n    Returns model from which the relation comes -&gt; either owner or through model\n\n    :return: source model\n    :rtype: Type[\"Model\"]\n    \"\"\"\n    return self.through\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.get_source_related_name","title":"<code>get_source_related_name()</code>","text":"<p>Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as <code>related_name</code> or by default it's field name. :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_source_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for source relation name.\n    For FK it's the same, differs for m2m fields.\n    It's either set as `related_name` or by default it's field name.\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return (\n        self.through.ormar_config.model_fields[\n            self.default_source_field_name()\n        ].related_name\n        or self.name\n    )\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToManyField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.to.__class__ == ForwardRef or self.through.__class__ == ForwardRef\n</code></pre>"},{"location":"api/fields/#ormar.fields.ReferentialAction","title":"<code>ReferentialAction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Because the database management system(DBMS) enforces referential constraints, it must ensure data integrity if rows in a referenced table are to be deleted (or updated).</p> <p>If dependent rows in referencing tables still exist, those references have to be considered.</p> <p>SQL specifies 5 different referential actions that shall take place in such occurrences.</p> Source code in <code>ormar/fields/referential_actions.py</code> <pre><code>class ReferentialAction(Enum):\n    \"\"\"\n    Because the database management system(DBMS) enforces referential constraints,\n    it must ensure data integrity\n    if rows in a referenced table are to be deleted (or updated).\n\n    If dependent rows in referencing tables still exist,\n    those references have to be considered.\n\n    SQL specifies 5 different referential actions\n    that shall take place in such occurrences.\n    \"\"\"\n\n    CASCADE: str = \"CASCADE\"\n    RESTRICT: str = \"RESTRICT\"\n    SET_NULL: str = \"SET NULL\"\n    SET_DEFAULT: str = \"SET DEFAULT\"\n    DO_NOTHING: str = \"NO ACTION\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.SmallInteger","title":"<code>SmallInteger</code>","text":"<p>               Bases: <code>Integer</code>, <code>int</code></p> <p>SmallInteger field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class SmallInteger(Integer, int):\n    \"\"\"\n    SmallInteger field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.SmallInteger()\n</code></pre>"},{"location":"api/fields/#ormar.fields.SmallInteger.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.SmallInteger()\n</code></pre>"},{"location":"api/fields/#ormar.fields.String","title":"<code>String</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>str</code></p> <p>String field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class String(ModelFieldFactory, str):\n    \"\"\"\n    String field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = str\n    _sample = \"string\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        max_length: int,\n        min_length: Optional[int] = None,\n        regex: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.String(length=kwargs.get(\"max_length\"))\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        max_length = kwargs.get(\"max_length\", None)\n        if max_length &lt;= 0:\n            raise ModelDefinitionError(\n                \"Parameter max_length is required for field String\"\n            )\n</code></pre>"},{"location":"api/fields/#ormar.fields.String.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.String(length=kwargs.get(\"max_length\"))\n</code></pre>"},{"location":"api/fields/#ormar.fields.String.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    max_length = kwargs.get(\"max_length\", None)\n    if max_length &lt;= 0:\n        raise ModelDefinitionError(\n            \"Parameter max_length is required for field String\"\n        )\n</code></pre>"},{"location":"api/fields/#ormar.fields.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>str</code></p> <p>Text field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Text(ModelFieldFactory, str):\n    \"\"\"\n    Text field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = str\n    _sample = \"text\"\n\n    def __new__(cls, **kwargs: Any) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Text()\n</code></pre>"},{"location":"api/fields/#ormar.fields.Text.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Text()\n</code></pre>"},{"location":"api/fields/#ormar.fields.ThroughField","title":"<code>ThroughField</code>","text":"<p>               Bases: <code>ForeignKeyField</code></p> <p>Field class used to access ManyToMany model through model.</p> Source code in <code>ormar/fields/through_field.py</code> <pre><code>class ThroughField(ForeignKeyField):\n    \"\"\"\n    Field class used to access ManyToMany model through model.\n    \"\"\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.Time","title":"<code>Time</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>time</code></p> <p>Time field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Time(ModelFieldFactory, datetime.time):\n    \"\"\"\n    Time field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.time\n    _sample = \"time\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, timezone: bool = False, **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Time(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/#ormar.fields.Time.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Time(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/#ormar.fields.UUID","title":"<code>UUID</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>UUID</code></p> <p>UUID field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class UUID(ModelFieldFactory, uuid.UUID):\n    \"\"\"\n    UUID field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = uuid.UUID\n    _sample = \"uuid\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, uuid_format: str = \"hex\", **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        uuid_format = kwargs.get(\"uuid_format\", \"hex\")\n        return sqlalchemy_uuid.UUID(uuid_format=uuid_format)\n</code></pre>"},{"location":"api/fields/#ormar.fields.UUID.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    uuid_format = kwargs.get(\"uuid_format\", \"hex\")\n    return sqlalchemy_uuid.UUID(uuid_format=uuid_format)\n</code></pre>"},{"location":"api/fields/#ormar.fields.UniqueColumns","title":"<code>UniqueColumns</code>","text":"<p>               Bases: <code>UniqueConstraint</code></p> <p>Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user.</p> Source code in <code>ormar/fields/constraints.py</code> <pre><code>class UniqueColumns(UniqueConstraint):\n    \"\"\"\n    Subclass of sqlalchemy.UniqueConstraint.\n    Used to avoid importing anything from sqlalchemy by user.\n    \"\"\"\n</code></pre>"},{"location":"api/fields/#ormar.fields.ForeignKey","title":"<code>ForeignKey(to, *, name=None, unique=False, nullable=True, related_name=None, virtual=False, onupdate=None, ondelete=None, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)).</p> <p>Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param name: name of the database field - later called alias :type name: str :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool :param nullable: marks field as optional/ required :type nullable: bool :param related_name: name of reversed FK relation populated for you on to model :type related_name: str :param virtual: marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool :param onupdate: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: Union[ReferentialAction, str] :param ondelete: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: Union[ReferentialAction, str] :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def ForeignKey(  # type: ignore # noqa CFQ002\n    to: Union[Type[\"T\"], \"ForwardRef\"],\n    *,\n    name: Optional[str] = None,\n    unique: bool = False,\n    nullable: bool = True,\n    related_name: Optional[str] = None,\n    virtual: bool = False,\n    onupdate: Union[ReferentialAction, str, None] = None,\n    ondelete: Union[ReferentialAction, str, None] = None,\n    **kwargs: Any,\n) -&gt; \"T\":\n    \"\"\"\n    Despite a name it's a function that returns constructed ForeignKeyField.\n    This function is actually used in model declaration (as ormar.ForeignKey(ToModel)).\n\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag\n    :type unique: bool\n    :param nullable: marks field as optional/ required\n    :type nullable: bool\n    :param related_name: name of reversed FK relation populated for you on to model\n    :type related_name: str\n    :param virtual: marks if relation is virtual.\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :type virtual: bool\n    :param onupdate: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on update of parent (the one where FK is defined) model.\n    :type onupdate: Union[ReferentialAction, str]\n    :param ondelete: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on delete of parent (the one where FK is defined) model.\n    :type ondelete: Union[ReferentialAction, str]\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ForeignKeyField with relation to selected model\n    :rtype: ForeignKeyField\n    \"\"\"\n\n    onupdate = validate_referential_action(action=onupdate)\n    ondelete = validate_referential_action(action=ondelete)\n\n    owner = kwargs.pop(\"owner\", None)\n    self_reference = kwargs.pop(\"self_reference\", False)\n\n    orders_by = kwargs.pop(\"orders_by\", None)\n    related_orders_by = kwargs.pop(\"related_orders_by\", None)\n\n    skip_reverse = kwargs.pop(\"skip_reverse\", False)\n    skip_field = kwargs.pop(\"skip_field\", False)\n\n    sql_nullable = kwargs.pop(\"sql_nullable\", None)\n    sql_nullable = nullable if sql_nullable is None else sql_nullable\n\n    index = kwargs.pop(\"index\", False)\n\n    validate_not_allowed_fields(kwargs)\n    pk_only_model = None\n    if to.__class__ == ForwardRef:\n        __type__ = to if not nullable else Optional[to]\n        constraints: List = []\n        column_type = None\n    else:\n        (\n            __type__,\n            constraints,\n            column_type,\n            pk_only_model,\n        ) = populate_fk_params_based_on_to_model(\n            to=to,  # type: ignore\n            nullable=nullable,\n            ondelete=ondelete,\n            onupdate=onupdate,\n        )\n\n    namespace = dict(\n        __type__=__type__,\n        to=to,\n        to_pk_only=pk_only_model,\n        through=None,\n        alias=name,\n        name=kwargs.pop(\"real_name\", None),\n        nullable=nullable,\n        sql_nullable=sql_nullable,\n        constraints=constraints,\n        unique=unique,\n        column_type=column_type,\n        related_name=related_name,\n        virtual=virtual,\n        primary_key=False,\n        index=index,\n        default=None,\n        server_default=None,\n        onupdate=onupdate,\n        ondelete=ondelete,\n        owner=owner,\n        self_reference=self_reference,\n        is_relation=True,\n        orders_by=orders_by,\n        related_orders_by=related_orders_by,\n        skip_reverse=skip_reverse,\n        skip_field=skip_field,\n    )\n\n    Field = type(\"ForeignKey\", (ForeignKeyField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/fields/#ormar.fields.ManyToMany","title":"<code>ManyToMany(to, through=None, *, name=None, unique=False, virtual=False, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)).</p> <p>Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param through: through model for m2m relation :type through: Model class :param name: name of the database field - later called alias :type name: str :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool :param virtual: marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ManyToManyField with m2m relation to selected model :rtype: ManyToManyField</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def ManyToMany(  # type: ignore\n    to: Union[Type[\"T\"], \"ForwardRef\"],\n    through: Optional[Union[Type[\"T\"], \"ForwardRef\"]] = None,\n    *,\n    name: Optional[str] = None,\n    unique: bool = False,\n    virtual: bool = False,\n    **kwargs: Any,\n) -&gt; \"RelationProxy[T]\":\n    \"\"\"\n    Despite a name it's a function that returns constructed ManyToManyField.\n    This function is actually used in model declaration\n    (as ormar.ManyToMany(ToModel, through=ThroughModel)).\n\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param through: through model for m2m relation\n    :type through: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag\n    :type unique: bool\n    :param virtual: marks if relation is virtual.\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :type virtual: bool\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ManyToManyField with m2m relation to selected model\n    :rtype: ManyToManyField\n    \"\"\"\n    related_name = kwargs.pop(\"related_name\", None)\n    nullable = kwargs.pop(\"nullable\", True)\n\n    owner = kwargs.pop(\"owner\", None)\n    self_reference = kwargs.pop(\"self_reference\", False)\n\n    orders_by = kwargs.pop(\"orders_by\", None)\n    related_orders_by = kwargs.pop(\"related_orders_by\", None)\n\n    skip_reverse = kwargs.pop(\"skip_reverse\", False)\n    skip_field = kwargs.pop(\"skip_field\", False)\n\n    through_relation_name = kwargs.pop(\"through_relation_name\", None)\n    through_reverse_relation_name = kwargs.pop(\"through_reverse_relation_name\", None)\n\n    if through is not None and through.__class__ != ForwardRef:\n        forbid_through_relations(cast(Type[\"Model\"], through))\n\n    validate_not_allowed_fields(kwargs)\n    pk_only_model = None\n    if to.__class__ == ForwardRef:\n        __type__ = (\n            Union[to, List[to]]  # type: ignore\n            if not nullable\n            else Optional[Union[to, List[to]]]  # type: ignore\n        )\n        column_type = None\n    else:\n        __type__, column_type, pk_only_model = populate_m2m_params_based_on_to_model(\n            to=to, nullable=nullable  # type: ignore\n        )\n    namespace = dict(\n        __type__=__type__,\n        to=to,\n        to_pk_only=pk_only_model,\n        through=through,\n        alias=name,\n        name=name,\n        nullable=nullable,\n        unique=unique,\n        column_type=column_type,\n        related_name=related_name,\n        virtual=virtual,\n        primary_key=False,\n        index=False,\n        default=None,\n        server_default=None,\n        owner=owner,\n        self_reference=self_reference,\n        is_relation=True,\n        is_multi=True,\n        orders_by=orders_by,\n        related_orders_by=related_orders_by,\n        skip_reverse=skip_reverse,\n        skip_field=skip_field,\n        through_relation_name=through_relation_name,\n        through_reverse_relation_name=through_reverse_relation_name,\n    )\n\n    Field = type(\"ManyToMany\", (ManyToManyField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/fields/#ormar.fields.Through","title":"<code>Through(to, *, name=None, related_name=None, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ThroughField. It's a special field populated only for m2m relations. Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param name: name of the database field - later called alias :type name: str :param related_name: name of reversed FK relation populated for you on to model :type related_name: str It is for reversed FK and auto generated FK on through model in Many2Many relations. :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField</p> Source code in <code>ormar/fields/through_field.py</code> <pre><code>def Through(  # noqa CFQ002\n    to: \"ToType\",\n    *,\n    name: Optional[str] = None,\n    related_name: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Any:\n    \"\"\"\n    Despite a name it's a function that returns constructed ThroughField.\n    It's a special field populated only for m2m relations.\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param related_name: name of reversed FK relation populated for you on to model\n    :type related_name: str\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ForeignKeyField with relation to selected model\n    :rtype: ForeignKeyField\n    \"\"\"\n    nullable = kwargs.pop(\"nullable\", False)\n    owner = kwargs.pop(\"owner\", None)\n    namespace = dict(\n        __type__=to,\n        to=to,\n        through=None,\n        alias=name,\n        name=kwargs.pop(\"real_name\", None),\n        related_name=related_name,\n        virtual=True,\n        owner=owner,\n        nullable=nullable,\n        unique=False,\n        column_type=None,\n        primary_key=False,\n        index=False,\n        default=None,\n        server_default=None,\n        is_relation=True,\n        is_through=True,\n    )\n\n    Field = type(\"Through\", (ThroughField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/fields/base/","title":"base","text":""},{"location":"api/fields/base/#ormar.fields.base.BaseField","title":"<code>BaseField</code>","text":"<p>               Bases: <code>FieldInfo</code></p> <p>BaseField serves as a parent class for all basic Fields in ormar. It keeps all common parameters available for all fields as well as set of useful functions.</p> <p>All values are kept as class variables, ormar Fields are never instantiated. Subclasses pydantic.FieldInfo to keep the fields related to pydantic field types like ConstrainedStr</p> Source code in <code>ormar/fields/base.py</code> <pre><code>class BaseField(FieldInfo):\n    \"\"\"\n    BaseField serves as a parent class for all basic Fields in ormar.\n    It keeps all common parameters available for all fields as well as\n    set of useful functions.\n\n    All values are kept as class variables, ormar Fields are never instantiated.\n    Subclasses pydantic.FieldInfo to keep the fields related\n    to pydantic field types like ConstrainedStr\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        self.__type__: type = kwargs.pop(\"__type__\", None)\n        self.__pydantic_type__: type = kwargs.pop(\"__pydantic_type__\", None)\n        self.__sample__: type = kwargs.pop(\"__sample__\", None)\n        self.related_name = kwargs.pop(\"related_name\", None)\n\n        self.column_type: sqlalchemy.Column = kwargs.pop(\"column_type\", None)\n        self.constraints: List = kwargs.pop(\"constraints\", list())\n        self.name: str = kwargs.pop(\"name\", None)\n        self.db_alias: str = kwargs.pop(\"alias\", None)\n\n        self.primary_key: bool = kwargs.pop(\"primary_key\", False)\n        self.autoincrement: bool = kwargs.pop(\"autoincrement\", False)\n        self.nullable: bool = kwargs.pop(\"nullable\", False)\n        self.sql_nullable: bool = kwargs.pop(\"sql_nullable\", False)\n        self.index: bool = kwargs.pop(\"index\", False)\n        self.unique: bool = kwargs.pop(\"unique\", False)\n\n        self.virtual: bool = kwargs.pop(\n            \"virtual\", None\n        )  # ManyToManyFields and reverse ForeignKeyFields\n        self.is_multi: bool = kwargs.pop(\"is_multi\", None)  # ManyToManyField\n        self.is_relation: bool = kwargs.pop(\n            \"is_relation\", None\n        )  # ForeignKeyField + subclasses\n        self.is_through: bool = kwargs.pop(\"is_through\", False)  # ThroughFields\n\n        self.through_relation_name = kwargs.pop(\"through_relation_name\", None)\n        self.through_reverse_relation_name = kwargs.pop(\n            \"through_reverse_relation_name\", None\n        )\n\n        self.skip_reverse: bool = kwargs.pop(\"skip_reverse\", False)\n        self.skip_field: bool = kwargs.pop(\"skip_field\", False)\n\n        self.owner: Type[\"Model\"] = kwargs.pop(\"owner\", None)\n        self.to: Type[\"Model\"] = kwargs.pop(\"to\", None)\n        self.to_pk_only: Type[\"Model\"] = kwargs.pop(\"to_pk_only\", None)\n        self.through: Type[\"Model\"] = kwargs.pop(\"through\", None)\n        self.self_reference: bool = kwargs.pop(\"self_reference\", False)\n        self.self_reference_primary: Optional[str] = kwargs.pop(\n            \"self_reference_primary\", None\n        )\n        self.orders_by: Optional[List[str]] = kwargs.pop(\"orders_by\", None)\n        self.related_orders_by: Optional[List[str]] = kwargs.pop(\n            \"related_orders_by\", None\n        )\n\n        self.encrypt_secret: str = kwargs.pop(\"encrypt_secret\", None)\n        self.encrypt_backend: EncryptBackends = kwargs.pop(\n            \"encrypt_backend\", EncryptBackends.NONE\n        )\n        self.encrypt_custom_backend: Optional[Type[EncryptBackend]] = kwargs.pop(\n            \"encrypt_custom_backend\", None\n        )\n\n        self.ormar_default: Any = kwargs.pop(\"default\", None)\n        self.server_default: Any = kwargs.pop(\"server_default\", None)\n\n        self.comment: str = kwargs.pop(\"comment\", None)\n\n        self.represent_as_base64_str: bool = kwargs.pop(\n            \"represent_as_base64_str\", False\n        )\n\n        for name, value in kwargs.items():\n            setattr(self, name, value)\n\n        kwargs.update(self.get_pydantic_default())\n        super().__init__(**kwargs)\n\n    def is_valid_uni_relation(self) -&gt; bool:\n        \"\"\"\n        Checks if field is a relation definition but only for ForeignKey relation,\n        so excludes ManyToMany fields, as well as virtual ForeignKey\n        (second side of FK relation).\n\n        Is used to define if a field is a db ForeignKey column that\n        should be saved/populated when dealing with internal/own\n        Model columns only.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return not self.is_multi and not self.virtual\n\n    def get_alias(self) -&gt; str:\n        \"\"\"\n        Used to translate Model column names to database column names during db queries.\n\n        :return: returns custom database column name if defined by user,\n        otherwise field name in ormar/pydantic\n        :rtype: str\n        \"\"\"\n        return self.db_alias if self.db_alias else self.name\n\n    def get_pydantic_default(self) -&gt; Dict:\n        \"\"\"\n        Generates base pydantic.FieldInfo with only default and optionally\n        required to fix pydantic Json field being set to required=False.\n        Used in an ormar Model Metaclass.\n\n        :return: instance of base pydantic.FieldInfo\n        :rtype: pydantic.FieldInfo\n        \"\"\"\n        base = self.default_value()\n        if base is None:\n            base = dict(default=None) if self.nullable else dict(default=_Unset)\n        return base\n\n    def default_value(self, use_server: bool = False) -&gt; Optional[Dict]:\n        \"\"\"\n        Returns a FieldInfo instance with populated default\n        (static) or default_factory (function).\n        If the field is a autoincrement primary key the default is None.\n        Otherwise field have to has either default, or default_factory populated.\n\n        If all default conditions fail None is returned.\n\n        Used in converting to pydantic FieldInfo.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: returns a call to pydantic.Field\n        which is returning a FieldInfo instance\n        :rtype: Optional[pydantic.FieldInfo]\n        \"\"\"\n        if self.is_auto_primary_key():\n            return dict(default=None)\n        if self.has_default(use_server=use_server):\n            default = (\n                self.ormar_default\n                if self.ormar_default is not None\n                else self.server_default\n            )\n            if callable(default):\n                return dict(default_factory=default)\n            return dict(default=default)\n        return None\n\n    def get_default(\n        self, use_server: bool = False, call_default_factory: bool = True\n    ) -&gt; Any:  # noqa CCR001\n        \"\"\"\n        Return default value for a field.\n        If the field is Callable the function is called and actual result is returned.\n        Used to populate default_values for pydantic Model in ormar Model Metaclass.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: default value for the field if set, otherwise implicit None\n        :rtype: Any\n        \"\"\"\n        if self.has_default():\n            default = (\n                self.ormar_default\n                if self.ormar_default is not None\n                else self._get_default_server_value(use_server=use_server)\n            )\n            return self._get_default_callable_value(\n                default=default,\n                call_default_factory=call_default_factory,\n            )\n\n    def _get_default_server_value(self, use_server: bool) -&gt; Any:\n        \"\"\"\n        Return default value for a server side if use_server is True\n        \"\"\"\n        return self.server_default if use_server else None\n\n    @staticmethod\n    def _get_default_callable_value(default: Any, call_default_factory: bool) -&gt; Any:\n        \"\"\"\n        Return default factory value if call_default_factory is True\n        and default is a callable.\n        \"\"\"\n        return default() if (callable(default) and call_default_factory) else default\n\n    def has_default(self, use_server: bool = True) -&gt; bool:\n        \"\"\"\n        Checks if the field has default value set.\n\n        :param use_server: flag marking if server_default should be\n        treated as default value, default False\n        :type use_server: bool\n        :return: result of the check if default value is set\n        :rtype: bool\n        \"\"\"\n        return self.ormar_default is not None or (\n            self.server_default is not None and use_server\n        )\n\n    def is_auto_primary_key(self) -&gt; bool:\n        \"\"\"\n        Checks if field is first a primary key and if it,\n        it's than check if it's set to autoincrement.\n        Autoincrement primary_key is nullable/optional.\n\n        :return: result of the check for primary key and autoincrement\n        :rtype: bool\n        \"\"\"\n        if self.primary_key:\n            return self.autoincrement\n        return False\n\n    def construct_constraints(self) -&gt; List:\n        \"\"\"\n        Converts list of ormar constraints into sqlalchemy ForeignKeys.\n        Has to be done dynamically as sqlalchemy binds ForeignKey to the table.\n        And we need a new ForeignKey for subclasses of current model\n\n        :return: List of sqlalchemy foreign keys - by default one.\n        :rtype: List[sqlalchemy.schema.ForeignKey]\n        \"\"\"\n        constraints = [\n            sqlalchemy.ForeignKey(\n                con.reference,\n                ondelete=con.ondelete,\n                onupdate=con.onupdate,\n                name=f\"fk_{self.owner.ormar_config.tablename}_{self.to.ormar_config.tablename}\"\n                f\"_{self.to.get_column_alias(self.to.ormar_config.pkname)}_{self.name}\",\n            )\n            for con in self.constraints\n        ]\n        return constraints\n\n    def get_column(self, name: str) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table.\n        Populates name, column type constraints, as well as a number of parameters like\n        primary_key, index, unique, nullable, default and server_default.\n\n        :param name: name of the db column - used if alias is not set\n        :type name: str\n        :return: actual definition of the database column as sqlalchemy requires.\n        :rtype: sqlalchemy.Column\n        \"\"\"\n        if self.encrypt_backend == EncryptBackends.NONE:\n            column = sqlalchemy.Column(\n                self.db_alias or name,\n                self.column_type,\n                *self.construct_constraints(),\n                primary_key=self.primary_key,\n                nullable=self.sql_nullable,\n                index=self.index,\n                unique=self.unique,\n                default=self.ormar_default,\n                server_default=self.server_default,\n                comment=self.comment,\n            )\n        else:\n            column = self._get_encrypted_column(name=name)\n        return column\n\n    def _get_encrypted_column(self, name: str) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Returns EncryptedString column type instead of actual column.\n\n        :param name: column name\n        :type name: str\n        :return: newly defined column\n        :rtype:  sqlalchemy.Column\n        \"\"\"\n        if self.primary_key or self.is_relation:\n            raise ModelDefinitionError(\n                \"Primary key field and relations fields\" \"cannot be encrypted!\"\n            )\n        column = sqlalchemy.Column(\n            self.db_alias or name,\n            EncryptedString(\n                _field_type=self,\n                encrypt_secret=self.encrypt_secret,\n                encrypt_backend=self.encrypt_backend,\n                encrypt_custom_backend=self.encrypt_custom_backend,\n            ),\n            nullable=self.nullable,\n            index=self.index,\n            unique=self.unique,\n            default=self.ormar_default,\n            server_default=self.server_default,\n        )\n        return column\n\n    def expand_relationship(\n        self,\n        value: Any,\n        child: Union[\"Model\", \"NewBaseModel\"],\n        to_register: bool = True,\n    ) -&gt; Any:\n        \"\"\"\n        Function overwritten for relations, in basic field the value is returned as is.\n        For relations the child model is first constructed (if needed),\n        registered in relation and returned.\n        For relation fields the value can be a pk value (Any type of field),\n        dict (from Model) or actual instance/list of a \"Model\".\n\n        :param value: a Model field value, returned untouched for non relation fields.\n        :type value: Any\n        :param child: a child Model to register\n        :type child: Union[\"Model\", \"NewBaseModel\"]\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: returns untouched value for normal fields, expands only for relations\n        :rtype: Any\n        \"\"\"\n        return value\n\n    def set_self_reference_flag(self) -&gt; None:\n        \"\"\"\n        Sets `self_reference` to True if field to and owner are same model.\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.owner is not None and (\n            self.owner == self.to or self.owner.ormar_config == self.to.ormar_config\n        ):\n            self.self_reference = True\n            self.self_reference_primary = self.name\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return False\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n\n    def get_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for reverse relation.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return \"\"  # pragma: no cover\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.construct_constraints","title":"<code>construct_constraints()</code>","text":"<p>Converts list of ormar constraints into sqlalchemy ForeignKeys. Has to be done dynamically as sqlalchemy binds ForeignKey to the table. And we need a new ForeignKey for subclasses of current model</p> <p>:return: List of sqlalchemy foreign keys - by default one. :rtype: List[sqlalchemy.schema.ForeignKey]</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def construct_constraints(self) -&gt; List:\n    \"\"\"\n    Converts list of ormar constraints into sqlalchemy ForeignKeys.\n    Has to be done dynamically as sqlalchemy binds ForeignKey to the table.\n    And we need a new ForeignKey for subclasses of current model\n\n    :return: List of sqlalchemy foreign keys - by default one.\n    :rtype: List[sqlalchemy.schema.ForeignKey]\n    \"\"\"\n    constraints = [\n        sqlalchemy.ForeignKey(\n            con.reference,\n            ondelete=con.ondelete,\n            onupdate=con.onupdate,\n            name=f\"fk_{self.owner.ormar_config.tablename}_{self.to.ormar_config.tablename}\"\n            f\"_{self.to.get_column_alias(self.to.ormar_config.pkname)}_{self.name}\",\n        )\n        for con in self.constraints\n    ]\n    return constraints\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.default_value","title":"<code>default_value(use_server=False)</code>","text":"<p>Returns a FieldInfo instance with populated default (static) or default_factory (function). If the field is a autoincrement primary key the default is None. Otherwise field have to has either default, or default_factory populated.</p> <p>If all default conditions fail None is returned.</p> <p>Used in converting to pydantic FieldInfo.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: returns a call to pydantic.Field which is returning a FieldInfo instance :rtype: Optional[pydantic.FieldInfo]</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def default_value(self, use_server: bool = False) -&gt; Optional[Dict]:\n    \"\"\"\n    Returns a FieldInfo instance with populated default\n    (static) or default_factory (function).\n    If the field is a autoincrement primary key the default is None.\n    Otherwise field have to has either default, or default_factory populated.\n\n    If all default conditions fail None is returned.\n\n    Used in converting to pydantic FieldInfo.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: returns a call to pydantic.Field\n    which is returning a FieldInfo instance\n    :rtype: Optional[pydantic.FieldInfo]\n    \"\"\"\n    if self.is_auto_primary_key():\n        return dict(default=None)\n    if self.has_default(use_server=use_server):\n        default = (\n            self.ormar_default\n            if self.ormar_default is not None\n            else self.server_default\n        )\n        if callable(default):\n            return dict(default_factory=default)\n        return dict(default=default)\n    return None\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.expand_relationship","title":"<code>expand_relationship(value, child, to_register=True)</code>","text":"<p>Function overwritten for relations, in basic field the value is returned as is. For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\".</p> <p>:param value: a Model field value, returned untouched for non relation fields. :type value: Any :param child: a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] :param to_register: flag if the relation should be set in RelationshipManager :type to_register: bool :return: returns untouched value for normal fields, expands only for relations :rtype: Any</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def expand_relationship(\n    self,\n    value: Any,\n    child: Union[\"Model\", \"NewBaseModel\"],\n    to_register: bool = True,\n) -&gt; Any:\n    \"\"\"\n    Function overwritten for relations, in basic field the value is returned as is.\n    For relations the child model is first constructed (if needed),\n    registered in relation and returned.\n    For relation fields the value can be a pk value (Any type of field),\n    dict (from Model) or actual instance/list of a \"Model\".\n\n    :param value: a Model field value, returned untouched for non relation fields.\n    :type value: Any\n    :param child: a child Model to register\n    :type child: Union[\"Model\", \"NewBaseModel\"]\n    :param to_register: flag if the relation should be set in RelationshipManager\n    :type to_register: bool\n    :return: returns untouched value for normal fields, expands only for relations\n    :rtype: Any\n    \"\"\"\n    return value\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.get_alias","title":"<code>get_alias()</code>","text":"<p>Used to translate Model column names to database column names during db queries.</p> <p>:return: returns custom database column name if defined by user, otherwise field name in ormar/pydantic :rtype: str</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_alias(self) -&gt; str:\n    \"\"\"\n    Used to translate Model column names to database column names during db queries.\n\n    :return: returns custom database column name if defined by user,\n    otherwise field name in ormar/pydantic\n    :rtype: str\n    \"\"\"\n    return self.db_alias if self.db_alias else self.name\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.get_column","title":"<code>get_column(name)</code>","text":"<p>Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table. Populates name, column type constraints, as well as a number of parameters like primary_key, index, unique, nullable, default and server_default.</p> <p>:param name: name of the db column - used if alias is not set :type name: str :return: actual definition of the database column as sqlalchemy requires. :rtype: sqlalchemy.Column</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_column(self, name: str) -&gt; sqlalchemy.Column:\n    \"\"\"\n    Returns definition of sqlalchemy.Column used in creation of sqlalchemy.Table.\n    Populates name, column type constraints, as well as a number of parameters like\n    primary_key, index, unique, nullable, default and server_default.\n\n    :param name: name of the db column - used if alias is not set\n    :type name: str\n    :return: actual definition of the database column as sqlalchemy requires.\n    :rtype: sqlalchemy.Column\n    \"\"\"\n    if self.encrypt_backend == EncryptBackends.NONE:\n        column = sqlalchemy.Column(\n            self.db_alias or name,\n            self.column_type,\n            *self.construct_constraints(),\n            primary_key=self.primary_key,\n            nullable=self.sql_nullable,\n            index=self.index,\n            unique=self.unique,\n            default=self.ormar_default,\n            server_default=self.server_default,\n            comment=self.comment,\n        )\n    else:\n        column = self._get_encrypted_column(name=name)\n    return column\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.get_default","title":"<code>get_default(use_server=False, call_default_factory=True)</code>","text":"<p>Return default value for a field. If the field is Callable the function is called and actual result is returned. Used to populate default_values for pydantic Model in ormar Model Metaclass.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: default value for the field if set, otherwise implicit None :rtype: Any</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_default(\n    self, use_server: bool = False, call_default_factory: bool = True\n) -&gt; Any:  # noqa CCR001\n    \"\"\"\n    Return default value for a field.\n    If the field is Callable the function is called and actual result is returned.\n    Used to populate default_values for pydantic Model in ormar Model Metaclass.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: default value for the field if set, otherwise implicit None\n    :rtype: Any\n    \"\"\"\n    if self.has_default():\n        default = (\n            self.ormar_default\n            if self.ormar_default is not None\n            else self._get_default_server_value(use_server=use_server)\n        )\n        return self._get_default_callable_value(\n            default=default,\n            call_default_factory=call_default_factory,\n        )\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.get_pydantic_default","title":"<code>get_pydantic_default()</code>","text":"<p>Generates base pydantic.FieldInfo with only default and optionally required to fix pydantic Json field being set to required=False. Used in an ormar Model Metaclass.</p> <p>:return: instance of base pydantic.FieldInfo :rtype: pydantic.FieldInfo</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_pydantic_default(self) -&gt; Dict:\n    \"\"\"\n    Generates base pydantic.FieldInfo with only default and optionally\n    required to fix pydantic Json field being set to required=False.\n    Used in an ormar Model Metaclass.\n\n    :return: instance of base pydantic.FieldInfo\n    :rtype: pydantic.FieldInfo\n    \"\"\"\n    base = self.default_value()\n    if base is None:\n        base = dict(default=None) if self.nullable else dict(default=_Unset)\n    return base\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.get_related_name","title":"<code>get_related_name()</code>","text":"<p>Returns name to use for reverse relation. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def get_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for reverse relation.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return \"\"  # pragma: no cover\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.has_default","title":"<code>has_default(use_server=True)</code>","text":"<p>Checks if the field has default value set.</p> <p>:param use_server: flag marking if server_default should be treated as default value, default False :type use_server: bool :return: result of the check if default value is set :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def has_default(self, use_server: bool = True) -&gt; bool:\n    \"\"\"\n    Checks if the field has default value set.\n\n    :param use_server: flag marking if server_default should be\n    treated as default value, default False\n    :type use_server: bool\n    :return: result of the check if default value is set\n    :rtype: bool\n    \"\"\"\n    return self.ormar_default is not None or (\n        self.server_default is not None and use_server\n    )\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.is_auto_primary_key","title":"<code>is_auto_primary_key()</code>","text":"<p>Checks if field is first a primary key and if it, it's than check if it's set to autoincrement. Autoincrement primary_key is nullable/optional.</p> <p>:return: result of the check for primary key and autoincrement :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def is_auto_primary_key(self) -&gt; bool:\n    \"\"\"\n    Checks if field is first a primary key and if it,\n    it's than check if it's set to autoincrement.\n    Autoincrement primary_key is nullable/optional.\n\n    :return: result of the check for primary key and autoincrement\n    :rtype: bool\n    \"\"\"\n    if self.primary_key:\n        return self.autoincrement\n    return False\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.is_valid_uni_relation","title":"<code>is_valid_uni_relation()</code>","text":"<p>Checks if field is a relation definition but only for ForeignKey relation, so excludes ManyToMany fields, as well as virtual ForeignKey (second side of FK relation).</p> <p>Is used to define if a field is a db ForeignKey column that should be saved/populated when dealing with internal/own Model columns only.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def is_valid_uni_relation(self) -&gt; bool:\n    \"\"\"\n    Checks if field is a relation definition but only for ForeignKey relation,\n    so excludes ManyToMany fields, as well as virtual ForeignKey\n    (second side of FK relation).\n\n    Is used to define if a field is a db ForeignKey column that\n    should be saved/populated when dealing with internal/own\n    Model columns only.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return not self.is_multi and not self.virtual\n</code></pre>"},{"location":"api/fields/base/#ormar.fields.base.BaseField.set_self_reference_flag","title":"<code>set_self_reference_flag()</code>","text":"<p>Sets <code>self_reference</code> to True if field to and owner are same model. :return: None :rtype: None</p> Source code in <code>ormar/fields/base.py</code> <pre><code>def set_self_reference_flag(self) -&gt; None:\n    \"\"\"\n    Sets `self_reference` to True if field to and owner are same model.\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.owner is not None and (\n        self.owner == self.to or self.owner.ormar_config == self.to.ormar_config\n    ):\n        self.self_reference = True\n        self.self_reference_primary = self.name\n</code></pre>"},{"location":"api/fields/constraints/","title":"constraints","text":""},{"location":"api/fields/constraints/#ormar.fields.constraints.CheckColumns","title":"<code>CheckColumns</code>","text":"<p>               Bases: <code>CheckConstraint</code></p> <p>Subclass of sqlalchemy.CheckConstraint. Used to avoid importing anything from sqlalchemy by user.</p> <p>Note that some databases do not actively support check constraints such as MySQL.</p> Source code in <code>ormar/fields/constraints.py</code> <pre><code>class CheckColumns(CheckConstraint):\n    \"\"\"\n    Subclass of sqlalchemy.CheckConstraint.\n    Used to avoid importing anything from sqlalchemy by user.\n\n    Note that some databases do not actively support check constraints such as MySQL.\n    \"\"\"\n</code></pre>"},{"location":"api/fields/constraints/#ormar.fields.constraints.UniqueColumns","title":"<code>UniqueColumns</code>","text":"<p>               Bases: <code>UniqueConstraint</code></p> <p>Subclass of sqlalchemy.UniqueConstraint. Used to avoid importing anything from sqlalchemy by user.</p> Source code in <code>ormar/fields/constraints.py</code> <pre><code>class UniqueColumns(UniqueConstraint):\n    \"\"\"\n    Subclass of sqlalchemy.UniqueConstraint.\n    Used to avoid importing anything from sqlalchemy by user.\n    \"\"\"\n</code></pre>"},{"location":"api/fields/foreign_key/","title":"foreign_key","text":""},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyConstraint","title":"<code>ForeignKeyConstraint</code>  <code>dataclass</code>","text":"<p>Internal container to store ForeignKey definitions used later to produce sqlalchemy.ForeignKeys</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>@dataclass\nclass ForeignKeyConstraint:\n    \"\"\"\n    Internal container to store ForeignKey definitions used later\n    to produce sqlalchemy.ForeignKeys\n    \"\"\"\n\n    reference: Union[str, sqlalchemy.Column]\n    name: Optional[str]\n    ondelete: Optional[str]\n    onupdate: Optional[str]\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField","title":"<code>ForeignKeyField</code>","text":"<p>               Bases: <code>BaseField</code></p> <p>Actual class returned from ForeignKey function call and stored in model_fields.</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>class ForeignKeyField(BaseField):\n    \"\"\"\n    Actual class returned from ForeignKey function call and stored in model_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        if TYPE_CHECKING:  # pragma: no cover\n            self.__type__: type\n            self.to: Type[\"Model\"]\n        self.ondelete: str = kwargs.pop(\"ondelete\", None)\n        self.onupdate: str = kwargs.pop(\"onupdate\", None)\n        super().__init__(**kwargs)\n\n    def get_source_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for source relation name.\n        For FK it's the same, differs for m2m fields.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return self.get_related_name()\n\n    def get_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for reverse relation.\n        It's either set as `related_name` or by default it's owner model. get_name + 's'\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return self.related_name or self.owner.get_name() + \"s\"\n\n    def default_target_field_name(self) -&gt; str:\n        \"\"\"\n        Returns default target model name on through model.\n        :return: name of the field\n        :rtype: str\n        \"\"\"\n        prefix = \"from_\" if self.self_reference else \"\"\n        return self.through_reverse_relation_name or f\"{prefix}{self.to.get_name()}\"\n\n    def default_source_field_name(self) -&gt; str:\n        \"\"\"\n        Returns default target model name on through model.\n        :return: name of the field\n        :rtype: str\n        \"\"\"\n        prefix = \"to_\" if self.self_reference else \"\"\n        return self.through_relation_name or f\"{prefix}{self.owner.get_name()}\"\n\n    def get_filter_clause_target(self) -&gt; Type[\"Model\"]:\n        return self.to\n\n    def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n        \"\"\"\n        Extract names of the database columns or model fields that are connected\n        with given relation based on use_alias switch and which side of the relation\n        the current field is - reverse or normal.\n\n        :param use_alias: use db names aliases or model fields\n        :type use_alias: bool\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if use_alias:\n            return self._get_model_relation_fields_alias()\n        return self._get_model_relation_fields_name()\n\n    def _get_model_relation_fields_name(self) -&gt; str:\n        if self.virtual:\n            return self.owner.ormar_config.pkname\n        return self.name\n\n    def _get_model_relation_fields_alias(self) -&gt; str:\n        if self.virtual:\n            return self.owner.ormar_config.model_fields[\n                self.owner.ormar_config.pkname\n            ].get_alias()\n        return self.get_alias()\n\n    def get_related_field_alias(self) -&gt; str:\n        \"\"\"\n        Extract names of the related database columns or that are connected\n        with given relation based to use as a target in filter clause.\n\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, Dict[str, str]]\n        \"\"\"\n        if self.virtual:\n            field_name = self.get_related_name()\n            field = self.to.ormar_config.model_fields[field_name]\n            return field.get_alias()\n        target_field = self.to.get_column_alias(self.to.ormar_config.pkname)\n        return target_field\n\n    def get_related_field_name(self) -&gt; Union[str, List[str]]:\n        \"\"\"\n        Returns name of the relation field that should be used in prefetch query.\n        This field is later used to register relation in prefetch query,\n        populate relations dict, and populate nested model in prefetch query.\n\n        :return: name(s) of the field\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if self.virtual:\n            return self.get_related_name()\n        return self.to.ormar_config.pkname\n\n    def _evaluate_forward_ref(\n        self, globalns: Any, localns: Any, is_through: bool = False\n    ) -&gt; None:\n        target = \"through\" if is_through else \"to\"\n        target_obj = getattr(self, target)\n        if sys.version_info.minor &lt;= 8:  # pragma: no cover\n            evaluated = target_obj._evaluate(globalns, localns)\n        else:  # pragma: no cover\n            evaluated = target_obj._evaluate(globalns, localns, recursive_guard=set())\n        setattr(self, target, evaluated)\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.to.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns)\n            (\n                self.__type__,\n                self.constraints,\n                self.column_type,\n                self.to_pk_only,\n            ) = populate_fk_params_based_on_to_model(\n                to=self.to,\n                nullable=self.nullable,\n                ondelete=self.ondelete,\n                onupdate=self.onupdate,\n            )\n\n    def _extract_model_from_sequence(\n        self, value: List, child: \"Model\", to_register: bool\n    ) -&gt; List[\"Model\"]:\n        \"\"\"\n        Takes a list of Models and registers them on parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in reverse FK relations.\n\n        :param value: list of Model\n        :type value: List\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: list (if needed) registered Models\n        :rtype: List[\"Model\"]\n        \"\"\"\n        return [\n            self.expand_relationship(  # type: ignore\n                value=val, child=child, to_register=to_register\n            )\n            for val in value\n        ]\n\n    def _register_existing_model(\n        self, value: \"Model\", child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes already created instance and registers it for parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in reverse FK relations and normal FK for single models.\n\n        :param value: already instantiated Model\n        :type value: Model\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        if to_register:\n            self.register_relation(model=value, child=child)\n        return value\n\n    def _construct_model_from_dict(\n        self, value: dict, child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes a dictionary, creates a instance and registers it for parent.\n        If dictionary contains only one field and it's a pk it is a __pk_only__ model.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in normal FK for dictionaries.\n\n        :param value: dictionary of a Model\n        :type value: dict\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        pk_only_model = None\n        keys = set(value.keys())\n        own_keys = keys - self.to.extract_related_names()\n        if (\n            len(own_keys) == 1\n            and list(own_keys)[0] == self.to.ormar_config.pkname\n            and value.get(self.to.ormar_config.pkname) is not None\n            and not self.is_through\n        ):\n            value[\"__pk_only__\"] = True\n            pk_only_model = self.to_pk_only(**value)\n        model = self.to(**value)\n        if to_register:\n            self.register_relation(model=model, child=child)\n        return pk_only_model if pk_only_model is not None else model\n\n    def _construct_model_from_pk(\n        self, value: Any, child: \"Model\", to_register: bool\n    ) -&gt; \"Model\":\n        \"\"\"\n        Takes a pk value, creates a dummy instance and registers it for parent.\n        Registration is mutual, so children have also reference to parent.\n\n        Used in normal FK for dictionaries.\n\n        :param value: value of a related pk / fk column\n        :type value: Any\n        :param child: child/ related Model\n        :type child: Model\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: (if needed) registered Model\n        :rtype: Model\n        \"\"\"\n        if self.to.pk_type() == uuid.UUID and isinstance(value, str):  # pragma: nocover\n            value = uuid.UUID(value)\n        if not isinstance(value, self.to.pk_type()):\n            if isinstance(value, self.to_pk_only):\n                value = getattr(value, self.to.ormar_config.pkname)\n            else:\n                raise RelationshipInstanceError(\n                    f\"Relationship error - ForeignKey {self.to.__name__} \"\n                    f\"is of type {self.to.pk_type()} \"\n                    f\"while {type(value)} passed as a parameter.\"\n                )\n        model = create_dummy_instance(fk=self.to, pk=value)\n        if to_register:\n            self.register_relation(model=model, child=child)\n        return model\n\n    def register_relation(self, model: \"Model\", child: \"Model\") -&gt; None:\n        \"\"\"\n        Registers relation between parent and child in relation manager.\n        Relation manager is kep on each model (different instance).\n\n        Used in Metaclass and sometimes some relations are missing\n        (i.e. cloned Models in fastapi might miss one).\n\n        :param model: parent model (with relation definition)\n        :type model: Model class\n        :param child: child model\n        :type child: Model class\n        \"\"\"\n        model._orm.add(parent=model, child=child, field=self)\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.to.__class__ == ForwardRef\n\n    def expand_relationship(\n        self,\n        value: Any,\n        child: Union[\"Model\", \"NewBaseModel\"],\n        to_register: bool = True,\n    ) -&gt; Optional[Union[\"Model\", List[\"Model\"]]]:\n        \"\"\"\n        For relations the child model is first constructed (if needed),\n        registered in relation and returned.\n        For relation fields the value can be a pk value (Any type of field),\n        dict (from Model) or actual instance/list of a \"Model\".\n\n        Selects the appropriate constructor based on a passed value.\n\n        :param value: a Model field value, returned untouched for non relation fields.\n        :type value: Any\n        :param child: a child Model to register\n        :type child: Union[\"Model\", \"NewBaseModel\"]\n        :param to_register: flag if the relation should be set in RelationshipManager\n        :type to_register: bool\n        :return: returns a Model or a list of Models\n        :rtype: Optional[Union[\"Model\", List[\"Model\"]]]\n        \"\"\"\n        if value is None:\n            return None if not self.virtual else []\n        constructors = {\n            f\"{self.to.__name__}\": self._register_existing_model,\n            \"dict\": self._construct_model_from_dict,\n            \"list\": self._extract_model_from_sequence,\n        }\n\n        model = constructors.get(  # type: ignore\n            value.__class__.__name__, self._construct_model_from_pk\n        )(value, child, to_register)\n        return model\n\n    def get_relation_name(self) -&gt; str:  # pragma: no cover\n        \"\"\"\n        Returns name of the relation, which can be a own name or through model\n        names for m2m models\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.name\n\n    def get_source_model(self) -&gt; Type[\"Model\"]:  # pragma: no cover\n        \"\"\"\n        Returns model from which the relation comes -&gt; either owner or through model\n\n        :return: source model\n        :rtype: Type[\"Model\"]\n        \"\"\"\n        return self.owner\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.default_source_field_name","title":"<code>default_source_field_name()</code>","text":"<p>Returns default target model name on through model. :return: name of the field :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def default_source_field_name(self) -&gt; str:\n    \"\"\"\n    Returns default target model name on through model.\n    :return: name of the field\n    :rtype: str\n    \"\"\"\n    prefix = \"to_\" if self.self_reference else \"\"\n    return self.through_relation_name or f\"{prefix}{self.owner.get_name()}\"\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.default_target_field_name","title":"<code>default_target_field_name()</code>","text":"<p>Returns default target model name on through model. :return: name of the field :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def default_target_field_name(self) -&gt; str:\n    \"\"\"\n    Returns default target model name on through model.\n    :return: name of the field\n    :rtype: str\n    \"\"\"\n    prefix = \"from_\" if self.self_reference else \"\"\n    return self.through_reverse_relation_name or f\"{prefix}{self.to.get_name()}\"\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.to.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns)\n        (\n            self.__type__,\n            self.constraints,\n            self.column_type,\n            self.to_pk_only,\n        ) = populate_fk_params_based_on_to_model(\n            to=self.to,\n            nullable=self.nullable,\n            ondelete=self.ondelete,\n            onupdate=self.onupdate,\n        )\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.expand_relationship","title":"<code>expand_relationship(value, child, to_register=True)</code>","text":"<p>For relations the child model is first constructed (if needed), registered in relation and returned. For relation fields the value can be a pk value (Any type of field), dict (from Model) or actual instance/list of a \"Model\".</p> <p>Selects the appropriate constructor based on a passed value.</p> <p>:param value: a Model field value, returned untouched for non relation fields. :type value: Any :param child: a child Model to register :type child: Union[\"Model\", \"NewBaseModel\"] :param to_register: flag if the relation should be set in RelationshipManager :type to_register: bool :return: returns a Model or a list of Models :rtype: Optional[Union[\"Model\", List[\"Model\"]]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def expand_relationship(\n    self,\n    value: Any,\n    child: Union[\"Model\", \"NewBaseModel\"],\n    to_register: bool = True,\n) -&gt; Optional[Union[\"Model\", List[\"Model\"]]]:\n    \"\"\"\n    For relations the child model is first constructed (if needed),\n    registered in relation and returned.\n    For relation fields the value can be a pk value (Any type of field),\n    dict (from Model) or actual instance/list of a \"Model\".\n\n    Selects the appropriate constructor based on a passed value.\n\n    :param value: a Model field value, returned untouched for non relation fields.\n    :type value: Any\n    :param child: a child Model to register\n    :type child: Union[\"Model\", \"NewBaseModel\"]\n    :param to_register: flag if the relation should be set in RelationshipManager\n    :type to_register: bool\n    :return: returns a Model or a list of Models\n    :rtype: Optional[Union[\"Model\", List[\"Model\"]]]\n    \"\"\"\n    if value is None:\n        return None if not self.virtual else []\n    constructors = {\n        f\"{self.to.__name__}\": self._register_existing_model,\n        \"dict\": self._construct_model_from_dict,\n        \"list\": self._extract_model_from_sequence,\n    }\n\n    model = constructors.get(  # type: ignore\n        value.__class__.__name__, self._construct_model_from_pk\n    )(value, child, to_register)\n    return model\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_model_relation_fields","title":"<code>get_model_relation_fields(use_alias=False)</code>","text":"<p>Extract names of the database columns or model fields that are connected with given relation based on use_alias switch and which side of the relation the current field is - reverse or normal.</p> <p>:param use_alias: use db names aliases or model fields :type use_alias: bool :return: name or names of the related columns/ fields :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n    \"\"\"\n    Extract names of the database columns or model fields that are connected\n    with given relation based on use_alias switch and which side of the relation\n    the current field is - reverse or normal.\n\n    :param use_alias: use db names aliases or model fields\n    :type use_alias: bool\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if use_alias:\n        return self._get_model_relation_fields_alias()\n    return self._get_model_relation_fields_name()\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_related_field_alias","title":"<code>get_related_field_alias()</code>","text":"<p>Extract names of the related database columns or that are connected with given relation based to use as a target in filter clause.</p> <p>:return: name or names of the related columns/ fields :rtype: Union[str, Dict[str, str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_field_alias(self) -&gt; str:\n    \"\"\"\n    Extract names of the related database columns or that are connected\n    with given relation based to use as a target in filter clause.\n\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, Dict[str, str]]\n    \"\"\"\n    if self.virtual:\n        field_name = self.get_related_name()\n        field = self.to.ormar_config.model_fields[field_name]\n        return field.get_alias()\n    target_field = self.to.get_column_alias(self.to.ormar_config.pkname)\n    return target_field\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_related_field_name","title":"<code>get_related_field_name()</code>","text":"<p>Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query.</p> <p>:return: name(s) of the field :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_field_name(self) -&gt; Union[str, List[str]]:\n    \"\"\"\n    Returns name of the relation field that should be used in prefetch query.\n    This field is later used to register relation in prefetch query,\n    populate relations dict, and populate nested model in prefetch query.\n\n    :return: name(s) of the field\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if self.virtual:\n        return self.get_related_name()\n    return self.to.ormar_config.pkname\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_related_name","title":"<code>get_related_name()</code>","text":"<p>Returns name to use for reverse relation. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for reverse relation.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return self.related_name or self.owner.get_name() + \"s\"\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_relation_name","title":"<code>get_relation_name()</code>","text":"<p>Returns name of the relation, which can be a own name or through model names for m2m models</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_relation_name(self) -&gt; str:  # pragma: no cover\n    \"\"\"\n    Returns name of the relation, which can be a own name or through model\n    names for m2m models\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_source_model","title":"<code>get_source_model()</code>","text":"<p>Returns model from which the relation comes -&gt; either owner or through model</p> <p>:return: source model :rtype: Type[\"Model\"]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_source_model(self) -&gt; Type[\"Model\"]:  # pragma: no cover\n    \"\"\"\n    Returns model from which the relation comes -&gt; either owner or through model\n\n    :return: source model\n    :rtype: Type[\"Model\"]\n    \"\"\"\n    return self.owner\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.get_source_related_name","title":"<code>get_source_related_name()</code>","text":"<p>Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as <code>related_name</code> or by default it's owner model. get_name + 's' :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def get_source_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for source relation name.\n    For FK it's the same, differs for m2m fields.\n    It's either set as `related_name` or by default it's owner model. get_name + 's'\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return self.get_related_name()\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.to.__class__ == ForwardRef\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKeyField.register_relation","title":"<code>register_relation(model, child)</code>","text":"<p>Registers relation between parent and child in relation manager. Relation manager is kep on each model (different instance).</p> <p>Used in Metaclass and sometimes some relations are missing (i.e. cloned Models in fastapi might miss one).</p> <p>:param model: parent model (with relation definition) :type model: Model class :param child: child model :type child: Model class</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def register_relation(self, model: \"Model\", child: \"Model\") -&gt; None:\n    \"\"\"\n    Registers relation between parent and child in relation manager.\n    Relation manager is kep on each model (different instance).\n\n    Used in Metaclass and sometimes some relations are missing\n    (i.e. cloned Models in fastapi might miss one).\n\n    :param model: parent model (with relation definition)\n    :type model: Model class\n    :param child: child model\n    :type child: Model class\n    \"\"\"\n    model._orm.add(parent=model, child=child, field=self)\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.ForeignKey","title":"<code>ForeignKey(to, *, name=None, unique=False, nullable=True, related_name=None, virtual=False, onupdate=None, ondelete=None, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ForeignKeyField. This function is actually used in model declaration (as ormar.ForeignKey(ToModel)).</p> <p>Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param name: name of the database field - later called alias :type name: str :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool :param nullable: marks field as optional/ required :type nullable: bool :param related_name: name of reversed FK relation populated for you on to model :type related_name: str :param virtual: marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool :param onupdate: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: Union[ReferentialAction, str] :param ondelete: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: Union[ReferentialAction, str] :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def ForeignKey(  # type: ignore # noqa CFQ002\n    to: Union[Type[\"T\"], \"ForwardRef\"],\n    *,\n    name: Optional[str] = None,\n    unique: bool = False,\n    nullable: bool = True,\n    related_name: Optional[str] = None,\n    virtual: bool = False,\n    onupdate: Union[ReferentialAction, str, None] = None,\n    ondelete: Union[ReferentialAction, str, None] = None,\n    **kwargs: Any,\n) -&gt; \"T\":\n    \"\"\"\n    Despite a name it's a function that returns constructed ForeignKeyField.\n    This function is actually used in model declaration (as ormar.ForeignKey(ToModel)).\n\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag\n    :type unique: bool\n    :param nullable: marks field as optional/ required\n    :type nullable: bool\n    :param related_name: name of reversed FK relation populated for you on to model\n    :type related_name: str\n    :param virtual: marks if relation is virtual.\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :type virtual: bool\n    :param onupdate: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on update of parent (the one where FK is defined) model.\n    :type onupdate: Union[ReferentialAction, str]\n    :param ondelete: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on delete of parent (the one where FK is defined) model.\n    :type ondelete: Union[ReferentialAction, str]\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ForeignKeyField with relation to selected model\n    :rtype: ForeignKeyField\n    \"\"\"\n\n    onupdate = validate_referential_action(action=onupdate)\n    ondelete = validate_referential_action(action=ondelete)\n\n    owner = kwargs.pop(\"owner\", None)\n    self_reference = kwargs.pop(\"self_reference\", False)\n\n    orders_by = kwargs.pop(\"orders_by\", None)\n    related_orders_by = kwargs.pop(\"related_orders_by\", None)\n\n    skip_reverse = kwargs.pop(\"skip_reverse\", False)\n    skip_field = kwargs.pop(\"skip_field\", False)\n\n    sql_nullable = kwargs.pop(\"sql_nullable\", None)\n    sql_nullable = nullable if sql_nullable is None else sql_nullable\n\n    index = kwargs.pop(\"index\", False)\n\n    validate_not_allowed_fields(kwargs)\n    pk_only_model = None\n    if to.__class__ == ForwardRef:\n        __type__ = to if not nullable else Optional[to]\n        constraints: List = []\n        column_type = None\n    else:\n        (\n            __type__,\n            constraints,\n            column_type,\n            pk_only_model,\n        ) = populate_fk_params_based_on_to_model(\n            to=to,  # type: ignore\n            nullable=nullable,\n            ondelete=ondelete,\n            onupdate=onupdate,\n        )\n\n    namespace = dict(\n        __type__=__type__,\n        to=to,\n        to_pk_only=pk_only_model,\n        through=None,\n        alias=name,\n        name=kwargs.pop(\"real_name\", None),\n        nullable=nullable,\n        sql_nullable=sql_nullable,\n        constraints=constraints,\n        unique=unique,\n        column_type=column_type,\n        related_name=related_name,\n        virtual=virtual,\n        primary_key=False,\n        index=index,\n        default=None,\n        server_default=None,\n        onupdate=onupdate,\n        ondelete=ondelete,\n        owner=owner,\n        self_reference=self_reference,\n        is_relation=True,\n        orders_by=orders_by,\n        related_orders_by=related_orders_by,\n        skip_reverse=skip_reverse,\n        skip_field=skip_field,\n    )\n\n    Field = type(\"ForeignKey\", (ForeignKeyField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.create_dummy_instance","title":"<code>create_dummy_instance(fk, pk=None)</code>","text":"<p>Ormar never returns you a raw data. So if you have a related field that has a value populated it will construct you a Model instance out of it.</p> <p>Creates a \"fake\" instance of passed Model from pk value. The instantiated Model has only pk value filled. To achieve this pk_only flag has to be passed as it skips the validation.</p> <p>If the nested related Models are required they are set with -1 as pk value.</p> <p>:param fk: class of the related Model to which instance should be constructed :type fk: Model class :param pk: value of the primary_key column :type pk: Any :return: Model instance populated with only pk :rtype: Model</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def create_dummy_instance(fk: Type[\"T\"], pk: Any = None) -&gt; \"T\":\n    \"\"\"\n    Ormar never returns you a raw data.\n    So if you have a related field that has a value populated\n    it will construct you a Model instance out of it.\n\n    Creates a \"fake\" instance of passed Model from pk value.\n    The instantiated Model has only pk value filled.\n    To achieve this __pk_only__ flag has to be passed as it skips the validation.\n\n    If the nested related Models are required they are set with -1 as pk value.\n\n    :param fk: class of the related Model to which instance should be constructed\n    :type fk: Model class\n    :param pk: value of the primary_key column\n    :type pk: Any\n    :return: Model instance populated with only pk\n    :rtype: Model\n    \"\"\"\n    init_dict = {\n        **{fk.ormar_config.pkname: pk or -1, \"__pk_only__\": True},\n        **{\n            k: create_dummy_instance(v.to)\n            for k, v in fk.ormar_config.model_fields.items()\n            if v.is_relation and not v.nullable and not v.virtual\n        },\n    }\n    return fk(**init_dict)\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.create_dummy_model","title":"<code>create_dummy_model(base_model, pk_field)</code>","text":"<p>Used to construct a dummy pydantic model for type hints and pydantic validation. Populates only pk field and set it to desired type.</p> <p>:param base_model: class of target dummy model :type base_model: Model class :param pk_field: ormar Field to be set on pydantic Model :type pk_field: Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"] :return: constructed dummy model :rtype: pydantic.BaseModel</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def create_dummy_model(\n    base_model: Type[\"T\"],\n    pk_field: Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"],\n) -&gt; Type[\"BaseModel\"]:\n    \"\"\"\n    Used to construct a dummy pydantic model for type hints and pydantic validation.\n    Populates only pk field and set it to desired type.\n\n    :param base_model: class of target dummy model\n    :type base_model: Model class\n    :param pk_field: ormar Field to be set on pydantic Model\n    :type pk_field: Union[BaseField, \"ForeignKeyField\", \"ManyToManyField\"]\n    :return: constructed dummy model\n    :rtype: pydantic.BaseModel\n    \"\"\"\n    alias = (\n        \"\".join(choices(string.ascii_uppercase, k=6))  # + uuid.uuid4().hex[:4]\n    ).lower()\n    fields = {f\"{pk_field.name}\": (pk_field.__type__, None)}\n\n    dummy_model = create_model(  # type: ignore\n        f\"PkOnly{base_model.get_name(lower=False)}{alias}\",\n        __module__=base_model.__module__,\n        **fields,  # type: ignore\n    )\n    return dummy_model\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.populate_fk_params_based_on_to_model","title":"<code>populate_fk_params_based_on_to_model(to, nullable, onupdate=None, ondelete=None)</code>","text":"<p>Based on target to model to which relation leads to populates the type of the pydantic field to use, ForeignKey constraint and type of the target column field.</p> <p>:param to: target related ormar Model :type to: Model class :param nullable: marks field as optional/ required :type nullable: bool :param onupdate: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on update of parent (the one where FK is defined) model. :type onupdate: str :param ondelete: parameter passed to sqlalchemy.ForeignKey. How to treat child rows on delete of parent (the one where FK is defined) model. :type ondelete: str :return: tuple with target pydantic type, list of fk constraints and target col type :rtype: Tuple[Any, List, Any]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def populate_fk_params_based_on_to_model(\n    to: Type[\"T\"],\n    nullable: bool,\n    onupdate: Optional[str] = None,\n    ondelete: Optional[str] = None,\n) -&gt; Tuple[Any, List, Any, Any]:\n    \"\"\"\n    Based on target to model to which relation leads to populates the type of the\n    pydantic field to use, ForeignKey constraint and type of the target column field.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param nullable: marks field as optional/ required\n    :type nullable: bool\n    :param onupdate: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on update of parent (the one where FK is defined) model.\n    :type onupdate: str\n    :param ondelete: parameter passed to sqlalchemy.ForeignKey.\n    How to treat child rows on delete of parent (the one where FK is defined) model.\n    :type ondelete: str\n    :return: tuple with target pydantic type, list of fk constraints and target col type\n    :rtype: Tuple[Any, List, Any]\n    \"\"\"\n    fk_string = (\n        to.ormar_config.tablename + \".\" + to.get_column_alias(to.ormar_config.pkname)\n    )\n    to_field = to.ormar_config.model_fields[to.ormar_config.pkname]\n    pk_only_model = create_dummy_model(to, to_field)\n    __type__ = (\n        Union[to_field.__type__, to, pk_only_model]\n        if not nullable\n        else Optional[Union[to_field.__type__, to, pk_only_model]]\n    )\n    constraints = [\n        ForeignKeyConstraint(\n            reference=fk_string, ondelete=ondelete, onupdate=onupdate, name=None\n        )\n    ]\n    column_type = to_field.column_type\n    return __type__, constraints, column_type, pk_only_model\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.validate_not_allowed_fields","title":"<code>validate_not_allowed_fields(kwargs)</code>","text":"<p>Verifies if not allowed parameters are set on relation models. Usually they are omitted later anyway but this way it's explicitly notify the user that it's not allowed/ supported.</p> <p>:raises ModelDefinitionError: if any forbidden field is set :param kwargs: dict of kwargs to verify passed to relation field :type kwargs: Dict</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def validate_not_allowed_fields(kwargs: Dict) -&gt; None:\n    \"\"\"\n    Verifies if not allowed parameters are set on relation models.\n    Usually they are omitted later anyway but this way it's explicitly\n    notify the user that it's not allowed/ supported.\n\n    :raises ModelDefinitionError: if any forbidden field is set\n    :param kwargs: dict of kwargs to verify passed to relation field\n    :type kwargs: Dict\n    \"\"\"\n    default = kwargs.pop(\"default\", None)\n    encrypt_secret = kwargs.pop(\"encrypt_secret\", None)\n    encrypt_backend = kwargs.pop(\"encrypt_backend\", None)\n    encrypt_custom_backend = kwargs.pop(\"encrypt_custom_backend\", None)\n    overwrite_pydantic_type = kwargs.pop(\"overwrite_pydantic_type\", None)\n\n    not_supported = [\n        default,\n        encrypt_secret,\n        encrypt_backend,\n        encrypt_custom_backend,\n        overwrite_pydantic_type,\n    ]\n    if any(x is not None for x in not_supported):\n        raise ModelDefinitionError(\n            f\"Argument {next((x for x in not_supported if x is not None))} \"\n            f\"is not supported \"\n            \"on relation fields!\"\n        )\n</code></pre>"},{"location":"api/fields/foreign_key/#ormar.fields.foreign_key.validate_referential_action","title":"<code>validate_referential_action(action)</code>","text":"<p>Validation <code>onupdate</code> and <code>ondelete</code> action cast to a string value</p> <p>:raises ModelDefinitionError: if action is a not valid name string value :param action: referential action attribute or name string :type action: Optional[Union[ReferentialAction, str]] :rtype: Optional[str]</p> Source code in <code>ormar/fields/foreign_key.py</code> <pre><code>def validate_referential_action(\n    action: Optional[Union[ReferentialAction, str]],\n) -&gt; Optional[str]:\n    \"\"\"\n    Validation `onupdate` and `ondelete` action cast to a string value\n\n    :raises ModelDefinitionError: if action is a not valid name string value\n    :param action: referential action attribute or name string\n    :type action: Optional[Union[ReferentialAction, str]]\n    :rtype: Optional[str]\n    \"\"\"\n\n    if action is not None and not isinstance(action, ReferentialAction):\n        try:\n            action = ReferentialAction(action.upper())\n        except (ValueError, AttributeError):\n            raise ModelDefinitionError(f\"{action} ReferentialAction not supported.\")\n\n    return action.value if action is not None else None\n</code></pre>"},{"location":"api/fields/many_to_many/","title":"many_to_many","text":""},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField","title":"<code>ManyToManyField</code>","text":"<p>               Bases: <code>ForeignKeyField</code>, <code>QuerySetProtocol</code>, <code>RelationProtocol</code></p> <p>Actual class returned from ManyToMany function call and stored in model_fields.</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>class ManyToManyField(  # type: ignore\n    ForeignKeyField,\n    ormar.QuerySetProtocol,\n    ormar.RelationProtocol,\n):\n    \"\"\"\n    Actual class returned from ManyToMany function call and stored in model_fields.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -&gt; None:\n        if TYPE_CHECKING:  # pragma: no cover\n            self.__type__: type\n            self.to: Type[\"Model\"]\n            self.through: Type[\"Model\"]\n        super().__init__(**kwargs)\n\n    def get_source_related_name(self) -&gt; str:\n        \"\"\"\n        Returns name to use for source relation name.\n        For FK it's the same, differs for m2m fields.\n        It's either set as `related_name` or by default it's field name.\n        :return: name of the related_name or default related name.\n        :rtype: str\n        \"\"\"\n        return (\n            self.through.ormar_config.model_fields[\n                self.default_source_field_name()\n            ].related_name\n            or self.name\n        )\n\n    def has_unresolved_forward_refs(self) -&gt; bool:\n        \"\"\"\n        Verifies if the filed has any ForwardRefs that require updating before the\n        model can be used.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return self.to.__class__ == ForwardRef or self.through.__class__ == ForwardRef\n\n    def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n        \"\"\"\n        Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n        :param globalns: global namespace\n        :type globalns: Any\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.to.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns)\n            (\n                self.__type__,\n                self.column_type,\n                pk_only_model,\n            ) = populate_m2m_params_based_on_to_model(\n                to=self.to, nullable=self.nullable\n            )\n            self.to_pk_only = pk_only_model\n\n        if self.through.__class__ == ForwardRef:\n            self._evaluate_forward_ref(globalns, localns, is_through=True)\n\n            forbid_through_relations(self.through)\n\n    def get_relation_name(self) -&gt; str:\n        \"\"\"\n        Returns name of the relation, which can be a own name or through model\n        names for m2m models\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        if self.self_reference and self.name == self.self_reference_primary:\n            return self.default_source_field_name()\n        return self.default_target_field_name()\n\n    def get_source_model(self) -&gt; Type[\"Model\"]:\n        \"\"\"\n        Returns model from which the relation comes -&gt; either owner or through model\n\n        :return: source model\n        :rtype: Type[\"Model\"]\n        \"\"\"\n        return self.through\n\n    def get_filter_clause_target(self) -&gt; Type[\"Model\"]:\n        return self.through\n\n    def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n        \"\"\"\n        Extract names of the database columns or model fields that are connected\n        with given relation based on use_alias switch.\n\n        :param use_alias: use db names aliases or model fields\n        :type use_alias: bool\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        pk_field = self.owner.ormar_config.model_fields[self.owner.ormar_config.pkname]\n        result = pk_field.get_alias() if use_alias else pk_field.name\n        return result\n\n    def get_related_field_alias(self) -&gt; str:\n        \"\"\"\n        Extract names of the related database columns or that are connected\n        with given relation based to use as a target in filter clause.\n\n        :return: name or names of the related columns/ fields\n        :rtype: Union[str, Dict[str, str]]\n        \"\"\"\n        if self.self_reference and self.self_reference_primary == self.name:\n            field_name = self.default_target_field_name()\n        else:\n            field_name = self.default_source_field_name()\n        sub_field = self.through.ormar_config.model_fields[field_name]\n        return sub_field.get_alias()\n\n    def get_related_field_name(self) -&gt; Union[str, List[str]]:\n        \"\"\"\n        Returns name of the relation field that should be used in prefetch query.\n        This field is later used to register relation in prefetch query,\n        populate relations dict, and populate nested model in prefetch query.\n\n        :return: name(s) of the field\n        :rtype: Union[str, List[str]]\n        \"\"\"\n        if self.self_reference and self.self_reference_primary == self.name:\n            return self.default_target_field_name()\n        return self.default_source_field_name()\n\n    def create_default_through_model(self) -&gt; None:\n        \"\"\"\n        Creates default empty through model if no additional fields are required.\n        \"\"\"\n        owner_name = self.owner.get_name(lower=False)\n        to_name = self.to.get_name(lower=False)\n        class_name = f\"{owner_name}{to_name}\"\n        table_name = f\"{owner_name.lower()}s_{to_name.lower()}s\"\n        base_namespace = {\n            \"__module__\": self.owner.__module__,\n            \"__qualname__\": f\"{self.owner.__qualname__}.{class_name}\",\n        }\n        new_config = ormar.models.ormar_config.OrmarConfig(\n            tablename=table_name,\n            database=self.owner.ormar_config.database,\n            metadata=self.owner.ormar_config.metadata,\n        )\n        through_model = type(\n            class_name,\n            (ormar.Model,),\n            {\n                **base_namespace,\n                \"ormar_config\": new_config,\n                \"id\": ormar.Integer(name=\"id\", primary_key=True),\n            },\n        )\n        self.through = cast(Type[\"Model\"], through_model)\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.create_default_through_model","title":"<code>create_default_through_model()</code>","text":"<p>Creates default empty through model if no additional fields are required.</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def create_default_through_model(self) -&gt; None:\n    \"\"\"\n    Creates default empty through model if no additional fields are required.\n    \"\"\"\n    owner_name = self.owner.get_name(lower=False)\n    to_name = self.to.get_name(lower=False)\n    class_name = f\"{owner_name}{to_name}\"\n    table_name = f\"{owner_name.lower()}s_{to_name.lower()}s\"\n    base_namespace = {\n        \"__module__\": self.owner.__module__,\n        \"__qualname__\": f\"{self.owner.__qualname__}.{class_name}\",\n    }\n    new_config = ormar.models.ormar_config.OrmarConfig(\n        tablename=table_name,\n        database=self.owner.ormar_config.database,\n        metadata=self.owner.ormar_config.metadata,\n    )\n    through_model = type(\n        class_name,\n        (ormar.Model,),\n        {\n            **base_namespace,\n            \"ormar_config\": new_config,\n            \"id\": ormar.Integer(name=\"id\", primary_key=True),\n        },\n    )\n    self.through = cast(Type[\"Model\"], through_model)\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.evaluate_forward_ref","title":"<code>evaluate_forward_ref(globalns, localns)</code>","text":"<p>Evaluates the ForwardRef to actual Field based on global and local namespaces</p> <p>:param globalns: global namespace :type globalns: Any :param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def evaluate_forward_ref(self, globalns: Any, localns: Any) -&gt; None:\n    \"\"\"\n    Evaluates the ForwardRef to actual Field based on global and local namespaces\n\n    :param globalns: global namespace\n    :type globalns: Any\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    if self.to.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns)\n        (\n            self.__type__,\n            self.column_type,\n            pk_only_model,\n        ) = populate_m2m_params_based_on_to_model(\n            to=self.to, nullable=self.nullable\n        )\n        self.to_pk_only = pk_only_model\n\n    if self.through.__class__ == ForwardRef:\n        self._evaluate_forward_ref(globalns, localns, is_through=True)\n\n        forbid_through_relations(self.through)\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.get_model_relation_fields","title":"<code>get_model_relation_fields(use_alias=False)</code>","text":"<p>Extract names of the database columns or model fields that are connected with given relation based on use_alias switch.</p> <p>:param use_alias: use db names aliases or model fields :type use_alias: bool :return: name or names of the related columns/ fields :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_model_relation_fields(self, use_alias: bool = False) -&gt; str:\n    \"\"\"\n    Extract names of the database columns or model fields that are connected\n    with given relation based on use_alias switch.\n\n    :param use_alias: use db names aliases or model fields\n    :type use_alias: bool\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    pk_field = self.owner.ormar_config.model_fields[self.owner.ormar_config.pkname]\n    result = pk_field.get_alias() if use_alias else pk_field.name\n    return result\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.get_related_field_alias","title":"<code>get_related_field_alias()</code>","text":"<p>Extract names of the related database columns or that are connected with given relation based to use as a target in filter clause.</p> <p>:return: name or names of the related columns/ fields :rtype: Union[str, Dict[str, str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_related_field_alias(self) -&gt; str:\n    \"\"\"\n    Extract names of the related database columns or that are connected\n    with given relation based to use as a target in filter clause.\n\n    :return: name or names of the related columns/ fields\n    :rtype: Union[str, Dict[str, str]]\n    \"\"\"\n    if self.self_reference and self.self_reference_primary == self.name:\n        field_name = self.default_target_field_name()\n    else:\n        field_name = self.default_source_field_name()\n    sub_field = self.through.ormar_config.model_fields[field_name]\n    return sub_field.get_alias()\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.get_related_field_name","title":"<code>get_related_field_name()</code>","text":"<p>Returns name of the relation field that should be used in prefetch query. This field is later used to register relation in prefetch query, populate relations dict, and populate nested model in prefetch query.</p> <p>:return: name(s) of the field :rtype: Union[str, List[str]]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_related_field_name(self) -&gt; Union[str, List[str]]:\n    \"\"\"\n    Returns name of the relation field that should be used in prefetch query.\n    This field is later used to register relation in prefetch query,\n    populate relations dict, and populate nested model in prefetch query.\n\n    :return: name(s) of the field\n    :rtype: Union[str, List[str]]\n    \"\"\"\n    if self.self_reference and self.self_reference_primary == self.name:\n        return self.default_target_field_name()\n    return self.default_source_field_name()\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.get_relation_name","title":"<code>get_relation_name()</code>","text":"<p>Returns name of the relation, which can be a own name or through model names for m2m models</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_relation_name(self) -&gt; str:\n    \"\"\"\n    Returns name of the relation, which can be a own name or through model\n    names for m2m models\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    if self.self_reference and self.name == self.self_reference_primary:\n        return self.default_source_field_name()\n    return self.default_target_field_name()\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.get_source_model","title":"<code>get_source_model()</code>","text":"<p>Returns model from which the relation comes -&gt; either owner or through model</p> <p>:return: source model :rtype: Type[\"Model\"]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_source_model(self) -&gt; Type[\"Model\"]:\n    \"\"\"\n    Returns model from which the relation comes -&gt; either owner or through model\n\n    :return: source model\n    :rtype: Type[\"Model\"]\n    \"\"\"\n    return self.through\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.get_source_related_name","title":"<code>get_source_related_name()</code>","text":"<p>Returns name to use for source relation name. For FK it's the same, differs for m2m fields. It's either set as <code>related_name</code> or by default it's field name. :return: name of the related_name or default related name. :rtype: str</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def get_source_related_name(self) -&gt; str:\n    \"\"\"\n    Returns name to use for source relation name.\n    For FK it's the same, differs for m2m fields.\n    It's either set as `related_name` or by default it's field name.\n    :return: name of the related_name or default related name.\n    :rtype: str\n    \"\"\"\n    return (\n        self.through.ormar_config.model_fields[\n            self.default_source_field_name()\n        ].related_name\n        or self.name\n    )\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToManyField.has_unresolved_forward_refs","title":"<code>has_unresolved_forward_refs()</code>","text":"<p>Verifies if the filed has any ForwardRefs that require updating before the model can be used.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def has_unresolved_forward_refs(self) -&gt; bool:\n    \"\"\"\n    Verifies if the filed has any ForwardRefs that require updating before the\n    model can be used.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return self.to.__class__ == ForwardRef or self.through.__class__ == ForwardRef\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.ManyToMany","title":"<code>ManyToMany(to, through=None, *, name=None, unique=False, virtual=False, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ManyToManyField. This function is actually used in model declaration (as ormar.ManyToMany(ToModel, through=ThroughModel)).</p> <p>Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param through: through model for m2m relation :type through: Model class :param name: name of the database field - later called alias :type name: str :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag :type unique: bool :param virtual: marks if relation is virtual. It is for reversed FK and auto generated FK on through model in Many2Many relations. :type virtual: bool :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ManyToManyField with m2m relation to selected model :rtype: ManyToManyField</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def ManyToMany(  # type: ignore\n    to: Union[Type[\"T\"], \"ForwardRef\"],\n    through: Optional[Union[Type[\"T\"], \"ForwardRef\"]] = None,\n    *,\n    name: Optional[str] = None,\n    unique: bool = False,\n    virtual: bool = False,\n    **kwargs: Any,\n) -&gt; \"RelationProxy[T]\":\n    \"\"\"\n    Despite a name it's a function that returns constructed ManyToManyField.\n    This function is actually used in model declaration\n    (as ormar.ManyToMany(ToModel, through=ThroughModel)).\n\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param through: through model for m2m relation\n    :type through: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param unique: parameter passed to sqlalchemy.ForeignKey, unique flag\n    :type unique: bool\n    :param virtual: marks if relation is virtual.\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :type virtual: bool\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ManyToManyField with m2m relation to selected model\n    :rtype: ManyToManyField\n    \"\"\"\n    related_name = kwargs.pop(\"related_name\", None)\n    nullable = kwargs.pop(\"nullable\", True)\n\n    owner = kwargs.pop(\"owner\", None)\n    self_reference = kwargs.pop(\"self_reference\", False)\n\n    orders_by = kwargs.pop(\"orders_by\", None)\n    related_orders_by = kwargs.pop(\"related_orders_by\", None)\n\n    skip_reverse = kwargs.pop(\"skip_reverse\", False)\n    skip_field = kwargs.pop(\"skip_field\", False)\n\n    through_relation_name = kwargs.pop(\"through_relation_name\", None)\n    through_reverse_relation_name = kwargs.pop(\"through_reverse_relation_name\", None)\n\n    if through is not None and through.__class__ != ForwardRef:\n        forbid_through_relations(cast(Type[\"Model\"], through))\n\n    validate_not_allowed_fields(kwargs)\n    pk_only_model = None\n    if to.__class__ == ForwardRef:\n        __type__ = (\n            Union[to, List[to]]  # type: ignore\n            if not nullable\n            else Optional[Union[to, List[to]]]  # type: ignore\n        )\n        column_type = None\n    else:\n        __type__, column_type, pk_only_model = populate_m2m_params_based_on_to_model(\n            to=to, nullable=nullable  # type: ignore\n        )\n    namespace = dict(\n        __type__=__type__,\n        to=to,\n        to_pk_only=pk_only_model,\n        through=through,\n        alias=name,\n        name=name,\n        nullable=nullable,\n        unique=unique,\n        column_type=column_type,\n        related_name=related_name,\n        virtual=virtual,\n        primary_key=False,\n        index=False,\n        default=None,\n        server_default=None,\n        owner=owner,\n        self_reference=self_reference,\n        is_relation=True,\n        is_multi=True,\n        orders_by=orders_by,\n        related_orders_by=related_orders_by,\n        skip_reverse=skip_reverse,\n        skip_field=skip_field,\n        through_relation_name=through_relation_name,\n        through_reverse_relation_name=through_reverse_relation_name,\n    )\n\n    Field = type(\"ManyToMany\", (ManyToManyField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.forbid_through_relations","title":"<code>forbid_through_relations(through)</code>","text":"<p>Verifies if the through model does not have relations.</p> <p>:param through: through Model to be checked :type through: Type['Model]</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def forbid_through_relations(through: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Verifies if the through model does not have relations.\n\n    :param through: through Model to be checked\n    :type through: Type['Model]\n    \"\"\"\n    if any(field.is_relation for field in through.ormar_config.model_fields.values()):\n        raise ModelDefinitionError(\n            f\"Through Models cannot have explicit relations \"\n            f\"defined. Remove the relations from Model \"\n            f\"{through.get_name(lower=False)}\"\n        )\n</code></pre>"},{"location":"api/fields/many_to_many/#ormar.fields.many_to_many.populate_m2m_params_based_on_to_model","title":"<code>populate_m2m_params_based_on_to_model(to, nullable)</code>","text":"<p>Based on target to model to which relation leads to populates the type of the pydantic field to use and type of the target column field.</p> <p>:param to: target related ormar Model :type to: Model class :param nullable: marks field as optional/ required :type nullable: bool :return: Tuple[List, Any] :rtype: tuple with target pydantic type and target col type</p> Source code in <code>ormar/fields/many_to_many.py</code> <pre><code>def populate_m2m_params_based_on_to_model(\n    to: Type[\"Model\"], nullable: bool\n) -&gt; Tuple[Any, Any, Any]:\n    \"\"\"\n    Based on target to model to which relation leads to populates the type of the\n    pydantic field to use and type of the target column field.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param nullable: marks field as optional/ required\n    :type nullable: bool\n    :return: Tuple[List, Any]\n    :rtype: tuple with target pydantic type and target col type\n    \"\"\"\n    to_field = to.ormar_config.model_fields[to.ormar_config.pkname]\n    pk_only_model = create_dummy_model(to, to_field)\n    base_type = Union[  # type: ignore\n        to_field.__type__,  # type: ignore\n        to,  # type: ignore\n        pk_only_model,  # type: ignore\n        List[to],  # type: ignore\n        List[pk_only_model],  # type: ignore\n    ]\n    __type__ = (\n        base_type  # type: ignore\n        if not nullable\n        else Optional[base_type]  # type: ignore\n    )\n    column_type = to_field.column_type\n    return __type__, column_type, pk_only_model\n</code></pre>"},{"location":"api/fields/model_fields/","title":"model_fields","text":""},{"location":"api/fields/model_fields/#ormar.fields.model_fields.BigInteger","title":"<code>BigInteger</code>","text":"<p>               Bases: <code>Integer</code>, <code>int</code></p> <p>BigInteger field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class BigInteger(Integer, int):\n    \"\"\"\n    BigInteger field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.BigInteger()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.BigInteger.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.BigInteger()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Boolean","title":"<code>Boolean</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>int</code></p> <p>Boolean field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Boolean(ModelFieldFactory, int):\n    \"\"\"\n    Boolean field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = bool\n    _sample = True\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Boolean()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Boolean.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Boolean()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Date","title":"<code>Date</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>date</code></p> <p>Date field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Date(ModelFieldFactory, datetime.date):\n    \"\"\"\n    Date field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.date\n    _sample = \"date\"\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Date()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Date.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Date()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.DateTime","title":"<code>DateTime</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>datetime</code></p> <p>DateTime field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class DateTime(ModelFieldFactory, datetime.datetime):\n    \"\"\"\n    DateTime field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.datetime\n    _sample = \"datetime\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, timezone: bool = False, **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.DateTime(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.DateTime.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.DateTime(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Decimal","title":"<code>Decimal</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>Decimal</code></p> <p>Decimal field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Decimal(ModelFieldFactory, decimal.Decimal):\n    \"\"\"\n    Decimal field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = decimal.Decimal\n    _sample = 0.0\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        minimum: Optional[float] = None,\n        maximum: Optional[float] = None,\n        multiple_of: Optional[int] = None,\n        precision: Optional[int] = None,\n        scale: Optional[int] = None,\n        max_digits: Optional[int] = None,\n        decimal_places: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n\n        if kwargs.get(\"max_digits\"):\n            kwargs[\"precision\"] = kwargs[\"max_digits\"]\n        elif kwargs.get(\"precision\"):\n            kwargs[\"max_digits\"] = kwargs[\"precision\"]\n\n        if kwargs.get(\"decimal_places\"):\n            kwargs[\"scale\"] = kwargs[\"decimal_places\"]\n        elif kwargs.get(\"scale\"):\n            kwargs[\"decimal_places\"] = kwargs[\"scale\"]\n\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        precision = kwargs.get(\"precision\")\n        scale = kwargs.get(\"scale\")\n        return sqlalchemy.DECIMAL(precision=precision, scale=scale)\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        precision = kwargs.get(\"precision\")\n        scale = kwargs.get(\"scale\")\n        if precision is None or precision &lt; 0 or scale is None or scale &lt; 0:\n            raise ModelDefinitionError(\n                \"Parameters scale and precision are required for field Decimal\"\n            )\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Decimal.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    precision = kwargs.get(\"precision\")\n    scale = kwargs.get(\"scale\")\n    return sqlalchemy.DECIMAL(precision=precision, scale=scale)\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Decimal.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    precision = kwargs.get(\"precision\")\n    scale = kwargs.get(\"scale\")\n    if precision is None or precision &lt; 0 or scale is None or scale &lt; 0:\n        raise ModelDefinitionError(\n            \"Parameters scale and precision are required for field Decimal\"\n        )\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Enum","title":"<code>Enum</code>","text":"<p>               Bases: <code>ModelFieldFactory</code></p> <p>Enum field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Enum(ModelFieldFactory):\n    \"\"\"\n    Enum field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = E\n    _sample = None\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, enum_class: Type[E], **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        enum_class = kwargs.get(\"enum_class\")\n        if enum_class is None or not isinstance(enum_class, EnumMeta):\n            raise ModelDefinitionError(\"Enum Field choices must be EnumType\")\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        enum_cls = kwargs.get(\"enum_class\")\n        return sqlalchemy.Enum(enum_cls)\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Float","title":"<code>Float</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>float</code></p> <p>Float field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Float(ModelFieldFactory, float):\n    \"\"\"\n    Float field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = float\n    _sample = 0.0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[float] = None,\n        maximum: Optional[float] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Float()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Float.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Float()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>int</code></p> <p>Integer field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Integer(ModelFieldFactory, int):\n    \"\"\"\n    Integer field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Integer()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Integer.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Integer()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.JSON","title":"<code>JSON</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>Json</code></p> <p>JSON field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class JSON(ModelFieldFactory, pydantic.Json):\n    \"\"\"\n    JSON field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = pydantic.Json\n    _sample = '{\"json\": \"json\"}'\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.JSON(none_as_null=kwargs.get(\"sql_nullable\", False))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.JSON.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.JSON(none_as_null=kwargs.get(\"sql_nullable\", False))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.LargeBinary","title":"<code>LargeBinary</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>bytes</code></p> <p>LargeBinary field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class LargeBinary(ModelFieldFactory, bytes):\n    \"\"\"\n    LargeBinary field factory that construct Field classes\n    and populated their values.\n    \"\"\"\n\n    _type = bytes\n    _sample = \"bytes\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        max_length: int,\n        represent_as_base64_str: bool = False,\n        **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.LargeBinary(length=kwargs.get(\"max_length\"))\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        max_length = kwargs.get(\"max_length\", None)\n        if max_length &lt;= 0:\n            raise ModelDefinitionError(\n                \"Parameter max_length is required for field LargeBinary\"\n            )\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.LargeBinary.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.LargeBinary(length=kwargs.get(\"max_length\"))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.LargeBinary.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    max_length = kwargs.get(\"max_length\", None)\n    if max_length &lt;= 0:\n        raise ModelDefinitionError(\n            \"Parameter max_length is required for field LargeBinary\"\n        )\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.ModelFieldFactory","title":"<code>ModelFieldFactory</code>","text":"<p>Default field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class ModelFieldFactory:\n    \"\"\"\n    Default field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _bases: Any = (BaseField,)\n    _type: Any = None\n    _sample: Any = None\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; BaseField:  # type: ignore\n        cls.validate(**kwargs)\n\n        default = kwargs.pop(\"default\", None)\n        server_default = kwargs.pop(\"server_default\", None)\n        nullable = kwargs.pop(\"nullable\", None)\n        sql_nullable = kwargs.pop(\"sql_nullable\", None)\n\n        primary_key = kwargs.pop(\"primary_key\", False)\n        autoincrement = kwargs.pop(\"autoincrement\", False)\n\n        encrypt_secret = kwargs.pop(\"encrypt_secret\", None)\n        encrypt_backend = kwargs.pop(\"encrypt_backend\", EncryptBackends.NONE)\n        encrypt_custom_backend = kwargs.pop(\"encrypt_custom_backend\", None)\n\n        overwrite_pydantic_type = kwargs.pop(\"overwrite_pydantic_type\", None)\n\n        nullable = is_field_nullable(\n            nullable, default, server_default\n        ) or is_auto_primary_key(primary_key, autoincrement)\n        sql_nullable = (\n            False\n            if primary_key\n            else (nullable if sql_nullable is None else sql_nullable)\n        )\n\n        enum_class = kwargs.pop(\"enum_class\", None)\n        field_type = cls._type if enum_class is None else enum_class\n\n        namespace = dict(\n            __type__=field_type,\n            __pydantic_type__=(\n                overwrite_pydantic_type\n                if overwrite_pydantic_type is not None\n                else field_type\n            ),\n            __sample__=cls._sample,\n            alias=kwargs.pop(\"name\", None),\n            name=None,\n            primary_key=primary_key,\n            default=default,\n            server_default=server_default,\n            nullable=nullable,\n            annotation=field_type,\n            sql_nullable=sql_nullable,\n            index=kwargs.pop(\"index\", False),\n            unique=kwargs.pop(\"unique\", False),\n            autoincrement=autoincrement,\n            column_type=cls.get_column_type(\n                **kwargs, sql_nullable=sql_nullable, enum_class=enum_class\n            ),\n            encrypt_secret=encrypt_secret,\n            encrypt_backend=encrypt_backend,\n            encrypt_custom_backend=encrypt_custom_backend,\n            **kwargs\n        )\n        Field = type(cls.__name__, cls._bases, {})\n        return Field(**namespace)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:  # pragma no cover\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return None\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:  # pragma no cover\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.ModelFieldFactory.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:  # pragma no cover\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.ModelFieldFactory.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:  # pragma no cover\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.SmallInteger","title":"<code>SmallInteger</code>","text":"<p>               Bases: <code>Integer</code>, <code>int</code></p> <p>SmallInteger field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class SmallInteger(Integer, int):\n    \"\"\"\n    SmallInteger field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = int\n    _sample = 0\n\n    def __new__(  # type: ignore\n        cls,\n        *,\n        minimum: Optional[int] = None,\n        maximum: Optional[int] = None,\n        multiple_of: Optional[int] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:\n        autoincrement = kwargs.pop(\"autoincrement\", None)\n        autoincrement = (\n            autoincrement\n            if autoincrement is not None\n            else kwargs.get(\"primary_key\", False)\n        )\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        kwargs[\"ge\"] = kwargs[\"minimum\"]\n        kwargs[\"le\"] = kwargs[\"maximum\"]\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.SmallInteger()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.SmallInteger.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.SmallInteger()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.String","title":"<code>String</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>str</code></p> <p>String field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class String(ModelFieldFactory, str):\n    \"\"\"\n    String field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = str\n    _sample = \"string\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls,\n        *,\n        max_length: int,\n        min_length: Optional[int] = None,\n        regex: Optional[str] = None,\n        **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.String(length=kwargs.get(\"max_length\"))\n\n    @classmethod\n    def validate(cls, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Used to validate if all required parameters on a given field type are set.\n        :param kwargs: all params passed during construction\n        :type kwargs: Any\n        \"\"\"\n        max_length = kwargs.get(\"max_length\", None)\n        if max_length &lt;= 0:\n            raise ModelDefinitionError(\n                \"Parameter max_length is required for field String\"\n            )\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.String.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.String(length=kwargs.get(\"max_length\"))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.String.validate","title":"<code>validate(**kwargs)</code>  <code>classmethod</code>","text":"<p>Used to validate if all required parameters on a given field type are set. :param kwargs: all params passed during construction :type kwargs: Any</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef validate(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Used to validate if all required parameters on a given field type are set.\n    :param kwargs: all params passed during construction\n    :type kwargs: Any\n    \"\"\"\n    max_length = kwargs.get(\"max_length\", None)\n    if max_length &lt;= 0:\n        raise ModelDefinitionError(\n            \"Parameter max_length is required for field String\"\n        )\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>str</code></p> <p>Text field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Text(ModelFieldFactory, str):\n    \"\"\"\n    Text field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = str\n    _sample = \"text\"\n\n    def __new__(cls, **kwargs: Any) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Text()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Text.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Text()\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Time","title":"<code>Time</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>time</code></p> <p>Time field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class Time(ModelFieldFactory, datetime.time):\n    \"\"\"\n    Time field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = datetime.time\n    _sample = \"time\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, timezone: bool = False, **kwargs: Any\n    ) -&gt; BaseField:  # type: ignore\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        return sqlalchemy.Time(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.Time.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    return sqlalchemy.Time(timezone=kwargs.get(\"timezone\", False))\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.UUID","title":"<code>UUID</code>","text":"<p>               Bases: <code>ModelFieldFactory</code>, <code>UUID</code></p> <p>UUID field factory that construct Field classes and populated their values.</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>class UUID(ModelFieldFactory, uuid.UUID):\n    \"\"\"\n    UUID field factory that construct Field classes and populated their values.\n    \"\"\"\n\n    _type = uuid.UUID\n    _sample = \"uuid\"\n\n    def __new__(  # type: ignore # noqa CFQ002\n        cls, *, uuid_format: str = \"hex\", **kwargs: Any\n    ) -&gt; BaseField:\n        kwargs = {\n            **kwargs,\n            **{\n                k: v\n                for k, v in locals().items()\n                if k not in [\"cls\", \"__class__\", \"kwargs\"]\n            },\n        }\n\n        return super().__new__(cls, **kwargs)\n\n    @classmethod\n    def get_column_type(cls, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Return proper type of db column for given field type.\n        Accepts required and optional parameters that each column type accepts.\n\n        :param kwargs: key, value pairs of sqlalchemy options\n        :type kwargs: Any\n        :return: initialized column with proper options\n        :rtype: sqlalchemy Column\n        \"\"\"\n        uuid_format = kwargs.get(\"uuid_format\", \"hex\")\n        return sqlalchemy_uuid.UUID(uuid_format=uuid_format)\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.UUID.get_column_type","title":"<code>get_column_type(**kwargs)</code>  <code>classmethod</code>","text":"<p>Return proper type of db column for given field type. Accepts required and optional parameters that each column type accepts.</p> <p>:param kwargs: key, value pairs of sqlalchemy options :type kwargs: Any :return: initialized column with proper options :rtype: sqlalchemy Column</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>@classmethod\ndef get_column_type(cls, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Return proper type of db column for given field type.\n    Accepts required and optional parameters that each column type accepts.\n\n    :param kwargs: key, value pairs of sqlalchemy options\n    :type kwargs: Any\n    :return: initialized column with proper options\n    :rtype: sqlalchemy Column\n    \"\"\"\n    uuid_format = kwargs.get(\"uuid_format\", \"hex\")\n    return sqlalchemy_uuid.UUID(uuid_format=uuid_format)\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.is_auto_primary_key","title":"<code>is_auto_primary_key(primary_key, autoincrement)</code>","text":"<p>Checks if field is an autoincrement pk -&gt; if yes it's optional.</p> <p>:param primary_key: flag if field is a pk field :type primary_key: bool :param autoincrement: flag if field should be autoincrement :type autoincrement: bool :return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>def is_auto_primary_key(primary_key: bool, autoincrement: bool) -&gt; bool:\n    \"\"\"\n    Checks if field is an autoincrement pk -&gt; if yes it's optional.\n\n    :param primary_key: flag if field is a pk field\n    :type primary_key: bool\n    :param autoincrement: flag if field should be autoincrement\n    :type autoincrement: bool\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return primary_key and autoincrement\n</code></pre>"},{"location":"api/fields/model_fields/#ormar.fields.model_fields.is_field_nullable","title":"<code>is_field_nullable(nullable, default, server_default)</code>","text":"<p>Checks if the given field should be nullable/ optional based on parameters given.</p> <p>:param nullable: flag explicit setting a column as nullable :type nullable: Optional[bool] :param default: value or function to be called as default in python :type default: Any :param server_default: function to be called as default by sql server :type server_default: Any :return: result of the check :rtype: bool</p> Source code in <code>ormar/fields/model_fields.py</code> <pre><code>def is_field_nullable(\n    nullable: Optional[bool],\n    default: Any,\n    server_default: Any,\n) -&gt; bool:\n    \"\"\"\n    Checks if the given field should be nullable/ optional based on parameters given.\n\n    :param nullable: flag explicit setting a column as nullable\n    :type nullable: Optional[bool]\n    :param default: value or function to be called as default in python\n    :type default: Any\n    :param server_default: function to be called as default by sql server\n    :type server_default: Any\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    if nullable is None:\n        return default is not None or server_default is not None\n    return nullable\n</code></pre>"},{"location":"api/fields/parsers/","title":"parsers","text":""},{"location":"api/fields/parsers/#ormar.fields.parsers.re_dump_value","title":"<code>re_dump_value(value)</code>","text":"<p>Re-dumps value due to different string representation in orjson and json :param value: string to re-dump :type value: str :return: re-dumped value :rtype: List[str]</p> Source code in <code>ormar/fields/parsers.py</code> <pre><code>def re_dump_value(value: str) -&gt; Union[str, bytes]:\n    \"\"\"\n    Re-dumps value due to different string representation in orjson and json\n    :param value: string to re-dump\n    :type value: str\n    :return: re-dumped value\n    :rtype: List[str]\n    \"\"\"\n    try:\n        result: Union[str, bytes] = json.dumps(json.loads(value))\n    except json.JSONDecodeError:\n        result = value\n    return result\n</code></pre>"},{"location":"api/fields/referential_actions/","title":"referential_actions","text":"<p>Gathers all referential actions by ormar.</p>"},{"location":"api/fields/referential_actions/#ormar.fields.referential_actions.ReferentialAction","title":"<code>ReferentialAction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Because the database management system(DBMS) enforces referential constraints, it must ensure data integrity if rows in a referenced table are to be deleted (or updated).</p> <p>If dependent rows in referencing tables still exist, those references have to be considered.</p> <p>SQL specifies 5 different referential actions that shall take place in such occurrences.</p> Source code in <code>ormar/fields/referential_actions.py</code> <pre><code>class ReferentialAction(Enum):\n    \"\"\"\n    Because the database management system(DBMS) enforces referential constraints,\n    it must ensure data integrity\n    if rows in a referenced table are to be deleted (or updated).\n\n    If dependent rows in referencing tables still exist,\n    those references have to be considered.\n\n    SQL specifies 5 different referential actions\n    that shall take place in such occurrences.\n    \"\"\"\n\n    CASCADE: str = \"CASCADE\"\n    RESTRICT: str = \"RESTRICT\"\n    SET_NULL: str = \"SET NULL\"\n    SET_DEFAULT: str = \"SET DEFAULT\"\n    DO_NOTHING: str = \"NO ACTION\"\n</code></pre>"},{"location":"api/fields/sqlalchemy_encrypted/","title":"sqlalchemy_encrypted","text":""},{"location":"api/fields/sqlalchemy_encrypted/#ormar.fields.sqlalchemy_encrypted.EncryptedString","title":"<code>EncryptedString</code>","text":"<p>               Bases: <code>TypeDecorator</code></p> <p>Used to store encrypted values in a database</p> Source code in <code>ormar/fields/sqlalchemy_encrypted.py</code> <pre><code>class EncryptedString(types.TypeDecorator):\n    \"\"\"\n    Used to store encrypted values in a database\n    \"\"\"\n\n    impl = types.TypeEngine\n\n    def __init__(\n        self,\n        encrypt_secret: Union[str, Callable],\n        encrypt_backend: EncryptBackends = EncryptBackends.FERNET,\n        encrypt_custom_backend: Optional[Type[EncryptBackend]] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        _field_type = kwargs.pop(\"_field_type\")\n        super().__init__()\n        if not cryptography:  # pragma: nocover\n            raise ModelDefinitionError(\n                \"In order to encrypt a column 'cryptography' is required!\"\n            )\n        backend = BACKENDS_MAP.get(encrypt_backend, encrypt_custom_backend)\n        if (\n            not backend\n            or not isinstance(backend, type)\n            or not issubclass(backend, EncryptBackend)\n        ):\n            raise ModelDefinitionError(\"Wrong or no encrypt backend provided!\")\n\n        self.backend: EncryptBackend = backend()\n        self._field_type: \"BaseField\" = _field_type\n        self._underlying_type: Any = _field_type.column_type\n        self._key: Union[str, Callable] = encrypt_secret\n        type_ = self._field_type.__type__\n        if type_ is None:  # pragma: nocover\n            raise ModelDefinitionError(\n                f\"Improperly configured field \" f\"{self._field_type.name}\"\n            )\n        self.type_: Any = type_\n\n    def __repr__(self) -&gt; str:  # pragma: nocover\n        return \"TEXT()\"\n\n    def load_dialect_impl(self, dialect: Dialect) -&gt; Any:\n        return dialect.type_descriptor(types.TEXT())\n\n    def _refresh(self) -&gt; None:\n        key = self._key() if callable(self._key) else self._key\n        self.backend._refresh(key)\n\n    def process_bind_param(self, value: Any, dialect: Dialect) -&gt; Optional[str]:\n        if value is None:\n            return value\n        self._refresh()\n        try:\n            value = self._underlying_type.process_bind_param(value, dialect)\n        except AttributeError:\n            encoder, additional_parameter = self._get_coder_type_and_params(\n                coders=ormar.SQL_ENCODERS_MAP\n            )\n            if encoder is not None:\n                params = [value] + (\n                    [additional_parameter] if additional_parameter else []\n                )\n                value = encoder(*params)\n\n        encrypted_value = self.backend.encrypt(value)\n        return encrypted_value\n\n    def process_result_value(self, value: Any, dialect: Dialect) -&gt; Any:\n        if value is None:\n            return value\n        self._refresh()\n        decrypted_value = self.backend.decrypt(value)\n        try:\n            return self._underlying_type.process_result_value(decrypted_value, dialect)\n        except AttributeError:\n            decoder, additional_parameter = self._get_coder_type_and_params(\n                coders=ormar.DECODERS_MAP\n            )\n            if decoder is not None:\n                params = [decrypted_value] + (\n                    [additional_parameter] if additional_parameter else []\n                )\n                return decoder(*params)  # type: ignore\n\n            return self._field_type.__type__(decrypted_value)  # type: ignore\n\n    def _get_coder_type_and_params(\n        self, coders: Dict[type, Callable]\n    ) -&gt; Tuple[Optional[Callable], Optional[str]]:\n        coder = coders.get(self.type_, None)\n        additional_parameter: Optional[str] = None\n        if self.type_ in ADDITIONAL_PARAMETERS_MAP:\n            additional_parameter = getattr(\n                self._field_type, ADDITIONAL_PARAMETERS_MAP[self.type_]\n            )\n        return coder, additional_parameter\n</code></pre>"},{"location":"api/fields/sqlalchemy_encrypted/#ormar.fields.sqlalchemy_encrypted.FernetBackend","title":"<code>FernetBackend</code>","text":"<p>               Bases: <code>EncryptBackend</code></p> <p>Two-way encryption, data stored in db are encrypted but decrypted during query.</p> Source code in <code>ormar/fields/sqlalchemy_encrypted.py</code> <pre><code>class FernetBackend(EncryptBackend):\n    \"\"\"\n    Two-way encryption, data stored in db are encrypted but decrypted during query.\n    \"\"\"\n\n    def _initialize_backend(self, secret_key: bytes) -&gt; None:\n        self.secret_key = base64.urlsafe_b64encode(secret_key)\n        self.fernet = Fernet(self.secret_key)\n\n    def encrypt(self, value: Any) -&gt; str:\n        if not isinstance(value, str):\n            value = repr(value)\n        value = value.encode()\n        encrypted = self.fernet.encrypt(value)\n        return encrypted.decode(\"utf-8\")\n\n    def decrypt(self, value: Any) -&gt; str:\n        if not isinstance(value, str):  # pragma: nocover\n            value = str(value)\n        decrypted: Union[str, bytes] = self.fernet.decrypt(value.encode())\n        if not isinstance(decrypted, str):\n            decrypted = decrypted.decode(\"utf-8\")\n        return decrypted\n</code></pre>"},{"location":"api/fields/sqlalchemy_encrypted/#ormar.fields.sqlalchemy_encrypted.HashBackend","title":"<code>HashBackend</code>","text":"<p>               Bases: <code>EncryptBackend</code></p> <p>One-way hashing - in example for passwords, no way to decrypt the value!</p> Source code in <code>ormar/fields/sqlalchemy_encrypted.py</code> <pre><code>class HashBackend(EncryptBackend):\n    \"\"\"\n    One-way hashing - in example for passwords, no way to decrypt the value!\n    \"\"\"\n\n    def _initialize_backend(self, secret_key: bytes) -&gt; None:\n        self.secret_key = base64.urlsafe_b64encode(secret_key)\n\n    def encrypt(self, value: Any) -&gt; str:\n        if not isinstance(value, str):  # pragma: nocover\n            value = repr(value)\n        value = value.encode()\n        digest = hashes.Hash(hashes.SHA512(), backend=default_backend())\n        digest.update(self.secret_key)\n        digest.update(value)\n        hashed_value = digest.finalize()\n        return hashed_value.hex()\n\n    def decrypt(self, value: Any) -&gt; str:\n        if not isinstance(value, str):  # pragma: nocover\n            value = str(value)\n        return value\n</code></pre>"},{"location":"api/fields/sqlalchemy_uuid/","title":"sqlalchemy_uuid","text":""},{"location":"api/fields/sqlalchemy_uuid/#ormar.fields.sqlalchemy_uuid.UUID","title":"<code>UUID</code>","text":"<p>               Bases: <code>TypeDecorator</code></p> <p>Platform-independent GUID type. Uses CHAR(36) if in a string mode, otherwise uses CHAR(32), to store UUID.</p> <p>For details for different methods check documentation of parent class.</p> Source code in <code>ormar/fields/sqlalchemy_uuid.py</code> <pre><code>class UUID(TypeDecorator):\n    \"\"\"\n    Platform-independent GUID type.\n    Uses CHAR(36) if in a string mode, otherwise uses CHAR(32), to store UUID.\n\n    For details for different methods check documentation of parent class.\n    \"\"\"\n\n    impl = CHAR\n\n    def __init__(self, *args: Any, uuid_format: str = \"hex\", **kwargs: Any) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.uuid_format = uuid_format\n\n    def __repr__(self) -&gt; str:  # pragma: nocover\n        if self.uuid_format == \"string\":\n            return \"CHAR(36)\"\n        return \"CHAR(32)\"\n\n    def load_dialect_impl(self, dialect: Dialect) -&gt; Any:\n        return (\n            dialect.type_descriptor(CHAR(36))\n            if self.uuid_format == \"string\"\n            else dialect.type_descriptor(CHAR(32))\n        )\n\n    def process_bind_param(self, value: uuid.UUID, dialect: Dialect) -&gt; Optional[str]:\n        if value is None:\n            return value\n        return str(value) if self.uuid_format == \"string\" else \"%.32x\" % value.int\n\n    def process_result_value(\n        self, value: Optional[str], dialect: Dialect\n    ) -&gt; Optional[uuid.UUID]:\n        if value is None:\n            return value\n        if not isinstance(value, uuid.UUID):\n            return uuid.UUID(value)\n        return value  # pragma: nocover\n</code></pre>"},{"location":"api/fields/through_field/","title":"through_field","text":""},{"location":"api/fields/through_field/#ormar.fields.through_field.ThroughField","title":"<code>ThroughField</code>","text":"<p>               Bases: <code>ForeignKeyField</code></p> <p>Field class used to access ManyToMany model through model.</p> Source code in <code>ormar/fields/through_field.py</code> <pre><code>class ThroughField(ForeignKeyField):\n    \"\"\"\n    Field class used to access ManyToMany model through model.\n    \"\"\"\n</code></pre>"},{"location":"api/fields/through_field/#ormar.fields.through_field.Through","title":"<code>Through(to, *, name=None, related_name=None, **kwargs)</code>","text":"<p>Despite a name it's a function that returns constructed ThroughField. It's a special field populated only for m2m relations. Accepts number of relation setting parameters as well as all BaseField ones.</p> <p>:param to: target related ormar Model :type to: Model class :param name: name of the database field - later called alias :type name: str :param related_name: name of reversed FK relation populated for you on to model :type related_name: str It is for reversed FK and auto generated FK on through model in Many2Many relations. :param kwargs: all other args to be populated by BaseField :type kwargs: Any :return: ormar ForeignKeyField with relation to selected model :rtype: ForeignKeyField</p> Source code in <code>ormar/fields/through_field.py</code> <pre><code>def Through(  # noqa CFQ002\n    to: \"ToType\",\n    *,\n    name: Optional[str] = None,\n    related_name: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Any:\n    \"\"\"\n    Despite a name it's a function that returns constructed ThroughField.\n    It's a special field populated only for m2m relations.\n    Accepts number of relation setting parameters as well as all BaseField ones.\n\n    :param to: target related ormar Model\n    :type to: Model class\n    :param name: name of the database field - later called alias\n    :type name: str\n    :param related_name: name of reversed FK relation populated for you on to model\n    :type related_name: str\n    It is for reversed FK and auto generated FK on through model in Many2Many relations.\n    :param kwargs: all other args to be populated by BaseField\n    :type kwargs: Any\n    :return: ormar ForeignKeyField with relation to selected model\n    :rtype: ForeignKeyField\n    \"\"\"\n    nullable = kwargs.pop(\"nullable\", False)\n    owner = kwargs.pop(\"owner\", None)\n    namespace = dict(\n        __type__=to,\n        to=to,\n        through=None,\n        alias=name,\n        name=kwargs.pop(\"real_name\", None),\n        related_name=related_name,\n        virtual=True,\n        owner=owner,\n        nullable=nullable,\n        unique=False,\n        column_type=None,\n        primary_key=False,\n        index=False,\n        default=None,\n        server_default=None,\n        is_relation=True,\n        is_through=True,\n    )\n\n    Field = type(\"Through\", (ThroughField, BaseField), {})\n    return Field(**namespace)\n</code></pre>"},{"location":"api/models/","title":"models","text":"<p>Definition of Model, it's parents NewBaseModel and mixins used by models. Also defines a Metaclass that handles all constructions and relations registration, ass well as vast number of helper functions for pydantic, sqlalchemy and relations.</p>"},{"location":"api/models/#ormar.models.ExcludableItems","title":"<code>ExcludableItems</code>","text":"<p>Keeps a dictionary of Excludables by alias + model_name keys to allow quick lookup by nested models without need to travers deeply nested dictionaries and passing include/exclude around</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>class ExcludableItems:\n    \"\"\"\n    Keeps a dictionary of Excludables by alias + model_name keys\n    to allow quick lookup by nested models without need to travers\n    deeply nested dictionaries and passing include/exclude around\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.items: Dict[str, Excludable] = dict()\n\n    @classmethod\n    def from_excludable(cls, other: \"ExcludableItems\") -&gt; \"ExcludableItems\":\n        \"\"\"\n        Copy passed ExcludableItems to avoid inplace modifications.\n\n        :param other: other excludable items to be copied\n        :type other: ormar.models.excludable.ExcludableItems\n        :return: copy of other\n        :rtype: ormar.models.excludable.ExcludableItems\n        \"\"\"\n        new_excludable = cls()\n        for key, value in other.items.items():\n            new_excludable.items[key] = value.get_copy()\n        return new_excludable\n\n    def include_entry_count(self) -&gt; int:\n        \"\"\"\n        Returns count of include items inside\n        \"\"\"\n        count = 0\n        for key in self.items.keys():\n            count += len(self.items[key].include)\n        return count\n\n    def get(self, model_cls: Type[\"Model\"], alias: str = \"\") -&gt; Excludable:\n        \"\"\"\n        Return Excludable for given model and alias.\n\n        :param model_cls: target model to check\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param alias: table alias from relation manager\n        :type alias: str\n        :return: Excludable for given model and alias\n        :rtype: ormar.models.excludable.Excludable\n        \"\"\"\n        key = f\"{alias + '_' if alias else ''}{model_cls.get_name(lower=True)}\"\n        excludable = self.items.get(key)\n        if not excludable:\n            excludable = Excludable()\n            self.items[key] = excludable\n        return excludable\n\n    def build(\n        self,\n        items: Union[List[str], str, Tuple[str], Set[str], Dict],\n        model_cls: Type[\"Model\"],\n        is_exclude: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Receives the one of the types of items and parses them as to achieve\n        a end situation with one excludable per alias/model in relation.\n\n        Each excludable has two sets of values - one to include, one to exclude.\n\n        :param items: values to be included or excluded\n        :type items: Union[List[str], str, Tuple[str], Set[str], Dict]\n        :param model_cls: source model from which relations are constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if items should be included or excluded\n        :type is_exclude: bool\n        \"\"\"\n        if isinstance(items, str):\n            items = {items}\n\n        if isinstance(items, Dict):\n            self._traverse_dict(\n                values=items,\n                source_model=model_cls,\n                model_cls=model_cls,\n                is_exclude=is_exclude,\n            )\n\n        else:\n            items = set(items)\n            nested_items = set(x for x in items if \"__\" in x)\n            items.difference_update(nested_items)\n            self._set_excludes(\n                items=items,\n                model_name=model_cls.get_name(lower=True),\n                is_exclude=is_exclude,\n            )\n            if nested_items:\n                self._traverse_list(\n                    values=nested_items, model_cls=model_cls, is_exclude=is_exclude\n                )\n\n    def _set_excludes(\n        self, items: Set, model_name: str, is_exclude: bool, alias: str = \"\"\n    ) -&gt; None:\n        \"\"\"\n        Sets set of values to be included or excluded for given key and model.\n\n        :param items: items to include/exclude\n        :type items: set\n        :param model_name: name of model to construct key\n        :type model_name: str\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        :param alias:\n        :type alias: str\n        \"\"\"\n        key = f\"{alias + '_' if alias else ''}{model_name}\"\n        excludable = self.items.get(key)\n        if not excludable:\n            excludable = Excludable()\n        excludable.set_values(value=items, is_exclude=is_exclude)\n        self.items[key] = excludable\n\n    def _traverse_dict(  # noqa: CFQ002\n        self,\n        values: Dict,\n        source_model: Type[\"Model\"],\n        model_cls: Type[\"Model\"],\n        is_exclude: bool,\n        related_items: Optional[List] = None,\n        alias: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Goes through dict of nested values and construct/update Excludables.\n\n        :param values: items to include/exclude\n        :type values: Dict\n        :param source_model: source model from which relations are constructed\n        :type source_model: ormar.models.metaclass.ModelMetaclass\n        :param model_cls: model from which current relation is constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        :param related_items: list of names of related fields chain\n        :type related_items: List\n        :param alias: alias of relation\n        :type alias: str\n        \"\"\"\n        self_fields = set()\n        related_items = related_items[:] if related_items else []\n        for key, value in values.items():\n            if value is ...:\n                self_fields.add(key)\n            elif isinstance(value, set):\n                (\n                    table_prefix,\n                    target_model,\n                    _,\n                    _,\n                ) = get_relationship_alias_model_and_str(\n                    source_model=source_model, related_parts=related_items + [key]\n                )\n                self._set_excludes(\n                    items=value,\n                    model_name=target_model.get_name(),\n                    is_exclude=is_exclude,\n                    alias=table_prefix,\n                )\n            else:\n                # dict\n                related_items.append(key)\n                (\n                    table_prefix,\n                    target_model,\n                    _,\n                    _,\n                ) = get_relationship_alias_model_and_str(\n                    source_model=source_model, related_parts=related_items\n                )\n                self._traverse_dict(\n                    values=value,\n                    source_model=source_model,\n                    model_cls=target_model,\n                    is_exclude=is_exclude,\n                    related_items=related_items,\n                    alias=table_prefix,\n                )\n        if self_fields:\n            self._set_excludes(\n                items=self_fields,\n                model_name=model_cls.get_name(),\n                is_exclude=is_exclude,\n                alias=alias,\n            )\n\n    def _traverse_list(\n        self, values: Set[str], model_cls: Type[\"Model\"], is_exclude: bool\n    ) -&gt; None:\n        \"\"\"\n        Goes through list of values and construct/update Excludables.\n\n        :param values: items to include/exclude\n        :type values: set\n        :param model_cls: model from which current relation is constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        \"\"\"\n        # here we have only nested related keys\n        for key in values:\n            key_split = key.split(\"__\")\n            related_items, field_name = key_split[:-1], key_split[-1]\n            (table_prefix, target_model, _, _) = get_relationship_alias_model_and_str(\n                source_model=model_cls, related_parts=related_items\n            )\n            self._set_excludes(\n                items={field_name},\n                model_name=target_model.get_name(),\n                is_exclude=is_exclude,\n                alias=table_prefix,\n            )\n</code></pre>"},{"location":"api/models/#ormar.models.ExcludableItems.build","title":"<code>build(items, model_cls, is_exclude=False)</code>","text":"<p>Receives the one of the types of items and parses them as to achieve a end situation with one excludable per alias/model in relation.</p> <p>Each excludable has two sets of values - one to include, one to exclude.</p> <p>:param items: values to be included or excluded :type items: Union[List[str], str, Tuple[str], Set[str], Dict] :param model_cls: source model from which relations are constructed :type model_cls: ormar.models.metaclass.ModelMetaclass :param is_exclude: flag if items should be included or excluded :type is_exclude: bool</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def build(\n    self,\n    items: Union[List[str], str, Tuple[str], Set[str], Dict],\n    model_cls: Type[\"Model\"],\n    is_exclude: bool = False,\n) -&gt; None:\n    \"\"\"\n    Receives the one of the types of items and parses them as to achieve\n    a end situation with one excludable per alias/model in relation.\n\n    Each excludable has two sets of values - one to include, one to exclude.\n\n    :param items: values to be included or excluded\n    :type items: Union[List[str], str, Tuple[str], Set[str], Dict]\n    :param model_cls: source model from which relations are constructed\n    :type model_cls: ormar.models.metaclass.ModelMetaclass\n    :param is_exclude: flag if items should be included or excluded\n    :type is_exclude: bool\n    \"\"\"\n    if isinstance(items, str):\n        items = {items}\n\n    if isinstance(items, Dict):\n        self._traverse_dict(\n            values=items,\n            source_model=model_cls,\n            model_cls=model_cls,\n            is_exclude=is_exclude,\n        )\n\n    else:\n        items = set(items)\n        nested_items = set(x for x in items if \"__\" in x)\n        items.difference_update(nested_items)\n        self._set_excludes(\n            items=items,\n            model_name=model_cls.get_name(lower=True),\n            is_exclude=is_exclude,\n        )\n        if nested_items:\n            self._traverse_list(\n                values=nested_items, model_cls=model_cls, is_exclude=is_exclude\n            )\n</code></pre>"},{"location":"api/models/#ormar.models.ExcludableItems.from_excludable","title":"<code>from_excludable(other)</code>  <code>classmethod</code>","text":"<p>Copy passed ExcludableItems to avoid inplace modifications.</p> <p>:param other: other excludable items to be copied :type other: ormar.models.excludable.ExcludableItems :return: copy of other :rtype: ormar.models.excludable.ExcludableItems</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>@classmethod\ndef from_excludable(cls, other: \"ExcludableItems\") -&gt; \"ExcludableItems\":\n    \"\"\"\n    Copy passed ExcludableItems to avoid inplace modifications.\n\n    :param other: other excludable items to be copied\n    :type other: ormar.models.excludable.ExcludableItems\n    :return: copy of other\n    :rtype: ormar.models.excludable.ExcludableItems\n    \"\"\"\n    new_excludable = cls()\n    for key, value in other.items.items():\n        new_excludable.items[key] = value.get_copy()\n    return new_excludable\n</code></pre>"},{"location":"api/models/#ormar.models.ExcludableItems.get","title":"<code>get(model_cls, alias='')</code>","text":"<p>Return Excludable for given model and alias.</p> <p>:param model_cls: target model to check :type model_cls: ormar.models.metaclass.ModelMetaclass :param alias: table alias from relation manager :type alias: str :return: Excludable for given model and alias :rtype: ormar.models.excludable.Excludable</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def get(self, model_cls: Type[\"Model\"], alias: str = \"\") -&gt; Excludable:\n    \"\"\"\n    Return Excludable for given model and alias.\n\n    :param model_cls: target model to check\n    :type model_cls: ormar.models.metaclass.ModelMetaclass\n    :param alias: table alias from relation manager\n    :type alias: str\n    :return: Excludable for given model and alias\n    :rtype: ormar.models.excludable.Excludable\n    \"\"\"\n    key = f\"{alias + '_' if alias else ''}{model_cls.get_name(lower=True)}\"\n    excludable = self.items.get(key)\n    if not excludable:\n        excludable = Excludable()\n        self.items[key] = excludable\n    return excludable\n</code></pre>"},{"location":"api/models/#ormar.models.ExcludableItems.include_entry_count","title":"<code>include_entry_count()</code>","text":"<p>Returns count of include items inside</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def include_entry_count(self) -&gt; int:\n    \"\"\"\n    Returns count of include items inside\n    \"\"\"\n    count = 0\n    for key in self.items.keys():\n        count += len(self.items[key].include)\n    return count\n</code></pre>"},{"location":"api/models/#ormar.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>ModelRow</code></p> Source code in <code>ormar/models/model.py</code> <pre><code>class Model(ModelRow):\n    __abstract__ = False\n    if TYPE_CHECKING:  # pragma nocover\n        ormar_config: OrmarConfig\n\n    def __repr__(self) -&gt; str:  # pragma nocover\n        _repr = {\n            k: getattr(self, k)\n            for k, v in self.ormar_config.model_fields.items()\n            if not v.skip_field\n        }\n        return f\"{self.__class__.__name__}({str(_repr)})\"\n\n    async def upsert(self: T, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Performs either a save or an update depending on the presence of the pk.\n        If the pk field is filled it's an update, otherwise the save is performed.\n        For save kwargs are ignored, used only in update if provided.\n\n        :param kwargs: list of fields to update\n        :type kwargs: Any\n        :return: saved Model\n        :rtype: Model\n        \"\"\"\n\n        force_save = kwargs.pop(\"__force_save__\", False)\n        if force_save:\n            expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n            row = await self.ormar_config.database.fetch_one(expr)\n            if not row:\n                return await self.save()\n            return await self.update(**kwargs)\n\n        if not self.pk:\n            return await self.save()\n        return await self.update(**kwargs)\n\n    async def save(self: T) -&gt; T:\n        \"\"\"\n        Performs a save of given Model instance.\n        If primary key is already saved, db backend will throw integrity error.\n\n        Related models are saved by pk number, reverse relation and many to many fields\n        are not saved - use corresponding relations methods.\n\n        If there are fields with server_default set and those fields\n        are not already filled save will trigger also a second query\n        to refreshed the fields populated server side.\n\n        Does not recognize if model was previously saved.\n        If you want to perform update or insert depending on the pk\n        fields presence use upsert.\n\n        Sends pre_save and post_save signals.\n\n        Sets model save status to True.\n\n        :return: saved Model\n        :rtype: Model\n        \"\"\"\n        await self.signals.pre_save.send(sender=self.__class__, instance=self)\n        self_fields = self._extract_model_db_fields()\n\n        if (\n            not self.pk\n            and self.ormar_config.model_fields[self.ormar_config.pkname].autoincrement\n        ):\n            self_fields.pop(self.ormar_config.pkname, None)\n        self_fields = self.populate_default_values(self_fields)\n        self.update_from_dict(\n            {\n                k: v\n                for k, v in self_fields.items()\n                if k not in self.extract_related_names()\n            }\n        )\n\n        self_fields = self.translate_columns_to_aliases(self_fields)\n        expr = self.ormar_config.table.insert()\n        expr = expr.values(**self_fields)\n\n        pk = await self.ormar_config.database.execute(expr)\n        if pk and isinstance(pk, self.pk_type()):\n            setattr(self, self.ormar_config.pkname, pk)\n\n        self.set_save_status(True)\n        # refresh server side defaults\n        if any(\n            field.server_default is not None\n            for name, field in self.ormar_config.model_fields.items()\n            if name not in self_fields\n        ):\n            await self.load()\n\n        await self.signals.post_save.send(sender=self.__class__, instance=self)\n        return self\n\n    async def save_related(  # noqa: CCR001, CFQ002\n        self,\n        follow: bool = False,\n        save_all: bool = False,\n        relation_map: Optional[Dict] = None,\n        exclude: Union[Set, Dict, None] = None,\n        update_count: int = 0,\n        previous_model: Optional[\"Model\"] = None,\n        relation_field: Optional[\"ForeignKeyField\"] = None,\n    ) -&gt; int:\n        \"\"\"\n        Triggers a upsert method on all related models\n        if the instances are not already saved.\n        By default saves only the directly related ones.\n\n        If follow=True is set it saves also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are saved, but the save do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second\n        Model A but will never follow into Model C.\n        Nested relations of those kind need to be persisted manually.\n\n        :param relation_field: field with relation leading to this model\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        :param exclude: items to exclude during saving of relations\n        :type exclude: Union[Set, Dict]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :param save_all: flag if all models should be saved or only not saved ones\n        :type save_all: bool\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :param update_count: internal parameter for recursive calls -\n        number of updated instances\n        :type update_count: int\n        :return: number of updated/saved models\n        :rtype: int\n        \"\"\"\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(self._iterate_related_models())\n        )\n        if exclude and isinstance(exclude, Set):\n            exclude = translate_list_to_dict(exclude)\n        relation_map = subtract_dict(relation_map, exclude or {})\n\n        if relation_map:\n            fields_to_visit = {\n                field\n                for field in self.extract_related_fields()\n                if field.name in relation_map\n            }\n            pre_save = {\n                field\n                for field in fields_to_visit\n                if not field.virtual and not field.is_multi\n            }\n\n            update_count = await self._update_relation_list(\n                fields_list=pre_save,\n                follow=follow,\n                save_all=save_all,\n                relation_map=relation_map,\n                update_count=update_count,\n            )\n\n            update_count = await self._upsert_model(\n                instance=self,\n                save_all=save_all,\n                previous_model=previous_model,\n                relation_field=relation_field,\n                update_count=update_count,\n            )\n\n            post_save = fields_to_visit - pre_save\n\n            update_count = await self._update_relation_list(\n                fields_list=post_save,\n                follow=follow,\n                save_all=save_all,\n                relation_map=relation_map,\n                update_count=update_count,\n            )\n\n        else:\n            update_count = await self._upsert_model(\n                instance=self,\n                save_all=save_all,\n                previous_model=previous_model,\n                relation_field=relation_field,\n                update_count=update_count,\n            )\n\n        return update_count\n\n    async def update(self: T, _columns: Optional[List[str]] = None, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Performs update of Model instance in the database.\n        Fields can be updated before or you can pass them as kwargs.\n\n        Sends pre_update and post_update signals.\n\n        Sets model save status to True.\n\n        :param _columns: list of columns to update, if None all are updated\n        :type _columns: List\n        :raises ModelPersistenceError: If the pk column is not set\n\n        :param kwargs: list of fields to update as field=value pairs\n        :type kwargs: Any\n        :return: updated Model\n        :rtype: Model\n        \"\"\"\n        if kwargs:\n            self.update_from_dict(kwargs)\n\n        if not self.pk:\n            raise ModelPersistenceError(\n                \"You cannot update not saved model! Use save or upsert method.\"\n            )\n\n        await self.signals.pre_update.send(\n            sender=self.__class__, instance=self, passed_args=kwargs\n        )\n        self_fields = self._extract_model_db_fields()\n        self_fields.pop(self.get_column_name_from_alias(self.ormar_config.pkname))\n        if _columns:\n            self_fields = {k: v for k, v in self_fields.items() if k in _columns}\n        if self_fields:\n            self_fields = self.translate_columns_to_aliases(self_fields)\n            expr = self.ormar_config.table.update().values(**self_fields)\n            expr = expr.where(self.pk_column == getattr(self, self.ormar_config.pkname))\n\n            await self.ormar_config.database.execute(expr)\n        self.set_save_status(True)\n        await self.signals.post_update.send(sender=self.__class__, instance=self)\n        return self\n\n    async def delete(self) -&gt; int:\n        \"\"\"\n        Removes the Model instance from the database.\n\n        Sends pre_delete and post_delete signals.\n\n        Sets model save status to False.\n\n        Note it does not delete the Model itself (python object).\n        So you can delete and later save (since pk is deleted no conflict will arise)\n        or update and the Model will be saved in database again.\n\n        :return: number of deleted rows (for some backends)\n        :rtype: int\n        \"\"\"\n        await self.signals.pre_delete.send(sender=self.__class__, instance=self)\n        expr = self.ormar_config.table.delete()\n        expr = expr.where(self.pk_column == (getattr(self, self.ormar_config.pkname)))\n        result = await self.ormar_config.database.execute(expr)\n        self.set_save_status(False)\n        await self.signals.post_delete.send(sender=self.__class__, instance=self)\n        return result\n\n    async def load(self: T) -&gt; T:\n        \"\"\"\n        Allow to refresh existing Models fields from database.\n        Be careful as the related models can be overwritten by pk_only models in load.\n        Does NOT refresh the related models fields if they were loaded before.\n\n        :raises NoMatch: If given pk is not found in database.\n\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n        row = await self.ormar_config.database.fetch_one(expr)\n        if not row:  # pragma nocover\n            raise NoMatch(\"Instance was deleted from database and cannot be refreshed\")\n        kwargs = dict(row)\n        kwargs = self.translate_aliases_to_columns(kwargs)\n        self.update_from_dict(kwargs)\n        self.set_save_status(True)\n        return self\n\n    async def load_all(\n        self: T,\n        follow: bool = False,\n        exclude: Union[List, str, Set, Dict, None] = None,\n        order_by: Union[List, str, None] = None,\n    ) -&gt; T:\n        \"\"\"\n        Allow to refresh existing Models fields from database.\n        Performs refresh of the related models fields.\n\n        By default, loads only self and the directly related ones.\n\n        If follow=True is set it loads also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param order_by: columns by which models should be sorted\n        :type order_by: Union[List, str]\n        :raises NoMatch: If given pk is not found in database.\n\n        :param exclude: related models to exclude\n        :type exclude: Union[List, str, Set, Dict]\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        relations = list(self.extract_related_names())\n        if follow:\n            relations = self._iterate_related_models()\n        queryset = self.__class__.objects\n        if exclude:\n            queryset = queryset.exclude_fields(exclude)\n        if order_by:\n            queryset = queryset.order_by(order_by)\n        instance = await queryset.select_related(relations).get(pk=self.pk)\n        self._orm.clear()\n        self.update_from_dict(instance.model_dump())\n        return self\n</code></pre>"},{"location":"api/models/#ormar.models.Model.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Removes the Model instance from the database.</p> <p>Sends pre_delete and post_delete signals.</p> <p>Sets model save status to False.</p> <p>Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again.</p> <p>:return: number of deleted rows (for some backends) :rtype: int</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def delete(self) -&gt; int:\n    \"\"\"\n    Removes the Model instance from the database.\n\n    Sends pre_delete and post_delete signals.\n\n    Sets model save status to False.\n\n    Note it does not delete the Model itself (python object).\n    So you can delete and later save (since pk is deleted no conflict will arise)\n    or update and the Model will be saved in database again.\n\n    :return: number of deleted rows (for some backends)\n    :rtype: int\n    \"\"\"\n    await self.signals.pre_delete.send(sender=self.__class__, instance=self)\n    expr = self.ormar_config.table.delete()\n    expr = expr.where(self.pk_column == (getattr(self, self.ormar_config.pkname)))\n    result = await self.ormar_config.database.execute(expr)\n    self.set_save_status(False)\n    await self.signals.post_delete.send(sender=self.__class__, instance=self)\n    return result\n</code></pre>"},{"location":"api/models/#ormar.models.Model.load","title":"<code>load()</code>  <code>async</code>","text":"<p>Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before.</p> <p>:raises NoMatch: If given pk is not found in database.</p> <p>:return: reloaded Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def load(self: T) -&gt; T:\n    \"\"\"\n    Allow to refresh existing Models fields from database.\n    Be careful as the related models can be overwritten by pk_only models in load.\n    Does NOT refresh the related models fields if they were loaded before.\n\n    :raises NoMatch: If given pk is not found in database.\n\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n    row = await self.ormar_config.database.fetch_one(expr)\n    if not row:  # pragma nocover\n        raise NoMatch(\"Instance was deleted from database and cannot be refreshed\")\n    kwargs = dict(row)\n    kwargs = self.translate_aliases_to_columns(kwargs)\n    self.update_from_dict(kwargs)\n    self.set_save_status(True)\n    return self\n</code></pre>"},{"location":"api/models/#ormar.models.Model.load_all","title":"<code>load_all(follow=False, exclude=None, order_by=None)</code>  <code>async</code>","text":"<p>Allow to refresh existing Models fields from database. Performs refresh of the related models fields.</p> <p>By default, loads only self and the directly related ones.</p> <p>If follow=True is set it loads also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param order_by: columns by which models should be sorted :type order_by: Union[List, str] :raises NoMatch: If given pk is not found in database.</p> <p>:param exclude: related models to exclude :type exclude: Union[List, str, Set, Dict] :param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def load_all(\n    self: T,\n    follow: bool = False,\n    exclude: Union[List, str, Set, Dict, None] = None,\n    order_by: Union[List, str, None] = None,\n) -&gt; T:\n    \"\"\"\n    Allow to refresh existing Models fields from database.\n    Performs refresh of the related models fields.\n\n    By default, loads only self and the directly related ones.\n\n    If follow=True is set it loads also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param order_by: columns by which models should be sorted\n    :type order_by: Union[List, str]\n    :raises NoMatch: If given pk is not found in database.\n\n    :param exclude: related models to exclude\n    :type exclude: Union[List, str, Set, Dict]\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    relations = list(self.extract_related_names())\n    if follow:\n        relations = self._iterate_related_models()\n    queryset = self.__class__.objects\n    if exclude:\n        queryset = queryset.exclude_fields(exclude)\n    if order_by:\n        queryset = queryset.order_by(order_by)\n    instance = await queryset.select_related(relations).get(pk=self.pk)\n    self._orm.clear()\n    self.update_from_dict(instance.model_dump())\n    return self\n</code></pre>"},{"location":"api/models/#ormar.models.Model.save","title":"<code>save()</code>  <code>async</code>","text":"<p>Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error.</p> <p>Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods.</p> <p>If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side.</p> <p>Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert.</p> <p>Sends pre_save and post_save signals.</p> <p>Sets model save status to True.</p> <p>:return: saved Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def save(self: T) -&gt; T:\n    \"\"\"\n    Performs a save of given Model instance.\n    If primary key is already saved, db backend will throw integrity error.\n\n    Related models are saved by pk number, reverse relation and many to many fields\n    are not saved - use corresponding relations methods.\n\n    If there are fields with server_default set and those fields\n    are not already filled save will trigger also a second query\n    to refreshed the fields populated server side.\n\n    Does not recognize if model was previously saved.\n    If you want to perform update or insert depending on the pk\n    fields presence use upsert.\n\n    Sends pre_save and post_save signals.\n\n    Sets model save status to True.\n\n    :return: saved Model\n    :rtype: Model\n    \"\"\"\n    await self.signals.pre_save.send(sender=self.__class__, instance=self)\n    self_fields = self._extract_model_db_fields()\n\n    if (\n        not self.pk\n        and self.ormar_config.model_fields[self.ormar_config.pkname].autoincrement\n    ):\n        self_fields.pop(self.ormar_config.pkname, None)\n    self_fields = self.populate_default_values(self_fields)\n    self.update_from_dict(\n        {\n            k: v\n            for k, v in self_fields.items()\n            if k not in self.extract_related_names()\n        }\n    )\n\n    self_fields = self.translate_columns_to_aliases(self_fields)\n    expr = self.ormar_config.table.insert()\n    expr = expr.values(**self_fields)\n\n    pk = await self.ormar_config.database.execute(expr)\n    if pk and isinstance(pk, self.pk_type()):\n        setattr(self, self.ormar_config.pkname, pk)\n\n    self.set_save_status(True)\n    # refresh server side defaults\n    if any(\n        field.server_default is not None\n        for name, field in self.ormar_config.model_fields.items()\n        if name not in self_fields\n    ):\n        await self.load()\n\n    await self.signals.post_save.send(sender=self.__class__, instance=self)\n    return self\n</code></pre>"},{"location":"api/models/#ormar.models.Model.save_related","title":"<code>save_related(follow=False, save_all=False, relation_map=None, exclude=None, update_count=0, previous_model=None, relation_field=None)</code>  <code>async</code>","text":"<p>Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones.</p> <p>If follow=True is set it saves also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually.</p> <p>:param relation_field: field with relation leading to this model :type relation_field: Optional[ForeignKeyField] :param previous_model: previous model from which method came :type previous_model: Model :param exclude: items to exclude during saving of relations :type exclude: Union[Set, Dict] :param relation_map: map of relations to follow :type relation_map: Dict :param save_all: flag if all models should be saved or only not saved ones :type save_all: bool :param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :param update_count: internal parameter for recursive calls - number of updated instances :type update_count: int :return: number of updated/saved models :rtype: int</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def save_related(  # noqa: CCR001, CFQ002\n    self,\n    follow: bool = False,\n    save_all: bool = False,\n    relation_map: Optional[Dict] = None,\n    exclude: Union[Set, Dict, None] = None,\n    update_count: int = 0,\n    previous_model: Optional[\"Model\"] = None,\n    relation_field: Optional[\"ForeignKeyField\"] = None,\n) -&gt; int:\n    \"\"\"\n    Triggers a upsert method on all related models\n    if the instances are not already saved.\n    By default saves only the directly related ones.\n\n    If follow=True is set it saves also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are saved, but the save do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second\n    Model A but will never follow into Model C.\n    Nested relations of those kind need to be persisted manually.\n\n    :param relation_field: field with relation leading to this model\n    :type relation_field: Optional[ForeignKeyField]\n    :param previous_model: previous model from which method came\n    :type previous_model: Model\n    :param exclude: items to exclude during saving of relations\n    :type exclude: Union[Set, Dict]\n    :param relation_map: map of relations to follow\n    :type relation_map: Dict\n    :param save_all: flag if all models should be saved or only not saved ones\n    :type save_all: bool\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :param update_count: internal parameter for recursive calls -\n    number of updated instances\n    :type update_count: int\n    :return: number of updated/saved models\n    :rtype: int\n    \"\"\"\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(self._iterate_related_models())\n    )\n    if exclude and isinstance(exclude, Set):\n        exclude = translate_list_to_dict(exclude)\n    relation_map = subtract_dict(relation_map, exclude or {})\n\n    if relation_map:\n        fields_to_visit = {\n            field\n            for field in self.extract_related_fields()\n            if field.name in relation_map\n        }\n        pre_save = {\n            field\n            for field in fields_to_visit\n            if not field.virtual and not field.is_multi\n        }\n\n        update_count = await self._update_relation_list(\n            fields_list=pre_save,\n            follow=follow,\n            save_all=save_all,\n            relation_map=relation_map,\n            update_count=update_count,\n        )\n\n        update_count = await self._upsert_model(\n            instance=self,\n            save_all=save_all,\n            previous_model=previous_model,\n            relation_field=relation_field,\n            update_count=update_count,\n        )\n\n        post_save = fields_to_visit - pre_save\n\n        update_count = await self._update_relation_list(\n            fields_list=post_save,\n            follow=follow,\n            save_all=save_all,\n            relation_map=relation_map,\n            update_count=update_count,\n        )\n\n    else:\n        update_count = await self._upsert_model(\n            instance=self,\n            save_all=save_all,\n            previous_model=previous_model,\n            relation_field=relation_field,\n            update_count=update_count,\n        )\n\n    return update_count\n</code></pre>"},{"location":"api/models/#ormar.models.Model.update","title":"<code>update(_columns=None, **kwargs)</code>  <code>async</code>","text":"<p>Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs.</p> <p>Sends pre_update and post_update signals.</p> <p>Sets model save status to True.</p> <p>:param _columns: list of columns to update, if None all are updated :type _columns: List :raises ModelPersistenceError: If the pk column is not set</p> <p>:param kwargs: list of fields to update as field=value pairs :type kwargs: Any :return: updated Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def update(self: T, _columns: Optional[List[str]] = None, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Performs update of Model instance in the database.\n    Fields can be updated before or you can pass them as kwargs.\n\n    Sends pre_update and post_update signals.\n\n    Sets model save status to True.\n\n    :param _columns: list of columns to update, if None all are updated\n    :type _columns: List\n    :raises ModelPersistenceError: If the pk column is not set\n\n    :param kwargs: list of fields to update as field=value pairs\n    :type kwargs: Any\n    :return: updated Model\n    :rtype: Model\n    \"\"\"\n    if kwargs:\n        self.update_from_dict(kwargs)\n\n    if not self.pk:\n        raise ModelPersistenceError(\n            \"You cannot update not saved model! Use save or upsert method.\"\n        )\n\n    await self.signals.pre_update.send(\n        sender=self.__class__, instance=self, passed_args=kwargs\n    )\n    self_fields = self._extract_model_db_fields()\n    self_fields.pop(self.get_column_name_from_alias(self.ormar_config.pkname))\n    if _columns:\n        self_fields = {k: v for k, v in self_fields.items() if k in _columns}\n    if self_fields:\n        self_fields = self.translate_columns_to_aliases(self_fields)\n        expr = self.ormar_config.table.update().values(**self_fields)\n        expr = expr.where(self.pk_column == getattr(self, self.ormar_config.pkname))\n\n        await self.ormar_config.database.execute(expr)\n    self.set_save_status(True)\n    await self.signals.post_update.send(sender=self.__class__, instance=self)\n    return self\n</code></pre>"},{"location":"api/models/#ormar.models.Model.upsert","title":"<code>upsert(**kwargs)</code>  <code>async</code>","text":"<p>Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided.</p> <p>:param kwargs: list of fields to update :type kwargs: Any :return: saved Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def upsert(self: T, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Performs either a save or an update depending on the presence of the pk.\n    If the pk field is filled it's an update, otherwise the save is performed.\n    For save kwargs are ignored, used only in update if provided.\n\n    :param kwargs: list of fields to update\n    :type kwargs: Any\n    :return: saved Model\n    :rtype: Model\n    \"\"\"\n\n    force_save = kwargs.pop(\"__force_save__\", False)\n    if force_save:\n        expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n        row = await self.ormar_config.database.fetch_one(expr)\n        if not row:\n            return await self.save()\n        return await self.update(**kwargs)\n\n    if not self.pk:\n        return await self.save()\n    return await self.update(**kwargs)\n</code></pre>"},{"location":"api/models/#ormar.models.ModelRow","title":"<code>ModelRow</code>","text":"<p>               Bases: <code>NewBaseModel</code></p> Source code in <code>ormar/models/model_row.py</code> <pre><code>class ModelRow(NewBaseModel):\n    @classmethod\n    def from_row(  # noqa: CFQ002\n        cls,\n        row: ResultProxy,\n        source_model: Type[\"Model\"],\n        select_related: Optional[List] = None,\n        related_models: Any = None,\n        related_field: Optional[\"ForeignKeyField\"] = None,\n        excludable: Optional[ExcludableItems] = None,\n        current_relation_str: str = \"\",\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n        used_prefixes: Optional[List[str]] = None,\n    ) -&gt; Optional[\"Model\"]:\n        \"\"\"\n        Model method to convert raw sql row from database into ormar.Model instance.\n        Traverses nested models if they were specified in select_related for query.\n\n        Called recurrently and returns model instance if it's present in the row.\n        Note that it's processing one row at a time, so if there are duplicates of\n        parent row that needs to be joined/combined\n        (like parent row in sql join with 2+ child rows)\n        instances populated in this method are later combined in the QuerySet.\n        Other method working directly on raw database results is in prefetch_query,\n        where rows are populated in a different way as they do not have\n        nested models in result.\n\n        :param used_prefixes: list of already extracted prefixes\n        :type used_prefixes: List[str]\n        :param proxy_source_model: source model from which querysetproxy is constructed\n        :type proxy_source_model: Optional[Type[\"ModelRow\"]]\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param current_relation_str: name of the relation field\n        :type current_relation_str: str\n        :param source_model: model on which relation was defined\n        :type source_model: Type[Model]\n        :param row: raw result row from the database\n        :type row: ResultProxy\n        :param select_related: list of names of related models fetched from database\n        :type select_related: List\n        :param related_models: list or dict of related models\n        :type related_models: Union[List, Dict]\n        :param related_field: field with relation declaration\n        :type related_field: ForeignKeyField\n        :return: returns model if model is populated from database\n        :rtype: Optional[Model]\n        \"\"\"\n        item: Dict[str, Any] = {}\n        select_related = select_related or []\n        related_models = related_models or []\n        table_prefix = \"\"\n        used_prefixes = used_prefixes if used_prefixes is not None else []\n        excludable = excludable or ExcludableItems()\n\n        if select_related:\n            related_models = group_related_list(select_related)\n\n        if related_field:\n            table_prefix = cls._process_table_prefix(\n                source_model=source_model,\n                current_relation_str=current_relation_str,\n                related_field=related_field,\n                used_prefixes=used_prefixes,\n            )\n\n        item = cls._populate_nested_models_from_row(\n            item=item,\n            row=row,\n            related_models=related_models,\n            excludable=excludable,\n            current_relation_str=current_relation_str,\n            source_model=source_model,  # type: ignore\n            proxy_source_model=proxy_source_model,  # type: ignore\n            table_prefix=table_prefix,\n            used_prefixes=used_prefixes,\n        )\n        item = cls.extract_prefixed_table_columns(\n            item=item, row=row, table_prefix=table_prefix, excludable=excludable\n        )\n\n        instance: Optional[\"Model\"] = None\n        if item.get(cls.ormar_config.pkname, None) is not None:\n            item[\"__excluded__\"] = cls.get_names_to_exclude(\n                excludable=excludable, alias=table_prefix\n            )\n            instance = cast(\"Model\", cls(**item))\n            instance.set_save_status(True)\n        return instance\n\n    @classmethod\n    def _process_table_prefix(\n        cls,\n        source_model: Type[\"Model\"],\n        current_relation_str: str,\n        related_field: \"ForeignKeyField\",\n        used_prefixes: List[str],\n    ) -&gt; str:\n        \"\"\"\n\n        :param source_model: model on which relation was defined\n        :type source_model: Type[Model]\n        :param current_relation_str: current relation string\n        :type current_relation_str: str\n        :param related_field: field with relation declaration\n        :type related_field: \"ForeignKeyField\"\n        :param used_prefixes: list of already extracted prefixes\n        :type used_prefixes: List[str]\n        :return: table_prefix to use\n        :rtype: str\n        \"\"\"\n        if related_field.is_multi:\n            previous_model = related_field.through\n        else:\n            previous_model = related_field.owner\n        table_prefix = cls.ormar_config.alias_manager.resolve_relation_alias(\n            from_model=previous_model, relation_name=related_field.name\n        )\n        if not table_prefix or table_prefix in used_prefixes:\n            manager = cls.ormar_config.alias_manager\n            table_prefix = manager.resolve_relation_alias_after_complex(\n                source_model=source_model,\n                relation_str=current_relation_str,\n                relation_field=related_field,\n            )\n        used_prefixes.append(table_prefix)\n        return table_prefix\n\n    @classmethod\n    def _populate_nested_models_from_row(  # noqa: CFQ002\n        cls,\n        item: dict,\n        row: ResultProxy,\n        source_model: Type[\"Model\"],\n        related_models: Any,\n        excludable: ExcludableItems,\n        table_prefix: str,\n        used_prefixes: List[str],\n        current_relation_str: Optional[str] = None,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; dict:\n        \"\"\"\n        Traverses structure of related models and populates the nested models\n        from the database row.\n        Related models can be a list if only directly related models are to be\n        populated, converted to dict if related models also have their own related\n        models to be populated.\n\n        Recurrently calls from_row method on nested instances and create nested\n        instances. In the end those instances are added to the final model dictionary.\n\n        :param proxy_source_model: source model from which querysetproxy is constructed\n        :type proxy_source_model: Optional[Type[\"ModelRow\"]]\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param source_model: source model from which relation started\n        :type source_model: Type[Model]\n        :param current_relation_str: joined related parts into one string\n        :type current_relation_str: str\n        :param item: dictionary of already populated nested models, otherwise empty dict\n        :type item: Dict\n        :param row: raw result row from the database\n        :type row: ResultProxy\n        :param related_models: list or dict of related models\n        :type related_models: Union[Dict, List]\n        :return: dictionary with keys corresponding to model fields names\n        and values are database values\n        :rtype: Dict\n        \"\"\"\n\n        for related in related_models:\n            field = cls.ormar_config.model_fields[related]\n            field = cast(\"ForeignKeyField\", field)\n            model_cls = field.to\n            model_excludable = excludable.get(\n                model_cls=cast(Type[\"Model\"], cls), alias=table_prefix\n            )\n            if model_excludable.is_excluded(related):\n                continue\n\n            relation_str, remainder = cls._process_remainder_and_relation_string(\n                related_models=related_models,\n                current_relation_str=current_relation_str,\n                related=related,\n            )\n            child = model_cls.from_row(\n                row,\n                related_models=remainder,\n                related_field=field,\n                excludable=excludable,\n                current_relation_str=relation_str,\n                source_model=source_model,\n                proxy_source_model=proxy_source_model,\n                used_prefixes=used_prefixes,\n            )\n            item[model_cls.get_column_name_from_alias(related)] = child\n            if (\n                field.is_multi\n                and child\n                and not model_excludable.is_excluded(field.through.get_name())\n            ):\n                cls._populate_through_instance(\n                    row=row,\n                    item=item,\n                    related=related,\n                    excludable=excludable,\n                    child=child,\n                    proxy_source_model=proxy_source_model,\n                )\n\n        return item\n\n    @staticmethod\n    def _process_remainder_and_relation_string(\n        related_models: Union[Dict, List],\n        current_relation_str: Optional[str],\n        related: str,\n    ) -&gt; Tuple[str, Optional[Union[Dict, List]]]:\n        \"\"\"\n        Process remainder models and relation string\n\n        :param related_models: list or dict of related models\n        :type related_models: Union[Dict, List]\n        :param current_relation_str: current relation string\n        :type current_relation_str: Optional[str]\n        :param related: name of the relation\n        :type related: str\n        \"\"\"\n        relation_str = (\n            \"__\".join([current_relation_str, related])\n            if current_relation_str\n            else related\n        )\n\n        remainder = None\n        if isinstance(related_models, dict) and related_models[related]:\n            remainder = related_models[related]\n        return relation_str, remainder\n\n    @classmethod\n    def _populate_through_instance(  # noqa: CFQ002\n        cls,\n        row: ResultProxy,\n        item: Dict,\n        related: str,\n        excludable: ExcludableItems,\n        child: \"Model\",\n        proxy_source_model: Optional[Type[\"Model\"]],\n    ) -&gt; None:\n        \"\"\"\n        Populates the through model on reverse side of current query.\n        Normally it's child class, unless the query is from queryset.\n\n        :param row: row from db result\n        :type row: ResultProxy\n        :param item: parent item dict\n        :type item: Dict\n        :param related: current relation name\n        :type related: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param child: child item of parent\n        :type child: \"Model\"\n        :param proxy_source_model: source model from which querysetproxy is constructed\n        :type proxy_source_model: Type[\"Model\"]\n        \"\"\"\n        through_name = cls.ormar_config.model_fields[related].through.get_name()\n        through_child = cls._create_through_instance(\n            row=row, related=related, through_name=through_name, excludable=excludable\n        )\n\n        if child.__class__ != proxy_source_model:\n            setattr(child, through_name, through_child)\n        else:\n            item[through_name] = through_child\n        child.set_save_status(True)\n\n    @classmethod\n    def _create_through_instance(\n        cls,\n        row: ResultProxy,\n        through_name: str,\n        related: str,\n        excludable: ExcludableItems,\n    ) -&gt; \"ModelRow\":\n        \"\"\"\n        Initialize the through model from db row.\n        Excluded all relation fields and other exclude/include set in excludable.\n\n        :param row: loaded row from database\n        :type row: sqlalchemy.engine.ResultProxy\n        :param through_name: name of the through field\n        :type through_name: str\n        :param related: name of the relation\n        :type related: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :return: initialized through model without relation\n        :rtype: \"ModelRow\"\n        \"\"\"\n        model_cls = cls.ormar_config.model_fields[through_name].to\n        table_prefix = cls.ormar_config.alias_manager.resolve_relation_alias(\n            from_model=cls, relation_name=related\n        )\n        # remove relations on through field\n        model_excludable = excludable.get(model_cls=model_cls, alias=table_prefix)\n        model_excludable.set_values(\n            value=model_cls.extract_related_names(), is_exclude=True\n        )\n        child_dict = model_cls.extract_prefixed_table_columns(\n            item={}, row=row, excludable=excludable, table_prefix=table_prefix\n        )\n        child_dict[\"__excluded__\"] = model_cls.get_names_to_exclude(\n            excludable=excludable, alias=table_prefix\n        )\n        child = model_cls(**child_dict)  # type: ignore\n        return child\n\n    @classmethod\n    def extract_prefixed_table_columns(\n        cls,\n        item: dict,\n        row: ResultProxy,\n        table_prefix: str,\n        excludable: ExcludableItems,\n    ) -&gt; Dict:\n        \"\"\"\n        Extracts own fields from raw sql result, using a given prefix.\n        Prefix changes depending on the table's position in a join.\n\n        If the table is a main table, there is no prefix.\n        All joined tables have prefixes to allow duplicate column names,\n        as well as duplicated joins to the same table from multiple different tables.\n\n        Extracted fields populates the related dict later used to construct a Model.\n\n        Used in Model.from_row and PrefetchQuery._populate_rows methods.\n\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param item: dictionary of already populated nested models, otherwise empty dict\n        :type item: Dict\n        :param row: raw result row from the database\n        :type row: sqlalchemy.engine.result.ResultProxy\n        :param table_prefix: prefix of the table from AliasManager\n        each pair of tables have own prefix (two of them depending on direction) -\n        used in joins to allow multiple joins to the same table.\n        :type table_prefix: str\n        :return: dictionary with keys corresponding to model fields names\n        and values are database values\n        :rtype: Dict\n        \"\"\"\n        selected_columns = cls.own_table_columns(\n            model=cls, excludable=excludable, alias=table_prefix, use_alias=False\n        )\n\n        column_prefix = table_prefix + \"_\" if table_prefix else \"\"\n        for column in cls.ormar_config.table.columns:\n            alias = cls.get_column_name_from_alias(column.name)\n            if alias not in item and alias in selected_columns:\n                prefixed_name = f\"{column_prefix}{column.name}\"\n                item[alias] = row[prefixed_name]\n\n        return item\n</code></pre>"},{"location":"api/models/#ormar.models.ModelRow.extract_prefixed_table_columns","title":"<code>extract_prefixed_table_columns(item, row, table_prefix, excludable)</code>  <code>classmethod</code>","text":"<p>Extracts own fields from raw sql result, using a given prefix. Prefix changes depending on the table's position in a join.</p> <p>If the table is a main table, there is no prefix. All joined tables have prefixes to allow duplicate column names, as well as duplicated joins to the same table from multiple different tables.</p> <p>Extracted fields populates the related dict later used to construct a Model.</p> <p>Used in Model.from_row and PrefetchQuery._populate_rows methods.</p> <p>:param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :param item: dictionary of already populated nested models, otherwise empty dict :type item: Dict :param row: raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy :param table_prefix: prefix of the table from AliasManager each pair of tables have own prefix (two of them depending on direction) - used in joins to allow multiple joins to the same table. :type table_prefix: str :return: dictionary with keys corresponding to model fields names and values are database values :rtype: Dict</p> Source code in <code>ormar/models/model_row.py</code> <pre><code>@classmethod\ndef extract_prefixed_table_columns(\n    cls,\n    item: dict,\n    row: ResultProxy,\n    table_prefix: str,\n    excludable: ExcludableItems,\n) -&gt; Dict:\n    \"\"\"\n    Extracts own fields from raw sql result, using a given prefix.\n    Prefix changes depending on the table's position in a join.\n\n    If the table is a main table, there is no prefix.\n    All joined tables have prefixes to allow duplicate column names,\n    as well as duplicated joins to the same table from multiple different tables.\n\n    Extracted fields populates the related dict later used to construct a Model.\n\n    Used in Model.from_row and PrefetchQuery._populate_rows methods.\n\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :param item: dictionary of already populated nested models, otherwise empty dict\n    :type item: Dict\n    :param row: raw result row from the database\n    :type row: sqlalchemy.engine.result.ResultProxy\n    :param table_prefix: prefix of the table from AliasManager\n    each pair of tables have own prefix (two of them depending on direction) -\n    used in joins to allow multiple joins to the same table.\n    :type table_prefix: str\n    :return: dictionary with keys corresponding to model fields names\n    and values are database values\n    :rtype: Dict\n    \"\"\"\n    selected_columns = cls.own_table_columns(\n        model=cls, excludable=excludable, alias=table_prefix, use_alias=False\n    )\n\n    column_prefix = table_prefix + \"_\" if table_prefix else \"\"\n    for column in cls.ormar_config.table.columns:\n        alias = cls.get_column_name_from_alias(column.name)\n        if alias not in item and alias in selected_columns:\n            prefixed_name = f\"{column_prefix}{column.name}\"\n            item[alias] = row[prefixed_name]\n\n    return item\n</code></pre>"},{"location":"api/models/#ormar.models.ModelRow.from_row","title":"<code>from_row(row, source_model, select_related=None, related_models=None, related_field=None, excludable=None, current_relation_str='', proxy_source_model=None, used_prefixes=None)</code>  <code>classmethod</code>","text":"<p>Model method to convert raw sql row from database into ormar.Model instance. Traverses nested models if they were specified in select_related for query.</p> <p>Called recurrently and returns model instance if it's present in the row. Note that it's processing one row at a time, so if there are duplicates of parent row that needs to be joined/combined (like parent row in sql join with 2+ child rows) instances populated in this method are later combined in the QuerySet. Other method working directly on raw database results is in prefetch_query, where rows are populated in a different way as they do not have nested models in result.</p> <p>:param used_prefixes: list of already extracted prefixes :type used_prefixes: List[str] :param proxy_source_model: source model from which querysetproxy is constructed :type proxy_source_model: Optional[Type[\"ModelRow\"]] :param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :param current_relation_str: name of the relation field :type current_relation_str: str :param source_model: model on which relation was defined :type source_model: Type[Model] :param row: raw result row from the database :type row: ResultProxy :param select_related: list of names of related models fetched from database :type select_related: List :param related_models: list or dict of related models :type related_models: Union[List, Dict] :param related_field: field with relation declaration :type related_field: ForeignKeyField :return: returns model if model is populated from database :rtype: Optional[Model]</p> Source code in <code>ormar/models/model_row.py</code> <pre><code>@classmethod\ndef from_row(  # noqa: CFQ002\n    cls,\n    row: ResultProxy,\n    source_model: Type[\"Model\"],\n    select_related: Optional[List] = None,\n    related_models: Any = None,\n    related_field: Optional[\"ForeignKeyField\"] = None,\n    excludable: Optional[ExcludableItems] = None,\n    current_relation_str: str = \"\",\n    proxy_source_model: Optional[Type[\"Model\"]] = None,\n    used_prefixes: Optional[List[str]] = None,\n) -&gt; Optional[\"Model\"]:\n    \"\"\"\n    Model method to convert raw sql row from database into ormar.Model instance.\n    Traverses nested models if they were specified in select_related for query.\n\n    Called recurrently and returns model instance if it's present in the row.\n    Note that it's processing one row at a time, so if there are duplicates of\n    parent row that needs to be joined/combined\n    (like parent row in sql join with 2+ child rows)\n    instances populated in this method are later combined in the QuerySet.\n    Other method working directly on raw database results is in prefetch_query,\n    where rows are populated in a different way as they do not have\n    nested models in result.\n\n    :param used_prefixes: list of already extracted prefixes\n    :type used_prefixes: List[str]\n    :param proxy_source_model: source model from which querysetproxy is constructed\n    :type proxy_source_model: Optional[Type[\"ModelRow\"]]\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :param current_relation_str: name of the relation field\n    :type current_relation_str: str\n    :param source_model: model on which relation was defined\n    :type source_model: Type[Model]\n    :param row: raw result row from the database\n    :type row: ResultProxy\n    :param select_related: list of names of related models fetched from database\n    :type select_related: List\n    :param related_models: list or dict of related models\n    :type related_models: Union[List, Dict]\n    :param related_field: field with relation declaration\n    :type related_field: ForeignKeyField\n    :return: returns model if model is populated from database\n    :rtype: Optional[Model]\n    \"\"\"\n    item: Dict[str, Any] = {}\n    select_related = select_related or []\n    related_models = related_models or []\n    table_prefix = \"\"\n    used_prefixes = used_prefixes if used_prefixes is not None else []\n    excludable = excludable or ExcludableItems()\n\n    if select_related:\n        related_models = group_related_list(select_related)\n\n    if related_field:\n        table_prefix = cls._process_table_prefix(\n            source_model=source_model,\n            current_relation_str=current_relation_str,\n            related_field=related_field,\n            used_prefixes=used_prefixes,\n        )\n\n    item = cls._populate_nested_models_from_row(\n        item=item,\n        row=row,\n        related_models=related_models,\n        excludable=excludable,\n        current_relation_str=current_relation_str,\n        source_model=source_model,  # type: ignore\n        proxy_source_model=proxy_source_model,  # type: ignore\n        table_prefix=table_prefix,\n        used_prefixes=used_prefixes,\n    )\n    item = cls.extract_prefixed_table_columns(\n        item=item, row=row, table_prefix=table_prefix, excludable=excludable\n    )\n\n    instance: Optional[\"Model\"] = None\n    if item.get(cls.ormar_config.pkname, None) is not None:\n        item[\"__excluded__\"] = cls.get_names_to_exclude(\n            excludable=excludable, alias=table_prefix\n        )\n        instance = cast(\"Model\", cls(**item))\n        instance.set_save_status(True)\n    return instance\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel","title":"<code>NewBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ModelTableProxy</code></p> <p>Main base class of ormar Model. Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy. Constructed with ModelMetaclass which in turn also inherits pydantic metaclass.</p> <p>Abstracts away all internals and helper functions, so final Model class has only the logic concerned with database connection and data persistence.</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>class NewBaseModel(pydantic.BaseModel, ModelTableProxy, metaclass=ModelMetaclass):\n    \"\"\"\n    Main base class of ormar Model.\n    Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy.\n    Constructed with ModelMetaclass which in turn also inherits pydantic metaclass.\n\n    Abstracts away all internals and helper functions, so final Model class has only\n    the logic concerned with database connection and data persistence.\n    \"\"\"\n\n    __slots__ = (\n        \"_orm_id\",\n        \"_orm_saved\",\n        \"_orm\",\n        \"_pk_column\",\n        \"__pk_only__\",\n        \"__cached_hash__\",\n        \"__pydantic_extra__\",\n        \"__pydantic_fields_set__\",\n    )\n\n    if TYPE_CHECKING:  # pragma no cover\n        pk: Any\n        __relation_map__: Optional[List[str]]\n        __cached_hash__: Optional[int]\n        _orm_relationship_manager: AliasManager\n        _orm: RelationsManager\n        _orm_id: int\n        _orm_saved: bool\n        _related_names: Optional[Set]\n        _through_names: Optional[Set]\n        _related_names_hash: str\n        _quick_access_fields: Set\n        _json_fields: Set\n        _bytes_fields: Set\n        ormar_config: OrmarConfig\n\n    # noinspection PyMissingConstructor\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # type: ignore\n        \"\"\"\n        Initializer that creates a new ormar Model that is also pydantic Model at the\n        same time.\n\n        Passed keyword arguments can be only field names and their corresponding values\n        as those will be passed to pydantic validation that will complain if extra\n        params are passed.\n\n        If relations are defined each relation is expanded and children models are also\n        initialized and validated. Relation from both sides is registered so you can\n        access related models from both sides.\n\n        Json fields are automatically loaded/dumped if needed.\n\n        Models marked as abstract=True in internal OrmarConfig cannot be initialized.\n\n        Accepts also special __pk_only__ flag that indicates that Model is constructed\n        only with primary key value (so no other fields, it's a child model on other\n        Model), that causes skipping the validation, that's the only case when the\n        validation can be skipped.\n\n        Accepts also special __excluded__ parameter that contains a set of fields that\n        should be explicitly set to None, as otherwise pydantic will try to populate\n        them with their default values if default is set.\n\n        :raises ModelError: if abstract model is initialized, model has ForwardRefs\n         that has not been updated or unknown field is passed\n        :param args: ignored args\n        :type args: Any\n        :param kwargs: keyword arguments - all fields values and some special params\n        :type kwargs: Any\n        \"\"\"\n        self._verify_model_can_be_initialized()\n        self._initialize_internal_attributes()\n\n        pk_only = kwargs.pop(\"__pk_only__\", False)\n        object.__setattr__(self, \"__pk_only__\", pk_only)\n\n        new_kwargs, through_tmp_dict = self._process_kwargs(kwargs)\n\n        if not pk_only:\n            self.__pydantic_validator__.validate_python(\n                new_kwargs, self_instance=self  # type: ignore\n            )\n        else:\n            fields_set = {self.ormar_config.pkname}\n            values = new_kwargs\n            object.__setattr__(self, \"__dict__\", values)\n            object.__setattr__(self, \"__pydantic_fields_set__\", fields_set)\n        # add back through fields\n        new_kwargs.update(through_tmp_dict)\n        model_fields = object.__getattribute__(self, \"ormar_config\").model_fields\n        # register the columns models after initialization\n        for related in self.extract_related_names().union(self.extract_through_names()):\n            model_fields[related].expand_relationship(\n                new_kwargs.get(related), self, to_register=True\n            )\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:  # noqa CCR001\n        \"\"\"\n        Overwrites setattr in pydantic parent as otherwise descriptors are not called.\n\n        :param name: name of the attribute to set\n        :type name: str\n        :param value: value of the attribute to set\n        :type value: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        prev_hash = hash(self)\n\n        if hasattr(self, name):\n            object.__setattr__(self, name, value)\n        else:\n            # let pydantic handle errors for unknown fields\n            super().__setattr__(name, value)\n\n        # In this case, the hash could have changed, so update it\n        if name == self.ormar_config.pkname or self.pk is None:\n            object.__setattr__(self, \"__cached_hash__\", None)\n            new_hash = hash(self)\n\n            if prev_hash != new_hash:\n                self._update_relation_cache(prev_hash, new_hash)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"\n        Used for private attributes of pydantic v2.\n\n        :param item: name of attribute\n        :type item: str\n        :return: Any\n        :rtype: Any\n        \"\"\"\n        # TODO: Check __pydantic_extra__\n        if item == \"__pydantic_extra__\":\n            return None\n        return super().__getattr__(item)  # type: ignore\n\n    def __getstate__(self) -&gt; Dict[Any, Any]:\n        state = super().__getstate__()\n        self_dict = self.model_dump()\n        state[\"__dict__\"].update(**self_dict)\n        return state\n\n    def __setstate__(self, state: Dict[Any, Any]) -&gt; None:\n        relations = {\n            k: v\n            for k, v in state[\"__dict__\"].items()\n            if k in self.extract_related_names()\n        }\n        basic_state = {\n            k: v\n            for k, v in state[\"__dict__\"].items()\n            if k not in self.extract_related_names()\n        }\n        state[\"__dict__\"] = basic_state\n        super().__setstate__(state)\n        self._initialize_internal_attributes()\n        for name, value in relations.items():\n            setattr(self, name, value)\n\n    def _update_relation_cache(self, prev_hash: int, new_hash: int) -&gt; None:\n        \"\"\"\n        Update all relation proxy caches with different hash if we have changed\n\n        :param prev_hash: The previous hash to update\n        :type prev_hash: int\n        :param new_hash: The hash to update to\n        :type new_hash: int\n        \"\"\"\n\n        def _update_cache(relations: List[Relation], recurse: bool = True) -&gt; None:\n            for relation in relations:\n                relation_proxy = relation.get()\n\n                if hasattr(relation_proxy, \"update_cache\"):\n                    relation_proxy.update_cache(prev_hash, new_hash)  # type: ignore\n                elif recurse and hasattr(relation_proxy, \"_orm\"):\n                    _update_cache(\n                        relation_proxy._orm._relations.values(),  # type: ignore\n                        recurse=False,\n                    )\n\n        _update_cache(list(self._orm._relations.values()))\n\n    def _internal_set(self, name: str, value: Any) -&gt; None:\n        \"\"\"\n        Delegates call to pydantic.\n\n        :param name: name of param\n        :type name: str\n        :param value: value to set\n        :type value: Any\n        \"\"\"\n        super().__setattr__(name, value)\n\n    def _verify_model_can_be_initialized(self) -&gt; None:\n        \"\"\"\n        Raises exception if model is abstract or has ForwardRefs in relation fields.\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.ormar_config.abstract:\n            raise ModelError(f\"You cannot initialize abstract model {self.get_name()}\")\n        if self.ormar_config.requires_ref_update:\n            raise ModelError(\n                f\"Model {self.get_name()} has not updated \"\n                f\"ForwardRefs. \\nBefore using the model you \"\n                f\"need to call update_forward_refs().\"\n            )\n\n    def _process_kwargs(self, kwargs: Dict) -&gt; Tuple[Dict, Dict]:  # noqa: CCR001\n        \"\"\"\n        Initializes nested models.\n\n        Removes property_fields\n\n        Checks if field is in the model fields or pydantic fields.\n\n        Nullifies fields that should be excluded.\n\n        Extracts through models from kwargs into temporary dict.\n\n        :param kwargs: passed to init keyword arguments\n        :type kwargs: Dict\n        :return: modified kwargs\n        :rtype: Tuple[Dict, Dict]\n        \"\"\"\n        property_fields = self.ormar_config.property_fields\n        model_fields = self.ormar_config.model_fields\n        pydantic_fields = set(self.model_fields.keys())\n\n        # remove property fields\n        for prop_filed in property_fields:\n            kwargs.pop(prop_filed, None)\n\n        excluded: Set[str] = kwargs.pop(\"__excluded__\", set())\n        if \"pk\" in kwargs:\n            kwargs[self.ormar_config.pkname] = kwargs.pop(\"pk\")\n\n        # extract through fields\n        through_tmp_dict = dict()\n        for field_name in self.extract_through_names():\n            through_tmp_dict[field_name] = kwargs.pop(field_name, None)\n\n        kwargs = self._remove_extra_parameters_if_they_should_be_ignored(\n            kwargs=kwargs, model_fields=model_fields, pydantic_fields=pydantic_fields\n        )\n        try:\n            new_kwargs: Dict[str, Any] = {\n                k: self._convert_to_bytes(\n                    k,\n                    self._convert_json(\n                        k,\n                        (\n                            model_fields[k].expand_relationship(\n                                v, self, to_register=False\n                            )\n                            if k in model_fields\n                            else (v if k in pydantic_fields else model_fields[k])\n                        ),\n                    ),\n                )\n                for k, v in kwargs.items()\n            }\n        except KeyError as e:\n            raise ModelError(\n                f\"Unknown field '{e.args[0]}' for model {self.get_name(lower=False)}\"\n            )\n\n        # explicitly set None to excluded fields\n        # as pydantic populates them with default if set\n        for field_to_nullify in excluded:\n            new_kwargs[field_to_nullify] = None\n\n        return new_kwargs, through_tmp_dict\n\n    def _remove_extra_parameters_if_they_should_be_ignored(\n        self, kwargs: Dict, model_fields: Dict, pydantic_fields: Set\n    ) -&gt; Dict:\n        \"\"\"\n        Removes the extra fields from kwargs if they should be ignored.\n\n        :param kwargs: passed arguments\n        :type kwargs: Dict\n        :param model_fields: dictionary of model fields\n        :type model_fields: Dict\n        :param pydantic_fields: set of pydantic fields names\n        :type pydantic_fields: Set\n        :return: dict without extra fields\n        :rtype: Dict\n        \"\"\"\n        if self.ormar_config.extra == Extra.ignore:\n            kwargs = {\n                k: v\n                for k, v in kwargs.items()\n                if k in model_fields or k in pydantic_fields\n            }\n        return kwargs\n\n    def _initialize_internal_attributes(self) -&gt; None:\n        \"\"\"\n        Initializes internal attributes during __init__()\n        :rtype: None\n        \"\"\"\n        # object.__setattr__(self, \"_orm_id\", uuid.uuid4().hex)\n        object.__setattr__(self, \"_orm_saved\", False)\n        object.__setattr__(self, \"_pk_column\", None)\n        object.__setattr__(\n            self,\n            \"_orm\",\n            RelationsManager(\n                related_fields=self.extract_related_fields(), owner=cast(\"Model\", self)\n            ),\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Compares other model to this model. when == is called.\n        :param other: other model to compare\n        :type other: object\n        :return: result of comparison\n        :rtype: bool\n        \"\"\"\n        if isinstance(other, NewBaseModel):\n            return self.__same__(other)\n        return super().__eq__(other)  # pragma no cover\n\n    def __hash__(self) -&gt; int:\n        if getattr(self, \"__cached_hash__\", None) is not None:\n            return self.__cached_hash__ or 0\n\n        if self.pk is not None:\n            ret = hash(str(self.pk) + self.__class__.__name__)\n        else:\n            vals = {\n                k: v\n                for k, v in self.__dict__.items()\n                if k not in self.extract_related_names()\n            }\n            ret = hash(str(vals) + self.__class__.__name__)\n\n        object.__setattr__(self, \"__cached_hash__\", ret)\n        return ret\n\n    def __same__(self, other: \"NewBaseModel\") -&gt; bool:\n        \"\"\"\n        Used by __eq__, compares other model to this model.\n        Compares:\n        * _orm_ids,\n        * primary key values if it's set\n        * dictionary of own fields (excluding relations)\n        :param other: model to compare to\n        :type other: NewBaseModel\n        :return: result of comparison\n        :rtype: bool\n        \"\"\"\n        if (self.pk is None and other.pk is not None) or (\n            self.pk is not None and other.pk is None\n        ):\n            return False\n        else:\n            return hash(self) == other.__hash__()\n\n    @classmethod\n    def get_name(cls, lower: bool = True) -&gt; str:\n        \"\"\"\n        Returns name of the Model class, by default lowercase.\n\n        :param lower: flag if name should be set to lowercase\n        :type lower: bool\n        :return: name of the model\n        :rtype: str\n        \"\"\"\n        name = cls.__name__\n        if lower:\n            name = name.lower()\n        return name\n\n    @property\n    def pk_column(self) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Retrieves primary key sqlalchemy column from models OrmarConfig.table.\n        Each model has to have primary key.\n        Only one primary key column is allowed.\n\n        :return: primary key sqlalchemy column\n        :rtype: sqlalchemy.Column\n        \"\"\"\n        if object.__getattribute__(self, \"_pk_column\") is not None:\n            return object.__getattribute__(self, \"_pk_column\")\n        pk_columns = self.ormar_config.table.primary_key.columns.values()\n        pk_col = pk_columns[0]\n        object.__setattr__(self, \"_pk_column\", pk_col)\n        return pk_col\n\n    @property\n    def saved(self) -&gt; bool:\n        \"\"\"Saved status of the model. Changed by setattr and loading from db\"\"\"\n        return self._orm_saved\n\n    @property\n    def signals(self) -&gt; \"SignalEmitter\":\n        \"\"\"Exposes signals from model OrmarConfig\"\"\"\n        return self.ormar_config.signals\n\n    @classmethod\n    def pk_type(cls) -&gt; Any:\n        \"\"\"Shortcut to models primary key field type\"\"\"\n        return cls.ormar_config.model_fields[cls.ormar_config.pkname].__type__\n\n    @classmethod\n    def db_backend_name(cls) -&gt; str:\n        \"\"\"Shortcut to database dialect,\n        cause some dialect require different treatment\"\"\"\n        return cls.ormar_config.database._backend._dialect.name\n\n    def remove(self, parent: \"Model\", name: str) -&gt; None:\n        \"\"\"Removes child from relation with given name in RelationshipManager\"\"\"\n        self._orm.remove_parent(self, parent, name)\n\n    def set_save_status(self, status: bool) -&gt; None:\n        \"\"\"Sets value of the save status\"\"\"\n        object.__setattr__(self, \"_orm_saved\", status)\n\n    @classmethod\n    def update_forward_refs(cls, **localns: Any) -&gt; None:\n        \"\"\"\n        Processes fields that are ForwardRef and need to be evaluated into actual\n        models.\n\n        Expands relationships, register relation in alias manager and substitutes\n        sqlalchemy columns with new ones with proper column type (null before).\n\n        Populates OrmarConfig table of the Model which is left empty before.\n\n        Sets self_reference flag on models that links to themselves.\n\n        Calls the pydantic method to evaluate pydantic fields.\n\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        globalns = sys.modules[cls.__module__].__dict__.copy()\n        globalns.setdefault(cls.__name__, cls)\n        fields_to_check = cls.ormar_config.model_fields.copy()\n        for field in fields_to_check.values():\n            if field.has_unresolved_forward_refs():\n                field = cast(ForeignKeyField, field)\n                field.evaluate_forward_ref(globalns=globalns, localns=localns)\n                field.set_self_reference_flag()\n                if field.is_multi and not field.through:\n                    field = cast(ormar.ManyToManyField, field)\n                    field.create_default_through_model()\n                expand_reverse_relationship(model_field=field)\n                register_relation_in_alias_manager(field=field)\n                update_column_definition(model=cls, field=field)\n        populate_config_sqlalchemy_table_if_required(config=cls.ormar_config)\n        # super().update_forward_refs(**localns)\n        cls.model_rebuild(force=True)\n        cls.ormar_config.requires_ref_update = False\n\n    @staticmethod\n    def _get_not_excluded_fields(\n        fields: Union[List, Set], include: Optional[Dict], exclude: Optional[Dict]\n    ) -&gt; List:\n        \"\"\"\n        Returns related field names applying on them include and exclude set.\n\n        :param include: fields to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :return:\n        :rtype: List of fields with relations that is not excluded\n        \"\"\"\n        fields = [*fields] if not isinstance(fields, list) else fields\n        if include:\n            fields = [field for field in fields if field in include]\n        if exclude:\n            fields = [\n                field\n                for field in fields\n                if field not in exclude\n                or (\n                    exclude.get(field) is not Ellipsis\n                    and exclude.get(field) != {\"__all__\"}\n                )\n            ]\n        return fields\n\n    @staticmethod\n    def _extract_nested_models_from_list(\n        relation_map: Dict,\n        models: MutableSequence,\n        include: Union[Set, Dict, None],\n        exclude: Union[Set, Dict, None],\n        exclude_primary_keys: bool,\n        exclude_through_models: bool,\n    ) -&gt; List:\n        \"\"\"\n        Converts list of models into list of dictionaries.\n\n        :param models: List of models\n        :type models: List\n        :param include: fields to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :return: list of models converted to dictionaries\n        :rtype: List[Dict]\n        \"\"\"\n        result = []\n        for model in models:\n            try:\n                model_dict = model.model_dump(\n                    relation_map=relation_map,\n                    include=include,\n                    exclude=exclude,\n                    exclude_primary_keys=exclude_primary_keys,\n                    exclude_through_models=exclude_through_models,\n                )\n                if not exclude_through_models:\n                    model.populate_through_models(\n                        model=model,\n                        model_dict=model_dict,\n                        include=include,\n                        exclude=exclude,\n                        relation_map=relation_map,\n                    )\n                result.append(model_dict)\n            except ReferenceError:  # pragma no cover\n                continue\n        return result\n\n    @staticmethod\n    def populate_through_models(\n        model: \"Model\",\n        model_dict: Dict,\n        include: Union[Set, Dict],\n        exclude: Union[Set, Dict],\n        relation_map: Dict,\n    ) -&gt; None:\n        \"\"\"\n        Populates through models with values from dict representation.\n\n        :param model: model to populate through models\n        :type model: Model\n        :param model_dict: dict representation of the model\n        :type model_dict: Dict\n        :param include: fields to include\n        :type include: Dict\n        :param exclude: fields to exclude\n        :type exclude: Dict\n        :param relation_map: map of relations to follow to avoid circular refs\n        :type relation_map: Dict\n        :return: None\n        :rtype: None\n        \"\"\"\n\n        include_dict = (\n            translate_list_to_dict(include)\n            if (include and isinstance(include, Set))\n            else include\n        )\n        exclude_dict = (\n            translate_list_to_dict(exclude)\n            if (exclude and isinstance(exclude, Set))\n            else exclude\n        )\n        models_to_populate = model._get_not_excluded_fields(\n            fields=model.extract_through_names(),\n            include=cast(Optional[Dict], include_dict),\n            exclude=cast(Optional[Dict], exclude_dict),\n        )\n        through_fields_to_populate = [\n            model.ormar_config.model_fields[through_model]\n            for through_model in models_to_populate\n            if model.ormar_config.model_fields[through_model].related_name\n            not in relation_map\n        ]\n        for through_field in through_fields_to_populate:\n            through_instance = getattr(model, through_field.name)\n            if through_instance:\n                model_dict[through_field.name] = through_instance.model_dump()\n\n    @classmethod\n    def _skip_ellipsis(\n        cls, items: Union[Set, Dict, None], key: str, default_return: Any = None\n    ) -&gt; Union[Set, Dict, None]:\n        \"\"\"\n        Helper to traverse the include/exclude dictionaries.\n        In model_dump() Ellipsis should be skipped as it indicates all fields required\n        and not the actual set/dict with fields names.\n\n        :param items: current include/exclude value\n        :type items: Union[Set, Dict, None]\n        :param key: key for nested relations to check\n        :type key: str\n        :return: nested value of the items\n        :rtype: Union[Set, Dict, None]\n        \"\"\"\n        result = cls.get_child(items, key)\n        return result if result is not Ellipsis else default_return\n\n    @staticmethod\n    def _convert_all(items: Union[Set, Dict, None]) -&gt; Union[Set, Dict, None]:\n        \"\"\"\n        Helper to convert __all__ pydantic special index to ormar which does not\n        support index based exclusions.\n\n        :param items: current include/exclude value\n        :type items: Union[Set, Dict, None]\n        \"\"\"\n        if isinstance(items, dict) and \"__all__\" in items:\n            return items.get(\"__all__\")\n        return items\n\n    def _extract_nested_models(  # noqa: CCR001, CFQ002\n        self,\n        relation_map: Dict,\n        dict_instance: Dict,\n        include: Optional[Dict],\n        exclude: Optional[Dict],\n        exclude_primary_keys: bool,\n        exclude_through_models: bool,\n        exclude_list: bool,\n    ) -&gt; Dict:\n        \"\"\"\n        Traverse nested models and converts them into dictionaries.\n        Calls itself recursively if needed.\n\n        :param nested: flag if current instance is nested\n        :type nested: bool\n        :param dict_instance: current instance dict\n        :type dict_instance: Dict\n        :param include: fields to include\n        :type include: Optional[Dict]\n        :param exclude: fields to exclude\n        :type exclude: Optional[Dict]\n        :param exclude: whether to exclude lists\n        :type exclude: bool\n        :return: current model dict with child models converted to dictionaries\n        :rtype: Dict\n        \"\"\"\n        fields = self._get_not_excluded_fields(\n            fields=self.extract_related_names(), include=include, exclude=exclude\n        )\n\n        for field in fields:\n            if not relation_map or field not in relation_map:\n                continue\n            try:\n                nested_model = getattr(self, field)\n                if isinstance(nested_model, MutableSequence):\n                    if exclude_list:\n                        continue\n\n                    dict_instance[field] = self._extract_nested_models_from_list(\n                        relation_map=self._skip_ellipsis(  # type: ignore\n                            relation_map, field, default_return=dict()\n                        ),\n                        models=nested_model,\n                        include=self._convert_all(self._skip_ellipsis(include, field)),\n                        exclude=self._convert_all(self._skip_ellipsis(exclude, field)),\n                        exclude_primary_keys=exclude_primary_keys,\n                        exclude_through_models=exclude_through_models,\n                    )\n                elif nested_model is not None:\n                    model_dict = nested_model.model_dump(\n                        relation_map=self._skip_ellipsis(\n                            relation_map, field, default_return=dict()\n                        ),\n                        include=self._convert_all(self._skip_ellipsis(include, field)),\n                        exclude=self._convert_all(self._skip_ellipsis(exclude, field)),\n                        exclude_primary_keys=exclude_primary_keys,\n                        exclude_through_models=exclude_through_models,\n                    )\n                    if not exclude_through_models:\n                        nested_model.populate_through_models(\n                            model=nested_model,\n                            model_dict=model_dict,\n                            include=self._convert_all(\n                                self._skip_ellipsis(include, field)\n                            ),\n                            exclude=self._convert_all(\n                                self._skip_ellipsis(exclude, field)\n                            ),\n                            relation_map=self._skip_ellipsis(\n                                relation_map, field, default_return=dict()\n                            ),\n                        )\n                    dict_instance[field] = model_dict\n                else:\n                    dict_instance[field] = None\n            except ReferenceError:  # pragma: no cover\n                dict_instance[field] = None\n        return dict_instance\n\n    @typing_extensions.deprecated(\n        \"The `dict` method is deprecated; use `model_dump` instead.\",\n        category=OrmarDeprecatedSince020,\n    )\n    def dict(  # type: ignore # noqa A003\n        self,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        exclude_list: bool = False,\n        relation_map: Optional[Dict] = None,\n    ) -&gt; \"DictStrAny\":  # noqa: A003 # pragma: no cover\n        warnings.warn(\n            \"The `dict` method is deprecated; use `model_dump` instead.\",\n            DeprecationWarning,\n        )\n        return self.model_dump(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n            exclude_list=exclude_list,\n            relation_map=relation_map,\n        )\n\n    def model_dump(  # type: ignore # noqa A003\n        self,\n        *,\n        mode: Union[Literal[\"json\", \"python\"], str] = \"python\",\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        exclude_list: bool = False,\n        relation_map: Optional[Dict] = None,\n        round_trip: bool = False,\n        warnings: bool = True,\n    ) -&gt; \"DictStrAny\":  # noqa: A003'\n        \"\"\"\n\n        Generate a dictionary representation of the model,\n        optionally specifying which fields to include or exclude.\n\n        Nested models are also parsed to dictionaries.\n\n        Additionally, fields decorated with @property_field are also added.\n\n        :param exclude_through_models: flag to exclude through models from dict\n        :type exclude_through_models: bool\n        :param exclude_primary_keys: flag to exclude primary keys from dict\n        :type exclude_primary_keys: bool\n        :param include: fields to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :param by_alias: flag to get values by alias - passed to pydantic\n        :type by_alias: bool\n        :param exclude_unset: flag to exclude not set values - passed to pydantic\n        :type exclude_unset: bool\n        :param exclude_defaults: flag to exclude default values - passed to pydantic\n        :type exclude_defaults: bool\n        :param exclude_none: flag to exclude None values - passed to pydantic\n        :type exclude_none: bool\n        :param exclude_list: flag to exclude lists of nested values models from dict\n        :type exclude_list: bool\n        :param relation_map: map of the relations to follow to avoid circular deps\n        :type relation_map: Dict\n        :param mode: The mode in which `to_python` should run.\n            If mode is 'json', the dictionary will only contain JSON serializable types.\n            If mode is 'python', the dictionary may contain any Python objects.\n        :type mode: str\n        :param round_trip: flag to enable serialization round-trip support\n        :type round_trip: bool\n        :param warnings: flag to log warnings for invalid fields\n        :type warnings: bool\n        :return:\n        :rtype:\n        \"\"\"\n        pydantic_exclude = self._update_excluded_with_related(exclude)\n        pydantic_exclude = self._update_excluded_with_pks_and_through(\n            exclude=pydantic_exclude,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n        )\n        dict_instance = super().model_dump(\n            mode=mode,\n            include=include,\n            exclude=pydantic_exclude,\n            by_alias=by_alias,\n            exclude_defaults=exclude_defaults,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=False,\n        )\n\n        dict_instance = {\n            k: self._convert_bytes_to_str(column_name=k, value=v)\n            for k, v in dict_instance.items()\n        }\n\n        include_dict = (\n            translate_list_to_dict(include) if isinstance(include, Set) else include\n        )\n        exclude_dict = (\n            translate_list_to_dict(exclude) if isinstance(exclude, Set) else exclude\n        )\n\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(self._iterate_related_models())\n        )\n        pk_only = getattr(self, \"__pk_only__\", False)\n        if relation_map and not pk_only:\n            dict_instance = self._extract_nested_models(\n                relation_map=relation_map,\n                dict_instance=dict_instance,\n                include=include_dict,\n                exclude=exclude_dict,\n                exclude_primary_keys=exclude_primary_keys,\n                exclude_through_models=exclude_through_models,\n                exclude_list=exclude_list,\n            )\n\n        return dict_instance\n\n    @typing_extensions.deprecated(\n        \"The `json` method is deprecated; use `model_dump_json` instead.\",\n        category=OrmarDeprecatedSince020,\n    )\n    def json(  # type: ignore # noqa A003\n        self,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        **dumps_kwargs: Any,\n    ) -&gt; str:  # pragma: no cover\n        warnings.warn(\n            \"The `json` method is deprecated; use `model_dump_json` instead.\",\n            DeprecationWarning,\n        )\n        return self.model_dump_json(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n            **dumps_kwargs,\n        )\n\n    def model_dump_json(  # type: ignore # noqa A003\n        self,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        \"\"\"\n        Generate a JSON representation of the model, `include` and `exclude`\n        arguments as per `dict()`.\n\n        `encoder` is an optional function to supply as `default` to json.dumps(),\n        other arguments as per `json.dumps()`.\n        \"\"\"\n        data = self.model_dump(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n        )\n        return self.__pydantic_serializer__.to_json(data, warnings=False).decode()\n\n    @classmethod\n    @typing_extensions.deprecated(\n        \"The `construct` method is deprecated; use `model_construct` instead.\",\n        category=OrmarDeprecatedSince020,\n    )\n    def construct(\n        cls: Type[\"T\"], _fields_set: Union[Set[str], None] = None, **values: Any\n    ) -&gt; \"T\":  # pragma: no cover\n        warnings.warn(\n            \"The `construct` method is deprecated; use `model_construct` instead.\",\n            DeprecationWarning,\n        )\n        return cls.model_construct(_fields_set=_fields_set, **values)\n\n    @classmethod\n    def model_construct(\n        cls: Type[\"T\"], _fields_set: Optional[\"SetStr\"] = None, **values: Any\n    ) -&gt; \"T\":\n        own_values = {\n            k: v for k, v in values.items() if k not in cls.extract_related_names()\n        }\n        model = cls.__new__(cls)\n        fields_values: Dict[str, Any] = {}\n        for name, field in cls.model_fields.items():\n            if name in own_values:\n                fields_values[name] = own_values[name]\n            elif not field.is_required():\n                fields_values[name] = field.get_default()\n        fields_values.update(own_values)\n\n        if _fields_set is None:\n            _fields_set = set(values.keys())\n\n        extra_allowed = cls.model_config.get(\"extra\") == \"allow\"\n        if not extra_allowed:\n            fields_values.update(values)\n        object.__setattr__(model, \"__dict__\", fields_values)\n        model._initialize_internal_attributes()\n        cls._construct_relations(model=model, values=values)\n        object.__setattr__(model, \"__pydantic_fields_set__\", _fields_set)\n        return cls._pydantic_model_construct_finalizer(\n            model=model, extra_allowed=extra_allowed, values=values\n        )\n\n    @classmethod\n    def _pydantic_model_construct_finalizer(\n        cls: Type[\"T\"], model: \"T\", extra_allowed: bool, **values: Any\n    ) -&gt; \"T\":\n        \"\"\"\n        Recreate pydantic model_construct logic here as we do not call super method.\n        \"\"\"\n        _extra: Union[Dict[str, Any], None] = None\n        if extra_allowed:  # pragma: no cover\n            _extra = {}\n            for k, v in values.items():\n                _extra[k] = v\n\n        if not cls.__pydantic_root_model__:\n            object.__setattr__(model, \"__pydantic_extra__\", _extra)\n\n        if cls.__pydantic_post_init__:  # pragma: no cover\n            model.model_post_init(None)\n        elif not cls.__pydantic_root_model__:\n            # Note: if there are any private attributes,\n            # cls.__pydantic_post_init__ would exist\n            # Since it doesn't, that means that `__pydantic_private__`\n            # should be set to None\n            object.__setattr__(model, \"__pydantic_private__\", None)\n\n        return model\n\n    @classmethod\n    def _construct_relations(cls: Type[\"T\"], model: \"T\", values: Dict) -&gt; None:\n        present_relations = [\n            relation for relation in cls.extract_related_names() if relation in values\n        ]\n        for relation in present_relations:\n            value_to_set = values[relation]\n            if not isinstance(value_to_set, list):\n                value_to_set = [value_to_set]\n            relation_field = cls.ormar_config.model_fields[relation]\n            relation_value = [\n                relation_field.expand_relationship(x, model, to_register=False)\n                for x in value_to_set\n                if x is not None\n            ]\n\n            for child in relation_value:\n                model._orm.add(\n                    parent=cast(\"Model\", child),\n                    child=cast(\"Model\", model),\n                    field=cast(\"ForeignKeyField\", relation_field),\n                )\n\n    def update_from_dict(self, value_dict: Dict) -&gt; \"NewBaseModel\":\n        \"\"\"\n        Updates self with values of fields passed in the dictionary.\n\n        :param value_dict: dictionary of fields names and values\n        :type value_dict: Dict\n        :return: self\n        :rtype: NewBaseModel\n        \"\"\"\n        for key, value in value_dict.items():\n            setattr(self, key, value)\n        return self\n\n    def _convert_to_bytes(self, column_name: str, value: Any) -&gt; Union[str, Dict]:\n        \"\"\"\n        Converts value to bytes from string\n\n        :param column_name: name of the field\n        :type column_name: str\n        :param value: value fo the field\n        :type value: Any\n        :return: converted value if needed, else original value\n        :rtype: Any\n        \"\"\"\n        if column_name not in self._bytes_fields:\n            return value\n        field = self.ormar_config.model_fields[column_name]\n        if value is not None:\n            value = decode_bytes(\n                value=value, represent_as_string=field.represent_as_base64_str\n            )\n        return value\n\n    def _convert_bytes_to_str(self, column_name: str, value: Any) -&gt; Union[str, Dict]:\n        \"\"\"\n        Converts value to str from bytes for represent_as_base64_str columns.\n\n        :param column_name: name of the field\n        :type column_name: str\n        :param value: value fo the field\n        :type value: Any\n        :return: converted value if needed, else original value\n        :rtype: Any\n        \"\"\"\n        if column_name not in self._bytes_fields:\n            return value\n        field = self.ormar_config.model_fields[column_name]\n        if (\n            value is not None\n            and not isinstance(value, str)\n            and field.represent_as_base64_str\n        ):\n            return base64.b64encode(value).decode()\n        return value\n\n    def _convert_json(self, column_name: str, value: Any) -&gt; Union[str, Dict, None]:\n        \"\"\"\n        Converts value to/from json if needed (for Json columns).\n\n        :param column_name: name of the field\n        :type column_name: str\n        :param value: value fo the field\n        :type value: Any\n        :return: converted value if needed, else original value\n        :rtype: Any\n        \"\"\"\n        if column_name not in self._json_fields:\n            return value\n        return encode_json(value)\n\n    def _extract_own_model_fields(self) -&gt; Dict:\n        \"\"\"\n        Returns a dictionary with field names and values for fields that are not\n        relations fields (ForeignKey, ManyToMany etc.)\n\n        :return: dictionary of fields names and values.\n        :rtype: Dict\n        \"\"\"\n        related_names = self.extract_related_names()\n        self_fields = {k: v for k, v in self.__dict__.items() if k not in related_names}\n        return self_fields\n\n    def _extract_model_db_fields(self) -&gt; Dict:\n        \"\"\"\n        Returns a dictionary with field names and values for fields that are stored in\n        current model's table.\n\n        That includes own non-relational fields ang foreign key fields.\n\n        :return: dictionary of fields names and values.\n        :rtype: Dict\n        \"\"\"\n        self_fields = self._extract_own_model_fields()\n        self_fields = {\n            k: v\n            for k, v in self_fields.items()\n            if self.get_column_alias(k) in self.ormar_config.table.columns\n        }\n        for field in self._extract_db_related_names():\n            relation_field = self.ormar_config.model_fields[field]\n            target_pk_name = relation_field.to.ormar_config.pkname\n            target_field = getattr(self, field)\n            self_fields[field] = getattr(target_field, target_pk_name, None)\n            if not relation_field.nullable and not self_fields[field]:\n                raise ModelPersistenceError(\n                    f\"You cannot save {relation_field.to.get_name()} \"\n                    f\"model without pk set!\"\n                )\n        return self_fields\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.pk_column","title":"<code>pk_column: sqlalchemy.Column</code>  <code>property</code>","text":"<p>Retrieves primary key sqlalchemy column from models OrmarConfig.table. Each model has to have primary key. Only one primary key column is allowed.</p> <p>:return: primary key sqlalchemy column :rtype: sqlalchemy.Column</p>"},{"location":"api/models/#ormar.models.NewBaseModel.saved","title":"<code>saved: bool</code>  <code>property</code>","text":"<p>Saved status of the model. Changed by setattr and loading from db</p>"},{"location":"api/models/#ormar.models.NewBaseModel.signals","title":"<code>signals: SignalEmitter</code>  <code>property</code>","text":"<p>Exposes signals from model OrmarConfig</p>"},{"location":"api/models/#ormar.models.NewBaseModel.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares other model to this model. when == is called. :param other: other model to compare :type other: object :return: result of comparison :rtype: bool</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compares other model to this model. when == is called.\n    :param other: other model to compare\n    :type other: object\n    :return: result of comparison\n    :rtype: bool\n    \"\"\"\n    if isinstance(other, NewBaseModel):\n        return self.__same__(other)\n    return super().__eq__(other)  # pragma no cover\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Used for private attributes of pydantic v2.</p> <p>:param item: name of attribute :type item: str :return: Any :rtype: Any</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    \"\"\"\n    Used for private attributes of pydantic v2.\n\n    :param item: name of attribute\n    :type item: str\n    :return: Any\n    :rtype: Any\n    \"\"\"\n    # TODO: Check __pydantic_extra__\n    if item == \"__pydantic_extra__\":\n        return None\n    return super().__getattr__(item)  # type: ignore\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializer that creates a new ormar Model that is also pydantic Model at the same time.</p> <p>Passed keyword arguments can be only field names and their corresponding values as those will be passed to pydantic validation that will complain if extra params are passed.</p> <p>If relations are defined each relation is expanded and children models are also initialized and validated. Relation from both sides is registered so you can access related models from both sides.</p> <p>Json fields are automatically loaded/dumped if needed.</p> <p>Models marked as abstract=True in internal OrmarConfig cannot be initialized.</p> <p>Accepts also special pk_only flag that indicates that Model is constructed only with primary key value (so no other fields, it's a child model on other Model), that causes skipping the validation, that's the only case when the validation can be skipped.</p> <p>Accepts also special excluded parameter that contains a set of fields that should be explicitly set to None, as otherwise pydantic will try to populate them with their default values if default is set.</p> <p>:raises ModelError: if abstract model is initialized, model has ForwardRefs  that has not been updated or unknown field is passed :param args: ignored args :type args: Any :param kwargs: keyword arguments - all fields values and some special params :type kwargs: Any</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # type: ignore\n    \"\"\"\n    Initializer that creates a new ormar Model that is also pydantic Model at the\n    same time.\n\n    Passed keyword arguments can be only field names and their corresponding values\n    as those will be passed to pydantic validation that will complain if extra\n    params are passed.\n\n    If relations are defined each relation is expanded and children models are also\n    initialized and validated. Relation from both sides is registered so you can\n    access related models from both sides.\n\n    Json fields are automatically loaded/dumped if needed.\n\n    Models marked as abstract=True in internal OrmarConfig cannot be initialized.\n\n    Accepts also special __pk_only__ flag that indicates that Model is constructed\n    only with primary key value (so no other fields, it's a child model on other\n    Model), that causes skipping the validation, that's the only case when the\n    validation can be skipped.\n\n    Accepts also special __excluded__ parameter that contains a set of fields that\n    should be explicitly set to None, as otherwise pydantic will try to populate\n    them with their default values if default is set.\n\n    :raises ModelError: if abstract model is initialized, model has ForwardRefs\n     that has not been updated or unknown field is passed\n    :param args: ignored args\n    :type args: Any\n    :param kwargs: keyword arguments - all fields values and some special params\n    :type kwargs: Any\n    \"\"\"\n    self._verify_model_can_be_initialized()\n    self._initialize_internal_attributes()\n\n    pk_only = kwargs.pop(\"__pk_only__\", False)\n    object.__setattr__(self, \"__pk_only__\", pk_only)\n\n    new_kwargs, through_tmp_dict = self._process_kwargs(kwargs)\n\n    if not pk_only:\n        self.__pydantic_validator__.validate_python(\n            new_kwargs, self_instance=self  # type: ignore\n        )\n    else:\n        fields_set = {self.ormar_config.pkname}\n        values = new_kwargs\n        object.__setattr__(self, \"__dict__\", values)\n        object.__setattr__(self, \"__pydantic_fields_set__\", fields_set)\n    # add back through fields\n    new_kwargs.update(through_tmp_dict)\n    model_fields = object.__getattribute__(self, \"ormar_config\").model_fields\n    # register the columns models after initialization\n    for related in self.extract_related_names().union(self.extract_through_names()):\n        model_fields[related].expand_relationship(\n            new_kwargs.get(related), self, to_register=True\n        )\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.__same__","title":"<code>__same__(other)</code>","text":"<p>Used by eq, compares other model to this model. Compares: * _orm_ids, * primary key values if it's set * dictionary of own fields (excluding relations) :param other: model to compare to :type other: NewBaseModel :return: result of comparison :rtype: bool</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __same__(self, other: \"NewBaseModel\") -&gt; bool:\n    \"\"\"\n    Used by __eq__, compares other model to this model.\n    Compares:\n    * _orm_ids,\n    * primary key values if it's set\n    * dictionary of own fields (excluding relations)\n    :param other: model to compare to\n    :type other: NewBaseModel\n    :return: result of comparison\n    :rtype: bool\n    \"\"\"\n    if (self.pk is None and other.pk is not None) or (\n        self.pk is not None and other.pk is None\n    ):\n        return False\n    else:\n        return hash(self) == other.__hash__()\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Overwrites setattr in pydantic parent as otherwise descriptors are not called.</p> <p>:param name: name of the attribute to set :type name: str :param value: value of the attribute to set :type value: Any :return: None :rtype: None</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:  # noqa CCR001\n    \"\"\"\n    Overwrites setattr in pydantic parent as otherwise descriptors are not called.\n\n    :param name: name of the attribute to set\n    :type name: str\n    :param value: value of the attribute to set\n    :type value: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    prev_hash = hash(self)\n\n    if hasattr(self, name):\n        object.__setattr__(self, name, value)\n    else:\n        # let pydantic handle errors for unknown fields\n        super().__setattr__(name, value)\n\n    # In this case, the hash could have changed, so update it\n    if name == self.ormar_config.pkname or self.pk is None:\n        object.__setattr__(self, \"__cached_hash__\", None)\n        new_hash = hash(self)\n\n        if prev_hash != new_hash:\n            self._update_relation_cache(prev_hash, new_hash)\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.db_backend_name","title":"<code>db_backend_name()</code>  <code>classmethod</code>","text":"<p>Shortcut to database dialect, cause some dialect require different treatment</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef db_backend_name(cls) -&gt; str:\n    \"\"\"Shortcut to database dialect,\n    cause some dialect require different treatment\"\"\"\n    return cls.ormar_config.database._backend._dialect.name\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.get_name","title":"<code>get_name(lower=True)</code>  <code>classmethod</code>","text":"<p>Returns name of the Model class, by default lowercase.</p> <p>:param lower: flag if name should be set to lowercase :type lower: bool :return: name of the model :rtype: str</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef get_name(cls, lower: bool = True) -&gt; str:\n    \"\"\"\n    Returns name of the Model class, by default lowercase.\n\n    :param lower: flag if name should be set to lowercase\n    :type lower: bool\n    :return: name of the model\n    :rtype: str\n    \"\"\"\n    name = cls.__name__\n    if lower:\n        name = name.lower()\n    return name\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.model_dump","title":"<code>model_dump(*, mode='python', include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, exclude_primary_keys=False, exclude_through_models=False, exclude_list=False, relation_map=None, round_trip=False, warnings=True)</code>","text":"<p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Nested models are also parsed to dictionaries.</p> <p>Additionally, fields decorated with @property_field are also added.</p> <p>:param exclude_through_models: flag to exclude through models from dict :type exclude_through_models: bool :param exclude_primary_keys: flag to exclude primary keys from dict :type exclude_primary_keys: bool :param include: fields to include :type include: Union[Set, Dict, None] :param exclude: fields to exclude :type exclude: Union[Set, Dict, None] :param by_alias: flag to get values by alias - passed to pydantic :type by_alias: bool :param exclude_unset: flag to exclude not set values - passed to pydantic :type exclude_unset: bool :param exclude_defaults: flag to exclude default values - passed to pydantic :type exclude_defaults: bool :param exclude_none: flag to exclude None values - passed to pydantic :type exclude_none: bool :param exclude_list: flag to exclude lists of nested values models from dict :type exclude_list: bool :param relation_map: map of the relations to follow to avoid circular deps :type relation_map: Dict :param mode: The mode in which <code>to_python</code> should run.     If mode is 'json', the dictionary will only contain JSON serializable types.     If mode is 'python', the dictionary may contain any Python objects. :type mode: str :param round_trip: flag to enable serialization round-trip support :type round_trip: bool :param warnings: flag to log warnings for invalid fields :type warnings: bool :return: :rtype:</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def model_dump(  # type: ignore # noqa A003\n    self,\n    *,\n    mode: Union[Literal[\"json\", \"python\"], str] = \"python\",\n    include: Union[Set, Dict, None] = None,\n    exclude: Union[Set, Dict, None] = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_primary_keys: bool = False,\n    exclude_through_models: bool = False,\n    exclude_list: bool = False,\n    relation_map: Optional[Dict] = None,\n    round_trip: bool = False,\n    warnings: bool = True,\n) -&gt; \"DictStrAny\":  # noqa: A003'\n    \"\"\"\n\n    Generate a dictionary representation of the model,\n    optionally specifying which fields to include or exclude.\n\n    Nested models are also parsed to dictionaries.\n\n    Additionally, fields decorated with @property_field are also added.\n\n    :param exclude_through_models: flag to exclude through models from dict\n    :type exclude_through_models: bool\n    :param exclude_primary_keys: flag to exclude primary keys from dict\n    :type exclude_primary_keys: bool\n    :param include: fields to include\n    :type include: Union[Set, Dict, None]\n    :param exclude: fields to exclude\n    :type exclude: Union[Set, Dict, None]\n    :param by_alias: flag to get values by alias - passed to pydantic\n    :type by_alias: bool\n    :param exclude_unset: flag to exclude not set values - passed to pydantic\n    :type exclude_unset: bool\n    :param exclude_defaults: flag to exclude default values - passed to pydantic\n    :type exclude_defaults: bool\n    :param exclude_none: flag to exclude None values - passed to pydantic\n    :type exclude_none: bool\n    :param exclude_list: flag to exclude lists of nested values models from dict\n    :type exclude_list: bool\n    :param relation_map: map of the relations to follow to avoid circular deps\n    :type relation_map: Dict\n    :param mode: The mode in which `to_python` should run.\n        If mode is 'json', the dictionary will only contain JSON serializable types.\n        If mode is 'python', the dictionary may contain any Python objects.\n    :type mode: str\n    :param round_trip: flag to enable serialization round-trip support\n    :type round_trip: bool\n    :param warnings: flag to log warnings for invalid fields\n    :type warnings: bool\n    :return:\n    :rtype:\n    \"\"\"\n    pydantic_exclude = self._update_excluded_with_related(exclude)\n    pydantic_exclude = self._update_excluded_with_pks_and_through(\n        exclude=pydantic_exclude,\n        exclude_primary_keys=exclude_primary_keys,\n        exclude_through_models=exclude_through_models,\n    )\n    dict_instance = super().model_dump(\n        mode=mode,\n        include=include,\n        exclude=pydantic_exclude,\n        by_alias=by_alias,\n        exclude_defaults=exclude_defaults,\n        exclude_unset=exclude_unset,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        warnings=False,\n    )\n\n    dict_instance = {\n        k: self._convert_bytes_to_str(column_name=k, value=v)\n        for k, v in dict_instance.items()\n    }\n\n    include_dict = (\n        translate_list_to_dict(include) if isinstance(include, Set) else include\n    )\n    exclude_dict = (\n        translate_list_to_dict(exclude) if isinstance(exclude, Set) else exclude\n    )\n\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(self._iterate_related_models())\n    )\n    pk_only = getattr(self, \"__pk_only__\", False)\n    if relation_map and not pk_only:\n        dict_instance = self._extract_nested_models(\n            relation_map=relation_map,\n            dict_instance=dict_instance,\n            include=include_dict,\n            exclude=exclude_dict,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n            exclude_list=exclude_list,\n        )\n\n    return dict_instance\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.model_dump_json","title":"<code>model_dump_json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, exclude_primary_keys=False, exclude_through_models=False, **dumps_kwargs)</code>","text":"<p>Generate a JSON representation of the model, <code>include</code> and <code>exclude</code> arguments as per <code>dict()</code>.</p> <p><code>encoder</code> is an optional function to supply as <code>default</code> to json.dumps(), other arguments as per <code>json.dumps()</code>.</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def model_dump_json(  # type: ignore # noqa A003\n    self,\n    *,\n    include: Union[Set, Dict, None] = None,\n    exclude: Union[Set, Dict, None] = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_primary_keys: bool = False,\n    exclude_through_models: bool = False,\n    **dumps_kwargs: Any,\n) -&gt; str:\n    \"\"\"\n    Generate a JSON representation of the model, `include` and `exclude`\n    arguments as per `dict()`.\n\n    `encoder` is an optional function to supply as `default` to json.dumps(),\n    other arguments as per `json.dumps()`.\n    \"\"\"\n    data = self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_primary_keys=exclude_primary_keys,\n        exclude_through_models=exclude_through_models,\n    )\n    return self.__pydantic_serializer__.to_json(data, warnings=False).decode()\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.pk_type","title":"<code>pk_type()</code>  <code>classmethod</code>","text":"<p>Shortcut to models primary key field type</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef pk_type(cls) -&gt; Any:\n    \"\"\"Shortcut to models primary key field type\"\"\"\n    return cls.ormar_config.model_fields[cls.ormar_config.pkname].__type__\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.populate_through_models","title":"<code>populate_through_models(model, model_dict, include, exclude, relation_map)</code>  <code>staticmethod</code>","text":"<p>Populates through models with values from dict representation.</p> <p>:param model: model to populate through models :type model: Model :param model_dict: dict representation of the model :type model_dict: Dict :param include: fields to include :type include: Dict :param exclude: fields to exclude :type exclude: Dict :param relation_map: map of relations to follow to avoid circular refs :type relation_map: Dict :return: None :rtype: None</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@staticmethod\ndef populate_through_models(\n    model: \"Model\",\n    model_dict: Dict,\n    include: Union[Set, Dict],\n    exclude: Union[Set, Dict],\n    relation_map: Dict,\n) -&gt; None:\n    \"\"\"\n    Populates through models with values from dict representation.\n\n    :param model: model to populate through models\n    :type model: Model\n    :param model_dict: dict representation of the model\n    :type model_dict: Dict\n    :param include: fields to include\n    :type include: Dict\n    :param exclude: fields to exclude\n    :type exclude: Dict\n    :param relation_map: map of relations to follow to avoid circular refs\n    :type relation_map: Dict\n    :return: None\n    :rtype: None\n    \"\"\"\n\n    include_dict = (\n        translate_list_to_dict(include)\n        if (include and isinstance(include, Set))\n        else include\n    )\n    exclude_dict = (\n        translate_list_to_dict(exclude)\n        if (exclude and isinstance(exclude, Set))\n        else exclude\n    )\n    models_to_populate = model._get_not_excluded_fields(\n        fields=model.extract_through_names(),\n        include=cast(Optional[Dict], include_dict),\n        exclude=cast(Optional[Dict], exclude_dict),\n    )\n    through_fields_to_populate = [\n        model.ormar_config.model_fields[through_model]\n        for through_model in models_to_populate\n        if model.ormar_config.model_fields[through_model].related_name\n        not in relation_map\n    ]\n    for through_field in through_fields_to_populate:\n        through_instance = getattr(model, through_field.name)\n        if through_instance:\n            model_dict[through_field.name] = through_instance.model_dump()\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.remove","title":"<code>remove(parent, name)</code>","text":"<p>Removes child from relation with given name in RelationshipManager</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def remove(self, parent: \"Model\", name: str) -&gt; None:\n    \"\"\"Removes child from relation with given name in RelationshipManager\"\"\"\n    self._orm.remove_parent(self, parent, name)\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.set_save_status","title":"<code>set_save_status(status)</code>","text":"<p>Sets value of the save status</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def set_save_status(self, status: bool) -&gt; None:\n    \"\"\"Sets value of the save status\"\"\"\n    object.__setattr__(self, \"_orm_saved\", status)\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.update_forward_refs","title":"<code>update_forward_refs(**localns)</code>  <code>classmethod</code>","text":"<p>Processes fields that are ForwardRef and need to be evaluated into actual models.</p> <p>Expands relationships, register relation in alias manager and substitutes sqlalchemy columns with new ones with proper column type (null before).</p> <p>Populates OrmarConfig table of the Model which is left empty before.</p> <p>Sets self_reference flag on models that links to themselves.</p> <p>Calls the pydantic method to evaluate pydantic fields.</p> <p>:param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef update_forward_refs(cls, **localns: Any) -&gt; None:\n    \"\"\"\n    Processes fields that are ForwardRef and need to be evaluated into actual\n    models.\n\n    Expands relationships, register relation in alias manager and substitutes\n    sqlalchemy columns with new ones with proper column type (null before).\n\n    Populates OrmarConfig table of the Model which is left empty before.\n\n    Sets self_reference flag on models that links to themselves.\n\n    Calls the pydantic method to evaluate pydantic fields.\n\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    globalns = sys.modules[cls.__module__].__dict__.copy()\n    globalns.setdefault(cls.__name__, cls)\n    fields_to_check = cls.ormar_config.model_fields.copy()\n    for field in fields_to_check.values():\n        if field.has_unresolved_forward_refs():\n            field = cast(ForeignKeyField, field)\n            field.evaluate_forward_ref(globalns=globalns, localns=localns)\n            field.set_self_reference_flag()\n            if field.is_multi and not field.through:\n                field = cast(ormar.ManyToManyField, field)\n                field.create_default_through_model()\n            expand_reverse_relationship(model_field=field)\n            register_relation_in_alias_manager(field=field)\n            update_column_definition(model=cls, field=field)\n    populate_config_sqlalchemy_table_if_required(config=cls.ormar_config)\n    # super().update_forward_refs(**localns)\n    cls.model_rebuild(force=True)\n    cls.ormar_config.requires_ref_update = False\n</code></pre>"},{"location":"api/models/#ormar.models.NewBaseModel.update_from_dict","title":"<code>update_from_dict(value_dict)</code>","text":"<p>Updates self with values of fields passed in the dictionary.</p> <p>:param value_dict: dictionary of fields names and values :type value_dict: Dict :return: self :rtype: NewBaseModel</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def update_from_dict(self, value_dict: Dict) -&gt; \"NewBaseModel\":\n    \"\"\"\n    Updates self with values of fields passed in the dictionary.\n\n    :param value_dict: dictionary of fields names and values\n    :type value_dict: Dict\n    :return: self\n    :rtype: NewBaseModel\n    \"\"\"\n    for key, value in value_dict.items():\n        setattr(self, key, value)\n    return self\n</code></pre>"},{"location":"api/models/excludable/","title":"excludable","text":""},{"location":"api/models/excludable/#ormar.models.excludable.Excludable","title":"<code>Excludable</code>  <code>dataclass</code>","text":"<p>Class that keeps sets of fields to exclude and include</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>@dataclass\nclass Excludable:\n    \"\"\"\n    Class that keeps sets of fields to exclude and include\n    \"\"\"\n\n    include: Set = field(default_factory=set)\n    exclude: Set = field(default_factory=set)\n\n    def get_copy(self) -&gt; \"Excludable\":\n        \"\"\"\n        Return copy of self to avoid in place modifications\n        :return: copy of self with copied sets\n        :rtype: ormar.models.excludable.Excludable\n        \"\"\"\n        _copy = self.__class__()\n        _copy.include = {x for x in self.include}\n        _copy.exclude = {x for x in self.exclude}\n        return _copy\n\n    def set_values(self, value: Set, is_exclude: bool) -&gt; None:\n        \"\"\"\n        Appends the data to include/exclude sets.\n\n        :param value: set of values to add\n        :type value: set\n        :param is_exclude: flag if values are to be excluded or included\n        :type is_exclude: bool\n        \"\"\"\n        prop = \"exclude\" if is_exclude else \"include\"\n        current_value = getattr(self, prop)\n        current_value.update(value)\n        setattr(self, prop, current_value)\n\n    def is_included(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if field in included (in set or set is {...})\n        :param key: key to check\n        :type key: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return (... in self.include or key in self.include) if self.include else True\n\n    def is_excluded(self, key: str) -&gt; bool:\n        \"\"\"\n        Check if field in excluded (in set or set is {...})\n        :param key: key to check\n        :type key: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return (... in self.exclude or key in self.exclude) if self.exclude else False\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.Excludable.get_copy","title":"<code>get_copy()</code>","text":"<p>Return copy of self to avoid in place modifications :return: copy of self with copied sets :rtype: ormar.models.excludable.Excludable</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def get_copy(self) -&gt; \"Excludable\":\n    \"\"\"\n    Return copy of self to avoid in place modifications\n    :return: copy of self with copied sets\n    :rtype: ormar.models.excludable.Excludable\n    \"\"\"\n    _copy = self.__class__()\n    _copy.include = {x for x in self.include}\n    _copy.exclude = {x for x in self.exclude}\n    return _copy\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.Excludable.is_excluded","title":"<code>is_excluded(key)</code>","text":"<p>Check if field in excluded (in set or set is {...}) :param key: key to check :type key: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def is_excluded(self, key: str) -&gt; bool:\n    \"\"\"\n    Check if field in excluded (in set or set is {...})\n    :param key: key to check\n    :type key: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return (... in self.exclude or key in self.exclude) if self.exclude else False\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.Excludable.is_included","title":"<code>is_included(key)</code>","text":"<p>Check if field in included (in set or set is {...}) :param key: key to check :type key: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def is_included(self, key: str) -&gt; bool:\n    \"\"\"\n    Check if field in included (in set or set is {...})\n    :param key: key to check\n    :type key: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return (... in self.include or key in self.include) if self.include else True\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.Excludable.set_values","title":"<code>set_values(value, is_exclude)</code>","text":"<p>Appends the data to include/exclude sets.</p> <p>:param value: set of values to add :type value: set :param is_exclude: flag if values are to be excluded or included :type is_exclude: bool</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def set_values(self, value: Set, is_exclude: bool) -&gt; None:\n    \"\"\"\n    Appends the data to include/exclude sets.\n\n    :param value: set of values to add\n    :type value: set\n    :param is_exclude: flag if values are to be excluded or included\n    :type is_exclude: bool\n    \"\"\"\n    prop = \"exclude\" if is_exclude else \"include\"\n    current_value = getattr(self, prop)\n    current_value.update(value)\n    setattr(self, prop, current_value)\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.ExcludableItems","title":"<code>ExcludableItems</code>","text":"<p>Keeps a dictionary of Excludables by alias + model_name keys to allow quick lookup by nested models without need to travers deeply nested dictionaries and passing include/exclude around</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>class ExcludableItems:\n    \"\"\"\n    Keeps a dictionary of Excludables by alias + model_name keys\n    to allow quick lookup by nested models without need to travers\n    deeply nested dictionaries and passing include/exclude around\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.items: Dict[str, Excludable] = dict()\n\n    @classmethod\n    def from_excludable(cls, other: \"ExcludableItems\") -&gt; \"ExcludableItems\":\n        \"\"\"\n        Copy passed ExcludableItems to avoid inplace modifications.\n\n        :param other: other excludable items to be copied\n        :type other: ormar.models.excludable.ExcludableItems\n        :return: copy of other\n        :rtype: ormar.models.excludable.ExcludableItems\n        \"\"\"\n        new_excludable = cls()\n        for key, value in other.items.items():\n            new_excludable.items[key] = value.get_copy()\n        return new_excludable\n\n    def include_entry_count(self) -&gt; int:\n        \"\"\"\n        Returns count of include items inside\n        \"\"\"\n        count = 0\n        for key in self.items.keys():\n            count += len(self.items[key].include)\n        return count\n\n    def get(self, model_cls: Type[\"Model\"], alias: str = \"\") -&gt; Excludable:\n        \"\"\"\n        Return Excludable for given model and alias.\n\n        :param model_cls: target model to check\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param alias: table alias from relation manager\n        :type alias: str\n        :return: Excludable for given model and alias\n        :rtype: ormar.models.excludable.Excludable\n        \"\"\"\n        key = f\"{alias + '_' if alias else ''}{model_cls.get_name(lower=True)}\"\n        excludable = self.items.get(key)\n        if not excludable:\n            excludable = Excludable()\n            self.items[key] = excludable\n        return excludable\n\n    def build(\n        self,\n        items: Union[List[str], str, Tuple[str], Set[str], Dict],\n        model_cls: Type[\"Model\"],\n        is_exclude: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Receives the one of the types of items and parses them as to achieve\n        a end situation with one excludable per alias/model in relation.\n\n        Each excludable has two sets of values - one to include, one to exclude.\n\n        :param items: values to be included or excluded\n        :type items: Union[List[str], str, Tuple[str], Set[str], Dict]\n        :param model_cls: source model from which relations are constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if items should be included or excluded\n        :type is_exclude: bool\n        \"\"\"\n        if isinstance(items, str):\n            items = {items}\n\n        if isinstance(items, Dict):\n            self._traverse_dict(\n                values=items,\n                source_model=model_cls,\n                model_cls=model_cls,\n                is_exclude=is_exclude,\n            )\n\n        else:\n            items = set(items)\n            nested_items = set(x for x in items if \"__\" in x)\n            items.difference_update(nested_items)\n            self._set_excludes(\n                items=items,\n                model_name=model_cls.get_name(lower=True),\n                is_exclude=is_exclude,\n            )\n            if nested_items:\n                self._traverse_list(\n                    values=nested_items, model_cls=model_cls, is_exclude=is_exclude\n                )\n\n    def _set_excludes(\n        self, items: Set, model_name: str, is_exclude: bool, alias: str = \"\"\n    ) -&gt; None:\n        \"\"\"\n        Sets set of values to be included or excluded for given key and model.\n\n        :param items: items to include/exclude\n        :type items: set\n        :param model_name: name of model to construct key\n        :type model_name: str\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        :param alias:\n        :type alias: str\n        \"\"\"\n        key = f\"{alias + '_' if alias else ''}{model_name}\"\n        excludable = self.items.get(key)\n        if not excludable:\n            excludable = Excludable()\n        excludable.set_values(value=items, is_exclude=is_exclude)\n        self.items[key] = excludable\n\n    def _traverse_dict(  # noqa: CFQ002\n        self,\n        values: Dict,\n        source_model: Type[\"Model\"],\n        model_cls: Type[\"Model\"],\n        is_exclude: bool,\n        related_items: Optional[List] = None,\n        alias: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Goes through dict of nested values and construct/update Excludables.\n\n        :param values: items to include/exclude\n        :type values: Dict\n        :param source_model: source model from which relations are constructed\n        :type source_model: ormar.models.metaclass.ModelMetaclass\n        :param model_cls: model from which current relation is constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        :param related_items: list of names of related fields chain\n        :type related_items: List\n        :param alias: alias of relation\n        :type alias: str\n        \"\"\"\n        self_fields = set()\n        related_items = related_items[:] if related_items else []\n        for key, value in values.items():\n            if value is ...:\n                self_fields.add(key)\n            elif isinstance(value, set):\n                (\n                    table_prefix,\n                    target_model,\n                    _,\n                    _,\n                ) = get_relationship_alias_model_and_str(\n                    source_model=source_model, related_parts=related_items + [key]\n                )\n                self._set_excludes(\n                    items=value,\n                    model_name=target_model.get_name(),\n                    is_exclude=is_exclude,\n                    alias=table_prefix,\n                )\n            else:\n                # dict\n                related_items.append(key)\n                (\n                    table_prefix,\n                    target_model,\n                    _,\n                    _,\n                ) = get_relationship_alias_model_and_str(\n                    source_model=source_model, related_parts=related_items\n                )\n                self._traverse_dict(\n                    values=value,\n                    source_model=source_model,\n                    model_cls=target_model,\n                    is_exclude=is_exclude,\n                    related_items=related_items,\n                    alias=table_prefix,\n                )\n        if self_fields:\n            self._set_excludes(\n                items=self_fields,\n                model_name=model_cls.get_name(),\n                is_exclude=is_exclude,\n                alias=alias,\n            )\n\n    def _traverse_list(\n        self, values: Set[str], model_cls: Type[\"Model\"], is_exclude: bool\n    ) -&gt; None:\n        \"\"\"\n        Goes through list of values and construct/update Excludables.\n\n        :param values: items to include/exclude\n        :type values: set\n        :param model_cls: model from which current relation is constructed\n        :type model_cls: ormar.models.metaclass.ModelMetaclass\n        :param is_exclude: flag if values should be included or excluded\n        :type is_exclude: bool\n        \"\"\"\n        # here we have only nested related keys\n        for key in values:\n            key_split = key.split(\"__\")\n            related_items, field_name = key_split[:-1], key_split[-1]\n            (table_prefix, target_model, _, _) = get_relationship_alias_model_and_str(\n                source_model=model_cls, related_parts=related_items\n            )\n            self._set_excludes(\n                items={field_name},\n                model_name=target_model.get_name(),\n                is_exclude=is_exclude,\n                alias=table_prefix,\n            )\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.ExcludableItems.build","title":"<code>build(items, model_cls, is_exclude=False)</code>","text":"<p>Receives the one of the types of items and parses them as to achieve a end situation with one excludable per alias/model in relation.</p> <p>Each excludable has two sets of values - one to include, one to exclude.</p> <p>:param items: values to be included or excluded :type items: Union[List[str], str, Tuple[str], Set[str], Dict] :param model_cls: source model from which relations are constructed :type model_cls: ormar.models.metaclass.ModelMetaclass :param is_exclude: flag if items should be included or excluded :type is_exclude: bool</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def build(\n    self,\n    items: Union[List[str], str, Tuple[str], Set[str], Dict],\n    model_cls: Type[\"Model\"],\n    is_exclude: bool = False,\n) -&gt; None:\n    \"\"\"\n    Receives the one of the types of items and parses them as to achieve\n    a end situation with one excludable per alias/model in relation.\n\n    Each excludable has two sets of values - one to include, one to exclude.\n\n    :param items: values to be included or excluded\n    :type items: Union[List[str], str, Tuple[str], Set[str], Dict]\n    :param model_cls: source model from which relations are constructed\n    :type model_cls: ormar.models.metaclass.ModelMetaclass\n    :param is_exclude: flag if items should be included or excluded\n    :type is_exclude: bool\n    \"\"\"\n    if isinstance(items, str):\n        items = {items}\n\n    if isinstance(items, Dict):\n        self._traverse_dict(\n            values=items,\n            source_model=model_cls,\n            model_cls=model_cls,\n            is_exclude=is_exclude,\n        )\n\n    else:\n        items = set(items)\n        nested_items = set(x for x in items if \"__\" in x)\n        items.difference_update(nested_items)\n        self._set_excludes(\n            items=items,\n            model_name=model_cls.get_name(lower=True),\n            is_exclude=is_exclude,\n        )\n        if nested_items:\n            self._traverse_list(\n                values=nested_items, model_cls=model_cls, is_exclude=is_exclude\n            )\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.ExcludableItems.from_excludable","title":"<code>from_excludable(other)</code>  <code>classmethod</code>","text":"<p>Copy passed ExcludableItems to avoid inplace modifications.</p> <p>:param other: other excludable items to be copied :type other: ormar.models.excludable.ExcludableItems :return: copy of other :rtype: ormar.models.excludable.ExcludableItems</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>@classmethod\ndef from_excludable(cls, other: \"ExcludableItems\") -&gt; \"ExcludableItems\":\n    \"\"\"\n    Copy passed ExcludableItems to avoid inplace modifications.\n\n    :param other: other excludable items to be copied\n    :type other: ormar.models.excludable.ExcludableItems\n    :return: copy of other\n    :rtype: ormar.models.excludable.ExcludableItems\n    \"\"\"\n    new_excludable = cls()\n    for key, value in other.items.items():\n        new_excludable.items[key] = value.get_copy()\n    return new_excludable\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.ExcludableItems.get","title":"<code>get(model_cls, alias='')</code>","text":"<p>Return Excludable for given model and alias.</p> <p>:param model_cls: target model to check :type model_cls: ormar.models.metaclass.ModelMetaclass :param alias: table alias from relation manager :type alias: str :return: Excludable for given model and alias :rtype: ormar.models.excludable.Excludable</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def get(self, model_cls: Type[\"Model\"], alias: str = \"\") -&gt; Excludable:\n    \"\"\"\n    Return Excludable for given model and alias.\n\n    :param model_cls: target model to check\n    :type model_cls: ormar.models.metaclass.ModelMetaclass\n    :param alias: table alias from relation manager\n    :type alias: str\n    :return: Excludable for given model and alias\n    :rtype: ormar.models.excludable.Excludable\n    \"\"\"\n    key = f\"{alias + '_' if alias else ''}{model_cls.get_name(lower=True)}\"\n    excludable = self.items.get(key)\n    if not excludable:\n        excludable = Excludable()\n        self.items[key] = excludable\n    return excludable\n</code></pre>"},{"location":"api/models/excludable/#ormar.models.excludable.ExcludableItems.include_entry_count","title":"<code>include_entry_count()</code>","text":"<p>Returns count of include items inside</p> Source code in <code>ormar/models/excludable.py</code> <pre><code>def include_entry_count(self) -&gt; int:\n    \"\"\"\n    Returns count of include items inside\n    \"\"\"\n    count = 0\n    for key in self.items.keys():\n        count += len(self.items[key].include)\n    return count\n</code></pre>"},{"location":"api/models/metaclass/","title":"metaclass","text":""},{"location":"api/models/metaclass/#ormar.models.metaclass.ModelMetaclass","title":"<code>ModelMetaclass</code>","text":"<p>               Bases: <code>ModelMetaclass</code></p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>class ModelMetaclass(pydantic._internal._model_construction.ModelMetaclass):\n    def __new__(  # type: ignore # noqa: CCR001\n        mcs: \"ModelMetaclass\",\n        name: str,\n        bases: Any,\n        attrs: dict,\n        __pydantic_generic_metadata__: Union[PydanticGenericMetadata, None] = None,\n        __pydantic_reset_parent_namespace__: bool = True,\n        _create_model_module: Union[str, None] = None,\n        **kwargs,\n    ) -&gt; type:\n        \"\"\"\n        Metaclass used by ormar Models that performs configuration\n        and build of ormar Models.\n\n\n        Sets pydantic configuration.\n        Extract model_fields and convert them to pydantic FieldInfo,\n        updates class namespace.\n\n        Extracts settings and fields from parent classes.\n        Fetches methods decorated with @computed_field decorator\n        to expose them later in dict().\n\n        Construct parent pydantic Metaclass/ Model.\n\n        If class has ormar_config declared (so actual ormar Models) it also:\n\n        * populate sqlalchemy columns, pkname and tables from model_fields\n        * register reverse relationships on related models\n        * registers all relations in alias manager that populates table_prefixes\n        * exposes alias manager on each Model\n        * creates QuerySet for each model and exposes it on a class\n        * sets custom serializers for relation models\n\n        :param name: name of current class\n        :type name: str\n        :param bases: base classes\n        :type bases: Tuple\n        :param attrs: class namespace\n        :type attrs: Dict\n        \"\"\"\n        merge_or_generate_pydantic_config(attrs=attrs, name=name)\n        attrs[\"__name__\"] = name\n        attrs, model_fields = extract_annotations_and_default_vals(attrs)\n        for base in reversed(bases):\n            mod = base.__module__\n            if mod.startswith(\"ormar.models.\") or mod.startswith(\"pydantic.\"):\n                continue\n            attrs, model_fields = extract_from_parents_definition(\n                base_class=base, curr_class=mcs, attrs=attrs, model_fields=model_fields\n            )\n        if \"ormar_config\" in attrs:\n            attrs[\"model_config\"][\"ignored_types\"] = (OrmarConfig,)\n            attrs[\"model_config\"][\"from_attributes\"] = True\n            for field_name, field in model_fields.items():\n                if field.is_relation:\n                    decorator = field_serializer(\n                        field_name, mode=\"wrap\", check_fields=False\n                    )(get_serializer())\n                    attrs[f\"serialize_{field_name}\"] = decorator\n\n        new_model = super().__new__(\n            mcs,  # type: ignore\n            name,\n            bases,\n            attrs,\n            __pydantic_generic_metadata__=__pydantic_generic_metadata__,\n            __pydantic_reset_parent_namespace__=__pydantic_reset_parent_namespace__,\n            _create_model_module=_create_model_module,\n            **kwargs,\n        )\n\n        add_cached_properties(new_model)\n\n        if hasattr(new_model, \"ormar_config\"):\n            populate_default_options_values(new_model, model_fields)\n            check_required_config_parameters(new_model)\n            add_property_fields(new_model, attrs)\n            register_signals(new_model=new_model)\n            modify_schema_example(model=new_model)\n\n            if not new_model.ormar_config.abstract:\n                new_model = populate_config_tablename_columns_and_pk(name, new_model)\n                populate_config_sqlalchemy_table_if_required(new_model.ormar_config)\n                expand_reverse_relationships(new_model)\n                for field_name, field in new_model.ormar_config.model_fields.items():\n                    register_relation_in_alias_manager(field=field)\n                    add_field_descriptor(\n                        name=field_name, field=field, new_model=new_model\n                    )\n\n                if (\n                    new_model.ormar_config.pkname\n                    and new_model.ormar_config.pkname not in attrs[\"__annotations__\"]\n                    and new_model.ormar_config.pkname not in new_model.model_fields\n                ):\n                    field_name = new_model.ormar_config.pkname\n                    new_model.model_fields[field_name] = (\n                        FieldInfo.from_annotated_attribute(\n                            Optional[int],  # type: ignore\n                            None,\n                        )\n                    )\n                    new_model.model_rebuild(force=True)\n\n                new_model.pk = PkDescriptor(name=new_model.ormar_config.pkname)\n                remove_excluded_parent_fields(new_model)\n\n        return new_model\n\n    @property\n    def objects(cls: Type[\"T\"]) -&gt; \"QuerySet[T]\":  # type: ignore\n        if cls.ormar_config.requires_ref_update:\n            raise ModelError(\n                f\"Model {cls.get_name()} has not updated \"\n                f\"ForwardRefs. \\nBefore using the model you \"\n                f\"need to call update_forward_refs().\"\n            )\n        return cls.ormar_config.queryset_class(model_cls=cls)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"\n        Returns FieldAccessors on access to model fields from a class,\n        that way it can be used in python style filters and order_by.\n\n        :param item: name of the field\n        :type item: str\n        :return: FieldAccessor for given field\n        :rtype: FieldAccessor\n        \"\"\"\n        # Ugly workaround for name shadowing warnings in pydantic\n        frame = sys._getframe(1)\n        file_name = Path(frame.f_code.co_filename)\n        if (\n            frame.f_code.co_name == \"collect_model_fields\"\n            and file_name.name == \"_fields.py\"\n            and file_name.parent.parent.name == \"pydantic\"\n        ):\n            raise AttributeError()\n        if item == \"pk\":\n            item = self.ormar_config.pkname\n        if item in object.__getattribute__(self, \"ormar_config\").model_fields:\n            field = self.ormar_config.model_fields.get(item)\n            if field.is_relation:\n                return FieldAccessor(\n                    source_model=cast(Type[\"Model\"], self),\n                    model=field.to,\n                    access_chain=item,\n                )\n            return FieldAccessor(\n                source_model=cast(Type[\"Model\"], self), field=field, access_chain=item\n            )\n        return object.__getattribute__(self, item)\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.ModelMetaclass.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Returns FieldAccessors on access to model fields from a class, that way it can be used in python style filters and order_by.</p> <p>:param item: name of the field :type item: str :return: FieldAccessor for given field :rtype: FieldAccessor</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    \"\"\"\n    Returns FieldAccessors on access to model fields from a class,\n    that way it can be used in python style filters and order_by.\n\n    :param item: name of the field\n    :type item: str\n    :return: FieldAccessor for given field\n    :rtype: FieldAccessor\n    \"\"\"\n    # Ugly workaround for name shadowing warnings in pydantic\n    frame = sys._getframe(1)\n    file_name = Path(frame.f_code.co_filename)\n    if (\n        frame.f_code.co_name == \"collect_model_fields\"\n        and file_name.name == \"_fields.py\"\n        and file_name.parent.parent.name == \"pydantic\"\n    ):\n        raise AttributeError()\n    if item == \"pk\":\n        item = self.ormar_config.pkname\n    if item in object.__getattribute__(self, \"ormar_config\").model_fields:\n        field = self.ormar_config.model_fields.get(item)\n        if field.is_relation:\n            return FieldAccessor(\n                source_model=cast(Type[\"Model\"], self),\n                model=field.to,\n                access_chain=item,\n            )\n        return FieldAccessor(\n            source_model=cast(Type[\"Model\"], self), field=field, access_chain=item\n        )\n    return object.__getattribute__(self, item)\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.ModelMetaclass.__new__","title":"<code>__new__(mcs, name, bases, attrs, __pydantic_generic_metadata__=None, __pydantic_reset_parent_namespace__=True, _create_model_module=None, **kwargs)</code>","text":"<p>Metaclass used by ormar Models that performs configuration and build of ormar Models.</p> <p>Sets pydantic configuration. Extract model_fields and convert them to pydantic FieldInfo, updates class namespace.</p> <p>Extracts settings and fields from parent classes. Fetches methods decorated with @computed_field decorator to expose them later in dict().</p> <p>Construct parent pydantic Metaclass/ Model.</p> <p>If class has ormar_config declared (so actual ormar Models) it also:</p> <ul> <li>populate sqlalchemy columns, pkname and tables from model_fields</li> <li>register reverse relationships on related models</li> <li>registers all relations in alias manager that populates table_prefixes</li> <li>exposes alias manager on each Model</li> <li>creates QuerySet for each model and exposes it on a class</li> <li>sets custom serializers for relation models</li> </ul> <p>:param name: name of current class :type name: str :param bases: base classes :type bases: Tuple :param attrs: class namespace :type attrs: Dict</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def __new__(  # type: ignore # noqa: CCR001\n    mcs: \"ModelMetaclass\",\n    name: str,\n    bases: Any,\n    attrs: dict,\n    __pydantic_generic_metadata__: Union[PydanticGenericMetadata, None] = None,\n    __pydantic_reset_parent_namespace__: bool = True,\n    _create_model_module: Union[str, None] = None,\n    **kwargs,\n) -&gt; type:\n    \"\"\"\n    Metaclass used by ormar Models that performs configuration\n    and build of ormar Models.\n\n\n    Sets pydantic configuration.\n    Extract model_fields and convert them to pydantic FieldInfo,\n    updates class namespace.\n\n    Extracts settings and fields from parent classes.\n    Fetches methods decorated with @computed_field decorator\n    to expose them later in dict().\n\n    Construct parent pydantic Metaclass/ Model.\n\n    If class has ormar_config declared (so actual ormar Models) it also:\n\n    * populate sqlalchemy columns, pkname and tables from model_fields\n    * register reverse relationships on related models\n    * registers all relations in alias manager that populates table_prefixes\n    * exposes alias manager on each Model\n    * creates QuerySet for each model and exposes it on a class\n    * sets custom serializers for relation models\n\n    :param name: name of current class\n    :type name: str\n    :param bases: base classes\n    :type bases: Tuple\n    :param attrs: class namespace\n    :type attrs: Dict\n    \"\"\"\n    merge_or_generate_pydantic_config(attrs=attrs, name=name)\n    attrs[\"__name__\"] = name\n    attrs, model_fields = extract_annotations_and_default_vals(attrs)\n    for base in reversed(bases):\n        mod = base.__module__\n        if mod.startswith(\"ormar.models.\") or mod.startswith(\"pydantic.\"):\n            continue\n        attrs, model_fields = extract_from_parents_definition(\n            base_class=base, curr_class=mcs, attrs=attrs, model_fields=model_fields\n        )\n    if \"ormar_config\" in attrs:\n        attrs[\"model_config\"][\"ignored_types\"] = (OrmarConfig,)\n        attrs[\"model_config\"][\"from_attributes\"] = True\n        for field_name, field in model_fields.items():\n            if field.is_relation:\n                decorator = field_serializer(\n                    field_name, mode=\"wrap\", check_fields=False\n                )(get_serializer())\n                attrs[f\"serialize_{field_name}\"] = decorator\n\n    new_model = super().__new__(\n        mcs,  # type: ignore\n        name,\n        bases,\n        attrs,\n        __pydantic_generic_metadata__=__pydantic_generic_metadata__,\n        __pydantic_reset_parent_namespace__=__pydantic_reset_parent_namespace__,\n        _create_model_module=_create_model_module,\n        **kwargs,\n    )\n\n    add_cached_properties(new_model)\n\n    if hasattr(new_model, \"ormar_config\"):\n        populate_default_options_values(new_model, model_fields)\n        check_required_config_parameters(new_model)\n        add_property_fields(new_model, attrs)\n        register_signals(new_model=new_model)\n        modify_schema_example(model=new_model)\n\n        if not new_model.ormar_config.abstract:\n            new_model = populate_config_tablename_columns_and_pk(name, new_model)\n            populate_config_sqlalchemy_table_if_required(new_model.ormar_config)\n            expand_reverse_relationships(new_model)\n            for field_name, field in new_model.ormar_config.model_fields.items():\n                register_relation_in_alias_manager(field=field)\n                add_field_descriptor(\n                    name=field_name, field=field, new_model=new_model\n                )\n\n            if (\n                new_model.ormar_config.pkname\n                and new_model.ormar_config.pkname not in attrs[\"__annotations__\"]\n                and new_model.ormar_config.pkname not in new_model.model_fields\n            ):\n                field_name = new_model.ormar_config.pkname\n                new_model.model_fields[field_name] = (\n                    FieldInfo.from_annotated_attribute(\n                        Optional[int],  # type: ignore\n                        None,\n                    )\n                )\n                new_model.model_rebuild(force=True)\n\n            new_model.pk = PkDescriptor(name=new_model.ormar_config.pkname)\n            remove_excluded_parent_fields(new_model)\n\n    return new_model\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.add_cached_properties","title":"<code>add_cached_properties(new_model)</code>","text":"<p>Sets cached properties for both pydantic and ormar models.</p> <p>Quick access fields are fields grabbed in getattribute to skip all checks.</p> <p>Related fields and names are populated to None as they can change later. When children models are constructed they can modify parent to register itself.</p> <p>All properties here are used as \"cache\" to not recalculate them constantly.</p> <p>:param new_model: newly constructed Model :type new_model: Model class</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def add_cached_properties(new_model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Sets cached properties for both pydantic and ormar models.\n\n    Quick access fields are fields grabbed in getattribute to skip all checks.\n\n    Related fields and names are populated to None as they can change later.\n    When children models are constructed they can modify parent to register itself.\n\n    All properties here are used as \"cache\" to not recalculate them constantly.\n\n    :param new_model: newly constructed Model\n    :type new_model: Model class\n    \"\"\"\n    new_model._quick_access_fields = quick_access_set\n    new_model._related_names = None\n    new_model._through_names = None\n    new_model._related_fields = None\n    new_model._json_fields = set()\n    new_model._bytes_fields = set()\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.add_field_descriptor","title":"<code>add_field_descriptor(name, field, new_model)</code>","text":"<p>Sets appropriate descriptor for each model field. There are 5 main types of descriptors, for bytes, json, pure pydantic fields, and 2 ormar ones - one for relation and one for pk shortcut</p> <p>:param name: name of the field :type name: str :param field: model field to add descriptor for :type field: BaseField :param new_model: model with fields :type new_model: Type[\"Model]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def add_field_descriptor(\n    name: str, field: \"BaseField\", new_model: Type[\"Model\"]\n) -&gt; None:\n    \"\"\"\n    Sets appropriate descriptor for each model field.\n    There are 5 main types of descriptors, for bytes, json, pure pydantic fields,\n    and 2 ormar ones - one for relation and one for pk shortcut\n\n    :param name: name of the field\n    :type name: str\n    :param field: model field to add descriptor for\n    :type field: BaseField\n    :param new_model: model with fields\n    :type new_model: Type[\"Model]\n    \"\"\"\n    if field.is_relation:\n        setattr(new_model, name, RelationDescriptor(name=name))\n    elif field.__type__ == pydantic.Json:\n        setattr(new_model, name, JsonDescriptor(name=name))\n    elif field.__type__ is bytes:\n        setattr(new_model, name, BytesDescriptor(name=name))\n    else:\n        setattr(new_model, name, PydanticDescriptor(name=name))\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.add_property_fields","title":"<code>add_property_fields(new_model, attrs)</code>","text":"<p>Checks class namespace for properties or functions with computed_field. If attribute have decorator_info it was decorated with @computed_field.</p> <p>Functions like this are exposed in dict() (therefore also fastapi result). Names of property fields are cached for quicker access / extraction.</p> <p>:param new_model: newly constructed model :type new_model: Model class :param attrs: :type attrs: Dict[str, str]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def add_property_fields(new_model: Type[\"Model\"], attrs: Dict) -&gt; None:  # noqa: CCR001\n    \"\"\"\n    Checks class namespace for properties or functions with computed_field.\n    If attribute have decorator_info it was decorated with @computed_field.\n\n    Functions like this are exposed in dict() (therefore also fastapi result).\n    Names of property fields are cached for quicker access / extraction.\n\n    :param new_model: newly constructed model\n    :type new_model: Model class\n    :param attrs:\n    :type attrs: Dict[str, str]\n    \"\"\"\n    props = set()\n    for var_name, value in attrs.items():\n        if hasattr(value, \"decorator_info\") and isinstance(\n            value.decorator_info, ComputedFieldInfo\n        ):\n            props.add(var_name)\n\n    if config_field_not_set(model=new_model, field_name=\"property_fields\"):\n        new_model.ormar_config.property_fields = props\n    else:\n        new_model.ormar_config.property_fields = (\n            new_model.ormar_config.property_fields.union(props)\n        )\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.copy_and_replace_m2m_through_model","title":"<code>copy_and_replace_m2m_through_model(field, field_name, table_name, parent_fields, attrs, ormar_config, base_class)</code>","text":"<p>Clones class with Through model for m2m relations, appends child name to the name of the cloned class.</p> <p>Clones non foreign keys fields from parent model, the same with database columns.</p> <p>Modifies related_name with appending child table name after '_'</p> <p>For table name, the table name of child is appended after '_'.</p> <p>Removes the original sqlalchemy table from metadata if it was not removed.</p> <p>:param base_class: base class model :type base_class: Type[\"Model\"] :param field: field with relations definition :type field: ManyToManyField :param field_name: name of the relation field :type field_name: str :param table_name: name of the table :type table_name: str :param parent_fields: dictionary of fields to copy to new models from parent :type parent_fields: Dict :param attrs: new namespace for class being constructed :type attrs: Dict :param ormar_config: metaclass of currently created model :type ormar_config: OrmarConfig</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def copy_and_replace_m2m_through_model(  # noqa: CFQ002\n    field: ManyToManyField,\n    field_name: str,\n    table_name: str,\n    parent_fields: Dict,\n    attrs: Dict,\n    ormar_config: OrmarConfig,\n    base_class: Type[\"Model\"],\n) -&gt; None:\n    \"\"\"\n    Clones class with Through model for m2m relations, appends child name to the name\n    of the cloned class.\n\n    Clones non foreign keys fields from parent model, the same with database columns.\n\n    Modifies related_name with appending child table name after '_'\n\n    For table name, the table name of child is appended after '_'.\n\n    Removes the original sqlalchemy table from metadata if it was not removed.\n\n    :param base_class: base class model\n    :type base_class: Type[\"Model\"]\n    :param field: field with relations definition\n    :type field: ManyToManyField\n    :param field_name: name of the relation field\n    :type field_name: str\n    :param table_name: name of the table\n    :type table_name: str\n    :param parent_fields: dictionary of fields to copy to new models from parent\n    :type parent_fields: Dict\n    :param attrs: new namespace for class being constructed\n    :type attrs: Dict\n    :param ormar_config: metaclass of currently created model\n    :type ormar_config: OrmarConfig\n    \"\"\"\n    Field: Type[BaseField] = type(  # type: ignore\n        field.__class__.__name__, (ManyToManyField, BaseField), {}\n    )\n    copy_field = Field(**dict(field.__dict__))\n    related_name = field.related_name + \"_\" + table_name\n    copy_field.related_name = related_name  # type: ignore\n\n    through_class = field.through\n    if not through_class:\n        field.owner = base_class\n        field.create_default_through_model()\n        through_class = field.through\n    new_config = ormar.OrmarConfig(\n        tablename=through_class.ormar_config.tablename,\n        metadata=through_class.ormar_config.metadata,\n        database=through_class.ormar_config.database,\n        abstract=through_class.ormar_config.abstract,\n        exclude_parent_fields=through_class.ormar_config.exclude_parent_fields,\n        queryset_class=through_class.ormar_config.queryset_class,\n        extra=through_class.ormar_config.extra,\n        constraints=through_class.ormar_config.constraints,\n        order_by=through_class.ormar_config.orders_by,\n    )\n    new_config.table = through_class.ormar_config.pkname\n    new_config.pkname = through_class.ormar_config.pkname\n    new_config.alias_manager = through_class.ormar_config.alias_manager\n    new_config.signals = through_class.ormar_config.signals\n    new_config.requires_ref_update = through_class.ormar_config.requires_ref_update\n    new_config.model_fields = copy.deepcopy(through_class.ormar_config.model_fields)\n    new_config.property_fields = copy.deepcopy(\n        through_class.ormar_config.property_fields\n    )\n    copy_name = through_class.__name__ + attrs.get(\"__name__\", \"\")\n    copy_through = cast(\n        Type[ormar.Model], type(copy_name, (ormar.Model,), {\"ormar_config\": new_config})\n    )\n    # create new table with copied columns but remove foreign keys\n    # they will be populated later in expanding reverse relation\n    # if hasattr(new_config, \"table\"):\n    new_config.tablename += \"_\" + ormar_config.tablename\n    new_config.table = None\n    new_config.model_fields = {\n        name: field\n        for name, field in new_config.model_fields.items()\n        if not field.is_relation\n    }\n    _, columns = sqlalchemy_columns_from_model_fields(\n        new_config.model_fields, copy_through\n    )  # type: ignore\n    new_config.columns = columns\n    populate_config_sqlalchemy_table_if_required(config=new_config)\n    copy_field.through = copy_through\n\n    parent_fields[field_name] = copy_field\n\n    if through_class.ormar_config.table in through_class.ormar_config.metadata:\n        through_class.ormar_config.metadata.remove(through_class.ormar_config.table)\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.copy_data_from_parent_model","title":"<code>copy_data_from_parent_model(base_class, curr_class, attrs, model_fields)</code>","text":"<p>Copy the key parameters [database, metadata, property_fields and constraints] and fields from parent models. Overwrites them if needed.</p> <p>Only abstract classes can be subclassed.</p> <p>Since relation fields requires different related_name for different children</p> <p>:raises ModelDefinitionError: if non abstract model is subclassed :param base_class: one of the parent classes :type base_class: Model or model parent class :param curr_class: current constructed class :type curr_class: Model or model parent class :param attrs: new namespace for class being constructed :type attrs: Dict :param model_fields: ormar fields in defined in current class :type model_fields: Dict[str, BaseField] :return: updated attrs and model_fields :rtype: Tuple[Dict, Dict]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def copy_data_from_parent_model(  # noqa: CCR001\n    base_class: Type[\"Model\"],\n    curr_class: type,\n    attrs: Dict,\n    model_fields: Dict[str, Union[BaseField, ForeignKeyField, ManyToManyField]],\n) -&gt; Tuple[Dict, Dict]:\n    \"\"\"\n    Copy the key parameters [database, metadata, property_fields and constraints]\n    and fields from parent models. Overwrites them if needed.\n\n    Only abstract classes can be subclassed.\n\n    Since relation fields requires different related_name for different children\n\n\n    :raises ModelDefinitionError: if non abstract model is subclassed\n    :param base_class: one of the parent classes\n    :type base_class: Model or model parent class\n    :param curr_class: current constructed class\n    :type curr_class: Model or model parent class\n    :param attrs: new namespace for class being constructed\n    :type attrs: Dict\n    :param model_fields: ormar fields in defined in current class\n    :type model_fields: Dict[str, BaseField]\n    :return: updated attrs and model_fields\n    :rtype: Tuple[Dict, Dict]\n    \"\"\"\n    if attrs.get(\"ormar_config\"):\n        if model_fields and not base_class.ormar_config.abstract:  # type: ignore\n            raise ModelDefinitionError(\n                f\"{curr_class.__name__} cannot inherit \"\n                f\"from non abstract class {base_class.__name__}\"\n            )\n        update_attrs_from_base_config(\n            base_class=base_class,  # type: ignore\n            attrs=attrs,\n            model_fields=model_fields,\n        )\n        parent_fields: Dict = dict()\n        ormar_config = attrs.get(\"ormar_config\")\n        if not ormar_config:  # pragma: no cover\n            raise ModelDefinitionError(\n                f\"Model {curr_class.__name__} declared without ormar_config\"\n            )\n        table_name = (\n            ormar_config.tablename\n            if hasattr(ormar_config, \"tablename\") and ormar_config.tablename\n            else attrs.get(\"__name__\", \"\").lower() + \"s\"\n        )\n        for field_name, field in base_class.ormar_config.model_fields.items():\n            if (\n                hasattr(ormar_config, \"exclude_parent_fields\")\n                and field_name in ormar_config.exclude_parent_fields\n            ):\n                continue\n            if field.is_multi:\n                field = cast(ManyToManyField, field)\n                copy_and_replace_m2m_through_model(\n                    field=field,\n                    field_name=field_name,\n                    table_name=table_name,\n                    parent_fields=parent_fields,\n                    attrs=attrs,\n                    ormar_config=ormar_config,\n                    base_class=base_class,  # type: ignore\n                )\n\n            elif field.is_relation and field.related_name:\n                Field = type(  # type: ignore\n                    field.__class__.__name__, (ForeignKeyField, BaseField), {}\n                )\n                copy_field = Field(**dict(field.__dict__))\n                related_name = field.related_name + \"_\" + table_name\n                copy_field.related_name = related_name  # type: ignore\n                parent_fields[field_name] = copy_field\n            else:\n                parent_fields[field_name] = field\n\n        parent_fields.update(model_fields)  # type: ignore\n        model_fields = parent_fields\n    return attrs, model_fields\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.extract_from_parents_definition","title":"<code>extract_from_parents_definition(base_class, curr_class, attrs, model_fields)</code>","text":"<p>Extracts fields from base classes if they have valid ormar fields.</p> <p>If model was already parsed -&gt; fields definitions need to be removed from class cause pydantic complains about field re-definition so after first child we need to extract from parsed_fields not the class itself.</p> <p>If the class is parsed first time annotations and field definition is parsed from the class.dict.</p> <p>If the class is a ormar.Model it is skipped.</p> <p>:param base_class: one of the parent classes :type base_class: Model or model parent class :param curr_class: current constructed class :type curr_class: Model or model parent class :param attrs: new namespace for class being constructed :type attrs: Dict :param model_fields: ormar fields in defined in current class :type model_fields: Dict[str, BaseField] :return: updated attrs and model_fields :rtype: Tuple[Dict, Dict]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def extract_from_parents_definition(  # noqa: CCR001\n    base_class: type,\n    curr_class: type,\n    attrs: Dict,\n    model_fields: Dict[str, Union[BaseField, ForeignKeyField, ManyToManyField]],\n) -&gt; Tuple[Dict, Dict]:\n    \"\"\"\n    Extracts fields from base classes if they have valid ormar fields.\n\n    If model was already parsed -&gt; fields definitions need to be removed from class\n    cause pydantic complains about field re-definition so after first child\n    we need to extract from __parsed_fields__ not the class itself.\n\n    If the class is parsed first time annotations and field definition is parsed\n    from the class.__dict__.\n\n    If the class is a ormar.Model it is skipped.\n\n    :param base_class: one of the parent classes\n    :type base_class: Model or model parent class\n    :param curr_class: current constructed class\n    :type curr_class: Model or model parent class\n    :param attrs: new namespace for class being constructed\n    :type attrs: Dict\n    :param model_fields: ormar fields in defined in current class\n    :type model_fields: Dict[str, BaseField]\n    :return: updated attrs and model_fields\n    :rtype: Tuple[Dict, Dict]\n    \"\"\"\n    if hasattr(base_class, \"ormar_config\"):\n        base_class = cast(Type[\"Model\"], base_class)\n        return copy_data_from_parent_model(\n            base_class=base_class,\n            curr_class=curr_class,\n            attrs=attrs,\n            model_fields=model_fields,\n        )\n\n    key = \"__annotations__\"\n    if hasattr(base_class, PARSED_FIELDS_KEY):\n        # model was already parsed -&gt; fields definitions need to be removed from class\n        # cause pydantic complains about field re-definition so after first child\n        # we need to extract from __parsed_fields__ not the class itself\n        new_attrs, new_model_fields = getattr(base_class, PARSED_FIELDS_KEY)\n\n        new_fields = set(new_model_fields.keys())\n        model_fields = update_attrs_and_fields(\n            attrs=attrs,\n            new_attrs=new_attrs,\n            model_fields=model_fields,\n            new_model_fields=new_model_fields,\n            new_fields=new_fields,\n        )\n        return attrs, model_fields\n\n    potential_fields = get_potential_fields(base_class.__dict__)\n    if potential_fields:\n        # parent model has ormar fields defined and was not parsed before\n        new_attrs = {key: {k: v for k, v in base_class.__dict__.get(key, {}).items()}}\n        new_attrs.update(potential_fields)\n\n        new_fields = set(potential_fields.keys())\n        for name in new_fields:\n            delattr(base_class, name)\n\n        new_attrs, new_model_fields = extract_annotations_and_default_vals(new_attrs)\n        setattr(base_class, PARSED_FIELDS_KEY, (new_attrs, new_model_fields))\n        model_fields = update_attrs_and_fields(\n            attrs=attrs,\n            new_attrs=new_attrs,\n            model_fields=model_fields,\n            new_model_fields=new_model_fields,\n            new_fields=new_fields,\n        )\n    return attrs, model_fields\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.get_constraint_copy","title":"<code>get_constraint_copy(constraint)</code>","text":"<p>Copy the constraint and unpacking it's values</p> <p>:raises ValueError: if non subclass of ColumnCollectionConstraint :param value: an instance of the ColumnCollectionConstraint class :type value: Instance of ColumnCollectionConstraint child :return: copy ColumnCollectionConstraint ormar constraints :rtype: Union[UniqueColumns, IndexColumns, CheckColumns]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def get_constraint_copy(\n    constraint: ColumnCollectionConstraint,\n) -&gt; Union[UniqueColumns, IndexColumns, CheckColumns]:\n    \"\"\"\n    Copy the constraint and unpacking it's values\n\n    :raises ValueError: if non subclass of ColumnCollectionConstraint\n    :param value: an instance of the ColumnCollectionConstraint class\n    :type value: Instance of ColumnCollectionConstraint child\n    :return: copy ColumnCollectionConstraint ormar constraints\n    :rtype: Union[UniqueColumns, IndexColumns, CheckColumns]\n    \"\"\"\n\n    constraints = {\n        sqlalchemy.UniqueConstraint: lambda x: UniqueColumns(*x._pending_colargs),\n        sqlalchemy.Index: lambda x: IndexColumns(*x._pending_colargs),\n        sqlalchemy.CheckConstraint: lambda x: CheckColumns(x.sqltext),\n    }\n    checks = (key if isinstance(constraint, key) else None for key in constraints)\n    target_class = next((target for target in checks if target is not None), None)\n    constructor: Optional[Callable] = constraints.get(target_class)\n    if not constructor:\n        raise ValueError(f\"{constraint} must be a ColumnCollectionMixin!\")\n\n    return constructor(constraint)\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.register_signals","title":"<code>register_signals(new_model)</code>","text":"<p>Registers on model's SignalEmmiter and sets pre-defined signals. Predefined signals are (pre/post) + (save/update/delete).</p> <p>Signals are emitted in both model own methods and in selected queryset ones.</p> <p>:param new_model: newly constructed model :type new_model: Model class</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def register_signals(new_model: Type[\"Model\"]) -&gt; None:  # noqa: CCR001\n    \"\"\"\n    Registers on model's SignalEmmiter and sets pre-defined signals.\n    Predefined signals are (pre/post) + (save/update/delete).\n\n    Signals are emitted in both model own methods and in selected queryset ones.\n\n    :param new_model: newly constructed model\n    :type new_model: Model class\n    \"\"\"\n    if config_field_not_set(model=new_model, field_name=\"signals\"):\n        signals = new_model.ormar_config.signals\n        signals.pre_save = Signal()\n        signals.pre_update = Signal()\n        signals.pre_delete = Signal()\n        signals.post_save = Signal()\n        signals.post_update = Signal()\n        signals.post_delete = Signal()\n        signals.pre_relation_add = Signal()\n        signals.post_relation_add = Signal()\n        signals.pre_relation_remove = Signal()\n        signals.post_relation_remove = Signal()\n        signals.post_bulk_update = Signal()\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.update_attrs_and_fields","title":"<code>update_attrs_and_fields(attrs, new_attrs, model_fields, new_model_fields, new_fields)</code>","text":"<p>Updates annotations, values of model fields (so pydantic FieldInfos) as well as model.ormar_config.model_fields definitions from parents.</p> <p>:param attrs: new namespace for class being constructed :type attrs: Dict :param new_attrs: related of the namespace extracted from parent class :type new_attrs: Dict :param model_fields: ormar fields in defined in current class :type model_fields: Dict[str, BaseField] :param new_model_fields: ormar fields defined in parent classes :type new_model_fields: Dict[str, BaseField] :param new_fields: set of new fields names :type new_fields: Set[str]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def update_attrs_and_fields(\n    attrs: Dict,\n    new_attrs: Dict,\n    model_fields: Dict,\n    new_model_fields: Dict,\n    new_fields: Set,\n) -&gt; Dict:\n    \"\"\"\n    Updates __annotations__, values of model fields (so pydantic FieldInfos)\n    as well as model.ormar_config.model_fields definitions from parents.\n\n    :param attrs: new namespace for class being constructed\n    :type attrs: Dict\n    :param new_attrs: related of the namespace extracted from parent class\n    :type new_attrs: Dict\n    :param model_fields: ormar fields in defined in current class\n    :type model_fields: Dict[str, BaseField]\n    :param new_model_fields: ormar fields defined in parent classes\n    :type new_model_fields: Dict[str, BaseField]\n    :param new_fields: set of new fields names\n    :type new_fields: Set[str]\n    \"\"\"\n    key = \"__annotations__\"\n    attrs[key].update(new_attrs[key])\n    attrs.update({name: new_attrs[name] for name in new_fields})\n    updated_model_fields = {k: v for k, v in new_model_fields.items()}\n    updated_model_fields.update(model_fields)\n    return updated_model_fields\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.update_attrs_from_base_config","title":"<code>update_attrs_from_base_config(base_class, attrs, model_fields)</code>","text":"<p>Updates OrmarConfig parameters in child from parent if needed.</p> <p>:param base_class: one of the parent classes :type base_class: Model or model parent class :param attrs: new namespace for class being constructed :type attrs: Dict :param model_fields: ormar fields in defined in current class :type model_fields: Dict[str, BaseField]</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def update_attrs_from_base_config(  # noqa: CCR001\n    base_class: \"Model\", attrs: Dict, model_fields: Dict\n) -&gt; None:\n    \"\"\"\n    Updates OrmarConfig parameters in child from parent if needed.\n\n    :param base_class: one of the parent classes\n    :type base_class: Model or model parent class\n    :param attrs: new namespace for class being constructed\n    :type attrs: Dict\n    :param model_fields: ormar fields in defined in current class\n    :type model_fields: Dict[str, BaseField]\n    \"\"\"\n\n    params_to_update = [\"metadata\", \"database\", \"constraints\", \"property_fields\"]\n    for param in params_to_update:\n        current_value = attrs.get(\"ormar_config\", {}).__dict__.get(\n            param, ormar.Undefined\n        )\n        parent_value = (\n            base_class.ormar_config.__dict__.get(param)\n            if hasattr(base_class, \"ormar_config\")\n            else None\n        )\n        if parent_value:\n            if param == \"constraints\":\n                verify_constraint_names(\n                    base_class=base_class,\n                    model_fields=model_fields,\n                    parent_value=parent_value,\n                )\n                parent_value = [get_constraint_copy(value) for value in parent_value]\n            if isinstance(current_value, list):\n                current_value.extend(parent_value)\n            else:\n                setattr(attrs[\"ormar_config\"], param, parent_value)\n</code></pre>"},{"location":"api/models/metaclass/#ormar.models.metaclass.verify_constraint_names","title":"<code>verify_constraint_names(base_class, model_fields, parent_value)</code>","text":"<p>Verifies if redefined fields that are overwritten in subclasses did not remove any name of the column that is used in constraint as it will fail in sqlalchemy Table creation.</p> <p>:param base_class: one of the parent classes :type base_class: Model or model parent class :param model_fields: ormar fields in defined in current class :type model_fields: Dict[str, BaseField] :param parent_value: list of base class constraints :type parent_value: List</p> Source code in <code>ormar/models/metaclass.py</code> <pre><code>def verify_constraint_names(\n    base_class: \"Model\", model_fields: Dict, parent_value: List\n) -&gt; None:\n    \"\"\"\n    Verifies if redefined fields that are overwritten in subclasses did not remove\n    any name of the column that is used in constraint as it will fail in sqlalchemy\n    Table creation.\n\n    :param base_class: one of the parent classes\n    :type base_class: Model or model parent class\n    :param model_fields: ormar fields in defined in current class\n    :type model_fields: Dict[str, BaseField]\n    :param parent_value: list of base class constraints\n    :type parent_value: List\n    \"\"\"\n    new_aliases = {x.name: x.get_alias() for x in model_fields.values()}\n    old_aliases = {\n        x.name: x.get_alias() for x in base_class.ormar_config.model_fields.values()\n    }\n    old_aliases.update(new_aliases)\n    constraints_columns = [x._pending_colargs for x in parent_value]\n    for column_set in constraints_columns:\n        if any(x not in old_aliases.values() for x in column_set):\n            raise ModelDefinitionError(\n                f\"Column constraints \"\n                f\"{column_set} \"\n                f\"has column names \"\n                f\"that are not in the model fields.\"\n                f\"\\n Check columns redefined in subclasses \"\n                f\"to verify that they have proper 'name' set.\"\n            )\n</code></pre>"},{"location":"api/models/model/","title":"model","text":""},{"location":"api/models/model/#ormar.models.model.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>ModelRow</code></p> Source code in <code>ormar/models/model.py</code> <pre><code>class Model(ModelRow):\n    __abstract__ = False\n    if TYPE_CHECKING:  # pragma nocover\n        ormar_config: OrmarConfig\n\n    def __repr__(self) -&gt; str:  # pragma nocover\n        _repr = {\n            k: getattr(self, k)\n            for k, v in self.ormar_config.model_fields.items()\n            if not v.skip_field\n        }\n        return f\"{self.__class__.__name__}({str(_repr)})\"\n\n    async def upsert(self: T, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Performs either a save or an update depending on the presence of the pk.\n        If the pk field is filled it's an update, otherwise the save is performed.\n        For save kwargs are ignored, used only in update if provided.\n\n        :param kwargs: list of fields to update\n        :type kwargs: Any\n        :return: saved Model\n        :rtype: Model\n        \"\"\"\n\n        force_save = kwargs.pop(\"__force_save__\", False)\n        if force_save:\n            expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n            row = await self.ormar_config.database.fetch_one(expr)\n            if not row:\n                return await self.save()\n            return await self.update(**kwargs)\n\n        if not self.pk:\n            return await self.save()\n        return await self.update(**kwargs)\n\n    async def save(self: T) -&gt; T:\n        \"\"\"\n        Performs a save of given Model instance.\n        If primary key is already saved, db backend will throw integrity error.\n\n        Related models are saved by pk number, reverse relation and many to many fields\n        are not saved - use corresponding relations methods.\n\n        If there are fields with server_default set and those fields\n        are not already filled save will trigger also a second query\n        to refreshed the fields populated server side.\n\n        Does not recognize if model was previously saved.\n        If you want to perform update or insert depending on the pk\n        fields presence use upsert.\n\n        Sends pre_save and post_save signals.\n\n        Sets model save status to True.\n\n        :return: saved Model\n        :rtype: Model\n        \"\"\"\n        await self.signals.pre_save.send(sender=self.__class__, instance=self)\n        self_fields = self._extract_model_db_fields()\n\n        if (\n            not self.pk\n            and self.ormar_config.model_fields[self.ormar_config.pkname].autoincrement\n        ):\n            self_fields.pop(self.ormar_config.pkname, None)\n        self_fields = self.populate_default_values(self_fields)\n        self.update_from_dict(\n            {\n                k: v\n                for k, v in self_fields.items()\n                if k not in self.extract_related_names()\n            }\n        )\n\n        self_fields = self.translate_columns_to_aliases(self_fields)\n        expr = self.ormar_config.table.insert()\n        expr = expr.values(**self_fields)\n\n        pk = await self.ormar_config.database.execute(expr)\n        if pk and isinstance(pk, self.pk_type()):\n            setattr(self, self.ormar_config.pkname, pk)\n\n        self.set_save_status(True)\n        # refresh server side defaults\n        if any(\n            field.server_default is not None\n            for name, field in self.ormar_config.model_fields.items()\n            if name not in self_fields\n        ):\n            await self.load()\n\n        await self.signals.post_save.send(sender=self.__class__, instance=self)\n        return self\n\n    async def save_related(  # noqa: CCR001, CFQ002\n        self,\n        follow: bool = False,\n        save_all: bool = False,\n        relation_map: Optional[Dict] = None,\n        exclude: Union[Set, Dict, None] = None,\n        update_count: int = 0,\n        previous_model: Optional[\"Model\"] = None,\n        relation_field: Optional[\"ForeignKeyField\"] = None,\n    ) -&gt; int:\n        \"\"\"\n        Triggers a upsert method on all related models\n        if the instances are not already saved.\n        By default saves only the directly related ones.\n\n        If follow=True is set it saves also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are saved, but the save do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second\n        Model A but will never follow into Model C.\n        Nested relations of those kind need to be persisted manually.\n\n        :param relation_field: field with relation leading to this model\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        :param exclude: items to exclude during saving of relations\n        :type exclude: Union[Set, Dict]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :param save_all: flag if all models should be saved or only not saved ones\n        :type save_all: bool\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :param update_count: internal parameter for recursive calls -\n        number of updated instances\n        :type update_count: int\n        :return: number of updated/saved models\n        :rtype: int\n        \"\"\"\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(self._iterate_related_models())\n        )\n        if exclude and isinstance(exclude, Set):\n            exclude = translate_list_to_dict(exclude)\n        relation_map = subtract_dict(relation_map, exclude or {})\n\n        if relation_map:\n            fields_to_visit = {\n                field\n                for field in self.extract_related_fields()\n                if field.name in relation_map\n            }\n            pre_save = {\n                field\n                for field in fields_to_visit\n                if not field.virtual and not field.is_multi\n            }\n\n            update_count = await self._update_relation_list(\n                fields_list=pre_save,\n                follow=follow,\n                save_all=save_all,\n                relation_map=relation_map,\n                update_count=update_count,\n            )\n\n            update_count = await self._upsert_model(\n                instance=self,\n                save_all=save_all,\n                previous_model=previous_model,\n                relation_field=relation_field,\n                update_count=update_count,\n            )\n\n            post_save = fields_to_visit - pre_save\n\n            update_count = await self._update_relation_list(\n                fields_list=post_save,\n                follow=follow,\n                save_all=save_all,\n                relation_map=relation_map,\n                update_count=update_count,\n            )\n\n        else:\n            update_count = await self._upsert_model(\n                instance=self,\n                save_all=save_all,\n                previous_model=previous_model,\n                relation_field=relation_field,\n                update_count=update_count,\n            )\n\n        return update_count\n\n    async def update(self: T, _columns: Optional[List[str]] = None, **kwargs: Any) -&gt; T:\n        \"\"\"\n        Performs update of Model instance in the database.\n        Fields can be updated before or you can pass them as kwargs.\n\n        Sends pre_update and post_update signals.\n\n        Sets model save status to True.\n\n        :param _columns: list of columns to update, if None all are updated\n        :type _columns: List\n        :raises ModelPersistenceError: If the pk column is not set\n\n        :param kwargs: list of fields to update as field=value pairs\n        :type kwargs: Any\n        :return: updated Model\n        :rtype: Model\n        \"\"\"\n        if kwargs:\n            self.update_from_dict(kwargs)\n\n        if not self.pk:\n            raise ModelPersistenceError(\n                \"You cannot update not saved model! Use save or upsert method.\"\n            )\n\n        await self.signals.pre_update.send(\n            sender=self.__class__, instance=self, passed_args=kwargs\n        )\n        self_fields = self._extract_model_db_fields()\n        self_fields.pop(self.get_column_name_from_alias(self.ormar_config.pkname))\n        if _columns:\n            self_fields = {k: v for k, v in self_fields.items() if k in _columns}\n        if self_fields:\n            self_fields = self.translate_columns_to_aliases(self_fields)\n            expr = self.ormar_config.table.update().values(**self_fields)\n            expr = expr.where(self.pk_column == getattr(self, self.ormar_config.pkname))\n\n            await self.ormar_config.database.execute(expr)\n        self.set_save_status(True)\n        await self.signals.post_update.send(sender=self.__class__, instance=self)\n        return self\n\n    async def delete(self) -&gt; int:\n        \"\"\"\n        Removes the Model instance from the database.\n\n        Sends pre_delete and post_delete signals.\n\n        Sets model save status to False.\n\n        Note it does not delete the Model itself (python object).\n        So you can delete and later save (since pk is deleted no conflict will arise)\n        or update and the Model will be saved in database again.\n\n        :return: number of deleted rows (for some backends)\n        :rtype: int\n        \"\"\"\n        await self.signals.pre_delete.send(sender=self.__class__, instance=self)\n        expr = self.ormar_config.table.delete()\n        expr = expr.where(self.pk_column == (getattr(self, self.ormar_config.pkname)))\n        result = await self.ormar_config.database.execute(expr)\n        self.set_save_status(False)\n        await self.signals.post_delete.send(sender=self.__class__, instance=self)\n        return result\n\n    async def load(self: T) -&gt; T:\n        \"\"\"\n        Allow to refresh existing Models fields from database.\n        Be careful as the related models can be overwritten by pk_only models in load.\n        Does NOT refresh the related models fields if they were loaded before.\n\n        :raises NoMatch: If given pk is not found in database.\n\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n        row = await self.ormar_config.database.fetch_one(expr)\n        if not row:  # pragma nocover\n            raise NoMatch(\"Instance was deleted from database and cannot be refreshed\")\n        kwargs = dict(row)\n        kwargs = self.translate_aliases_to_columns(kwargs)\n        self.update_from_dict(kwargs)\n        self.set_save_status(True)\n        return self\n\n    async def load_all(\n        self: T,\n        follow: bool = False,\n        exclude: Union[List, str, Set, Dict, None] = None,\n        order_by: Union[List, str, None] = None,\n    ) -&gt; T:\n        \"\"\"\n        Allow to refresh existing Models fields from database.\n        Performs refresh of the related models fields.\n\n        By default, loads only self and the directly related ones.\n\n        If follow=True is set it loads also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param order_by: columns by which models should be sorted\n        :type order_by: Union[List, str]\n        :raises NoMatch: If given pk is not found in database.\n\n        :param exclude: related models to exclude\n        :type exclude: Union[List, str, Set, Dict]\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        relations = list(self.extract_related_names())\n        if follow:\n            relations = self._iterate_related_models()\n        queryset = self.__class__.objects\n        if exclude:\n            queryset = queryset.exclude_fields(exclude)\n        if order_by:\n            queryset = queryset.order_by(order_by)\n        instance = await queryset.select_related(relations).get(pk=self.pk)\n        self._orm.clear()\n        self.update_from_dict(instance.model_dump())\n        return self\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Removes the Model instance from the database.</p> <p>Sends pre_delete and post_delete signals.</p> <p>Sets model save status to False.</p> <p>Note it does not delete the Model itself (python object). So you can delete and later save (since pk is deleted no conflict will arise) or update and the Model will be saved in database again.</p> <p>:return: number of deleted rows (for some backends) :rtype: int</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def delete(self) -&gt; int:\n    \"\"\"\n    Removes the Model instance from the database.\n\n    Sends pre_delete and post_delete signals.\n\n    Sets model save status to False.\n\n    Note it does not delete the Model itself (python object).\n    So you can delete and later save (since pk is deleted no conflict will arise)\n    or update and the Model will be saved in database again.\n\n    :return: number of deleted rows (for some backends)\n    :rtype: int\n    \"\"\"\n    await self.signals.pre_delete.send(sender=self.__class__, instance=self)\n    expr = self.ormar_config.table.delete()\n    expr = expr.where(self.pk_column == (getattr(self, self.ormar_config.pkname)))\n    result = await self.ormar_config.database.execute(expr)\n    self.set_save_status(False)\n    await self.signals.post_delete.send(sender=self.__class__, instance=self)\n    return result\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.load","title":"<code>load()</code>  <code>async</code>","text":"<p>Allow to refresh existing Models fields from database. Be careful as the related models can be overwritten by pk_only models in load. Does NOT refresh the related models fields if they were loaded before.</p> <p>:raises NoMatch: If given pk is not found in database.</p> <p>:return: reloaded Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def load(self: T) -&gt; T:\n    \"\"\"\n    Allow to refresh existing Models fields from database.\n    Be careful as the related models can be overwritten by pk_only models in load.\n    Does NOT refresh the related models fields if they were loaded before.\n\n    :raises NoMatch: If given pk is not found in database.\n\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n    row = await self.ormar_config.database.fetch_one(expr)\n    if not row:  # pragma nocover\n        raise NoMatch(\"Instance was deleted from database and cannot be refreshed\")\n    kwargs = dict(row)\n    kwargs = self.translate_aliases_to_columns(kwargs)\n    self.update_from_dict(kwargs)\n    self.set_save_status(True)\n    return self\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.load_all","title":"<code>load_all(follow=False, exclude=None, order_by=None)</code>  <code>async</code>","text":"<p>Allow to refresh existing Models fields from database. Performs refresh of the related models fields.</p> <p>By default, loads only self and the directly related ones.</p> <p>If follow=True is set it loads also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param order_by: columns by which models should be sorted :type order_by: Union[List, str] :raises NoMatch: If given pk is not found in database.</p> <p>:param exclude: related models to exclude :type exclude: Union[List, str, Set, Dict] :param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def load_all(\n    self: T,\n    follow: bool = False,\n    exclude: Union[List, str, Set, Dict, None] = None,\n    order_by: Union[List, str, None] = None,\n) -&gt; T:\n    \"\"\"\n    Allow to refresh existing Models fields from database.\n    Performs refresh of the related models fields.\n\n    By default, loads only self and the directly related ones.\n\n    If follow=True is set it loads also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param order_by: columns by which models should be sorted\n    :type order_by: Union[List, str]\n    :raises NoMatch: If given pk is not found in database.\n\n    :param exclude: related models to exclude\n    :type exclude: Union[List, str, Set, Dict]\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    relations = list(self.extract_related_names())\n    if follow:\n        relations = self._iterate_related_models()\n    queryset = self.__class__.objects\n    if exclude:\n        queryset = queryset.exclude_fields(exclude)\n    if order_by:\n        queryset = queryset.order_by(order_by)\n    instance = await queryset.select_related(relations).get(pk=self.pk)\n    self._orm.clear()\n    self.update_from_dict(instance.model_dump())\n    return self\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.save","title":"<code>save()</code>  <code>async</code>","text":"<p>Performs a save of given Model instance. If primary key is already saved, db backend will throw integrity error.</p> <p>Related models are saved by pk number, reverse relation and many to many fields are not saved - use corresponding relations methods.</p> <p>If there are fields with server_default set and those fields are not already filled save will trigger also a second query to refreshed the fields populated server side.</p> <p>Does not recognize if model was previously saved. If you want to perform update or insert depending on the pk fields presence use upsert.</p> <p>Sends pre_save and post_save signals.</p> <p>Sets model save status to True.</p> <p>:return: saved Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def save(self: T) -&gt; T:\n    \"\"\"\n    Performs a save of given Model instance.\n    If primary key is already saved, db backend will throw integrity error.\n\n    Related models are saved by pk number, reverse relation and many to many fields\n    are not saved - use corresponding relations methods.\n\n    If there are fields with server_default set and those fields\n    are not already filled save will trigger also a second query\n    to refreshed the fields populated server side.\n\n    Does not recognize if model was previously saved.\n    If you want to perform update or insert depending on the pk\n    fields presence use upsert.\n\n    Sends pre_save and post_save signals.\n\n    Sets model save status to True.\n\n    :return: saved Model\n    :rtype: Model\n    \"\"\"\n    await self.signals.pre_save.send(sender=self.__class__, instance=self)\n    self_fields = self._extract_model_db_fields()\n\n    if (\n        not self.pk\n        and self.ormar_config.model_fields[self.ormar_config.pkname].autoincrement\n    ):\n        self_fields.pop(self.ormar_config.pkname, None)\n    self_fields = self.populate_default_values(self_fields)\n    self.update_from_dict(\n        {\n            k: v\n            for k, v in self_fields.items()\n            if k not in self.extract_related_names()\n        }\n    )\n\n    self_fields = self.translate_columns_to_aliases(self_fields)\n    expr = self.ormar_config.table.insert()\n    expr = expr.values(**self_fields)\n\n    pk = await self.ormar_config.database.execute(expr)\n    if pk and isinstance(pk, self.pk_type()):\n        setattr(self, self.ormar_config.pkname, pk)\n\n    self.set_save_status(True)\n    # refresh server side defaults\n    if any(\n        field.server_default is not None\n        for name, field in self.ormar_config.model_fields.items()\n        if name not in self_fields\n    ):\n        await self.load()\n\n    await self.signals.post_save.send(sender=self.__class__, instance=self)\n    return self\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.save_related","title":"<code>save_related(follow=False, save_all=False, relation_map=None, exclude=None, update_count=0, previous_model=None, relation_field=None)</code>  <code>async</code>","text":"<p>Triggers a upsert method on all related models if the instances are not already saved. By default saves only the directly related ones.</p> <p>If follow=True is set it saves also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are saved, but the save do not follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second Model A but will never follow into Model C. Nested relations of those kind need to be persisted manually.</p> <p>:param relation_field: field with relation leading to this model :type relation_field: Optional[ForeignKeyField] :param previous_model: previous model from which method came :type previous_model: Model :param exclude: items to exclude during saving of relations :type exclude: Union[Set, Dict] :param relation_map: map of relations to follow :type relation_map: Dict :param save_all: flag if all models should be saved or only not saved ones :type save_all: bool :param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :param update_count: internal parameter for recursive calls - number of updated instances :type update_count: int :return: number of updated/saved models :rtype: int</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def save_related(  # noqa: CCR001, CFQ002\n    self,\n    follow: bool = False,\n    save_all: bool = False,\n    relation_map: Optional[Dict] = None,\n    exclude: Union[Set, Dict, None] = None,\n    update_count: int = 0,\n    previous_model: Optional[\"Model\"] = None,\n    relation_field: Optional[\"ForeignKeyField\"] = None,\n) -&gt; int:\n    \"\"\"\n    Triggers a upsert method on all related models\n    if the instances are not already saved.\n    By default saves only the directly related ones.\n\n    If follow=True is set it saves also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are saved, but the save do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model A -&gt; Model C will save second\n    Model A but will never follow into Model C.\n    Nested relations of those kind need to be persisted manually.\n\n    :param relation_field: field with relation leading to this model\n    :type relation_field: Optional[ForeignKeyField]\n    :param previous_model: previous model from which method came\n    :type previous_model: Model\n    :param exclude: items to exclude during saving of relations\n    :type exclude: Union[Set, Dict]\n    :param relation_map: map of relations to follow\n    :type relation_map: Dict\n    :param save_all: flag if all models should be saved or only not saved ones\n    :type save_all: bool\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :param update_count: internal parameter for recursive calls -\n    number of updated instances\n    :type update_count: int\n    :return: number of updated/saved models\n    :rtype: int\n    \"\"\"\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(self._iterate_related_models())\n    )\n    if exclude and isinstance(exclude, Set):\n        exclude = translate_list_to_dict(exclude)\n    relation_map = subtract_dict(relation_map, exclude or {})\n\n    if relation_map:\n        fields_to_visit = {\n            field\n            for field in self.extract_related_fields()\n            if field.name in relation_map\n        }\n        pre_save = {\n            field\n            for field in fields_to_visit\n            if not field.virtual and not field.is_multi\n        }\n\n        update_count = await self._update_relation_list(\n            fields_list=pre_save,\n            follow=follow,\n            save_all=save_all,\n            relation_map=relation_map,\n            update_count=update_count,\n        )\n\n        update_count = await self._upsert_model(\n            instance=self,\n            save_all=save_all,\n            previous_model=previous_model,\n            relation_field=relation_field,\n            update_count=update_count,\n        )\n\n        post_save = fields_to_visit - pre_save\n\n        update_count = await self._update_relation_list(\n            fields_list=post_save,\n            follow=follow,\n            save_all=save_all,\n            relation_map=relation_map,\n            update_count=update_count,\n        )\n\n    else:\n        update_count = await self._upsert_model(\n            instance=self,\n            save_all=save_all,\n            previous_model=previous_model,\n            relation_field=relation_field,\n            update_count=update_count,\n        )\n\n    return update_count\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.update","title":"<code>update(_columns=None, **kwargs)</code>  <code>async</code>","text":"<p>Performs update of Model instance in the database. Fields can be updated before or you can pass them as kwargs.</p> <p>Sends pre_update and post_update signals.</p> <p>Sets model save status to True.</p> <p>:param _columns: list of columns to update, if None all are updated :type _columns: List :raises ModelPersistenceError: If the pk column is not set</p> <p>:param kwargs: list of fields to update as field=value pairs :type kwargs: Any :return: updated Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def update(self: T, _columns: Optional[List[str]] = None, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Performs update of Model instance in the database.\n    Fields can be updated before or you can pass them as kwargs.\n\n    Sends pre_update and post_update signals.\n\n    Sets model save status to True.\n\n    :param _columns: list of columns to update, if None all are updated\n    :type _columns: List\n    :raises ModelPersistenceError: If the pk column is not set\n\n    :param kwargs: list of fields to update as field=value pairs\n    :type kwargs: Any\n    :return: updated Model\n    :rtype: Model\n    \"\"\"\n    if kwargs:\n        self.update_from_dict(kwargs)\n\n    if not self.pk:\n        raise ModelPersistenceError(\n            \"You cannot update not saved model! Use save or upsert method.\"\n        )\n\n    await self.signals.pre_update.send(\n        sender=self.__class__, instance=self, passed_args=kwargs\n    )\n    self_fields = self._extract_model_db_fields()\n    self_fields.pop(self.get_column_name_from_alias(self.ormar_config.pkname))\n    if _columns:\n        self_fields = {k: v for k, v in self_fields.items() if k in _columns}\n    if self_fields:\n        self_fields = self.translate_columns_to_aliases(self_fields)\n        expr = self.ormar_config.table.update().values(**self_fields)\n        expr = expr.where(self.pk_column == getattr(self, self.ormar_config.pkname))\n\n        await self.ormar_config.database.execute(expr)\n    self.set_save_status(True)\n    await self.signals.post_update.send(sender=self.__class__, instance=self)\n    return self\n</code></pre>"},{"location":"api/models/model/#ormar.models.model.Model.upsert","title":"<code>upsert(**kwargs)</code>  <code>async</code>","text":"<p>Performs either a save or an update depending on the presence of the pk. If the pk field is filled it's an update, otherwise the save is performed. For save kwargs are ignored, used only in update if provided.</p> <p>:param kwargs: list of fields to update :type kwargs: Any :return: saved Model :rtype: Model</p> Source code in <code>ormar/models/model.py</code> <pre><code>async def upsert(self: T, **kwargs: Any) -&gt; T:\n    \"\"\"\n    Performs either a save or an update depending on the presence of the pk.\n    If the pk field is filled it's an update, otherwise the save is performed.\n    For save kwargs are ignored, used only in update if provided.\n\n    :param kwargs: list of fields to update\n    :type kwargs: Any\n    :return: saved Model\n    :rtype: Model\n    \"\"\"\n\n    force_save = kwargs.pop(\"__force_save__\", False)\n    if force_save:\n        expr = self.ormar_config.table.select().where(self.pk_column == self.pk)\n        row = await self.ormar_config.database.fetch_one(expr)\n        if not row:\n            return await self.save()\n        return await self.update(**kwargs)\n\n    if not self.pk:\n        return await self.save()\n    return await self.update(**kwargs)\n</code></pre>"},{"location":"api/models/model_row/","title":"model_row","text":""},{"location":"api/models/model_row/#ormar.models.model_row.ModelRow","title":"<code>ModelRow</code>","text":"<p>               Bases: <code>NewBaseModel</code></p> Source code in <code>ormar/models/model_row.py</code> <pre><code>class ModelRow(NewBaseModel):\n    @classmethod\n    def from_row(  # noqa: CFQ002\n        cls,\n        row: ResultProxy,\n        source_model: Type[\"Model\"],\n        select_related: Optional[List] = None,\n        related_models: Any = None,\n        related_field: Optional[\"ForeignKeyField\"] = None,\n        excludable: Optional[ExcludableItems] = None,\n        current_relation_str: str = \"\",\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n        used_prefixes: Optional[List[str]] = None,\n    ) -&gt; Optional[\"Model\"]:\n        \"\"\"\n        Model method to convert raw sql row from database into ormar.Model instance.\n        Traverses nested models if they were specified in select_related for query.\n\n        Called recurrently and returns model instance if it's present in the row.\n        Note that it's processing one row at a time, so if there are duplicates of\n        parent row that needs to be joined/combined\n        (like parent row in sql join with 2+ child rows)\n        instances populated in this method are later combined in the QuerySet.\n        Other method working directly on raw database results is in prefetch_query,\n        where rows are populated in a different way as they do not have\n        nested models in result.\n\n        :param used_prefixes: list of already extracted prefixes\n        :type used_prefixes: List[str]\n        :param proxy_source_model: source model from which querysetproxy is constructed\n        :type proxy_source_model: Optional[Type[\"ModelRow\"]]\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param current_relation_str: name of the relation field\n        :type current_relation_str: str\n        :param source_model: model on which relation was defined\n        :type source_model: Type[Model]\n        :param row: raw result row from the database\n        :type row: ResultProxy\n        :param select_related: list of names of related models fetched from database\n        :type select_related: List\n        :param related_models: list or dict of related models\n        :type related_models: Union[List, Dict]\n        :param related_field: field with relation declaration\n        :type related_field: ForeignKeyField\n        :return: returns model if model is populated from database\n        :rtype: Optional[Model]\n        \"\"\"\n        item: Dict[str, Any] = {}\n        select_related = select_related or []\n        related_models = related_models or []\n        table_prefix = \"\"\n        used_prefixes = used_prefixes if used_prefixes is not None else []\n        excludable = excludable or ExcludableItems()\n\n        if select_related:\n            related_models = group_related_list(select_related)\n\n        if related_field:\n            table_prefix = cls._process_table_prefix(\n                source_model=source_model,\n                current_relation_str=current_relation_str,\n                related_field=related_field,\n                used_prefixes=used_prefixes,\n            )\n\n        item = cls._populate_nested_models_from_row(\n            item=item,\n            row=row,\n            related_models=related_models,\n            excludable=excludable,\n            current_relation_str=current_relation_str,\n            source_model=source_model,  # type: ignore\n            proxy_source_model=proxy_source_model,  # type: ignore\n            table_prefix=table_prefix,\n            used_prefixes=used_prefixes,\n        )\n        item = cls.extract_prefixed_table_columns(\n            item=item, row=row, table_prefix=table_prefix, excludable=excludable\n        )\n\n        instance: Optional[\"Model\"] = None\n        if item.get(cls.ormar_config.pkname, None) is not None:\n            item[\"__excluded__\"] = cls.get_names_to_exclude(\n                excludable=excludable, alias=table_prefix\n            )\n            instance = cast(\"Model\", cls(**item))\n            instance.set_save_status(True)\n        return instance\n\n    @classmethod\n    def _process_table_prefix(\n        cls,\n        source_model: Type[\"Model\"],\n        current_relation_str: str,\n        related_field: \"ForeignKeyField\",\n        used_prefixes: List[str],\n    ) -&gt; str:\n        \"\"\"\n\n        :param source_model: model on which relation was defined\n        :type source_model: Type[Model]\n        :param current_relation_str: current relation string\n        :type current_relation_str: str\n        :param related_field: field with relation declaration\n        :type related_field: \"ForeignKeyField\"\n        :param used_prefixes: list of already extracted prefixes\n        :type used_prefixes: List[str]\n        :return: table_prefix to use\n        :rtype: str\n        \"\"\"\n        if related_field.is_multi:\n            previous_model = related_field.through\n        else:\n            previous_model = related_field.owner\n        table_prefix = cls.ormar_config.alias_manager.resolve_relation_alias(\n            from_model=previous_model, relation_name=related_field.name\n        )\n        if not table_prefix or table_prefix in used_prefixes:\n            manager = cls.ormar_config.alias_manager\n            table_prefix = manager.resolve_relation_alias_after_complex(\n                source_model=source_model,\n                relation_str=current_relation_str,\n                relation_field=related_field,\n            )\n        used_prefixes.append(table_prefix)\n        return table_prefix\n\n    @classmethod\n    def _populate_nested_models_from_row(  # noqa: CFQ002\n        cls,\n        item: dict,\n        row: ResultProxy,\n        source_model: Type[\"Model\"],\n        related_models: Any,\n        excludable: ExcludableItems,\n        table_prefix: str,\n        used_prefixes: List[str],\n        current_relation_str: Optional[str] = None,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; dict:\n        \"\"\"\n        Traverses structure of related models and populates the nested models\n        from the database row.\n        Related models can be a list if only directly related models are to be\n        populated, converted to dict if related models also have their own related\n        models to be populated.\n\n        Recurrently calls from_row method on nested instances and create nested\n        instances. In the end those instances are added to the final model dictionary.\n\n        :param proxy_source_model: source model from which querysetproxy is constructed\n        :type proxy_source_model: Optional[Type[\"ModelRow\"]]\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param source_model: source model from which relation started\n        :type source_model: Type[Model]\n        :param current_relation_str: joined related parts into one string\n        :type current_relation_str: str\n        :param item: dictionary of already populated nested models, otherwise empty dict\n        :type item: Dict\n        :param row: raw result row from the database\n        :type row: ResultProxy\n        :param related_models: list or dict of related models\n        :type related_models: Union[Dict, List]\n        :return: dictionary with keys corresponding to model fields names\n        and values are database values\n        :rtype: Dict\n        \"\"\"\n\n        for related in related_models:\n            field = cls.ormar_config.model_fields[related]\n            field = cast(\"ForeignKeyField\", field)\n            model_cls = field.to\n            model_excludable = excludable.get(\n                model_cls=cast(Type[\"Model\"], cls), alias=table_prefix\n            )\n            if model_excludable.is_excluded(related):\n                continue\n\n            relation_str, remainder = cls._process_remainder_and_relation_string(\n                related_models=related_models,\n                current_relation_str=current_relation_str,\n                related=related,\n            )\n            child = model_cls.from_row(\n                row,\n                related_models=remainder,\n                related_field=field,\n                excludable=excludable,\n                current_relation_str=relation_str,\n                source_model=source_model,\n                proxy_source_model=proxy_source_model,\n                used_prefixes=used_prefixes,\n            )\n            item[model_cls.get_column_name_from_alias(related)] = child\n            if (\n                field.is_multi\n                and child\n                and not model_excludable.is_excluded(field.through.get_name())\n            ):\n                cls._populate_through_instance(\n                    row=row,\n                    item=item,\n                    related=related,\n                    excludable=excludable,\n                    child=child,\n                    proxy_source_model=proxy_source_model,\n                )\n\n        return item\n\n    @staticmethod\n    def _process_remainder_and_relation_string(\n        related_models: Union[Dict, List],\n        current_relation_str: Optional[str],\n        related: str,\n    ) -&gt; Tuple[str, Optional[Union[Dict, List]]]:\n        \"\"\"\n        Process remainder models and relation string\n\n        :param related_models: list or dict of related models\n        :type related_models: Union[Dict, List]\n        :param current_relation_str: current relation string\n        :type current_relation_str: Optional[str]\n        :param related: name of the relation\n        :type related: str\n        \"\"\"\n        relation_str = (\n            \"__\".join([current_relation_str, related])\n            if current_relation_str\n            else related\n        )\n\n        remainder = None\n        if isinstance(related_models, dict) and related_models[related]:\n            remainder = related_models[related]\n        return relation_str, remainder\n\n    @classmethod\n    def _populate_through_instance(  # noqa: CFQ002\n        cls,\n        row: ResultProxy,\n        item: Dict,\n        related: str,\n        excludable: ExcludableItems,\n        child: \"Model\",\n        proxy_source_model: Optional[Type[\"Model\"]],\n    ) -&gt; None:\n        \"\"\"\n        Populates the through model on reverse side of current query.\n        Normally it's child class, unless the query is from queryset.\n\n        :param row: row from db result\n        :type row: ResultProxy\n        :param item: parent item dict\n        :type item: Dict\n        :param related: current relation name\n        :type related: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param child: child item of parent\n        :type child: \"Model\"\n        :param proxy_source_model: source model from which querysetproxy is constructed\n        :type proxy_source_model: Type[\"Model\"]\n        \"\"\"\n        through_name = cls.ormar_config.model_fields[related].through.get_name()\n        through_child = cls._create_through_instance(\n            row=row, related=related, through_name=through_name, excludable=excludable\n        )\n\n        if child.__class__ != proxy_source_model:\n            setattr(child, through_name, through_child)\n        else:\n            item[through_name] = through_child\n        child.set_save_status(True)\n\n    @classmethod\n    def _create_through_instance(\n        cls,\n        row: ResultProxy,\n        through_name: str,\n        related: str,\n        excludable: ExcludableItems,\n    ) -&gt; \"ModelRow\":\n        \"\"\"\n        Initialize the through model from db row.\n        Excluded all relation fields and other exclude/include set in excludable.\n\n        :param row: loaded row from database\n        :type row: sqlalchemy.engine.ResultProxy\n        :param through_name: name of the through field\n        :type through_name: str\n        :param related: name of the relation\n        :type related: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :return: initialized through model without relation\n        :rtype: \"ModelRow\"\n        \"\"\"\n        model_cls = cls.ormar_config.model_fields[through_name].to\n        table_prefix = cls.ormar_config.alias_manager.resolve_relation_alias(\n            from_model=cls, relation_name=related\n        )\n        # remove relations on through field\n        model_excludable = excludable.get(model_cls=model_cls, alias=table_prefix)\n        model_excludable.set_values(\n            value=model_cls.extract_related_names(), is_exclude=True\n        )\n        child_dict = model_cls.extract_prefixed_table_columns(\n            item={}, row=row, excludable=excludable, table_prefix=table_prefix\n        )\n        child_dict[\"__excluded__\"] = model_cls.get_names_to_exclude(\n            excludable=excludable, alias=table_prefix\n        )\n        child = model_cls(**child_dict)  # type: ignore\n        return child\n\n    @classmethod\n    def extract_prefixed_table_columns(\n        cls,\n        item: dict,\n        row: ResultProxy,\n        table_prefix: str,\n        excludable: ExcludableItems,\n    ) -&gt; Dict:\n        \"\"\"\n        Extracts own fields from raw sql result, using a given prefix.\n        Prefix changes depending on the table's position in a join.\n\n        If the table is a main table, there is no prefix.\n        All joined tables have prefixes to allow duplicate column names,\n        as well as duplicated joins to the same table from multiple different tables.\n\n        Extracted fields populates the related dict later used to construct a Model.\n\n        Used in Model.from_row and PrefetchQuery._populate_rows methods.\n\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param item: dictionary of already populated nested models, otherwise empty dict\n        :type item: Dict\n        :param row: raw result row from the database\n        :type row: sqlalchemy.engine.result.ResultProxy\n        :param table_prefix: prefix of the table from AliasManager\n        each pair of tables have own prefix (two of them depending on direction) -\n        used in joins to allow multiple joins to the same table.\n        :type table_prefix: str\n        :return: dictionary with keys corresponding to model fields names\n        and values are database values\n        :rtype: Dict\n        \"\"\"\n        selected_columns = cls.own_table_columns(\n            model=cls, excludable=excludable, alias=table_prefix, use_alias=False\n        )\n\n        column_prefix = table_prefix + \"_\" if table_prefix else \"\"\n        for column in cls.ormar_config.table.columns:\n            alias = cls.get_column_name_from_alias(column.name)\n            if alias not in item and alias in selected_columns:\n                prefixed_name = f\"{column_prefix}{column.name}\"\n                item[alias] = row[prefixed_name]\n\n        return item\n</code></pre>"},{"location":"api/models/model_row/#ormar.models.model_row.ModelRow.extract_prefixed_table_columns","title":"<code>extract_prefixed_table_columns(item, row, table_prefix, excludable)</code>  <code>classmethod</code>","text":"<p>Extracts own fields from raw sql result, using a given prefix. Prefix changes depending on the table's position in a join.</p> <p>If the table is a main table, there is no prefix. All joined tables have prefixes to allow duplicate column names, as well as duplicated joins to the same table from multiple different tables.</p> <p>Extracted fields populates the related dict later used to construct a Model.</p> <p>Used in Model.from_row and PrefetchQuery._populate_rows methods.</p> <p>:param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :param item: dictionary of already populated nested models, otherwise empty dict :type item: Dict :param row: raw result row from the database :type row: sqlalchemy.engine.result.ResultProxy :param table_prefix: prefix of the table from AliasManager each pair of tables have own prefix (two of them depending on direction) - used in joins to allow multiple joins to the same table. :type table_prefix: str :return: dictionary with keys corresponding to model fields names and values are database values :rtype: Dict</p> Source code in <code>ormar/models/model_row.py</code> <pre><code>@classmethod\ndef extract_prefixed_table_columns(\n    cls,\n    item: dict,\n    row: ResultProxy,\n    table_prefix: str,\n    excludable: ExcludableItems,\n) -&gt; Dict:\n    \"\"\"\n    Extracts own fields from raw sql result, using a given prefix.\n    Prefix changes depending on the table's position in a join.\n\n    If the table is a main table, there is no prefix.\n    All joined tables have prefixes to allow duplicate column names,\n    as well as duplicated joins to the same table from multiple different tables.\n\n    Extracted fields populates the related dict later used to construct a Model.\n\n    Used in Model.from_row and PrefetchQuery._populate_rows methods.\n\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :param item: dictionary of already populated nested models, otherwise empty dict\n    :type item: Dict\n    :param row: raw result row from the database\n    :type row: sqlalchemy.engine.result.ResultProxy\n    :param table_prefix: prefix of the table from AliasManager\n    each pair of tables have own prefix (two of them depending on direction) -\n    used in joins to allow multiple joins to the same table.\n    :type table_prefix: str\n    :return: dictionary with keys corresponding to model fields names\n    and values are database values\n    :rtype: Dict\n    \"\"\"\n    selected_columns = cls.own_table_columns(\n        model=cls, excludable=excludable, alias=table_prefix, use_alias=False\n    )\n\n    column_prefix = table_prefix + \"_\" if table_prefix else \"\"\n    for column in cls.ormar_config.table.columns:\n        alias = cls.get_column_name_from_alias(column.name)\n        if alias not in item and alias in selected_columns:\n            prefixed_name = f\"{column_prefix}{column.name}\"\n            item[alias] = row[prefixed_name]\n\n    return item\n</code></pre>"},{"location":"api/models/model_row/#ormar.models.model_row.ModelRow.from_row","title":"<code>from_row(row, source_model, select_related=None, related_models=None, related_field=None, excludable=None, current_relation_str='', proxy_source_model=None, used_prefixes=None)</code>  <code>classmethod</code>","text":"<p>Model method to convert raw sql row from database into ormar.Model instance. Traverses nested models if they were specified in select_related for query.</p> <p>Called recurrently and returns model instance if it's present in the row. Note that it's processing one row at a time, so if there are duplicates of parent row that needs to be joined/combined (like parent row in sql join with 2+ child rows) instances populated in this method are later combined in the QuerySet. Other method working directly on raw database results is in prefetch_query, where rows are populated in a different way as they do not have nested models in result.</p> <p>:param used_prefixes: list of already extracted prefixes :type used_prefixes: List[str] :param proxy_source_model: source model from which querysetproxy is constructed :type proxy_source_model: Optional[Type[\"ModelRow\"]] :param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :param current_relation_str: name of the relation field :type current_relation_str: str :param source_model: model on which relation was defined :type source_model: Type[Model] :param row: raw result row from the database :type row: ResultProxy :param select_related: list of names of related models fetched from database :type select_related: List :param related_models: list or dict of related models :type related_models: Union[List, Dict] :param related_field: field with relation declaration :type related_field: ForeignKeyField :return: returns model if model is populated from database :rtype: Optional[Model]</p> Source code in <code>ormar/models/model_row.py</code> <pre><code>@classmethod\ndef from_row(  # noqa: CFQ002\n    cls,\n    row: ResultProxy,\n    source_model: Type[\"Model\"],\n    select_related: Optional[List] = None,\n    related_models: Any = None,\n    related_field: Optional[\"ForeignKeyField\"] = None,\n    excludable: Optional[ExcludableItems] = None,\n    current_relation_str: str = \"\",\n    proxy_source_model: Optional[Type[\"Model\"]] = None,\n    used_prefixes: Optional[List[str]] = None,\n) -&gt; Optional[\"Model\"]:\n    \"\"\"\n    Model method to convert raw sql row from database into ormar.Model instance.\n    Traverses nested models if they were specified in select_related for query.\n\n    Called recurrently and returns model instance if it's present in the row.\n    Note that it's processing one row at a time, so if there are duplicates of\n    parent row that needs to be joined/combined\n    (like parent row in sql join with 2+ child rows)\n    instances populated in this method are later combined in the QuerySet.\n    Other method working directly on raw database results is in prefetch_query,\n    where rows are populated in a different way as they do not have\n    nested models in result.\n\n    :param used_prefixes: list of already extracted prefixes\n    :type used_prefixes: List[str]\n    :param proxy_source_model: source model from which querysetproxy is constructed\n    :type proxy_source_model: Optional[Type[\"ModelRow\"]]\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :param current_relation_str: name of the relation field\n    :type current_relation_str: str\n    :param source_model: model on which relation was defined\n    :type source_model: Type[Model]\n    :param row: raw result row from the database\n    :type row: ResultProxy\n    :param select_related: list of names of related models fetched from database\n    :type select_related: List\n    :param related_models: list or dict of related models\n    :type related_models: Union[List, Dict]\n    :param related_field: field with relation declaration\n    :type related_field: ForeignKeyField\n    :return: returns model if model is populated from database\n    :rtype: Optional[Model]\n    \"\"\"\n    item: Dict[str, Any] = {}\n    select_related = select_related or []\n    related_models = related_models or []\n    table_prefix = \"\"\n    used_prefixes = used_prefixes if used_prefixes is not None else []\n    excludable = excludable or ExcludableItems()\n\n    if select_related:\n        related_models = group_related_list(select_related)\n\n    if related_field:\n        table_prefix = cls._process_table_prefix(\n            source_model=source_model,\n            current_relation_str=current_relation_str,\n            related_field=related_field,\n            used_prefixes=used_prefixes,\n        )\n\n    item = cls._populate_nested_models_from_row(\n        item=item,\n        row=row,\n        related_models=related_models,\n        excludable=excludable,\n        current_relation_str=current_relation_str,\n        source_model=source_model,  # type: ignore\n        proxy_source_model=proxy_source_model,  # type: ignore\n        table_prefix=table_prefix,\n        used_prefixes=used_prefixes,\n    )\n    item = cls.extract_prefixed_table_columns(\n        item=item, row=row, table_prefix=table_prefix, excludable=excludable\n    )\n\n    instance: Optional[\"Model\"] = None\n    if item.get(cls.ormar_config.pkname, None) is not None:\n        item[\"__excluded__\"] = cls.get_names_to_exclude(\n            excludable=excludable, alias=table_prefix\n        )\n        instance = cast(\"Model\", cls(**item))\n        instance.set_save_status(True)\n    return instance\n</code></pre>"},{"location":"api/models/modelproxy/","title":"modelproxy","text":""},{"location":"api/models/modelproxy/#ormar.models.modelproxy.ModelTableProxy","title":"<code>ModelTableProxy</code>","text":"<p>               Bases: <code>MergeModelMixin</code>, <code>SavePrepareMixin</code>, <code>ExcludableMixin</code>, <code>PydanticMixin</code></p> <p>Used to combine all mixins with different set of functionalities. One of the bases of the ormar Model class.</p> Source code in <code>ormar/models/modelproxy.py</code> <pre><code>class ModelTableProxy(\n    MergeModelMixin,\n    SavePrepareMixin,\n    ExcludableMixin,\n    PydanticMixin,\n):\n    \"\"\"\n    Used to combine all mixins with different set of functionalities.\n    One of the bases of the ormar Model class.\n    \"\"\"\n</code></pre>"},{"location":"api/models/newbasemodel/","title":"newbasemodel","text":""},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel","title":"<code>NewBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>ModelTableProxy</code></p> <p>Main base class of ormar Model. Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy. Constructed with ModelMetaclass which in turn also inherits pydantic metaclass.</p> <p>Abstracts away all internals and helper functions, so final Model class has only the logic concerned with database connection and data persistence.</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>class NewBaseModel(pydantic.BaseModel, ModelTableProxy, metaclass=ModelMetaclass):\n    \"\"\"\n    Main base class of ormar Model.\n    Inherits from pydantic BaseModel and has all mixins combined in ModelTableProxy.\n    Constructed with ModelMetaclass which in turn also inherits pydantic metaclass.\n\n    Abstracts away all internals and helper functions, so final Model class has only\n    the logic concerned with database connection and data persistence.\n    \"\"\"\n\n    __slots__ = (\n        \"_orm_id\",\n        \"_orm_saved\",\n        \"_orm\",\n        \"_pk_column\",\n        \"__pk_only__\",\n        \"__cached_hash__\",\n        \"__pydantic_extra__\",\n        \"__pydantic_fields_set__\",\n    )\n\n    if TYPE_CHECKING:  # pragma no cover\n        pk: Any\n        __relation_map__: Optional[List[str]]\n        __cached_hash__: Optional[int]\n        _orm_relationship_manager: AliasManager\n        _orm: RelationsManager\n        _orm_id: int\n        _orm_saved: bool\n        _related_names: Optional[Set]\n        _through_names: Optional[Set]\n        _related_names_hash: str\n        _quick_access_fields: Set\n        _json_fields: Set\n        _bytes_fields: Set\n        ormar_config: OrmarConfig\n\n    # noinspection PyMissingConstructor\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # type: ignore\n        \"\"\"\n        Initializer that creates a new ormar Model that is also pydantic Model at the\n        same time.\n\n        Passed keyword arguments can be only field names and their corresponding values\n        as those will be passed to pydantic validation that will complain if extra\n        params are passed.\n\n        If relations are defined each relation is expanded and children models are also\n        initialized and validated. Relation from both sides is registered so you can\n        access related models from both sides.\n\n        Json fields are automatically loaded/dumped if needed.\n\n        Models marked as abstract=True in internal OrmarConfig cannot be initialized.\n\n        Accepts also special __pk_only__ flag that indicates that Model is constructed\n        only with primary key value (so no other fields, it's a child model on other\n        Model), that causes skipping the validation, that's the only case when the\n        validation can be skipped.\n\n        Accepts also special __excluded__ parameter that contains a set of fields that\n        should be explicitly set to None, as otherwise pydantic will try to populate\n        them with their default values if default is set.\n\n        :raises ModelError: if abstract model is initialized, model has ForwardRefs\n         that has not been updated or unknown field is passed\n        :param args: ignored args\n        :type args: Any\n        :param kwargs: keyword arguments - all fields values and some special params\n        :type kwargs: Any\n        \"\"\"\n        self._verify_model_can_be_initialized()\n        self._initialize_internal_attributes()\n\n        pk_only = kwargs.pop(\"__pk_only__\", False)\n        object.__setattr__(self, \"__pk_only__\", pk_only)\n\n        new_kwargs, through_tmp_dict = self._process_kwargs(kwargs)\n\n        if not pk_only:\n            self.__pydantic_validator__.validate_python(\n                new_kwargs, self_instance=self  # type: ignore\n            )\n        else:\n            fields_set = {self.ormar_config.pkname}\n            values = new_kwargs\n            object.__setattr__(self, \"__dict__\", values)\n            object.__setattr__(self, \"__pydantic_fields_set__\", fields_set)\n        # add back through fields\n        new_kwargs.update(through_tmp_dict)\n        model_fields = object.__getattribute__(self, \"ormar_config\").model_fields\n        # register the columns models after initialization\n        for related in self.extract_related_names().union(self.extract_through_names()):\n            model_fields[related].expand_relationship(\n                new_kwargs.get(related), self, to_register=True\n            )\n\n    def __setattr__(self, name: str, value: Any) -&gt; None:  # noqa CCR001\n        \"\"\"\n        Overwrites setattr in pydantic parent as otherwise descriptors are not called.\n\n        :param name: name of the attribute to set\n        :type name: str\n        :param value: value of the attribute to set\n        :type value: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        prev_hash = hash(self)\n\n        if hasattr(self, name):\n            object.__setattr__(self, name, value)\n        else:\n            # let pydantic handle errors for unknown fields\n            super().__setattr__(name, value)\n\n        # In this case, the hash could have changed, so update it\n        if name == self.ormar_config.pkname or self.pk is None:\n            object.__setattr__(self, \"__cached_hash__\", None)\n            new_hash = hash(self)\n\n            if prev_hash != new_hash:\n                self._update_relation_cache(prev_hash, new_hash)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"\n        Used for private attributes of pydantic v2.\n\n        :param item: name of attribute\n        :type item: str\n        :return: Any\n        :rtype: Any\n        \"\"\"\n        # TODO: Check __pydantic_extra__\n        if item == \"__pydantic_extra__\":\n            return None\n        return super().__getattr__(item)  # type: ignore\n\n    def __getstate__(self) -&gt; Dict[Any, Any]:\n        state = super().__getstate__()\n        self_dict = self.model_dump()\n        state[\"__dict__\"].update(**self_dict)\n        return state\n\n    def __setstate__(self, state: Dict[Any, Any]) -&gt; None:\n        relations = {\n            k: v\n            for k, v in state[\"__dict__\"].items()\n            if k in self.extract_related_names()\n        }\n        basic_state = {\n            k: v\n            for k, v in state[\"__dict__\"].items()\n            if k not in self.extract_related_names()\n        }\n        state[\"__dict__\"] = basic_state\n        super().__setstate__(state)\n        self._initialize_internal_attributes()\n        for name, value in relations.items():\n            setattr(self, name, value)\n\n    def _update_relation_cache(self, prev_hash: int, new_hash: int) -&gt; None:\n        \"\"\"\n        Update all relation proxy caches with different hash if we have changed\n\n        :param prev_hash: The previous hash to update\n        :type prev_hash: int\n        :param new_hash: The hash to update to\n        :type new_hash: int\n        \"\"\"\n\n        def _update_cache(relations: List[Relation], recurse: bool = True) -&gt; None:\n            for relation in relations:\n                relation_proxy = relation.get()\n\n                if hasattr(relation_proxy, \"update_cache\"):\n                    relation_proxy.update_cache(prev_hash, new_hash)  # type: ignore\n                elif recurse and hasattr(relation_proxy, \"_orm\"):\n                    _update_cache(\n                        relation_proxy._orm._relations.values(),  # type: ignore\n                        recurse=False,\n                    )\n\n        _update_cache(list(self._orm._relations.values()))\n\n    def _internal_set(self, name: str, value: Any) -&gt; None:\n        \"\"\"\n        Delegates call to pydantic.\n\n        :param name: name of param\n        :type name: str\n        :param value: value to set\n        :type value: Any\n        \"\"\"\n        super().__setattr__(name, value)\n\n    def _verify_model_can_be_initialized(self) -&gt; None:\n        \"\"\"\n        Raises exception if model is abstract or has ForwardRefs in relation fields.\n\n        :return: None\n        :rtype: None\n        \"\"\"\n        if self.ormar_config.abstract:\n            raise ModelError(f\"You cannot initialize abstract model {self.get_name()}\")\n        if self.ormar_config.requires_ref_update:\n            raise ModelError(\n                f\"Model {self.get_name()} has not updated \"\n                f\"ForwardRefs. \\nBefore using the model you \"\n                f\"need to call update_forward_refs().\"\n            )\n\n    def _process_kwargs(self, kwargs: Dict) -&gt; Tuple[Dict, Dict]:  # noqa: CCR001\n        \"\"\"\n        Initializes nested models.\n\n        Removes property_fields\n\n        Checks if field is in the model fields or pydantic fields.\n\n        Nullifies fields that should be excluded.\n\n        Extracts through models from kwargs into temporary dict.\n\n        :param kwargs: passed to init keyword arguments\n        :type kwargs: Dict\n        :return: modified kwargs\n        :rtype: Tuple[Dict, Dict]\n        \"\"\"\n        property_fields = self.ormar_config.property_fields\n        model_fields = self.ormar_config.model_fields\n        pydantic_fields = set(self.model_fields.keys())\n\n        # remove property fields\n        for prop_filed in property_fields:\n            kwargs.pop(prop_filed, None)\n\n        excluded: Set[str] = kwargs.pop(\"__excluded__\", set())\n        if \"pk\" in kwargs:\n            kwargs[self.ormar_config.pkname] = kwargs.pop(\"pk\")\n\n        # extract through fields\n        through_tmp_dict = dict()\n        for field_name in self.extract_through_names():\n            through_tmp_dict[field_name] = kwargs.pop(field_name, None)\n\n        kwargs = self._remove_extra_parameters_if_they_should_be_ignored(\n            kwargs=kwargs, model_fields=model_fields, pydantic_fields=pydantic_fields\n        )\n        try:\n            new_kwargs: Dict[str, Any] = {\n                k: self._convert_to_bytes(\n                    k,\n                    self._convert_json(\n                        k,\n                        (\n                            model_fields[k].expand_relationship(\n                                v, self, to_register=False\n                            )\n                            if k in model_fields\n                            else (v if k in pydantic_fields else model_fields[k])\n                        ),\n                    ),\n                )\n                for k, v in kwargs.items()\n            }\n        except KeyError as e:\n            raise ModelError(\n                f\"Unknown field '{e.args[0]}' for model {self.get_name(lower=False)}\"\n            )\n\n        # explicitly set None to excluded fields\n        # as pydantic populates them with default if set\n        for field_to_nullify in excluded:\n            new_kwargs[field_to_nullify] = None\n\n        return new_kwargs, through_tmp_dict\n\n    def _remove_extra_parameters_if_they_should_be_ignored(\n        self, kwargs: Dict, model_fields: Dict, pydantic_fields: Set\n    ) -&gt; Dict:\n        \"\"\"\n        Removes the extra fields from kwargs if they should be ignored.\n\n        :param kwargs: passed arguments\n        :type kwargs: Dict\n        :param model_fields: dictionary of model fields\n        :type model_fields: Dict\n        :param pydantic_fields: set of pydantic fields names\n        :type pydantic_fields: Set\n        :return: dict without extra fields\n        :rtype: Dict\n        \"\"\"\n        if self.ormar_config.extra == Extra.ignore:\n            kwargs = {\n                k: v\n                for k, v in kwargs.items()\n                if k in model_fields or k in pydantic_fields\n            }\n        return kwargs\n\n    def _initialize_internal_attributes(self) -&gt; None:\n        \"\"\"\n        Initializes internal attributes during __init__()\n        :rtype: None\n        \"\"\"\n        # object.__setattr__(self, \"_orm_id\", uuid.uuid4().hex)\n        object.__setattr__(self, \"_orm_saved\", False)\n        object.__setattr__(self, \"_pk_column\", None)\n        object.__setattr__(\n            self,\n            \"_orm\",\n            RelationsManager(\n                related_fields=self.extract_related_fields(), owner=cast(\"Model\", self)\n            ),\n        )\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Compares other model to this model. when == is called.\n        :param other: other model to compare\n        :type other: object\n        :return: result of comparison\n        :rtype: bool\n        \"\"\"\n        if isinstance(other, NewBaseModel):\n            return self.__same__(other)\n        return super().__eq__(other)  # pragma no cover\n\n    def __hash__(self) -&gt; int:\n        if getattr(self, \"__cached_hash__\", None) is not None:\n            return self.__cached_hash__ or 0\n\n        if self.pk is not None:\n            ret = hash(str(self.pk) + self.__class__.__name__)\n        else:\n            vals = {\n                k: v\n                for k, v in self.__dict__.items()\n                if k not in self.extract_related_names()\n            }\n            ret = hash(str(vals) + self.__class__.__name__)\n\n        object.__setattr__(self, \"__cached_hash__\", ret)\n        return ret\n\n    def __same__(self, other: \"NewBaseModel\") -&gt; bool:\n        \"\"\"\n        Used by __eq__, compares other model to this model.\n        Compares:\n        * _orm_ids,\n        * primary key values if it's set\n        * dictionary of own fields (excluding relations)\n        :param other: model to compare to\n        :type other: NewBaseModel\n        :return: result of comparison\n        :rtype: bool\n        \"\"\"\n        if (self.pk is None and other.pk is not None) or (\n            self.pk is not None and other.pk is None\n        ):\n            return False\n        else:\n            return hash(self) == other.__hash__()\n\n    @classmethod\n    def get_name(cls, lower: bool = True) -&gt; str:\n        \"\"\"\n        Returns name of the Model class, by default lowercase.\n\n        :param lower: flag if name should be set to lowercase\n        :type lower: bool\n        :return: name of the model\n        :rtype: str\n        \"\"\"\n        name = cls.__name__\n        if lower:\n            name = name.lower()\n        return name\n\n    @property\n    def pk_column(self) -&gt; sqlalchemy.Column:\n        \"\"\"\n        Retrieves primary key sqlalchemy column from models OrmarConfig.table.\n        Each model has to have primary key.\n        Only one primary key column is allowed.\n\n        :return: primary key sqlalchemy column\n        :rtype: sqlalchemy.Column\n        \"\"\"\n        if object.__getattribute__(self, \"_pk_column\") is not None:\n            return object.__getattribute__(self, \"_pk_column\")\n        pk_columns = self.ormar_config.table.primary_key.columns.values()\n        pk_col = pk_columns[0]\n        object.__setattr__(self, \"_pk_column\", pk_col)\n        return pk_col\n\n    @property\n    def saved(self) -&gt; bool:\n        \"\"\"Saved status of the model. Changed by setattr and loading from db\"\"\"\n        return self._orm_saved\n\n    @property\n    def signals(self) -&gt; \"SignalEmitter\":\n        \"\"\"Exposes signals from model OrmarConfig\"\"\"\n        return self.ormar_config.signals\n\n    @classmethod\n    def pk_type(cls) -&gt; Any:\n        \"\"\"Shortcut to models primary key field type\"\"\"\n        return cls.ormar_config.model_fields[cls.ormar_config.pkname].__type__\n\n    @classmethod\n    def db_backend_name(cls) -&gt; str:\n        \"\"\"Shortcut to database dialect,\n        cause some dialect require different treatment\"\"\"\n        return cls.ormar_config.database._backend._dialect.name\n\n    def remove(self, parent: \"Model\", name: str) -&gt; None:\n        \"\"\"Removes child from relation with given name in RelationshipManager\"\"\"\n        self._orm.remove_parent(self, parent, name)\n\n    def set_save_status(self, status: bool) -&gt; None:\n        \"\"\"Sets value of the save status\"\"\"\n        object.__setattr__(self, \"_orm_saved\", status)\n\n    @classmethod\n    def update_forward_refs(cls, **localns: Any) -&gt; None:\n        \"\"\"\n        Processes fields that are ForwardRef and need to be evaluated into actual\n        models.\n\n        Expands relationships, register relation in alias manager and substitutes\n        sqlalchemy columns with new ones with proper column type (null before).\n\n        Populates OrmarConfig table of the Model which is left empty before.\n\n        Sets self_reference flag on models that links to themselves.\n\n        Calls the pydantic method to evaluate pydantic fields.\n\n        :param localns: local namespace\n        :type localns: Any\n        :return: None\n        :rtype: None\n        \"\"\"\n        globalns = sys.modules[cls.__module__].__dict__.copy()\n        globalns.setdefault(cls.__name__, cls)\n        fields_to_check = cls.ormar_config.model_fields.copy()\n        for field in fields_to_check.values():\n            if field.has_unresolved_forward_refs():\n                field = cast(ForeignKeyField, field)\n                field.evaluate_forward_ref(globalns=globalns, localns=localns)\n                field.set_self_reference_flag()\n                if field.is_multi and not field.through:\n                    field = cast(ormar.ManyToManyField, field)\n                    field.create_default_through_model()\n                expand_reverse_relationship(model_field=field)\n                register_relation_in_alias_manager(field=field)\n                update_column_definition(model=cls, field=field)\n        populate_config_sqlalchemy_table_if_required(config=cls.ormar_config)\n        # super().update_forward_refs(**localns)\n        cls.model_rebuild(force=True)\n        cls.ormar_config.requires_ref_update = False\n\n    @staticmethod\n    def _get_not_excluded_fields(\n        fields: Union[List, Set], include: Optional[Dict], exclude: Optional[Dict]\n    ) -&gt; List:\n        \"\"\"\n        Returns related field names applying on them include and exclude set.\n\n        :param include: fields to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :return:\n        :rtype: List of fields with relations that is not excluded\n        \"\"\"\n        fields = [*fields] if not isinstance(fields, list) else fields\n        if include:\n            fields = [field for field in fields if field in include]\n        if exclude:\n            fields = [\n                field\n                for field in fields\n                if field not in exclude\n                or (\n                    exclude.get(field) is not Ellipsis\n                    and exclude.get(field) != {\"__all__\"}\n                )\n            ]\n        return fields\n\n    @staticmethod\n    def _extract_nested_models_from_list(\n        relation_map: Dict,\n        models: MutableSequence,\n        include: Union[Set, Dict, None],\n        exclude: Union[Set, Dict, None],\n        exclude_primary_keys: bool,\n        exclude_through_models: bool,\n    ) -&gt; List:\n        \"\"\"\n        Converts list of models into list of dictionaries.\n\n        :param models: List of models\n        :type models: List\n        :param include: fields to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :return: list of models converted to dictionaries\n        :rtype: List[Dict]\n        \"\"\"\n        result = []\n        for model in models:\n            try:\n                model_dict = model.model_dump(\n                    relation_map=relation_map,\n                    include=include,\n                    exclude=exclude,\n                    exclude_primary_keys=exclude_primary_keys,\n                    exclude_through_models=exclude_through_models,\n                )\n                if not exclude_through_models:\n                    model.populate_through_models(\n                        model=model,\n                        model_dict=model_dict,\n                        include=include,\n                        exclude=exclude,\n                        relation_map=relation_map,\n                    )\n                result.append(model_dict)\n            except ReferenceError:  # pragma no cover\n                continue\n        return result\n\n    @staticmethod\n    def populate_through_models(\n        model: \"Model\",\n        model_dict: Dict,\n        include: Union[Set, Dict],\n        exclude: Union[Set, Dict],\n        relation_map: Dict,\n    ) -&gt; None:\n        \"\"\"\n        Populates through models with values from dict representation.\n\n        :param model: model to populate through models\n        :type model: Model\n        :param model_dict: dict representation of the model\n        :type model_dict: Dict\n        :param include: fields to include\n        :type include: Dict\n        :param exclude: fields to exclude\n        :type exclude: Dict\n        :param relation_map: map of relations to follow to avoid circular refs\n        :type relation_map: Dict\n        :return: None\n        :rtype: None\n        \"\"\"\n\n        include_dict = (\n            translate_list_to_dict(include)\n            if (include and isinstance(include, Set))\n            else include\n        )\n        exclude_dict = (\n            translate_list_to_dict(exclude)\n            if (exclude and isinstance(exclude, Set))\n            else exclude\n        )\n        models_to_populate = model._get_not_excluded_fields(\n            fields=model.extract_through_names(),\n            include=cast(Optional[Dict], include_dict),\n            exclude=cast(Optional[Dict], exclude_dict),\n        )\n        through_fields_to_populate = [\n            model.ormar_config.model_fields[through_model]\n            for through_model in models_to_populate\n            if model.ormar_config.model_fields[through_model].related_name\n            not in relation_map\n        ]\n        for through_field in through_fields_to_populate:\n            through_instance = getattr(model, through_field.name)\n            if through_instance:\n                model_dict[through_field.name] = through_instance.model_dump()\n\n    @classmethod\n    def _skip_ellipsis(\n        cls, items: Union[Set, Dict, None], key: str, default_return: Any = None\n    ) -&gt; Union[Set, Dict, None]:\n        \"\"\"\n        Helper to traverse the include/exclude dictionaries.\n        In model_dump() Ellipsis should be skipped as it indicates all fields required\n        and not the actual set/dict with fields names.\n\n        :param items: current include/exclude value\n        :type items: Union[Set, Dict, None]\n        :param key: key for nested relations to check\n        :type key: str\n        :return: nested value of the items\n        :rtype: Union[Set, Dict, None]\n        \"\"\"\n        result = cls.get_child(items, key)\n        return result if result is not Ellipsis else default_return\n\n    @staticmethod\n    def _convert_all(items: Union[Set, Dict, None]) -&gt; Union[Set, Dict, None]:\n        \"\"\"\n        Helper to convert __all__ pydantic special index to ormar which does not\n        support index based exclusions.\n\n        :param items: current include/exclude value\n        :type items: Union[Set, Dict, None]\n        \"\"\"\n        if isinstance(items, dict) and \"__all__\" in items:\n            return items.get(\"__all__\")\n        return items\n\n    def _extract_nested_models(  # noqa: CCR001, CFQ002\n        self,\n        relation_map: Dict,\n        dict_instance: Dict,\n        include: Optional[Dict],\n        exclude: Optional[Dict],\n        exclude_primary_keys: bool,\n        exclude_through_models: bool,\n        exclude_list: bool,\n    ) -&gt; Dict:\n        \"\"\"\n        Traverse nested models and converts them into dictionaries.\n        Calls itself recursively if needed.\n\n        :param nested: flag if current instance is nested\n        :type nested: bool\n        :param dict_instance: current instance dict\n        :type dict_instance: Dict\n        :param include: fields to include\n        :type include: Optional[Dict]\n        :param exclude: fields to exclude\n        :type exclude: Optional[Dict]\n        :param exclude: whether to exclude lists\n        :type exclude: bool\n        :return: current model dict with child models converted to dictionaries\n        :rtype: Dict\n        \"\"\"\n        fields = self._get_not_excluded_fields(\n            fields=self.extract_related_names(), include=include, exclude=exclude\n        )\n\n        for field in fields:\n            if not relation_map or field not in relation_map:\n                continue\n            try:\n                nested_model = getattr(self, field)\n                if isinstance(nested_model, MutableSequence):\n                    if exclude_list:\n                        continue\n\n                    dict_instance[field] = self._extract_nested_models_from_list(\n                        relation_map=self._skip_ellipsis(  # type: ignore\n                            relation_map, field, default_return=dict()\n                        ),\n                        models=nested_model,\n                        include=self._convert_all(self._skip_ellipsis(include, field)),\n                        exclude=self._convert_all(self._skip_ellipsis(exclude, field)),\n                        exclude_primary_keys=exclude_primary_keys,\n                        exclude_through_models=exclude_through_models,\n                    )\n                elif nested_model is not None:\n                    model_dict = nested_model.model_dump(\n                        relation_map=self._skip_ellipsis(\n                            relation_map, field, default_return=dict()\n                        ),\n                        include=self._convert_all(self._skip_ellipsis(include, field)),\n                        exclude=self._convert_all(self._skip_ellipsis(exclude, field)),\n                        exclude_primary_keys=exclude_primary_keys,\n                        exclude_through_models=exclude_through_models,\n                    )\n                    if not exclude_through_models:\n                        nested_model.populate_through_models(\n                            model=nested_model,\n                            model_dict=model_dict,\n                            include=self._convert_all(\n                                self._skip_ellipsis(include, field)\n                            ),\n                            exclude=self._convert_all(\n                                self._skip_ellipsis(exclude, field)\n                            ),\n                            relation_map=self._skip_ellipsis(\n                                relation_map, field, default_return=dict()\n                            ),\n                        )\n                    dict_instance[field] = model_dict\n                else:\n                    dict_instance[field] = None\n            except ReferenceError:  # pragma: no cover\n                dict_instance[field] = None\n        return dict_instance\n\n    @typing_extensions.deprecated(\n        \"The `dict` method is deprecated; use `model_dump` instead.\",\n        category=OrmarDeprecatedSince020,\n    )\n    def dict(  # type: ignore # noqa A003\n        self,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        exclude_list: bool = False,\n        relation_map: Optional[Dict] = None,\n    ) -&gt; \"DictStrAny\":  # noqa: A003 # pragma: no cover\n        warnings.warn(\n            \"The `dict` method is deprecated; use `model_dump` instead.\",\n            DeprecationWarning,\n        )\n        return self.model_dump(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n            exclude_list=exclude_list,\n            relation_map=relation_map,\n        )\n\n    def model_dump(  # type: ignore # noqa A003\n        self,\n        *,\n        mode: Union[Literal[\"json\", \"python\"], str] = \"python\",\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        exclude_list: bool = False,\n        relation_map: Optional[Dict] = None,\n        round_trip: bool = False,\n        warnings: bool = True,\n    ) -&gt; \"DictStrAny\":  # noqa: A003'\n        \"\"\"\n\n        Generate a dictionary representation of the model,\n        optionally specifying which fields to include or exclude.\n\n        Nested models are also parsed to dictionaries.\n\n        Additionally, fields decorated with @property_field are also added.\n\n        :param exclude_through_models: flag to exclude through models from dict\n        :type exclude_through_models: bool\n        :param exclude_primary_keys: flag to exclude primary keys from dict\n        :type exclude_primary_keys: bool\n        :param include: fields to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :param by_alias: flag to get values by alias - passed to pydantic\n        :type by_alias: bool\n        :param exclude_unset: flag to exclude not set values - passed to pydantic\n        :type exclude_unset: bool\n        :param exclude_defaults: flag to exclude default values - passed to pydantic\n        :type exclude_defaults: bool\n        :param exclude_none: flag to exclude None values - passed to pydantic\n        :type exclude_none: bool\n        :param exclude_list: flag to exclude lists of nested values models from dict\n        :type exclude_list: bool\n        :param relation_map: map of the relations to follow to avoid circular deps\n        :type relation_map: Dict\n        :param mode: The mode in which `to_python` should run.\n            If mode is 'json', the dictionary will only contain JSON serializable types.\n            If mode is 'python', the dictionary may contain any Python objects.\n        :type mode: str\n        :param round_trip: flag to enable serialization round-trip support\n        :type round_trip: bool\n        :param warnings: flag to log warnings for invalid fields\n        :type warnings: bool\n        :return:\n        :rtype:\n        \"\"\"\n        pydantic_exclude = self._update_excluded_with_related(exclude)\n        pydantic_exclude = self._update_excluded_with_pks_and_through(\n            exclude=pydantic_exclude,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n        )\n        dict_instance = super().model_dump(\n            mode=mode,\n            include=include,\n            exclude=pydantic_exclude,\n            by_alias=by_alias,\n            exclude_defaults=exclude_defaults,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=False,\n        )\n\n        dict_instance = {\n            k: self._convert_bytes_to_str(column_name=k, value=v)\n            for k, v in dict_instance.items()\n        }\n\n        include_dict = (\n            translate_list_to_dict(include) if isinstance(include, Set) else include\n        )\n        exclude_dict = (\n            translate_list_to_dict(exclude) if isinstance(exclude, Set) else exclude\n        )\n\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(self._iterate_related_models())\n        )\n        pk_only = getattr(self, \"__pk_only__\", False)\n        if relation_map and not pk_only:\n            dict_instance = self._extract_nested_models(\n                relation_map=relation_map,\n                dict_instance=dict_instance,\n                include=include_dict,\n                exclude=exclude_dict,\n                exclude_primary_keys=exclude_primary_keys,\n                exclude_through_models=exclude_through_models,\n                exclude_list=exclude_list,\n            )\n\n        return dict_instance\n\n    @typing_extensions.deprecated(\n        \"The `json` method is deprecated; use `model_dump_json` instead.\",\n        category=OrmarDeprecatedSince020,\n    )\n    def json(  # type: ignore # noqa A003\n        self,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        **dumps_kwargs: Any,\n    ) -&gt; str:  # pragma: no cover\n        warnings.warn(\n            \"The `json` method is deprecated; use `model_dump_json` instead.\",\n            DeprecationWarning,\n        )\n        return self.model_dump_json(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n            **dumps_kwargs,\n        )\n\n    def model_dump_json(  # type: ignore # noqa A003\n        self,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_primary_keys: bool = False,\n        exclude_through_models: bool = False,\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        \"\"\"\n        Generate a JSON representation of the model, `include` and `exclude`\n        arguments as per `dict()`.\n\n        `encoder` is an optional function to supply as `default` to json.dumps(),\n        other arguments as per `json.dumps()`.\n        \"\"\"\n        data = self.model_dump(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n        )\n        return self.__pydantic_serializer__.to_json(data, warnings=False).decode()\n\n    @classmethod\n    @typing_extensions.deprecated(\n        \"The `construct` method is deprecated; use `model_construct` instead.\",\n        category=OrmarDeprecatedSince020,\n    )\n    def construct(\n        cls: Type[\"T\"], _fields_set: Union[Set[str], None] = None, **values: Any\n    ) -&gt; \"T\":  # pragma: no cover\n        warnings.warn(\n            \"The `construct` method is deprecated; use `model_construct` instead.\",\n            DeprecationWarning,\n        )\n        return cls.model_construct(_fields_set=_fields_set, **values)\n\n    @classmethod\n    def model_construct(\n        cls: Type[\"T\"], _fields_set: Optional[\"SetStr\"] = None, **values: Any\n    ) -&gt; \"T\":\n        own_values = {\n            k: v for k, v in values.items() if k not in cls.extract_related_names()\n        }\n        model = cls.__new__(cls)\n        fields_values: Dict[str, Any] = {}\n        for name, field in cls.model_fields.items():\n            if name in own_values:\n                fields_values[name] = own_values[name]\n            elif not field.is_required():\n                fields_values[name] = field.get_default()\n        fields_values.update(own_values)\n\n        if _fields_set is None:\n            _fields_set = set(values.keys())\n\n        extra_allowed = cls.model_config.get(\"extra\") == \"allow\"\n        if not extra_allowed:\n            fields_values.update(values)\n        object.__setattr__(model, \"__dict__\", fields_values)\n        model._initialize_internal_attributes()\n        cls._construct_relations(model=model, values=values)\n        object.__setattr__(model, \"__pydantic_fields_set__\", _fields_set)\n        return cls._pydantic_model_construct_finalizer(\n            model=model, extra_allowed=extra_allowed, values=values\n        )\n\n    @classmethod\n    def _pydantic_model_construct_finalizer(\n        cls: Type[\"T\"], model: \"T\", extra_allowed: bool, **values: Any\n    ) -&gt; \"T\":\n        \"\"\"\n        Recreate pydantic model_construct logic here as we do not call super method.\n        \"\"\"\n        _extra: Union[Dict[str, Any], None] = None\n        if extra_allowed:  # pragma: no cover\n            _extra = {}\n            for k, v in values.items():\n                _extra[k] = v\n\n        if not cls.__pydantic_root_model__:\n            object.__setattr__(model, \"__pydantic_extra__\", _extra)\n\n        if cls.__pydantic_post_init__:  # pragma: no cover\n            model.model_post_init(None)\n        elif not cls.__pydantic_root_model__:\n            # Note: if there are any private attributes,\n            # cls.__pydantic_post_init__ would exist\n            # Since it doesn't, that means that `__pydantic_private__`\n            # should be set to None\n            object.__setattr__(model, \"__pydantic_private__\", None)\n\n        return model\n\n    @classmethod\n    def _construct_relations(cls: Type[\"T\"], model: \"T\", values: Dict) -&gt; None:\n        present_relations = [\n            relation for relation in cls.extract_related_names() if relation in values\n        ]\n        for relation in present_relations:\n            value_to_set = values[relation]\n            if not isinstance(value_to_set, list):\n                value_to_set = [value_to_set]\n            relation_field = cls.ormar_config.model_fields[relation]\n            relation_value = [\n                relation_field.expand_relationship(x, model, to_register=False)\n                for x in value_to_set\n                if x is not None\n            ]\n\n            for child in relation_value:\n                model._orm.add(\n                    parent=cast(\"Model\", child),\n                    child=cast(\"Model\", model),\n                    field=cast(\"ForeignKeyField\", relation_field),\n                )\n\n    def update_from_dict(self, value_dict: Dict) -&gt; \"NewBaseModel\":\n        \"\"\"\n        Updates self with values of fields passed in the dictionary.\n\n        :param value_dict: dictionary of fields names and values\n        :type value_dict: Dict\n        :return: self\n        :rtype: NewBaseModel\n        \"\"\"\n        for key, value in value_dict.items():\n            setattr(self, key, value)\n        return self\n\n    def _convert_to_bytes(self, column_name: str, value: Any) -&gt; Union[str, Dict]:\n        \"\"\"\n        Converts value to bytes from string\n\n        :param column_name: name of the field\n        :type column_name: str\n        :param value: value fo the field\n        :type value: Any\n        :return: converted value if needed, else original value\n        :rtype: Any\n        \"\"\"\n        if column_name not in self._bytes_fields:\n            return value\n        field = self.ormar_config.model_fields[column_name]\n        if value is not None:\n            value = decode_bytes(\n                value=value, represent_as_string=field.represent_as_base64_str\n            )\n        return value\n\n    def _convert_bytes_to_str(self, column_name: str, value: Any) -&gt; Union[str, Dict]:\n        \"\"\"\n        Converts value to str from bytes for represent_as_base64_str columns.\n\n        :param column_name: name of the field\n        :type column_name: str\n        :param value: value fo the field\n        :type value: Any\n        :return: converted value if needed, else original value\n        :rtype: Any\n        \"\"\"\n        if column_name not in self._bytes_fields:\n            return value\n        field = self.ormar_config.model_fields[column_name]\n        if (\n            value is not None\n            and not isinstance(value, str)\n            and field.represent_as_base64_str\n        ):\n            return base64.b64encode(value).decode()\n        return value\n\n    def _convert_json(self, column_name: str, value: Any) -&gt; Union[str, Dict, None]:\n        \"\"\"\n        Converts value to/from json if needed (for Json columns).\n\n        :param column_name: name of the field\n        :type column_name: str\n        :param value: value fo the field\n        :type value: Any\n        :return: converted value if needed, else original value\n        :rtype: Any\n        \"\"\"\n        if column_name not in self._json_fields:\n            return value\n        return encode_json(value)\n\n    def _extract_own_model_fields(self) -&gt; Dict:\n        \"\"\"\n        Returns a dictionary with field names and values for fields that are not\n        relations fields (ForeignKey, ManyToMany etc.)\n\n        :return: dictionary of fields names and values.\n        :rtype: Dict\n        \"\"\"\n        related_names = self.extract_related_names()\n        self_fields = {k: v for k, v in self.__dict__.items() if k not in related_names}\n        return self_fields\n\n    def _extract_model_db_fields(self) -&gt; Dict:\n        \"\"\"\n        Returns a dictionary with field names and values for fields that are stored in\n        current model's table.\n\n        That includes own non-relational fields ang foreign key fields.\n\n        :return: dictionary of fields names and values.\n        :rtype: Dict\n        \"\"\"\n        self_fields = self._extract_own_model_fields()\n        self_fields = {\n            k: v\n            for k, v in self_fields.items()\n            if self.get_column_alias(k) in self.ormar_config.table.columns\n        }\n        for field in self._extract_db_related_names():\n            relation_field = self.ormar_config.model_fields[field]\n            target_pk_name = relation_field.to.ormar_config.pkname\n            target_field = getattr(self, field)\n            self_fields[field] = getattr(target_field, target_pk_name, None)\n            if not relation_field.nullable and not self_fields[field]:\n                raise ModelPersistenceError(\n                    f\"You cannot save {relation_field.to.get_name()} \"\n                    f\"model without pk set!\"\n                )\n        return self_fields\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.pk_column","title":"<code>pk_column: sqlalchemy.Column</code>  <code>property</code>","text":"<p>Retrieves primary key sqlalchemy column from models OrmarConfig.table. Each model has to have primary key. Only one primary key column is allowed.</p> <p>:return: primary key sqlalchemy column :rtype: sqlalchemy.Column</p>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.saved","title":"<code>saved: bool</code>  <code>property</code>","text":"<p>Saved status of the model. Changed by setattr and loading from db</p>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.signals","title":"<code>signals: SignalEmitter</code>  <code>property</code>","text":"<p>Exposes signals from model OrmarConfig</p>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares other model to this model. when == is called. :param other: other model to compare :type other: object :return: result of comparison :rtype: bool</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Compares other model to this model. when == is called.\n    :param other: other model to compare\n    :type other: object\n    :return: result of comparison\n    :rtype: bool\n    \"\"\"\n    if isinstance(other, NewBaseModel):\n        return self.__same__(other)\n    return super().__eq__(other)  # pragma no cover\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Used for private attributes of pydantic v2.</p> <p>:param item: name of attribute :type item: str :return: Any :rtype: Any</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    \"\"\"\n    Used for private attributes of pydantic v2.\n\n    :param item: name of attribute\n    :type item: str\n    :return: Any\n    :rtype: Any\n    \"\"\"\n    # TODO: Check __pydantic_extra__\n    if item == \"__pydantic_extra__\":\n        return None\n    return super().__getattr__(item)  # type: ignore\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializer that creates a new ormar Model that is also pydantic Model at the same time.</p> <p>Passed keyword arguments can be only field names and their corresponding values as those will be passed to pydantic validation that will complain if extra params are passed.</p> <p>If relations are defined each relation is expanded and children models are also initialized and validated. Relation from both sides is registered so you can access related models from both sides.</p> <p>Json fields are automatically loaded/dumped if needed.</p> <p>Models marked as abstract=True in internal OrmarConfig cannot be initialized.</p> <p>Accepts also special pk_only flag that indicates that Model is constructed only with primary key value (so no other fields, it's a child model on other Model), that causes skipping the validation, that's the only case when the validation can be skipped.</p> <p>Accepts also special excluded parameter that contains a set of fields that should be explicitly set to None, as otherwise pydantic will try to populate them with their default values if default is set.</p> <p>:raises ModelError: if abstract model is initialized, model has ForwardRefs  that has not been updated or unknown field is passed :param args: ignored args :type args: Any :param kwargs: keyword arguments - all fields values and some special params :type kwargs: Any</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # type: ignore\n    \"\"\"\n    Initializer that creates a new ormar Model that is also pydantic Model at the\n    same time.\n\n    Passed keyword arguments can be only field names and their corresponding values\n    as those will be passed to pydantic validation that will complain if extra\n    params are passed.\n\n    If relations are defined each relation is expanded and children models are also\n    initialized and validated. Relation from both sides is registered so you can\n    access related models from both sides.\n\n    Json fields are automatically loaded/dumped if needed.\n\n    Models marked as abstract=True in internal OrmarConfig cannot be initialized.\n\n    Accepts also special __pk_only__ flag that indicates that Model is constructed\n    only with primary key value (so no other fields, it's a child model on other\n    Model), that causes skipping the validation, that's the only case when the\n    validation can be skipped.\n\n    Accepts also special __excluded__ parameter that contains a set of fields that\n    should be explicitly set to None, as otherwise pydantic will try to populate\n    them with their default values if default is set.\n\n    :raises ModelError: if abstract model is initialized, model has ForwardRefs\n     that has not been updated or unknown field is passed\n    :param args: ignored args\n    :type args: Any\n    :param kwargs: keyword arguments - all fields values and some special params\n    :type kwargs: Any\n    \"\"\"\n    self._verify_model_can_be_initialized()\n    self._initialize_internal_attributes()\n\n    pk_only = kwargs.pop(\"__pk_only__\", False)\n    object.__setattr__(self, \"__pk_only__\", pk_only)\n\n    new_kwargs, through_tmp_dict = self._process_kwargs(kwargs)\n\n    if not pk_only:\n        self.__pydantic_validator__.validate_python(\n            new_kwargs, self_instance=self  # type: ignore\n        )\n    else:\n        fields_set = {self.ormar_config.pkname}\n        values = new_kwargs\n        object.__setattr__(self, \"__dict__\", values)\n        object.__setattr__(self, \"__pydantic_fields_set__\", fields_set)\n    # add back through fields\n    new_kwargs.update(through_tmp_dict)\n    model_fields = object.__getattribute__(self, \"ormar_config\").model_fields\n    # register the columns models after initialization\n    for related in self.extract_related_names().union(self.extract_through_names()):\n        model_fields[related].expand_relationship(\n            new_kwargs.get(related), self, to_register=True\n        )\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.__same__","title":"<code>__same__(other)</code>","text":"<p>Used by eq, compares other model to this model. Compares: * _orm_ids, * primary key values if it's set * dictionary of own fields (excluding relations) :param other: model to compare to :type other: NewBaseModel :return: result of comparison :rtype: bool</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __same__(self, other: \"NewBaseModel\") -&gt; bool:\n    \"\"\"\n    Used by __eq__, compares other model to this model.\n    Compares:\n    * _orm_ids,\n    * primary key values if it's set\n    * dictionary of own fields (excluding relations)\n    :param other: model to compare to\n    :type other: NewBaseModel\n    :return: result of comparison\n    :rtype: bool\n    \"\"\"\n    if (self.pk is None and other.pk is not None) or (\n        self.pk is not None and other.pk is None\n    ):\n        return False\n    else:\n        return hash(self) == other.__hash__()\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Overwrites setattr in pydantic parent as otherwise descriptors are not called.</p> <p>:param name: name of the attribute to set :type name: str :param value: value of the attribute to set :type value: Any :return: None :rtype: None</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:  # noqa CCR001\n    \"\"\"\n    Overwrites setattr in pydantic parent as otherwise descriptors are not called.\n\n    :param name: name of the attribute to set\n    :type name: str\n    :param value: value of the attribute to set\n    :type value: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    prev_hash = hash(self)\n\n    if hasattr(self, name):\n        object.__setattr__(self, name, value)\n    else:\n        # let pydantic handle errors for unknown fields\n        super().__setattr__(name, value)\n\n    # In this case, the hash could have changed, so update it\n    if name == self.ormar_config.pkname or self.pk is None:\n        object.__setattr__(self, \"__cached_hash__\", None)\n        new_hash = hash(self)\n\n        if prev_hash != new_hash:\n            self._update_relation_cache(prev_hash, new_hash)\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.db_backend_name","title":"<code>db_backend_name()</code>  <code>classmethod</code>","text":"<p>Shortcut to database dialect, cause some dialect require different treatment</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef db_backend_name(cls) -&gt; str:\n    \"\"\"Shortcut to database dialect,\n    cause some dialect require different treatment\"\"\"\n    return cls.ormar_config.database._backend._dialect.name\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.get_name","title":"<code>get_name(lower=True)</code>  <code>classmethod</code>","text":"<p>Returns name of the Model class, by default lowercase.</p> <p>:param lower: flag if name should be set to lowercase :type lower: bool :return: name of the model :rtype: str</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef get_name(cls, lower: bool = True) -&gt; str:\n    \"\"\"\n    Returns name of the Model class, by default lowercase.\n\n    :param lower: flag if name should be set to lowercase\n    :type lower: bool\n    :return: name of the model\n    :rtype: str\n    \"\"\"\n    name = cls.__name__\n    if lower:\n        name = name.lower()\n    return name\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.model_dump","title":"<code>model_dump(*, mode='python', include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, exclude_primary_keys=False, exclude_through_models=False, exclude_list=False, relation_map=None, round_trip=False, warnings=True)</code>","text":"<p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>Nested models are also parsed to dictionaries.</p> <p>Additionally, fields decorated with @property_field are also added.</p> <p>:param exclude_through_models: flag to exclude through models from dict :type exclude_through_models: bool :param exclude_primary_keys: flag to exclude primary keys from dict :type exclude_primary_keys: bool :param include: fields to include :type include: Union[Set, Dict, None] :param exclude: fields to exclude :type exclude: Union[Set, Dict, None] :param by_alias: flag to get values by alias - passed to pydantic :type by_alias: bool :param exclude_unset: flag to exclude not set values - passed to pydantic :type exclude_unset: bool :param exclude_defaults: flag to exclude default values - passed to pydantic :type exclude_defaults: bool :param exclude_none: flag to exclude None values - passed to pydantic :type exclude_none: bool :param exclude_list: flag to exclude lists of nested values models from dict :type exclude_list: bool :param relation_map: map of the relations to follow to avoid circular deps :type relation_map: Dict :param mode: The mode in which <code>to_python</code> should run.     If mode is 'json', the dictionary will only contain JSON serializable types.     If mode is 'python', the dictionary may contain any Python objects. :type mode: str :param round_trip: flag to enable serialization round-trip support :type round_trip: bool :param warnings: flag to log warnings for invalid fields :type warnings: bool :return: :rtype:</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def model_dump(  # type: ignore # noqa A003\n    self,\n    *,\n    mode: Union[Literal[\"json\", \"python\"], str] = \"python\",\n    include: Union[Set, Dict, None] = None,\n    exclude: Union[Set, Dict, None] = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_primary_keys: bool = False,\n    exclude_through_models: bool = False,\n    exclude_list: bool = False,\n    relation_map: Optional[Dict] = None,\n    round_trip: bool = False,\n    warnings: bool = True,\n) -&gt; \"DictStrAny\":  # noqa: A003'\n    \"\"\"\n\n    Generate a dictionary representation of the model,\n    optionally specifying which fields to include or exclude.\n\n    Nested models are also parsed to dictionaries.\n\n    Additionally, fields decorated with @property_field are also added.\n\n    :param exclude_through_models: flag to exclude through models from dict\n    :type exclude_through_models: bool\n    :param exclude_primary_keys: flag to exclude primary keys from dict\n    :type exclude_primary_keys: bool\n    :param include: fields to include\n    :type include: Union[Set, Dict, None]\n    :param exclude: fields to exclude\n    :type exclude: Union[Set, Dict, None]\n    :param by_alias: flag to get values by alias - passed to pydantic\n    :type by_alias: bool\n    :param exclude_unset: flag to exclude not set values - passed to pydantic\n    :type exclude_unset: bool\n    :param exclude_defaults: flag to exclude default values - passed to pydantic\n    :type exclude_defaults: bool\n    :param exclude_none: flag to exclude None values - passed to pydantic\n    :type exclude_none: bool\n    :param exclude_list: flag to exclude lists of nested values models from dict\n    :type exclude_list: bool\n    :param relation_map: map of the relations to follow to avoid circular deps\n    :type relation_map: Dict\n    :param mode: The mode in which `to_python` should run.\n        If mode is 'json', the dictionary will only contain JSON serializable types.\n        If mode is 'python', the dictionary may contain any Python objects.\n    :type mode: str\n    :param round_trip: flag to enable serialization round-trip support\n    :type round_trip: bool\n    :param warnings: flag to log warnings for invalid fields\n    :type warnings: bool\n    :return:\n    :rtype:\n    \"\"\"\n    pydantic_exclude = self._update_excluded_with_related(exclude)\n    pydantic_exclude = self._update_excluded_with_pks_and_through(\n        exclude=pydantic_exclude,\n        exclude_primary_keys=exclude_primary_keys,\n        exclude_through_models=exclude_through_models,\n    )\n    dict_instance = super().model_dump(\n        mode=mode,\n        include=include,\n        exclude=pydantic_exclude,\n        by_alias=by_alias,\n        exclude_defaults=exclude_defaults,\n        exclude_unset=exclude_unset,\n        exclude_none=exclude_none,\n        round_trip=round_trip,\n        warnings=False,\n    )\n\n    dict_instance = {\n        k: self._convert_bytes_to_str(column_name=k, value=v)\n        for k, v in dict_instance.items()\n    }\n\n    include_dict = (\n        translate_list_to_dict(include) if isinstance(include, Set) else include\n    )\n    exclude_dict = (\n        translate_list_to_dict(exclude) if isinstance(exclude, Set) else exclude\n    )\n\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(self._iterate_related_models())\n    )\n    pk_only = getattr(self, \"__pk_only__\", False)\n    if relation_map and not pk_only:\n        dict_instance = self._extract_nested_models(\n            relation_map=relation_map,\n            dict_instance=dict_instance,\n            include=include_dict,\n            exclude=exclude_dict,\n            exclude_primary_keys=exclude_primary_keys,\n            exclude_through_models=exclude_through_models,\n            exclude_list=exclude_list,\n        )\n\n    return dict_instance\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.model_dump_json","title":"<code>model_dump_json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, exclude_primary_keys=False, exclude_through_models=False, **dumps_kwargs)</code>","text":"<p>Generate a JSON representation of the model, <code>include</code> and <code>exclude</code> arguments as per <code>dict()</code>.</p> <p><code>encoder</code> is an optional function to supply as <code>default</code> to json.dumps(), other arguments as per <code>json.dumps()</code>.</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def model_dump_json(  # type: ignore # noqa A003\n    self,\n    *,\n    include: Union[Set, Dict, None] = None,\n    exclude: Union[Set, Dict, None] = None,\n    by_alias: bool = False,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_primary_keys: bool = False,\n    exclude_through_models: bool = False,\n    **dumps_kwargs: Any,\n) -&gt; str:\n    \"\"\"\n    Generate a JSON representation of the model, `include` and `exclude`\n    arguments as per `dict()`.\n\n    `encoder` is an optional function to supply as `default` to json.dumps(),\n    other arguments as per `json.dumps()`.\n    \"\"\"\n    data = self.model_dump(\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_primary_keys=exclude_primary_keys,\n        exclude_through_models=exclude_through_models,\n    )\n    return self.__pydantic_serializer__.to_json(data, warnings=False).decode()\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.pk_type","title":"<code>pk_type()</code>  <code>classmethod</code>","text":"<p>Shortcut to models primary key field type</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef pk_type(cls) -&gt; Any:\n    \"\"\"Shortcut to models primary key field type\"\"\"\n    return cls.ormar_config.model_fields[cls.ormar_config.pkname].__type__\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.populate_through_models","title":"<code>populate_through_models(model, model_dict, include, exclude, relation_map)</code>  <code>staticmethod</code>","text":"<p>Populates through models with values from dict representation.</p> <p>:param model: model to populate through models :type model: Model :param model_dict: dict representation of the model :type model_dict: Dict :param include: fields to include :type include: Dict :param exclude: fields to exclude :type exclude: Dict :param relation_map: map of relations to follow to avoid circular refs :type relation_map: Dict :return: None :rtype: None</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@staticmethod\ndef populate_through_models(\n    model: \"Model\",\n    model_dict: Dict,\n    include: Union[Set, Dict],\n    exclude: Union[Set, Dict],\n    relation_map: Dict,\n) -&gt; None:\n    \"\"\"\n    Populates through models with values from dict representation.\n\n    :param model: model to populate through models\n    :type model: Model\n    :param model_dict: dict representation of the model\n    :type model_dict: Dict\n    :param include: fields to include\n    :type include: Dict\n    :param exclude: fields to exclude\n    :type exclude: Dict\n    :param relation_map: map of relations to follow to avoid circular refs\n    :type relation_map: Dict\n    :return: None\n    :rtype: None\n    \"\"\"\n\n    include_dict = (\n        translate_list_to_dict(include)\n        if (include and isinstance(include, Set))\n        else include\n    )\n    exclude_dict = (\n        translate_list_to_dict(exclude)\n        if (exclude and isinstance(exclude, Set))\n        else exclude\n    )\n    models_to_populate = model._get_not_excluded_fields(\n        fields=model.extract_through_names(),\n        include=cast(Optional[Dict], include_dict),\n        exclude=cast(Optional[Dict], exclude_dict),\n    )\n    through_fields_to_populate = [\n        model.ormar_config.model_fields[through_model]\n        for through_model in models_to_populate\n        if model.ormar_config.model_fields[through_model].related_name\n        not in relation_map\n    ]\n    for through_field in through_fields_to_populate:\n        through_instance = getattr(model, through_field.name)\n        if through_instance:\n            model_dict[through_field.name] = through_instance.model_dump()\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.remove","title":"<code>remove(parent, name)</code>","text":"<p>Removes child from relation with given name in RelationshipManager</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def remove(self, parent: \"Model\", name: str) -&gt; None:\n    \"\"\"Removes child from relation with given name in RelationshipManager\"\"\"\n    self._orm.remove_parent(self, parent, name)\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.set_save_status","title":"<code>set_save_status(status)</code>","text":"<p>Sets value of the save status</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def set_save_status(self, status: bool) -&gt; None:\n    \"\"\"Sets value of the save status\"\"\"\n    object.__setattr__(self, \"_orm_saved\", status)\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.update_forward_refs","title":"<code>update_forward_refs(**localns)</code>  <code>classmethod</code>","text":"<p>Processes fields that are ForwardRef and need to be evaluated into actual models.</p> <p>Expands relationships, register relation in alias manager and substitutes sqlalchemy columns with new ones with proper column type (null before).</p> <p>Populates OrmarConfig table of the Model which is left empty before.</p> <p>Sets self_reference flag on models that links to themselves.</p> <p>Calls the pydantic method to evaluate pydantic fields.</p> <p>:param localns: local namespace :type localns: Any :return: None :rtype: None</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>@classmethod\ndef update_forward_refs(cls, **localns: Any) -&gt; None:\n    \"\"\"\n    Processes fields that are ForwardRef and need to be evaluated into actual\n    models.\n\n    Expands relationships, register relation in alias manager and substitutes\n    sqlalchemy columns with new ones with proper column type (null before).\n\n    Populates OrmarConfig table of the Model which is left empty before.\n\n    Sets self_reference flag on models that links to themselves.\n\n    Calls the pydantic method to evaluate pydantic fields.\n\n    :param localns: local namespace\n    :type localns: Any\n    :return: None\n    :rtype: None\n    \"\"\"\n    globalns = sys.modules[cls.__module__].__dict__.copy()\n    globalns.setdefault(cls.__name__, cls)\n    fields_to_check = cls.ormar_config.model_fields.copy()\n    for field in fields_to_check.values():\n        if field.has_unresolved_forward_refs():\n            field = cast(ForeignKeyField, field)\n            field.evaluate_forward_ref(globalns=globalns, localns=localns)\n            field.set_self_reference_flag()\n            if field.is_multi and not field.through:\n                field = cast(ormar.ManyToManyField, field)\n                field.create_default_through_model()\n            expand_reverse_relationship(model_field=field)\n            register_relation_in_alias_manager(field=field)\n            update_column_definition(model=cls, field=field)\n    populate_config_sqlalchemy_table_if_required(config=cls.ormar_config)\n    # super().update_forward_refs(**localns)\n    cls.model_rebuild(force=True)\n    cls.ormar_config.requires_ref_update = False\n</code></pre>"},{"location":"api/models/newbasemodel/#ormar.models.newbasemodel.NewBaseModel.update_from_dict","title":"<code>update_from_dict(value_dict)</code>","text":"<p>Updates self with values of fields passed in the dictionary.</p> <p>:param value_dict: dictionary of fields names and values :type value_dict: Dict :return: self :rtype: NewBaseModel</p> Source code in <code>ormar/models/newbasemodel.py</code> <pre><code>def update_from_dict(self, value_dict: Dict) -&gt; \"NewBaseModel\":\n    \"\"\"\n    Updates self with values of fields passed in the dictionary.\n\n    :param value_dict: dictionary of fields names and values\n    :type value_dict: Dict\n    :return: self\n    :rtype: NewBaseModel\n    \"\"\"\n    for key, value in value_dict.items():\n        setattr(self, key, value)\n    return self\n</code></pre>"},{"location":"api/models/ormar_config/","title":"ormar_config","text":""},{"location":"api/models/quick_access_views/","title":"quick_access_views","text":"<p>Contains set of fields/methods etc names that are used to bypass the checks in NewBaseModel getattribute calls to speed the calls.</p>"},{"location":"api/models/traversible/","title":"traversible","text":""},{"location":"api/models/traversible/#ormar.models.traversible.Node","title":"<code>Node</code>","text":"Source code in <code>ormar/models/traversible.py</code> <pre><code>class Node:\n    def __init__(\n        self,\n        node_class: Type[\"RelationMixin\"],\n        relation_name: Optional[str] = None,\n        parent_node: Optional[\"Node\"] = None,\n    ) -&gt; None:\n        self.relation_name = relation_name\n        self.node_class = node_class\n        self.parent_node = parent_node\n        self.visited_children: List[\"Node\"] = []\n        if self.parent_node:\n            self.parent_node.visited_children.append(self)\n\n    def __repr__(self) -&gt; str:  # pragma: no cover\n        return (\n            f\"{self.node_class.get_name(lower=False)}, \"\n            f\"relation:{self.relation_name}, \"\n            f\"parent: {self.parent_node}\"\n        )\n\n    def visited(self, relation_name: str) -&gt; bool:\n        \"\"\"\n        Checks if given relation was already visited.\n\n        Relation was visited if it's name is in current node children.\n\n        Relation was visited if one of the parent node had the same Model class\n\n        :param relation_name: name of relation\n        :type relation_name: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        target_model = self.node_class.ormar_config.model_fields[relation_name].to\n        if self.parent_node:\n            node = self\n            while node.parent_node:\n                node = node.parent_node\n                if node.node_class == target_model:\n                    return True\n        return False\n</code></pre>"},{"location":"api/models/traversible/#ormar.models.traversible.Node.visited","title":"<code>visited(relation_name)</code>","text":"<p>Checks if given relation was already visited.</p> <p>Relation was visited if it's name is in current node children.</p> <p>Relation was visited if one of the parent node had the same Model class</p> <p>:param relation_name: name of relation :type relation_name: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/traversible.py</code> <pre><code>def visited(self, relation_name: str) -&gt; bool:\n    \"\"\"\n    Checks if given relation was already visited.\n\n    Relation was visited if it's name is in current node children.\n\n    Relation was visited if one of the parent node had the same Model class\n\n    :param relation_name: name of relation\n    :type relation_name: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    target_model = self.node_class.ormar_config.model_fields[relation_name].to\n    if self.parent_node:\n        node = self\n        while node.parent_node:\n            node = node.parent_node\n            if node.node_class == target_model:\n                return True\n    return False\n</code></pre>"},{"location":"api/models/traversible/#ormar.models.traversible.NodeList","title":"<code>NodeList</code>","text":"<p>Helper class that helps with iterating nested models</p> Source code in <code>ormar/models/traversible.py</code> <pre><code>class NodeList:\n    \"\"\"\n    Helper class that helps with iterating nested models\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.node_list: List[\"Node\"] = []\n\n    def __getitem__(self, item: Any) -&gt; Any:\n        return self.node_list.__getitem__(item)\n\n    def add(\n        self,\n        node_class: Type[\"RelationMixin\"],\n        relation_name: Optional[str] = None,\n        parent_node: Optional[\"Node\"] = None,\n    ) -&gt; \"Node\":\n        \"\"\"\n        Adds new Node or returns the existing one\n\n        :param node_class: Model in current node\n        :type node_class: ormar.models.metaclass.ModelMetaclass\n        :param relation_name: name of the current relation\n        :type relation_name: str\n        :param parent_node: parent node\n        :type parent_node: Optional[Node]\n        :return: returns new or already existing node\n        :rtype: Node\n        \"\"\"\n        existing_node = self.find(\n            relation_name=relation_name, node_class=node_class, parent_node=parent_node\n        )\n        if not existing_node:\n            current_node = Node(\n                node_class=node_class,\n                relation_name=relation_name,\n                parent_node=parent_node,\n            )\n            self.node_list.append(current_node)\n            return current_node\n        return existing_node  # pragma: no cover\n\n    def find(\n        self,\n        node_class: Type[\"RelationMixin\"],\n        relation_name: Optional[str] = None,\n        parent_node: Optional[\"Node\"] = None,\n    ) -&gt; Optional[\"Node\"]:\n        \"\"\"\n        Searches for existing node with given parameters\n\n        :param node_class: Model in current node\n        :type node_class: ormar.models.metaclass.ModelMetaclass\n        :param relation_name: name of the current relation\n        :type relation_name: str\n        :param parent_node: parent node\n        :type parent_node: Optional[Node]\n        :return: returns already existing node or None\n        :rtype: Optional[Node]\n        \"\"\"\n        for node in self.node_list:\n            if (\n                node.node_class == node_class\n                and node.parent_node == parent_node\n                and node.relation_name == relation_name\n            ):\n                return node  # pragma: no cover\n        return None\n</code></pre>"},{"location":"api/models/traversible/#ormar.models.traversible.NodeList.add","title":"<code>add(node_class, relation_name=None, parent_node=None)</code>","text":"<p>Adds new Node or returns the existing one</p> <p>:param node_class: Model in current node :type node_class: ormar.models.metaclass.ModelMetaclass :param relation_name: name of the current relation :type relation_name: str :param parent_node: parent node :type parent_node: Optional[Node] :return: returns new or already existing node :rtype: Node</p> Source code in <code>ormar/models/traversible.py</code> <pre><code>def add(\n    self,\n    node_class: Type[\"RelationMixin\"],\n    relation_name: Optional[str] = None,\n    parent_node: Optional[\"Node\"] = None,\n) -&gt; \"Node\":\n    \"\"\"\n    Adds new Node or returns the existing one\n\n    :param node_class: Model in current node\n    :type node_class: ormar.models.metaclass.ModelMetaclass\n    :param relation_name: name of the current relation\n    :type relation_name: str\n    :param parent_node: parent node\n    :type parent_node: Optional[Node]\n    :return: returns new or already existing node\n    :rtype: Node\n    \"\"\"\n    existing_node = self.find(\n        relation_name=relation_name, node_class=node_class, parent_node=parent_node\n    )\n    if not existing_node:\n        current_node = Node(\n            node_class=node_class,\n            relation_name=relation_name,\n            parent_node=parent_node,\n        )\n        self.node_list.append(current_node)\n        return current_node\n    return existing_node  # pragma: no cover\n</code></pre>"},{"location":"api/models/traversible/#ormar.models.traversible.NodeList.find","title":"<code>find(node_class, relation_name=None, parent_node=None)</code>","text":"<p>Searches for existing node with given parameters</p> <p>:param node_class: Model in current node :type node_class: ormar.models.metaclass.ModelMetaclass :param relation_name: name of the current relation :type relation_name: str :param parent_node: parent node :type parent_node: Optional[Node] :return: returns already existing node or None :rtype: Optional[Node]</p> Source code in <code>ormar/models/traversible.py</code> <pre><code>def find(\n    self,\n    node_class: Type[\"RelationMixin\"],\n    relation_name: Optional[str] = None,\n    parent_node: Optional[\"Node\"] = None,\n) -&gt; Optional[\"Node\"]:\n    \"\"\"\n    Searches for existing node with given parameters\n\n    :param node_class: Model in current node\n    :type node_class: ormar.models.metaclass.ModelMetaclass\n    :param relation_name: name of the current relation\n    :type relation_name: str\n    :param parent_node: parent node\n    :type parent_node: Optional[Node]\n    :return: returns already existing node or None\n    :rtype: Optional[Node]\n    \"\"\"\n    for node in self.node_list:\n        if (\n            node.node_class == node_class\n            and node.parent_node == parent_node\n            and node.relation_name == relation_name\n        ):\n            return node  # pragma: no cover\n    return None\n</code></pre>"},{"location":"api/models/utils/","title":"utils","text":""},{"location":"api/models/descriptors/","title":"descriptors","text":""},{"location":"api/models/descriptors/#ormar.models.descriptors.BytesDescriptor","title":"<code>BytesDescriptor</code>","text":"<p>Bytes descriptor converts strings to bytes on write and converts bytes to str if represent_as_base64_str flag is set, so the value can be dumped to json</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class BytesDescriptor:\n    \"\"\"\n    Bytes descriptor converts strings to bytes on write and converts bytes to str\n    if represent_as_base64_str flag is set, so the value can be dumped to json\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        field = instance.ormar_config.model_fields[self.name]\n        if (\n            value is not None\n            and field.represent_as_base64_str\n            and not isinstance(value, str)\n        ):\n            value = base64.b64encode(value).decode()\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        field = instance.ormar_config.model_fields[self.name]\n        if isinstance(value, str):\n            value = decode_bytes(\n                value=value, represent_as_string=field.represent_as_base64_str\n            )\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/#ormar.models.descriptors.JsonDescriptor","title":"<code>JsonDescriptor</code>","text":"<p>Json descriptor dumps/loads strings to actual data on write/read</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class JsonDescriptor:\n    \"\"\"\n    Json descriptor dumps/loads strings to actual data on write/read\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        value = encode_json(value)\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/#ormar.models.descriptors.PkDescriptor","title":"<code>PkDescriptor</code>","text":"<p>As of now it's basically a copy of PydanticDescriptor but that will change in the future with multi column primary keys</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class PkDescriptor:\n    \"\"\"\n    As of now it's basically a copy of PydanticDescriptor but that will\n    change in the future with multi column primary keys\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/#ormar.models.descriptors.PydanticDescriptor","title":"<code>PydanticDescriptor</code>","text":"<p>Pydantic descriptor simply delegates everything to pydantic model</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class PydanticDescriptor:\n    \"\"\"\n    Pydantic descriptor simply delegates everything to pydantic model\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/#ormar.models.descriptors.RelationDescriptor","title":"<code>RelationDescriptor</code>","text":"<p>Relation descriptor expands the relation to initialize the related model before setting it to dict. Note that expanding also registers the related model in RelationManager.</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class RelationDescriptor:\n    \"\"\"\n    Relation descriptor expands the relation to initialize the related model\n    before setting it to __dict__. Note that expanding also registers the\n    related model in RelationManager.\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        if self.name in instance._orm:\n            return instance._orm.get(self.name)  # type: ignore\n        return None  # pragma no cover\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        instance.ormar_config.model_fields[self.name].expand_relationship(\n            value=value, child=instance\n        )\n\n        if not isinstance(instance.__dict__.get(self.name), list):\n            instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/descriptors/","title":"descriptors","text":""},{"location":"api/models/descriptors/descriptors/#ormar.models.descriptors.descriptors.BytesDescriptor","title":"<code>BytesDescriptor</code>","text":"<p>Bytes descriptor converts strings to bytes on write and converts bytes to str if represent_as_base64_str flag is set, so the value can be dumped to json</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class BytesDescriptor:\n    \"\"\"\n    Bytes descriptor converts strings to bytes on write and converts bytes to str\n    if represent_as_base64_str flag is set, so the value can be dumped to json\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        field = instance.ormar_config.model_fields[self.name]\n        if (\n            value is not None\n            and field.represent_as_base64_str\n            and not isinstance(value, str)\n        ):\n            value = base64.b64encode(value).decode()\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        field = instance.ormar_config.model_fields[self.name]\n        if isinstance(value, str):\n            value = decode_bytes(\n                value=value, represent_as_string=field.represent_as_base64_str\n            )\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/descriptors/#ormar.models.descriptors.descriptors.JsonDescriptor","title":"<code>JsonDescriptor</code>","text":"<p>Json descriptor dumps/loads strings to actual data on write/read</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class JsonDescriptor:\n    \"\"\"\n    Json descriptor dumps/loads strings to actual data on write/read\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        value = encode_json(value)\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/descriptors/#ormar.models.descriptors.descriptors.PkDescriptor","title":"<code>PkDescriptor</code>","text":"<p>As of now it's basically a copy of PydanticDescriptor but that will change in the future with multi column primary keys</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class PkDescriptor:\n    \"\"\"\n    As of now it's basically a copy of PydanticDescriptor but that will\n    change in the future with multi column primary keys\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/descriptors/#ormar.models.descriptors.descriptors.PydanticDescriptor","title":"<code>PydanticDescriptor</code>","text":"<p>Pydantic descriptor simply delegates everything to pydantic model</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class PydanticDescriptor:\n    \"\"\"\n    Pydantic descriptor simply delegates everything to pydantic model\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        value = instance.__dict__.get(self.name, None)\n        return value\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        instance._internal_set(self.name, value)\n        instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/descriptors/descriptors/#ormar.models.descriptors.descriptors.RelationDescriptor","title":"<code>RelationDescriptor</code>","text":"<p>Relation descriptor expands the relation to initialize the related model before setting it to dict. Note that expanding also registers the related model in RelationManager.</p> Source code in <code>ormar/models/descriptors/descriptors.py</code> <pre><code>class RelationDescriptor:\n    \"\"\"\n    Relation descriptor expands the relation to initialize the related model\n    before setting it to __dict__. Note that expanding also registers the\n    related model in RelationManager.\n    \"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        self.name = name\n\n    def __get__(self, instance: \"Model\", owner: Type[\"Model\"]) -&gt; Any:\n        if self.name in instance._orm:\n            return instance._orm.get(self.name)  # type: ignore\n        return None  # pragma no cover\n\n    def __set__(self, instance: \"Model\", value: Any) -&gt; None:\n        instance.ormar_config.model_fields[self.name].expand_relationship(\n            value=value, child=instance\n        )\n\n        if not isinstance(instance.__dict__.get(self.name), list):\n            instance.set_save_status(False)\n</code></pre>"},{"location":"api/models/helpers/","title":"helpers","text":""},{"location":"api/models/helpers/#ormar.models.helpers.check_required_config_parameters","title":"<code>check_required_config_parameters(new_model)</code>","text":"<p>Verifies if ormar.Model has database and metadata set.</p> <p>Recreates Connection pool for sqlite3</p> <p>:param new_model: newly declared ormar Model :type new_model: Model class</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def check_required_config_parameters(new_model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Verifies if ormar.Model has database and metadata set.\n\n    Recreates Connection pool for sqlite3\n\n    :param new_model: newly declared ormar Model\n    :type new_model: Model class\n    \"\"\"\n    if new_model.ormar_config.database is None and not new_model.ormar_config.abstract:\n        raise ormar.ModelDefinitionError(\n            f\"{new_model.__name__} does not have database defined.\"\n        )\n    elif not new_model.ormar_config.abstract:\n        substitue_backend_pool_for_sqlite(new_model=new_model)\n\n    if new_model.ormar_config.metadata is None and not new_model.ormar_config.abstract:\n        raise ormar.ModelDefinitionError(\n            f\"{new_model.__name__} does not have metadata defined.\"\n        )\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.config_field_not_set","title":"<code>config_field_not_set(model, field_name)</code>","text":"<p>Checks if field with given name is already present in model.OrmarConfig. Then check if it's set to something truthful (in practice meaning not None, as it's non or ormar Field only).</p> <p>:param model: newly constructed model :type model: Model class :param field_name: name of the ormar field :type field_name: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def config_field_not_set(model: Type[\"Model\"], field_name: str) -&gt; bool:\n    \"\"\"\n    Checks if field with given name is already present in model.OrmarConfig.\n    Then check if it's set to something truthful\n    (in practice meaning not None, as it's non or ormar Field only).\n\n    :param model: newly constructed model\n    :type model: Model class\n    :param field_name: name of the ormar field\n    :type field_name: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return not getattr(model.ormar_config, field_name)\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.expand_reverse_relationships","title":"<code>expand_reverse_relationships(model)</code>","text":"<p>Iterates through model_fields of given model and verifies if all reverse relation have been populated on related models.</p> <p>If the reverse relation has not been set before it's set here.</p> <p>:param model: model on which relation should be checked and registered :type model: Model class</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def expand_reverse_relationships(model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Iterates through model_fields of given model and verifies if all reverse\n    relation have been populated on related models.\n\n    If the reverse relation has not been set before it's set here.\n\n    :param model: model on which relation should be checked and registered\n    :type model: Model class\n    \"\"\"\n    model_fields = list(model.ormar_config.model_fields.values())\n    for model_field in model_fields:\n        if (\n            model_field.is_relation\n            and not model_field.has_unresolved_forward_refs()\n            and not model_field.is_through\n        ):\n            model_field = cast(\"ForeignKeyField\", model_field)\n            expand_reverse_relationship(model_field=model_field)\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.extract_annotations_and_default_vals","title":"<code>extract_annotations_and_default_vals(attrs)</code>","text":"<p>Extracts annotations from class namespace dict and triggers extraction of ormar model_fields.</p> <p>:param attrs: namespace of the class created :type attrs: Dict :return: namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict]</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def extract_annotations_and_default_vals(attrs: Dict) -&gt; Tuple[Dict, Dict]:\n    \"\"\"\n    Extracts annotations from class namespace dict and triggers\n    extraction of ormar model_fields.\n\n    :param attrs: namespace of the class created\n    :type attrs: Dict\n    :return: namespace of the class updated, dict of extracted model_fields\n    :rtype: Tuple[Dict, Dict]\n    \"\"\"\n    key = \"__annotations__\"\n    attrs[key] = attrs.get(key, {})\n    attrs, model_fields = populate_pydantic_default_values(attrs)\n    return attrs, model_fields\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.get_potential_fields","title":"<code>get_potential_fields(attrs)</code>","text":"<p>Gets all the fields in current class namespace that are Fields.</p> <p>:param attrs: current class namespace :type attrs: Dict :return: extracted fields that are ormar Fields :rtype: Dict</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def get_potential_fields(attrs: Union[Dict, MappingProxyType]) -&gt; Dict:\n    \"\"\"\n    Gets all the fields in current class namespace that are Fields.\n\n    :param attrs: current class namespace\n    :type attrs: Dict\n    :return: extracted fields that are ormar Fields\n    :rtype: Dict\n    \"\"\"\n    return {\n        k: v\n        for k, v in attrs.items()\n        if (\n            (isinstance(v, type) and issubclass(v, BaseField))\n            or isinstance(v, BaseField)\n        )\n    }\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.get_pydantic_base_orm_config","title":"<code>get_pydantic_base_orm_config()</code>","text":"<p>Returns empty pydantic Config with orm_mode set to True.</p> <p>:return: empty default config with orm_mode set. :rtype: pydantic Config</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def get_pydantic_base_orm_config() -&gt; pydantic.ConfigDict:\n    \"\"\"\n    Returns empty pydantic Config with orm_mode set to True.\n\n    :return: empty default config with orm_mode set.\n    :rtype: pydantic Config\n    \"\"\"\n\n    return ConfigDict(validate_assignment=True, ser_json_bytes=\"base64\")\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.merge_or_generate_pydantic_config","title":"<code>merge_or_generate_pydantic_config(attrs, name)</code>","text":"<p>Checks if the user provided pydantic Config, and if he did merges it with the default one.</p> <p>Updates the attrs in place with a new config.</p> <p>:rtype: None</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def merge_or_generate_pydantic_config(attrs: Dict, name: str) -&gt; None:\n    \"\"\"\n    Checks if the user provided pydantic Config,\n    and if he did merges it with the default one.\n\n    Updates the attrs in place with a new config.\n\n    :rtype: None\n    \"\"\"\n    default_config = get_pydantic_base_orm_config()\n    if \"model_config\" in attrs:\n        provided_config = attrs[\"model_config\"]\n        if not isinstance(provided_config, dict):\n            raise ModelDefinitionError(\n                f\"Config provided for class {name} has to be a dictionary.\"\n            )\n\n        config = {**default_config, **provided_config}\n        attrs[\"model_config\"] = config\n    else:\n        attrs[\"model_config\"] = default_config\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.modify_schema_example","title":"<code>modify_schema_example(model)</code>","text":"<p>Modifies the schema example in openapi schema.</p> <p>:param model: newly constructed Model :type model: Model class</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def modify_schema_example(model: Type[\"Model\"]) -&gt; None:  # noqa CCR001\n    \"\"\"\n    Modifies the schema example in openapi schema.\n\n    :param model: newly constructed Model\n    :type model: Model class\n    \"\"\"\n    if not config_field_not_set(model=model, field_name=\"model_fields\"):\n        model.model_config[\"json_schema_extra\"] = construct_schema_function()\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.populate_config_sqlalchemy_table_if_required","title":"<code>populate_config_sqlalchemy_table_if_required(config)</code>","text":"<p>Constructs sqlalchemy table out of columns and parameters set on OrmarConfig. It populates name, metadata, columns and constraints.</p> <p>:param config: OrmarConfig of the Model without sqlalchemy table constructed :type config: Model class OrmarConfig</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def populate_config_sqlalchemy_table_if_required(config: \"OrmarConfig\") -&gt; None:\n    \"\"\"\n    Constructs sqlalchemy table out of columns and parameters set on OrmarConfig.\n    It populates name, metadata, columns and constraints.\n\n    :param config: OrmarConfig of the Model without sqlalchemy table constructed\n    :type config: Model class OrmarConfig\n    \"\"\"\n    if config.table is None and check_for_null_type_columns_from_forward_refs(\n        config=config\n    ):\n        set_constraint_names(config=config)\n        table = sqlalchemy.Table(\n            config.tablename, config.metadata, *config.columns, *config.constraints\n        )\n        config.table = table\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.populate_config_tablename_columns_and_pk","title":"<code>populate_config_tablename_columns_and_pk(name, new_model)</code>","text":"<p>Sets Model tablename if it's not already set in OrmarConfig. Default tablename if not present is class name lower + s (i.e. Bed becomes -&gt; beds)</p> <p>Checks if Model's OrmarConfig have pkname and columns set. If not calls the sqlalchemy_columns_from_model_fields to populate columns from ormar.fields definitions.</p> <p>:raises ModelDefinitionError: if pkname is not present raises ModelDefinitionError. Each model has to have pk.</p> <p>:param name: name of the current Model :type name: str :param new_model: currently constructed Model :type new_model: ormar.models.metaclass.ModelMetaclass :return: Model with populated pkname and columns in OrmarConfig :rtype: ormar.models.metaclass.ModelMetaclass</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def populate_config_tablename_columns_and_pk(\n    name: str, new_model: Type[\"Model\"]\n) -&gt; Type[\"Model\"]:\n    \"\"\"\n    Sets Model tablename if it's not already set in OrmarConfig.\n    Default tablename if not present is class name lower + s (i.e. Bed becomes -&gt; beds)\n\n    Checks if Model's OrmarConfig have pkname and columns set.\n    If not calls the sqlalchemy_columns_from_model_fields to populate\n    columns from ormar.fields definitions.\n\n    :raises ModelDefinitionError: if pkname is not present raises ModelDefinitionError.\n    Each model has to have pk.\n\n    :param name: name of the current Model\n    :type name: str\n    :param new_model: currently constructed Model\n    :type new_model: ormar.models.metaclass.ModelMetaclass\n    :return: Model with populated pkname and columns in OrmarConfig\n    :rtype: ormar.models.metaclass.ModelMetaclass\n    \"\"\"\n    tablename = name.lower() + \"s\"\n    new_model.ormar_config.tablename = (\n        new_model.ormar_config.tablename\n        if new_model.ormar_config.tablename\n        else tablename\n    )\n    pkname: Optional[str]\n\n    if new_model.ormar_config.columns:\n        columns = new_model.ormar_config.columns\n        pkname = new_model.ormar_config.pkname\n    else:\n        pkname, columns = sqlalchemy_columns_from_model_fields(\n            new_model.ormar_config.model_fields, new_model\n        )\n\n    if pkname is None:\n        raise ormar.ModelDefinitionError(\"Table has to have a primary key.\")\n\n    new_model.ormar_config.columns = columns\n    new_model.ormar_config.pkname = pkname\n    if not new_model.ormar_config.orders_by:\n        # by default, we sort by pk name if other option not provided\n        new_model.ormar_config.orders_by.append(pkname)\n    return new_model\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.populate_default_options_values","title":"<code>populate_default_options_values(new_model, model_fields)</code>","text":"<p>Sets all optional OrmarConfig values to its defaults and set model_fields that were already previously extracted.</p> <p>Here should live all options that are not overwritten/set for all models.</p> <p>Current options are: * constraints = [] * abstract = False</p> <p>:param new_model: newly constructed Model :type new_model: Model class :param model_fields: dict of model fields :type model_fields: Union[Dict[str, type], Dict]</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def populate_default_options_values(  # noqa: CCR001\n    new_model: Type[\"Model\"], model_fields: Dict\n) -&gt; None:\n    \"\"\"\n    Sets all optional OrmarConfig values to its defaults\n    and set model_fields that were already previously extracted.\n\n    Here should live all options that are not overwritten/set for all models.\n\n    Current options are:\n    * constraints = []\n    * abstract = False\n\n    :param new_model: newly constructed Model\n    :type new_model: Model class\n    :param model_fields: dict of model fields\n    :type model_fields: Union[Dict[str, type], Dict]\n    \"\"\"\n    new_model.ormar_config.model_fields.update(model_fields)\n    if any(is_field_an_forward_ref(field) for field in model_fields.values()):\n        new_model.ormar_config.requires_ref_update = True\n\n    new_model._json_fields = {\n        name for name, field in model_fields.items() if field.__type__ == pydantic.Json\n    }\n    new_model._bytes_fields = {\n        name for name, field in model_fields.items() if field.__type__ is bytes\n    }\n\n    new_model.__relation_map__ = None\n    new_model.__ormar_fields_validators__ = None\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.register_relation_in_alias_manager","title":"<code>register_relation_in_alias_manager(field)</code>","text":"<p>Registers the relation (and reverse relation) in alias manager. The m2m relations require registration of through model between actual end models of the relation.</p> <p>Delegates the actual registration to: m2m - register_many_to_many_relation_on_build fk - register_relation_on_build</p> <p>:param field: relation field :type field: ForeignKey or ManyToManyField class</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def register_relation_in_alias_manager(field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    Registers the relation (and reverse relation) in alias manager.\n    The m2m relations require registration of through model between\n    actual end models of the relation.\n\n    Delegates the actual registration to:\n    m2m - register_many_to_many_relation_on_build\n    fk - register_relation_on_build\n\n    :param field: relation field\n    :type field: ForeignKey or ManyToManyField class\n    \"\"\"\n    if field.is_multi:\n        if field.has_unresolved_forward_refs():\n            return\n        field = cast(\"ManyToManyField\", field)\n        register_many_to_many_relation_on_build(field=field)\n    elif field.is_relation and not field.is_through:\n        if field.has_unresolved_forward_refs():\n            return\n        register_relation_on_build(field=field)\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.remove_excluded_parent_fields","title":"<code>remove_excluded_parent_fields(model)</code>","text":"<p>Removes pydantic fields that should be excluded from parent models</p> <p>:param model: :type model: Type[\"Model\"]</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def remove_excluded_parent_fields(model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Removes pydantic fields that should be excluded from parent models\n\n    :param model:\n    :type model: Type[\"Model\"]\n    \"\"\"\n    excludes = {*model.ormar_config.exclude_parent_fields} - {\n        *model.ormar_config.model_fields.keys()\n    }\n    if excludes:\n        model.model_fields = {\n            k: v for k, v in model.model_fields.items() if k not in excludes\n        }\n        model.model_rebuild(force=True)\n</code></pre>"},{"location":"api/models/helpers/#ormar.models.helpers.sqlalchemy_columns_from_model_fields","title":"<code>sqlalchemy_columns_from_model_fields(model_fields, new_model)</code>","text":"<p>Iterates over declared on Model model fields and extracts fields that should be treated as database fields.</p> <p>If the model is empty it sets mandatory id field as primary key (used in through models in m2m relations).</p> <p>Triggers a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param. Also related_names have to be unique.</p> <p>Trigger validation of primary_key - only one and required pk can be set</p> <p>Sets <code>owner</code> on each model_field as reference to newly created Model.</p> <p>:raises ModelDefinitionError: if validation of related_names fail, or pkname validation fails. :param model_fields: dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] :param new_model: :type new_model: Model class :return: pkname, list of sqlalchemy columns :rtype: Tuple[Optional[str], List[sqlalchemy.Column]]</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def sqlalchemy_columns_from_model_fields(\n    model_fields: Dict, new_model: Type[\"Model\"]\n) -&gt; Tuple[Optional[str], List[sqlalchemy.Column]]:\n    \"\"\"\n    Iterates over declared on Model model fields and extracts fields that\n    should be treated as database fields.\n\n    If the model is empty it sets mandatory id field as primary key\n    (used in through models in m2m relations).\n\n    Triggers a validation of relation_names in relation fields. If multiple fields\n    are leading to the same related model only one can have empty related_name param.\n    Also related_names have to be unique.\n\n    Trigger validation of primary_key - only one and required pk can be set\n\n    Sets `owner` on each model_field as reference to newly created Model.\n\n    :raises ModelDefinitionError: if validation of related_names fail,\n    or pkname validation fails.\n    :param model_fields: dictionary of declared ormar model fields\n    :type model_fields: Dict[str, ormar.Field]\n    :param new_model:\n    :type new_model: Model class\n    :return: pkname, list of sqlalchemy columns\n    :rtype: Tuple[Optional[str], List[sqlalchemy.Column]]\n    \"\"\"\n    if len(model_fields.keys()) == 0:\n        model_fields[\"id\"] = ormar.Integer(name=\"id\", primary_key=True)\n        logging.warning(\n            f\"Table {new_model.ormar_config.tablename} had no fields so auto \"\n            \"Integer primary key named `id` created.\"\n        )\n    validate_related_names_in_relations(model_fields, new_model)\n    return _process_fields(model_fields=model_fields, new_model=new_model)\n</code></pre>"},{"location":"api/models/helpers/models/","title":"models","text":""},{"location":"api/models/helpers/models/#ormar.models.helpers.models.check_required_config_parameters","title":"<code>check_required_config_parameters(new_model)</code>","text":"<p>Verifies if ormar.Model has database and metadata set.</p> <p>Recreates Connection pool for sqlite3</p> <p>:param new_model: newly declared ormar Model :type new_model: Model class</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def check_required_config_parameters(new_model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Verifies if ormar.Model has database and metadata set.\n\n    Recreates Connection pool for sqlite3\n\n    :param new_model: newly declared ormar Model\n    :type new_model: Model class\n    \"\"\"\n    if new_model.ormar_config.database is None and not new_model.ormar_config.abstract:\n        raise ormar.ModelDefinitionError(\n            f\"{new_model.__name__} does not have database defined.\"\n        )\n    elif not new_model.ormar_config.abstract:\n        substitue_backend_pool_for_sqlite(new_model=new_model)\n\n    if new_model.ormar_config.metadata is None and not new_model.ormar_config.abstract:\n        raise ormar.ModelDefinitionError(\n            f\"{new_model.__name__} does not have metadata defined.\"\n        )\n</code></pre>"},{"location":"api/models/helpers/models/#ormar.models.helpers.models.config_field_not_set","title":"<code>config_field_not_set(model, field_name)</code>","text":"<p>Checks if field with given name is already present in model.OrmarConfig. Then check if it's set to something truthful (in practice meaning not None, as it's non or ormar Field only).</p> <p>:param model: newly constructed model :type model: Model class :param field_name: name of the ormar field :type field_name: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def config_field_not_set(model: Type[\"Model\"], field_name: str) -&gt; bool:\n    \"\"\"\n    Checks if field with given name is already present in model.OrmarConfig.\n    Then check if it's set to something truthful\n    (in practice meaning not None, as it's non or ormar Field only).\n\n    :param model: newly constructed model\n    :type model: Model class\n    :param field_name: name of the ormar field\n    :type field_name: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return not getattr(model.ormar_config, field_name)\n</code></pre>"},{"location":"api/models/helpers/models/#ormar.models.helpers.models.extract_annotations_and_default_vals","title":"<code>extract_annotations_and_default_vals(attrs)</code>","text":"<p>Extracts annotations from class namespace dict and triggers extraction of ormar model_fields.</p> <p>:param attrs: namespace of the class created :type attrs: Dict :return: namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict]</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def extract_annotations_and_default_vals(attrs: Dict) -&gt; Tuple[Dict, Dict]:\n    \"\"\"\n    Extracts annotations from class namespace dict and triggers\n    extraction of ormar model_fields.\n\n    :param attrs: namespace of the class created\n    :type attrs: Dict\n    :return: namespace of the class updated, dict of extracted model_fields\n    :rtype: Tuple[Dict, Dict]\n    \"\"\"\n    key = \"__annotations__\"\n    attrs[key] = attrs.get(key, {})\n    attrs, model_fields = populate_pydantic_default_values(attrs)\n    return attrs, model_fields\n</code></pre>"},{"location":"api/models/helpers/models/#ormar.models.helpers.models.group_related_list","title":"<code>group_related_list(list_)</code>","text":"<p>Translates the list of related strings into a dictionary. That way nested models are grouped to traverse them in a right order and to avoid repetition.</p> <p>Sample: [\"people__houses\", \"people__cars__models\", \"people__cars__colors\"] will become: {'people': {'houses': [], 'cars': ['models', 'colors']}}</p> <p>Result dictionary is sorted by length of the values and by key</p> <p>:param list_: list of related models used in select related :type list_: List[str] :return: list converted to dictionary to avoid repetition and group nested models :rtype: Dict[str, List]</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def group_related_list(list_: List) -&gt; Dict:\n    \"\"\"\n    Translates the list of related strings into a dictionary.\n    That way nested models are grouped to traverse them in a right order\n    and to avoid repetition.\n\n    Sample: [\"people__houses\", \"people__cars__models\", \"people__cars__colors\"]\n    will become:\n    {'people': {'houses': [], 'cars': ['models', 'colors']}}\n\n    Result dictionary is sorted by length of the values and by key\n\n    :param list_: list of related models used in select related\n    :type list_: List[str]\n    :return: list converted to dictionary to avoid repetition and group nested models\n    :rtype: Dict[str, List]\n    \"\"\"\n    result_dict: Dict[str, Any] = dict()\n    list_.sort(key=lambda x: x.split(\"__\")[0])\n    grouped = itertools.groupby(list_, key=lambda x: x.split(\"__\")[0])\n    for key, group in grouped:\n        group_list = list(group)\n        new = sorted(\n            [\"__\".join(x.split(\"__\")[1:]) for x in group_list if len(x.split(\"__\")) &gt; 1]\n        )\n        if any(\"__\" in x for x in new):\n            result_dict[key] = group_related_list(new)\n        else:\n            result_dict.setdefault(key, []).extend(new)\n    return dict(sorted(result_dict.items(), key=lambda item: len(item[1])))\n</code></pre>"},{"location":"api/models/helpers/models/#ormar.models.helpers.models.is_field_an_forward_ref","title":"<code>is_field_an_forward_ref(field)</code>","text":"<p>Checks if field is a relation field and whether any of the referenced models are ForwardRefs that needs to be updated before proceeding.</p> <p>:param field: model field to verify :type field: Type[BaseField] :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def is_field_an_forward_ref(field: \"BaseField\") -&gt; bool:\n    \"\"\"\n    Checks if field is a relation field and whether any of the referenced models\n    are ForwardRefs that needs to be updated before proceeding.\n\n    :param field: model field to verify\n    :type field: Type[BaseField]\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return field.is_relation and (\n        field.to.__class__ == ForwardRef or field.through.__class__ == ForwardRef\n    )\n</code></pre>"},{"location":"api/models/helpers/models/#ormar.models.helpers.models.populate_default_options_values","title":"<code>populate_default_options_values(new_model, model_fields)</code>","text":"<p>Sets all optional OrmarConfig values to its defaults and set model_fields that were already previously extracted.</p> <p>Here should live all options that are not overwritten/set for all models.</p> <p>Current options are: * constraints = [] * abstract = False</p> <p>:param new_model: newly constructed Model :type new_model: Model class :param model_fields: dict of model fields :type model_fields: Union[Dict[str, type], Dict]</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def populate_default_options_values(  # noqa: CCR001\n    new_model: Type[\"Model\"], model_fields: Dict\n) -&gt; None:\n    \"\"\"\n    Sets all optional OrmarConfig values to its defaults\n    and set model_fields that were already previously extracted.\n\n    Here should live all options that are not overwritten/set for all models.\n\n    Current options are:\n    * constraints = []\n    * abstract = False\n\n    :param new_model: newly constructed Model\n    :type new_model: Model class\n    :param model_fields: dict of model fields\n    :type model_fields: Union[Dict[str, type], Dict]\n    \"\"\"\n    new_model.ormar_config.model_fields.update(model_fields)\n    if any(is_field_an_forward_ref(field) for field in model_fields.values()):\n        new_model.ormar_config.requires_ref_update = True\n\n    new_model._json_fields = {\n        name for name, field in model_fields.items() if field.__type__ == pydantic.Json\n    }\n    new_model._bytes_fields = {\n        name for name, field in model_fields.items() if field.__type__ is bytes\n    }\n\n    new_model.__relation_map__ = None\n    new_model.__ormar_fields_validators__ = None\n</code></pre>"},{"location":"api/models/helpers/models/#ormar.models.helpers.models.substitue_backend_pool_for_sqlite","title":"<code>substitue_backend_pool_for_sqlite(new_model)</code>","text":"<p>Recreates Connection pool for sqlite3 with new factory that executes \"PRAGMA foreign_keys=1; on initialization to enable foreign keys.</p> <p>:param new_model: newly declared ormar Model :type new_model: Model class</p> Source code in <code>ormar/models/helpers/models.py</code> <pre><code>def substitue_backend_pool_for_sqlite(new_model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Recreates Connection pool for sqlite3 with new factory that\n    executes \"PRAGMA foreign_keys=1; on initialization to enable foreign keys.\n\n    :param new_model: newly declared ormar Model\n    :type new_model: Model class\n    \"\"\"\n    backend = new_model.ormar_config.database._backend\n    if (\n        backend._dialect.name == \"sqlite\" and \"factory\" not in backend._options\n    ):  # pragma: no cover\n        backend._options[\"factory\"] = Connection\n        old_pool = backend._pool\n        backend._pool = old_pool.__class__(backend._database_url, **backend._options)\n</code></pre>"},{"location":"api/models/helpers/pydantic/","title":"pydantic","text":""},{"location":"api/models/helpers/pydantic/#ormar.models.helpers.pydantic.create_pydantic_field","title":"<code>create_pydantic_field(field_name, model, model_field)</code>","text":"<p>Registers pydantic field on through model that leads to passed model and is registered as field_name passed.</p> <p>Through model is fetched from through attributed on passed model_field.</p> <p>:param field_name: field name to register :type field_name: str :param model: type of field to register :type model: Model class :param model_field: relation field from which through model is extracted :type model_field: ManyToManyField class</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def create_pydantic_field(\n    field_name: str, model: Type[\"Model\"], model_field: \"ManyToManyField\"\n) -&gt; None:\n    \"\"\"\n    Registers pydantic field on through model that leads to passed model\n    and is registered as field_name passed.\n\n    Through model is fetched from through attributed on passed model_field.\n\n    :param field_name: field name to register\n    :type field_name: str\n    :param model: type of field to register\n    :type model: Model class\n    :param model_field: relation field from which through model is extracted\n    :type model_field: ManyToManyField class\n    \"\"\"\n    model_field.through.model_fields[field_name] = FieldInfo.from_annotated_attribute(\n        annotation=Optional[model], default=None  # type: ignore\n    )\n    model_field.through.model_rebuild(force=True)\n</code></pre>"},{"location":"api/models/helpers/pydantic/#ormar.models.helpers.pydantic.get_potential_fields","title":"<code>get_potential_fields(attrs)</code>","text":"<p>Gets all the fields in current class namespace that are Fields.</p> <p>:param attrs: current class namespace :type attrs: Dict :return: extracted fields that are ormar Fields :rtype: Dict</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def get_potential_fields(attrs: Union[Dict, MappingProxyType]) -&gt; Dict:\n    \"\"\"\n    Gets all the fields in current class namespace that are Fields.\n\n    :param attrs: current class namespace\n    :type attrs: Dict\n    :return: extracted fields that are ormar Fields\n    :rtype: Dict\n    \"\"\"\n    return {\n        k: v\n        for k, v in attrs.items()\n        if (\n            (isinstance(v, type) and issubclass(v, BaseField))\n            or isinstance(v, BaseField)\n        )\n    }\n</code></pre>"},{"location":"api/models/helpers/pydantic/#ormar.models.helpers.pydantic.get_pydantic_base_orm_config","title":"<code>get_pydantic_base_orm_config()</code>","text":"<p>Returns empty pydantic Config with orm_mode set to True.</p> <p>:return: empty default config with orm_mode set. :rtype: pydantic Config</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def get_pydantic_base_orm_config() -&gt; pydantic.ConfigDict:\n    \"\"\"\n    Returns empty pydantic Config with orm_mode set to True.\n\n    :return: empty default config with orm_mode set.\n    :rtype: pydantic Config\n    \"\"\"\n\n    return ConfigDict(validate_assignment=True, ser_json_bytes=\"base64\")\n</code></pre>"},{"location":"api/models/helpers/pydantic/#ormar.models.helpers.pydantic.merge_or_generate_pydantic_config","title":"<code>merge_or_generate_pydantic_config(attrs, name)</code>","text":"<p>Checks if the user provided pydantic Config, and if he did merges it with the default one.</p> <p>Updates the attrs in place with a new config.</p> <p>:rtype: None</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def merge_or_generate_pydantic_config(attrs: Dict, name: str) -&gt; None:\n    \"\"\"\n    Checks if the user provided pydantic Config,\n    and if he did merges it with the default one.\n\n    Updates the attrs in place with a new config.\n\n    :rtype: None\n    \"\"\"\n    default_config = get_pydantic_base_orm_config()\n    if \"model_config\" in attrs:\n        provided_config = attrs[\"model_config\"]\n        if not isinstance(provided_config, dict):\n            raise ModelDefinitionError(\n                f\"Config provided for class {name} has to be a dictionary.\"\n            )\n\n        config = {**default_config, **provided_config}\n        attrs[\"model_config\"] = config\n    else:\n        attrs[\"model_config\"] = default_config\n</code></pre>"},{"location":"api/models/helpers/pydantic/#ormar.models.helpers.pydantic.populate_pydantic_default_values","title":"<code>populate_pydantic_default_values(attrs)</code>","text":"<p>Extracts ormar fields from annotations (deprecated) and from namespace dictionary of the class. Fields declared on model are all subclasses of the BaseField class.</p> <p>Trigger conversion of ormar field into pydantic FieldInfo, which has all needed parameters saved.</p> <p>Overwrites the annotations of ormar fields to corresponding types declared on ormar fields (constructed dynamically for relations). Those annotations are later used by pydantic to construct it's own fields.</p> <p>:param attrs: current class namespace :type attrs: Dict :return: namespace of the class updated, dict of extracted model_fields :rtype: Tuple[Dict, Dict]</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def populate_pydantic_default_values(attrs: Dict) -&gt; Tuple[Dict, Dict]:\n    \"\"\"\n    Extracts ormar fields from annotations (deprecated) and from namespace\n    dictionary of the class. Fields declared on model are all subclasses of the\n    BaseField class.\n\n    Trigger conversion of ormar field into pydantic FieldInfo, which has all needed\n    parameters saved.\n\n    Overwrites the annotations of ormar fields to corresponding types declared on\n    ormar fields (constructed dynamically for relations).\n    Those annotations are later used by pydantic to construct it's own fields.\n\n    :param attrs: current class namespace\n    :type attrs: Dict\n    :return: namespace of the class updated, dict of extracted model_fields\n    :rtype: Tuple[Dict, Dict]\n    \"\"\"\n    model_fields = {}\n    potential_fields = {}\n\n    potential_fields.update(get_potential_fields(attrs))\n    for field_name, field in potential_fields.items():\n        field.name = field_name\n        model_fields[field_name] = field\n        default_type = (\n            field.__type__ if not field.nullable else Optional[field.__type__]\n        )\n        overwrite_type = (\n            field.__pydantic_type__\n            if field.__type__ != field.__pydantic_type__\n            else None\n        )\n        attrs[\"__annotations__\"][field_name] = overwrite_type or default_type\n    return attrs, model_fields\n</code></pre>"},{"location":"api/models/helpers/pydantic/#ormar.models.helpers.pydantic.remove_excluded_parent_fields","title":"<code>remove_excluded_parent_fields(model)</code>","text":"<p>Removes pydantic fields that should be excluded from parent models</p> <p>:param model: :type model: Type[\"Model\"]</p> Source code in <code>ormar/models/helpers/pydantic.py</code> <pre><code>def remove_excluded_parent_fields(model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Removes pydantic fields that should be excluded from parent models\n\n    :param model:\n    :type model: Type[\"Model\"]\n    \"\"\"\n    excludes = {*model.ormar_config.exclude_parent_fields} - {\n        *model.ormar_config.model_fields.keys()\n    }\n    if excludes:\n        model.model_fields = {\n            k: v for k, v in model.model_fields.items() if k not in excludes\n        }\n        model.model_rebuild(force=True)\n</code></pre>"},{"location":"api/models/helpers/related_names_validation/","title":"related_names_validation","text":""},{"location":"api/models/helpers/related_names_validation/#ormar.models.helpers.related_names_validation.validate_related_names_in_relations","title":"<code>validate_related_names_in_relations(model_fields, new_model)</code>","text":"<p>Performs a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param (populated by default as model.name.lower()+'s'). Also related_names have to be unique for given related model.</p> <p>:raises ModelDefinitionError: if validation of related_names fail :param model_fields: dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] :param new_model: :type new_model: Model class</p> Source code in <code>ormar/models/helpers/related_names_validation.py</code> <pre><code>def validate_related_names_in_relations(  # noqa CCR001\n    model_fields: Dict, new_model: Type[\"Model\"]\n) -&gt; None:\n    \"\"\"\n    Performs a validation of relation_names in relation fields.\n    If multiple fields are leading to the same related model\n    only one can have empty related_name param\n    (populated by default as model.name.lower()+'s').\n    Also related_names have to be unique for given related model.\n\n    :raises ModelDefinitionError: if validation of related_names fail\n    :param model_fields: dictionary of declared ormar model fields\n    :type model_fields: Dict[str, ormar.Field]\n    :param new_model:\n    :type new_model: Model class\n    \"\"\"\n    already_registered: Dict[str, List[Optional[str]]] = dict()\n    for field in model_fields.values():\n        if field.is_relation:\n            to_name = (\n                field.to.get_name()\n                if not field.to.__class__ == ForwardRef\n                else str(field.to)\n            )\n            previous_related_names = already_registered.setdefault(to_name, [])\n            if field.related_name in previous_related_names:\n                raise ormar.ModelDefinitionError(\n                    f\"Multiple fields declared on {new_model.get_name(lower=False)} \"\n                    f\"model leading to {field.to.get_name(lower=False)} model without \"\n                    f\"related_name property set. \\nThere can be only one relation with \"\n                    f\"default/empty name: '{new_model.get_name() + 's'}'\"\n                    f\"\\nTip: provide different related_name for FK and/or M2M fields\"\n                )\n            previous_related_names.append(field.related_name)\n</code></pre>"},{"location":"api/models/helpers/relations/","title":"relations","text":""},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.expand_reverse_relationship","title":"<code>expand_reverse_relationship(model_field)</code>","text":"<p>If the reverse relation has not been set before it's set here.</p> <p>:param model_field: :type model_field: :return: None :rtype: None</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def expand_reverse_relationship(model_field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    If the reverse relation has not been set before it's set here.\n\n    :param model_field:\n    :type model_field:\n    :return: None\n    :rtype: None\n    \"\"\"\n    if reverse_field_not_already_registered(model_field=model_field):\n        register_reverse_model_fields(model_field=model_field)\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.expand_reverse_relationships","title":"<code>expand_reverse_relationships(model)</code>","text":"<p>Iterates through model_fields of given model and verifies if all reverse relation have been populated on related models.</p> <p>If the reverse relation has not been set before it's set here.</p> <p>:param model: model on which relation should be checked and registered :type model: Model class</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def expand_reverse_relationships(model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Iterates through model_fields of given model and verifies if all reverse\n    relation have been populated on related models.\n\n    If the reverse relation has not been set before it's set here.\n\n    :param model: model on which relation should be checked and registered\n    :type model: Model class\n    \"\"\"\n    model_fields = list(model.ormar_config.model_fields.values())\n    for model_field in model_fields:\n        if (\n            model_field.is_relation\n            and not model_field.has_unresolved_forward_refs()\n            and not model_field.is_through\n        ):\n            model_field = cast(\"ForeignKeyField\", model_field)\n            expand_reverse_relationship(model_field=model_field)\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.register_many_to_many_relation_on_build","title":"<code>register_many_to_many_relation_on_build(field)</code>","text":"<p>Registers connection between through model and both sides of the m2m relation. Registration include also reverse relation side to be able to join both sides.</p> <p>Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins.</p> <p>By default relation name is a model.name.lower().</p> <p>:param field: relation field :type field: ManyToManyField class</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def register_many_to_many_relation_on_build(field: \"ManyToManyField\") -&gt; None:\n    \"\"\"\n    Registers connection between through model and both sides of the m2m relation.\n    Registration include also reverse relation side to be able to join both sides.\n\n    Relation is registered by model name and relation field name to allow for multiple\n    relations between two Models that needs to have different\n    aliases for proper sql joins.\n\n    By default relation name is a model.name.lower().\n\n    :param field: relation field\n    :type field: ManyToManyField class\n    \"\"\"\n    alias_manager.add_relation_type(\n        source_model=field.through,\n        relation_name=field.default_source_field_name(),\n        reverse_name=field.get_source_related_name(),\n    )\n    alias_manager.add_relation_type(\n        source_model=field.through,\n        relation_name=field.default_target_field_name(),\n        reverse_name=field.get_related_name(),\n    )\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.register_relation_in_alias_manager","title":"<code>register_relation_in_alias_manager(field)</code>","text":"<p>Registers the relation (and reverse relation) in alias manager. The m2m relations require registration of through model between actual end models of the relation.</p> <p>Delegates the actual registration to: m2m - register_many_to_many_relation_on_build fk - register_relation_on_build</p> <p>:param field: relation field :type field: ForeignKey or ManyToManyField class</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def register_relation_in_alias_manager(field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    Registers the relation (and reverse relation) in alias manager.\n    The m2m relations require registration of through model between\n    actual end models of the relation.\n\n    Delegates the actual registration to:\n    m2m - register_many_to_many_relation_on_build\n    fk - register_relation_on_build\n\n    :param field: relation field\n    :type field: ForeignKey or ManyToManyField class\n    \"\"\"\n    if field.is_multi:\n        if field.has_unresolved_forward_refs():\n            return\n        field = cast(\"ManyToManyField\", field)\n        register_many_to_many_relation_on_build(field=field)\n    elif field.is_relation and not field.is_through:\n        if field.has_unresolved_forward_refs():\n            return\n        register_relation_on_build(field=field)\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.register_relation_on_build","title":"<code>register_relation_on_build(field)</code>","text":"<p>Registers ForeignKey relation in alias_manager to set a table_prefix. Registration include also reverse relation side to be able to join both sides.</p> <p>Relation is registered by model name and relation field name to allow for multiple relations between two Models that needs to have different aliases for proper sql joins.</p> <p>:param field: relation field :type field: ForeignKey class</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def register_relation_on_build(field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    Registers ForeignKey relation in alias_manager to set a table_prefix.\n    Registration include also reverse relation side to be able to join both sides.\n\n    Relation is registered by model name and relation field name to allow for multiple\n    relations between two Models that needs to have different\n    aliases for proper sql joins.\n\n    :param field: relation field\n    :type field: ForeignKey class\n    \"\"\"\n    alias_manager.add_relation_type(\n        source_model=field.owner,\n        relation_name=field.name,\n        reverse_name=field.get_source_related_name(),\n    )\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.register_reverse_model_fields","title":"<code>register_reverse_model_fields(model_field)</code>","text":"<p>Registers reverse ForeignKey field on related model. By default it's name.lower()+'s' of the model on which relation is defined.</p> <p>But if the related_model name is provided it's registered with that name. Autogenerated reverse fields also set related_name to the original field name.</p> <p>:param model_field: original relation ForeignKey field :type model_field: relation Field</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def register_reverse_model_fields(model_field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    Registers reverse ForeignKey field on related model.\n    By default it's name.lower()+'s' of the model on which relation is defined.\n\n    But if the related_model name is provided it's registered with that name.\n    Autogenerated reverse fields also set related_name to the original field name.\n\n    :param model_field: original relation ForeignKey field\n    :type model_field: relation Field\n    \"\"\"\n    related_name = model_field.get_related_name()\n    related_model_fields = model_field.to.ormar_config.model_fields\n    if model_field.is_multi:\n        related_model_fields[related_name] = ManyToMany(  # type: ignore\n            model_field.owner,\n            through=model_field.through,\n            name=related_name,\n            virtual=True,\n            related_name=model_field.name,\n            owner=model_field.to,\n            self_reference=model_field.self_reference,\n            self_reference_primary=model_field.self_reference_primary,\n            orders_by=model_field.related_orders_by,\n            skip_field=model_field.skip_reverse,\n            through_relation_name=model_field.through_reverse_relation_name,\n            through_reverse_relation_name=model_field.through_relation_name,\n        )\n        # register foreign keys on through model\n        model_field = cast(\"ManyToManyField\", model_field)\n        register_through_shortcut_fields(model_field=model_field)\n        adjust_through_many_to_many_model(model_field=model_field)\n    else:\n        related_model_fields[related_name] = ForeignKey(  # type: ignore\n            model_field.owner,\n            real_name=related_name,\n            virtual=True,\n            related_name=model_field.name,\n            owner=model_field.to,\n            self_reference=model_field.self_reference,\n            orders_by=model_field.related_orders_by,\n            skip_field=model_field.skip_reverse,\n        )\n    if not model_field.skip_reverse:\n        field_type = related_model_fields[related_name].__type__\n        field_type = replace_models_with_copy(\n            annotation=field_type, source_model_field=model_field.name\n        )\n        if not model_field.is_multi:\n            field_type = Union[field_type, List[field_type], None]  # type: ignore\n        model_field.to.model_fields[related_name] = FieldInfo.from_annotated_attribute(\n            annotation=field_type, default=None\n        )\n        add_field_serializer_for_reverse_relations(\n            to_model=model_field.to, related_name=related_name\n        )\n        model_field.to.model_rebuild(force=True)\n        setattr(model_field.to, related_name, RelationDescriptor(name=related_name))\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.register_through_shortcut_fields","title":"<code>register_through_shortcut_fields(model_field)</code>","text":"<p>Registers m2m relation through shortcut on both ends of the relation.</p> <p>:param model_field: relation field defined in parent model :type model_field: ManyToManyField</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def register_through_shortcut_fields(model_field: \"ManyToManyField\") -&gt; None:\n    \"\"\"\n    Registers m2m relation through shortcut on both ends of the relation.\n\n    :param model_field: relation field defined in parent model\n    :type model_field: ManyToManyField\n    \"\"\"\n    through_model = model_field.through\n    through_name = through_model.get_name(lower=True)\n    related_name = model_field.get_related_name()\n\n    model_field.owner.ormar_config.model_fields[through_name] = Through(\n        through_model,\n        real_name=through_name,\n        virtual=True,\n        related_name=model_field.name,\n        owner=model_field.owner,\n        nullable=True,\n    )\n\n    model_field.to.ormar_config.model_fields[through_name] = Through(\n        through_model,\n        real_name=through_name,\n        virtual=True,\n        related_name=related_name,\n        owner=model_field.to,\n        nullable=True,\n    )\n    setattr(model_field.owner, through_name, RelationDescriptor(name=through_name))\n    setattr(model_field.to, through_name, RelationDescriptor(name=through_name))\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.replace_models_with_copy","title":"<code>replace_models_with_copy(annotation, source_model_field=None)</code>","text":"<p>Replaces all models in annotation with their copies to avoid circular references.</p> <p>:param annotation: annotation to replace models in :type annotation: Type :return: annotation with replaced models :rtype: Type</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def replace_models_with_copy(\n    annotation: Type, source_model_field: Optional[str] = None\n) -&gt; Any:\n    \"\"\"\n    Replaces all models in annotation with their copies to avoid circular references.\n\n    :param annotation: annotation to replace models in\n    :type annotation: Type\n    :return: annotation with replaced models\n    :rtype: Type\n    \"\"\"\n    if inspect.isclass(annotation) and issubclass(annotation, ormar.Model):\n        return create_copy_to_avoid_circular_references(model=annotation)\n    elif hasattr(annotation, \"__origin__\") and annotation.__origin__ in {list, Union}:\n        if annotation.__origin__ is list:\n            return List[  # type: ignore\n                replace_models_with_copy(\n                    annotation=annotation.__args__[0],\n                    source_model_field=source_model_field,\n                )\n            ]\n        elif annotation.__origin__ == Union:\n            args = annotation.__args__\n            new_args = [\n                replace_models_with_copy(\n                    annotation=arg, source_model_field=source_model_field\n                )\n                for arg in args\n            ]\n            return Union[tuple(new_args)]\n    else:\n        return annotation\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.reverse_field_not_already_registered","title":"<code>reverse_field_not_already_registered(model_field)</code>","text":"<p>Checks if child is already registered in parents pydantic fields.</p> <p>:raises ModelDefinitionError: if related name is already used but lead to different related model :param model_field: original relation ForeignKey field :type model_field: relation Field :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def reverse_field_not_already_registered(model_field: \"ForeignKeyField\") -&gt; bool:\n    \"\"\"\n    Checks if child is already registered in parents pydantic fields.\n\n    :raises ModelDefinitionError: if related name is already used but lead to different\n    related model\n    :param model_field: original relation ForeignKey field\n    :type model_field: relation Field\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    related_name = model_field.get_related_name()\n    check_result = related_name not in model_field.to.ormar_config.model_fields\n    check_result2 = (\n        model_field.owner.get_name() not in model_field.to.ormar_config.model_fields\n    )\n\n    if not check_result:\n        verify_related_name_dont_duplicate(\n            related_name=related_name, model_field=model_field\n        )\n    if not check_result2:\n        verify_related_name_dont_duplicate(\n            related_name=model_field.owner.get_name(), model_field=model_field\n        )\n\n    return check_result and check_result2\n</code></pre>"},{"location":"api/models/helpers/relations/#ormar.models.helpers.relations.verify_related_name_dont_duplicate","title":"<code>verify_related_name_dont_duplicate(related_name, model_field)</code>","text":"<p>Verifies whether the used related_name (regardless of the fact if user defined or auto generated) is already used on related model, but is connected with other model than the one that we connect right now.</p> <p>:raises ModelDefinitionError: if name is already used but lead to different related model :param related_name: :type related_name: :param model_field: original relation ForeignKey field :type model_field: relation Field :return: None :rtype: None</p> Source code in <code>ormar/models/helpers/relations.py</code> <pre><code>def verify_related_name_dont_duplicate(\n    related_name: str, model_field: \"ForeignKeyField\"\n) -&gt; None:\n    \"\"\"\n    Verifies whether the used related_name (regardless of the fact if user defined or\n    auto generated) is already used on related model, but is connected with other model\n    than the one that we connect right now.\n\n    :raises ModelDefinitionError: if name is already used but lead to different related\n    model\n    :param related_name:\n    :type related_name:\n    :param model_field: original relation ForeignKey field\n    :type model_field: relation Field\n    :return: None\n    :rtype: None\n    \"\"\"\n    fk_field = model_field.to.ormar_config.model_fields.get(related_name)\n    if not fk_field:  # pragma: no cover\n        return\n    if (\n        fk_field.to != model_field.owner\n        and fk_field.to.ormar_config != model_field.owner.ormar_config\n    ):\n        raise ormar.ModelDefinitionError(\n            f\"Relation with related_name \"\n            f\"'{related_name}' \"\n            f\"leading to model \"\n            f\"{model_field.to.get_name(lower=False)} \"\n            f\"cannot be used on model \"\n            f\"{model_field.owner.get_name(lower=False)} \"\n            f\"because it's already used by model \"\n            f\"{fk_field.to.get_name(lower=False)}\"\n        )\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/","title":"sqlalchemy","text":""},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.adjust_through_many_to_many_model","title":"<code>adjust_through_many_to_many_model(model_field)</code>","text":"<p>Registers m2m relation on through model. Sets ormar.ForeignKey from through model to both child and parent models. Sets sqlalchemy.ForeignKey to both child and parent models. Sets pydantic fields with child and parent model types.</p> <p>:param model_field: relation field defined in parent model :type model_field: ManyToManyField</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def adjust_through_many_to_many_model(model_field: \"ManyToManyField\") -&gt; None:\n    \"\"\"\n    Registers m2m relation on through model.\n    Sets ormar.ForeignKey from through model to both child and parent models.\n    Sets sqlalchemy.ForeignKey to both child and parent models.\n    Sets pydantic fields with child and parent model types.\n\n    :param model_field: relation field defined in parent model\n    :type model_field: ManyToManyField\n    \"\"\"\n    parent_name = model_field.default_target_field_name()\n    child_name = model_field.default_source_field_name()\n    model_fields = model_field.through.ormar_config.model_fields\n    model_fields[parent_name] = ormar.ForeignKey(  # type: ignore\n        model_field.to,\n        real_name=parent_name,\n        ondelete=\"CASCADE\",\n        owner=model_field.through,\n    )\n\n    model_fields[child_name] = ormar.ForeignKey(  # type: ignore\n        model_field.owner,\n        real_name=child_name,\n        ondelete=\"CASCADE\",\n        owner=model_field.through,\n    )\n\n    create_and_append_m2m_fk(\n        model=model_field.to, model_field=model_field, field_name=parent_name\n    )\n    create_and_append_m2m_fk(\n        model=model_field.owner, model_field=model_field, field_name=child_name\n    )\n\n    create_pydantic_field(parent_name, model_field.to, model_field)\n    create_pydantic_field(child_name, model_field.owner, model_field)\n\n    setattr(model_field.through, parent_name, RelationDescriptor(name=parent_name))\n    setattr(model_field.through, child_name, RelationDescriptor(name=child_name))\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.check_for_null_type_columns_from_forward_refs","title":"<code>check_for_null_type_columns_from_forward_refs(config)</code>","text":"<p>Check is any column is of NUllType() meaning it's empty column from ForwardRef</p> <p>:param config: OrmarConfig of the Model without sqlalchemy table constructed :type config: Model class OrmarConfig :return: result of the check :rtype: bool</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def check_for_null_type_columns_from_forward_refs(config: \"OrmarConfig\") -&gt; bool:\n    \"\"\"\n    Check is any column is of NUllType() meaning it's empty column from ForwardRef\n\n    :param config: OrmarConfig of the Model without sqlalchemy table constructed\n    :type config: Model class OrmarConfig\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return not any(\n        isinstance(col.type, sqlalchemy.sql.sqltypes.NullType) for col in config.columns\n    )\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.check_pk_column_validity","title":"<code>check_pk_column_validity(field_name, field, pkname)</code>","text":"<p>Receives the field marked as primary key and verifies if the pkname was not already set (only one allowed per model).</p> <p>:raises ModelDefintionError: if pkname already set :param field_name: name of field :type field_name: str :param field: ormar.Field :type field: BaseField :param pkname: already set pkname :type pkname: Optional[str] :return: name of the field that should be set as pkname :rtype: str</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def check_pk_column_validity(\n    field_name: str, field: \"BaseField\", pkname: Optional[str]\n) -&gt; Optional[str]:\n    \"\"\"\n    Receives the field marked as primary key and verifies if the pkname\n    was not already set (only one allowed per model).\n\n    :raises ModelDefintionError: if pkname already set\n    :param field_name: name of field\n    :type field_name: str\n    :param field: ormar.Field\n    :type field: BaseField\n    :param pkname: already set pkname\n    :type pkname: Optional[str]\n    :return: name of the field that should be set as pkname\n    :rtype: str\n    \"\"\"\n    if pkname is not None:\n        raise ormar.ModelDefinitionError(\"Only one primary key column is allowed.\")\n    return field_name\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.create_and_append_m2m_fk","title":"<code>create_and_append_m2m_fk(model, model_field, field_name)</code>","text":"<p>Registers sqlalchemy Column with sqlalchemy.ForeignKey leading to the model.</p> <p>Newly created field is added to m2m relation through model OrmarConfig columns and table.</p> <p>:param field_name: name of the column to create :type field_name: str :param model: Model class to which FK should be created :type model: Model class :param model_field: field with ManyToMany relation :type model_field: ManyToManyField field</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def create_and_append_m2m_fk(\n    model: Type[\"Model\"], model_field: \"ManyToManyField\", field_name: str\n) -&gt; None:\n    \"\"\"\n    Registers sqlalchemy Column with sqlalchemy.ForeignKey leading to the model.\n\n    Newly created field is added to m2m relation\n    through model OrmarConfig columns and table.\n\n    :param field_name: name of the column to create\n    :type field_name: str\n    :param model: Model class to which FK should be created\n    :type model: Model class\n    :param model_field: field with ManyToMany relation\n    :type model_field: ManyToManyField field\n    \"\"\"\n    pk_alias = model.get_column_alias(model.ormar_config.pkname)\n    pk_column = next(\n        (col for col in model.ormar_config.columns if col.name == pk_alias), None\n    )\n    if pk_column is None:  # pragma: no cover\n        raise ormar.ModelDefinitionError(\n            \"ManyToMany relation cannot lead to field without pk\"\n        )\n    column = sqlalchemy.Column(\n        field_name,\n        pk_column.type,\n        sqlalchemy.schema.ForeignKey(\n            model.ormar_config.tablename + \".\" + pk_alias,\n            ondelete=\"CASCADE\",\n            onupdate=\"CASCADE\",\n            name=f\"fk_{model_field.through.ormar_config.tablename}_{model.ormar_config.tablename}\"\n            f\"_{field_name}_{pk_alias}\",\n        ),\n    )\n    model_field.through.ormar_config.columns.append(column)\n    model_field.through.ormar_config.table.append_column(column)\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.populate_config_sqlalchemy_table_if_required","title":"<code>populate_config_sqlalchemy_table_if_required(config)</code>","text":"<p>Constructs sqlalchemy table out of columns and parameters set on OrmarConfig. It populates name, metadata, columns and constraints.</p> <p>:param config: OrmarConfig of the Model without sqlalchemy table constructed :type config: Model class OrmarConfig</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def populate_config_sqlalchemy_table_if_required(config: \"OrmarConfig\") -&gt; None:\n    \"\"\"\n    Constructs sqlalchemy table out of columns and parameters set on OrmarConfig.\n    It populates name, metadata, columns and constraints.\n\n    :param config: OrmarConfig of the Model without sqlalchemy table constructed\n    :type config: Model class OrmarConfig\n    \"\"\"\n    if config.table is None and check_for_null_type_columns_from_forward_refs(\n        config=config\n    ):\n        set_constraint_names(config=config)\n        table = sqlalchemy.Table(\n            config.tablename, config.metadata, *config.columns, *config.constraints\n        )\n        config.table = table\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.populate_config_tablename_columns_and_pk","title":"<code>populate_config_tablename_columns_and_pk(name, new_model)</code>","text":"<p>Sets Model tablename if it's not already set in OrmarConfig. Default tablename if not present is class name lower + s (i.e. Bed becomes -&gt; beds)</p> <p>Checks if Model's OrmarConfig have pkname and columns set. If not calls the sqlalchemy_columns_from_model_fields to populate columns from ormar.fields definitions.</p> <p>:raises ModelDefinitionError: if pkname is not present raises ModelDefinitionError. Each model has to have pk.</p> <p>:param name: name of the current Model :type name: str :param new_model: currently constructed Model :type new_model: ormar.models.metaclass.ModelMetaclass :return: Model with populated pkname and columns in OrmarConfig :rtype: ormar.models.metaclass.ModelMetaclass</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def populate_config_tablename_columns_and_pk(\n    name: str, new_model: Type[\"Model\"]\n) -&gt; Type[\"Model\"]:\n    \"\"\"\n    Sets Model tablename if it's not already set in OrmarConfig.\n    Default tablename if not present is class name lower + s (i.e. Bed becomes -&gt; beds)\n\n    Checks if Model's OrmarConfig have pkname and columns set.\n    If not calls the sqlalchemy_columns_from_model_fields to populate\n    columns from ormar.fields definitions.\n\n    :raises ModelDefinitionError: if pkname is not present raises ModelDefinitionError.\n    Each model has to have pk.\n\n    :param name: name of the current Model\n    :type name: str\n    :param new_model: currently constructed Model\n    :type new_model: ormar.models.metaclass.ModelMetaclass\n    :return: Model with populated pkname and columns in OrmarConfig\n    :rtype: ormar.models.metaclass.ModelMetaclass\n    \"\"\"\n    tablename = name.lower() + \"s\"\n    new_model.ormar_config.tablename = (\n        new_model.ormar_config.tablename\n        if new_model.ormar_config.tablename\n        else tablename\n    )\n    pkname: Optional[str]\n\n    if new_model.ormar_config.columns:\n        columns = new_model.ormar_config.columns\n        pkname = new_model.ormar_config.pkname\n    else:\n        pkname, columns = sqlalchemy_columns_from_model_fields(\n            new_model.ormar_config.model_fields, new_model\n        )\n\n    if pkname is None:\n        raise ormar.ModelDefinitionError(\"Table has to have a primary key.\")\n\n    new_model.ormar_config.columns = columns\n    new_model.ormar_config.pkname = pkname\n    if not new_model.ormar_config.orders_by:\n        # by default, we sort by pk name if other option not provided\n        new_model.ormar_config.orders_by.append(pkname)\n    return new_model\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.set_constraint_names","title":"<code>set_constraint_names(config)</code>","text":"<p>Populates the names on IndexColumns and UniqueColumns and CheckColumns constraints.</p> <p>:param config: OrmarConfig of the Model without sqlalchemy table constructed :type config: Model class OrmarConfig</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def set_constraint_names(config: \"OrmarConfig\") -&gt; None:\n    \"\"\"\n    Populates the names on IndexColumns and UniqueColumns and CheckColumns constraints.\n\n    :param config: OrmarConfig of the Model without sqlalchemy table constructed\n    :type config: Model class OrmarConfig\n    \"\"\"\n    for constraint in config.constraints:\n        if isinstance(constraint, sqlalchemy.UniqueConstraint) and not constraint.name:\n            constraint.name = (\n                f\"uc_{config.tablename}_\"\n                f'{\"_\".join([str(col) for col in constraint._pending_colargs])}'\n            )\n        elif (\n            isinstance(constraint, sqlalchemy.Index)\n            and constraint.name == \"TEMPORARY_NAME\"\n        ):\n            constraint.name = (\n                f\"ix_{config.tablename}_\"\n                f'{\"_\".join([col for col in constraint._pending_colargs])}'\n            )\n        elif isinstance(constraint, sqlalchemy.CheckConstraint) and not constraint.name:\n            sql_condition: str = str(constraint.sqltext).replace(\" \", \"_\")\n            constraint.name = f\"check_{config.tablename}_{sql_condition}\"\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.sqlalchemy_columns_from_model_fields","title":"<code>sqlalchemy_columns_from_model_fields(model_fields, new_model)</code>","text":"<p>Iterates over declared on Model model fields and extracts fields that should be treated as database fields.</p> <p>If the model is empty it sets mandatory id field as primary key (used in through models in m2m relations).</p> <p>Triggers a validation of relation_names in relation fields. If multiple fields are leading to the same related model only one can have empty related_name param. Also related_names have to be unique.</p> <p>Trigger validation of primary_key - only one and required pk can be set</p> <p>Sets <code>owner</code> on each model_field as reference to newly created Model.</p> <p>:raises ModelDefinitionError: if validation of related_names fail, or pkname validation fails. :param model_fields: dictionary of declared ormar model fields :type model_fields: Dict[str, ormar.Field] :param new_model: :type new_model: Model class :return: pkname, list of sqlalchemy columns :rtype: Tuple[Optional[str], List[sqlalchemy.Column]]</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def sqlalchemy_columns_from_model_fields(\n    model_fields: Dict, new_model: Type[\"Model\"]\n) -&gt; Tuple[Optional[str], List[sqlalchemy.Column]]:\n    \"\"\"\n    Iterates over declared on Model model fields and extracts fields that\n    should be treated as database fields.\n\n    If the model is empty it sets mandatory id field as primary key\n    (used in through models in m2m relations).\n\n    Triggers a validation of relation_names in relation fields. If multiple fields\n    are leading to the same related model only one can have empty related_name param.\n    Also related_names have to be unique.\n\n    Trigger validation of primary_key - only one and required pk can be set\n\n    Sets `owner` on each model_field as reference to newly created Model.\n\n    :raises ModelDefinitionError: if validation of related_names fail,\n    or pkname validation fails.\n    :param model_fields: dictionary of declared ormar model fields\n    :type model_fields: Dict[str, ormar.Field]\n    :param new_model:\n    :type new_model: Model class\n    :return: pkname, list of sqlalchemy columns\n    :rtype: Tuple[Optional[str], List[sqlalchemy.Column]]\n    \"\"\"\n    if len(model_fields.keys()) == 0:\n        model_fields[\"id\"] = ormar.Integer(name=\"id\", primary_key=True)\n        logging.warning(\n            f\"Table {new_model.ormar_config.tablename} had no fields so auto \"\n            \"Integer primary key named `id` created.\"\n        )\n    validate_related_names_in_relations(model_fields, new_model)\n    return _process_fields(model_fields=model_fields, new_model=new_model)\n</code></pre>"},{"location":"api/models/helpers/sqlalchemy/#ormar.models.helpers.sqlalchemy.update_column_definition","title":"<code>update_column_definition(model, field)</code>","text":"<p>Updates a column with a new type column based on updated parameters in FK fields.</p> <p>:param model: model on which columns needs to be updated :type model: Type[\"Model\"] :param field: field with column definition that requires update :type field: ForeignKeyField :return: None :rtype: None</p> Source code in <code>ormar/models/helpers/sqlalchemy.py</code> <pre><code>def update_column_definition(\n    model: Union[Type[\"Model\"], Type[\"NewBaseModel\"]], field: \"ForeignKeyField\"\n) -&gt; None:\n    \"\"\"\n    Updates a column with a new type column based on updated parameters in FK fields.\n\n    :param model: model on which columns needs to be updated\n    :type model: Type[\"Model\"]\n    :param field: field with column definition that requires update\n    :type field: ForeignKeyField\n    :return: None\n    :rtype: None\n    \"\"\"\n    columns = model.ormar_config.columns\n    for ind, column in enumerate(columns):\n        if column.name == field.get_alias():\n            new_column = field.get_column(field.get_alias())\n            columns[ind] = new_column\n            break\n</code></pre>"},{"location":"api/models/helpers/validation/","title":"validation","text":""},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.construct_schema_function","title":"<code>construct_schema_function()</code>","text":"<p>Modifies model example and description if needed.</p> <p>Note that schema extra has to be a function, otherwise it's called to soon before all the relations are expanded.</p> <p>:return: callable that will be run by pydantic to modify the schema :rtype: Callable</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def construct_schema_function() -&gt; Callable:\n    \"\"\"\n    Modifies model example and description if needed.\n\n    Note that schema extra has to be a function, otherwise it's called to soon\n    before all the relations are expanded.\n\n    :return: callable that will be run by pydantic to modify the schema\n    :rtype: Callable\n    \"\"\"\n\n    def schema_extra(schema: Dict[str, Any], model: Type[\"Model\"]) -&gt; None:\n        overwrite_example_and_description(schema=schema, model=model)\n        overwrite_binary_format(schema=schema, model=model)\n\n    return staticmethod(schema_extra)  # type: ignore\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.generate_example_for_nested_types","title":"<code>generate_example_for_nested_types(type_)</code>","text":"<p>Process nested types like Union[X, Y] or List[X]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def generate_example_for_nested_types(type_: Any) -&gt; Any:\n    \"\"\"\n    Process nested types like Union[X, Y] or List[X]\n    \"\"\"\n    if type_.__origin__ == Union:\n        return generate_example_for_union(type_=type_)\n    if type_.__origin__ is list:\n        return [get_pydantic_example_repr(type_.__args__[0])]\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.generate_example_for_union","title":"<code>generate_example_for_union(type_)</code>","text":"<p>Generates a pydantic example for Union[X, Y, ...]. Note that Optional can also be set as Union[X, None]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def generate_example_for_union(type_: Any) -&gt; Any:\n    \"\"\"\n    Generates a pydantic example for Union[X, Y, ...].\n    Note that Optional can also be set as Union[X, None]\n    \"\"\"\n    values = tuple(\n        get_pydantic_example_repr(x) for x in type_.__args__ if x is not type(None)\n    )\n    return values[0] if len(values) == 1 else values\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.generate_model_example","title":"<code>generate_model_example(model, relation_map=None)</code>","text":"<p>Generates example to be included in schema in fastapi.</p> <p>:param model: ormar.Model :type model: Type[\"Model\"] :param relation_map: dict with relations to follow :type relation_map: Optional[Dict] :return: dict with example values :rtype: Dict[str, int]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def generate_model_example(\n    model: Type[\"Model\"], relation_map: Optional[Dict] = None\n) -&gt; Dict:\n    \"\"\"\n    Generates example to be included in schema in fastapi.\n\n    :param model: ormar.Model\n    :type model: Type[\"Model\"]\n    :param relation_map: dict with relations to follow\n    :type relation_map: Optional[Dict]\n    :return: dict with example values\n    :rtype: Dict[str, int]\n    \"\"\"\n    example: Dict[str, Any] = dict()\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(model._iterate_related_models())\n    )\n    for name, field in model.ormar_config.model_fields.items():\n        populates_sample_fields_values(\n            example=example, name=name, field=field, relation_map=relation_map\n        )\n    to_exclude = {name for name in model.ormar_config.model_fields}\n    pydantic_repr = generate_pydantic_example(pydantic_model=model, exclude=to_exclude)\n    example.update(pydantic_repr)\n\n    return example\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.generate_pydantic_example","title":"<code>generate_pydantic_example(pydantic_model, exclude=None)</code>","text":"<p>Generates dict with example.</p> <p>:param pydantic_model: model to parse :type pydantic_model: Type[pydantic.BaseModel] :param exclude: list of fields to exclude :type exclude: Optional[Set] :return: dict with fields and sample values :rtype: Dict</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def generate_pydantic_example(\n    pydantic_model: Type[pydantic.BaseModel], exclude: Optional[Set] = None\n) -&gt; Dict:\n    \"\"\"\n    Generates dict with example.\n\n    :param pydantic_model: model to parse\n    :type pydantic_model: Type[pydantic.BaseModel]\n    :param exclude: list of fields to exclude\n    :type exclude: Optional[Set]\n    :return: dict with fields and sample values\n    :rtype: Dict\n    \"\"\"\n    example: Dict[str, Any] = dict()\n    exclude = exclude or set()\n    name_to_check = [\n        name for name in pydantic_model.model_fields if name not in exclude\n    ]\n    for name in name_to_check:\n        field = pydantic_model.model_fields[name]\n        type_ = field.annotation\n        example[name] = get_pydantic_example_repr(type_)\n    return example\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.get_nested_model_example","title":"<code>get_nested_model_example(name, field, relation_map)</code>","text":"<p>Gets representation of nested model.</p> <p>:param name: name of the field to follow :type name: str :param field: ormar field :type field: BaseField :param relation_map: dict with relation map :type relation_map: Dict :return: nested model or list of nested model repr :rtype: Union[List, Dict]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def get_nested_model_example(\n    name: str, field: \"BaseField\", relation_map: Dict\n) -&gt; Union[List, Dict]:\n    \"\"\"\n    Gets representation of nested model.\n\n    :param name: name of the field to follow\n    :type name: str\n    :param field: ormar field\n    :type field: BaseField\n    :param relation_map: dict with relation map\n    :type relation_map: Dict\n    :return: nested model or list of nested model repr\n    :rtype: Union[List, Dict]\n    \"\"\"\n    value = generate_model_example(field.to, relation_map=relation_map.get(name, {}))\n    new_value: Union[List, Dict] = [value] if field.is_multi or field.virtual else value\n    return new_value\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.get_pydantic_example_repr","title":"<code>get_pydantic_example_repr(type_)</code>","text":"<p>Gets sample representation of pydantic field for example dict.</p> <p>:param type_: type of pydantic field :type type_: Any :return: representation to include in example :rtype: Any</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def get_pydantic_example_repr(type_: Any) -&gt; Any:\n    \"\"\"\n    Gets sample representation of pydantic field for example dict.\n\n    :param type_: type of pydantic field\n    :type type_: Any\n    :return: representation to include in example\n    :rtype: Any\n    \"\"\"\n    if hasattr(type_, \"__origin__\"):\n        return generate_example_for_nested_types(type_)\n    if issubclass(type_, (numbers.Number, decimal.Decimal)):\n        return 0\n    if issubclass(type_, pydantic.BaseModel):\n        return generate_pydantic_example(pydantic_model=type_)\n    return \"string\"\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.modify_schema_example","title":"<code>modify_schema_example(model)</code>","text":"<p>Modifies the schema example in openapi schema.</p> <p>:param model: newly constructed Model :type model: Model class</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def modify_schema_example(model: Type[\"Model\"]) -&gt; None:  # noqa CCR001\n    \"\"\"\n    Modifies the schema example in openapi schema.\n\n    :param model: newly constructed Model\n    :type model: Model class\n    \"\"\"\n    if not config_field_not_set(model=model, field_name=\"model_fields\"):\n        model.model_config[\"json_schema_extra\"] = construct_schema_function()\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.overwrite_binary_format","title":"<code>overwrite_binary_format(schema, model)</code>","text":"<p>Overwrites format of the field if it's a LargeBinary field with a flag to represent the field as base64 encoded string.</p> <p>:param schema: schema of current model :type schema: Dict[str, Any] :param model: model class :type model: Type[\"Model\"]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def overwrite_binary_format(schema: Dict[str, Any], model: Type[\"Model\"]) -&gt; None:\n    \"\"\"\n    Overwrites format of the field if it's a LargeBinary field with\n    a flag to represent the field as base64 encoded string.\n\n    :param schema: schema of current model\n    :type schema: Dict[str, Any]\n    :param model: model class\n    :type model: Type[\"Model\"]\n    \"\"\"\n    for field_id, prop in schema.get(\"properties\", {}).items():\n        if (\n            field_id in model._bytes_fields\n            and model.ormar_config.model_fields[field_id].represent_as_base64_str\n        ):\n            prop[\"format\"] = \"base64\"\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.overwrite_example_and_description","title":"<code>overwrite_example_and_description(schema, model)</code>","text":"<p>Overwrites the example with properly nested children models. Overwrites the description if it's taken from ormar.Model.</p> <p>:param schema: schema of current model :type schema: Dict[str, Any] :param model: model class :type model: Type[\"Model\"]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def overwrite_example_and_description(\n    schema: Dict[str, Any], model: Type[\"Model\"]\n) -&gt; None:\n    \"\"\"\n    Overwrites the example with properly nested children models.\n    Overwrites the description if it's taken from ormar.Model.\n\n    :param schema: schema of current model\n    :type schema: Dict[str, Any]\n    :param model: model class\n    :type model: Type[\"Model\"]\n    \"\"\"\n    schema[\"example\"] = generate_model_example(model=model)\n</code></pre>"},{"location":"api/models/helpers/validation/#ormar.models.helpers.validation.populates_sample_fields_values","title":"<code>populates_sample_fields_values(example, name, field, relation_map=None)</code>","text":"<p>Iterates the field and sets fields to sample values</p> <p>:param field: ormar field :type field: BaseField :param name: name of the field :type name: str :param example: example dict :type example: Dict[str, Any] :param relation_map: dict with relations to follow :type relation_map: Optional[Dict]</p> Source code in <code>ormar/models/helpers/validation.py</code> <pre><code>def populates_sample_fields_values(\n    example: Dict[str, Any],\n    name: str,\n    field: \"BaseField\",\n    relation_map: Optional[Dict] = None,\n) -&gt; None:\n    \"\"\"\n    Iterates the field and sets fields to sample values\n\n    :param field: ormar field\n    :type field: BaseField\n    :param name: name of the field\n    :type name: str\n    :param example: example dict\n    :type example: Dict[str, Any]\n    :param relation_map: dict with relations to follow\n    :type relation_map: Optional[Dict]\n    \"\"\"\n    if not field.is_relation:\n        is_bytes_str = field.__type__ is bytes and field.represent_as_base64_str\n        example[name] = field.__sample__ if not is_bytes_str else \"string\"\n    elif isinstance(relation_map, dict) and name in relation_map:\n        example[name] = get_nested_model_example(\n            name=name, field=field, relation_map=relation_map\n        )\n</code></pre>"},{"location":"api/models/mixins/","title":"mixins","text":"<p>Package contains functionalities divided by features. All mixins are combined into ModelTableProxy which is one of the parents of Model. The split into mixins was done to ease the maintainability of the proxy class, as it became quite complicated over time.</p>"},{"location":"api/models/mixins/#ormar.models.mixins.AliasMixin","title":"<code>AliasMixin</code>","text":"<p>Used to translate field names into database column names.</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>class AliasMixin:\n    \"\"\"\n    Used to translate field names into database column names.\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma: no cover\n        from ormar.models.ormar_config import OrmarConfig\n\n        ormar_config: OrmarConfig\n\n    @classmethod\n    def get_column_alias(cls, field_name: str) -&gt; str:\n        \"\"\"\n        Returns db alias (column name in db) for given ormar field.\n        For fields without alias field name is returned.\n        :param field_name: name of the field to get alias from\n        :type field_name: str\n        :return: alias (db name) if set, otherwise passed name\n        :rtype: str\n        \"\"\"\n        field = cls.ormar_config.model_fields.get(field_name)\n        return field.get_alias() if field is not None else field_name\n\n    @classmethod\n    def get_column_name_from_alias(cls, alias: str) -&gt; str:\n        \"\"\"\n        Returns ormar field name for given db alias (column name in db).\n        If field do not have alias it's returned as is.\n        :param alias:\n        :type alias: str\n        :return: field name if set, otherwise passed alias (db name)\n        :rtype: str\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field.get_alias() == alias:\n                return field_name\n        return alias  # if not found it's not an alias but actual name\n\n    @classmethod\n    def translate_columns_to_aliases(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Translates dictionary of model fields changing field names into aliases.\n        If field has no alias the field name remains intact.\n        Only fields present in the dictionary are translated.\n        :param new_kwargs: dict with fields names and their values\n        :type new_kwargs: Dict\n        :return: dict with aliases and their values\n        :rtype: Dict\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field_name in new_kwargs:\n                new_kwargs[field.get_alias()] = new_kwargs.pop(field_name)\n        return new_kwargs\n\n    @classmethod\n    def translate_aliases_to_columns(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Translates dictionary of model fields changing aliases into field names.\n        If field has no alias the alias is already a field name.\n        Only fields present in the dictionary are translated.\n        :param new_kwargs: dict with aliases and their values\n        :type new_kwargs: Dict\n        :return: dict with fields names and their values\n        :rtype: Dict\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field.get_alias() and field.get_alias() in new_kwargs:\n                new_kwargs[field_name] = new_kwargs.pop(field.get_alias())\n        return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.AliasMixin.get_column_alias","title":"<code>get_column_alias(field_name)</code>  <code>classmethod</code>","text":"<p>Returns db alias (column name in db) for given ormar field. For fields without alias field name is returned. :param field_name: name of the field to get alias from :type field_name: str :return: alias (db name) if set, otherwise passed name :rtype: str</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef get_column_alias(cls, field_name: str) -&gt; str:\n    \"\"\"\n    Returns db alias (column name in db) for given ormar field.\n    For fields without alias field name is returned.\n    :param field_name: name of the field to get alias from\n    :type field_name: str\n    :return: alias (db name) if set, otherwise passed name\n    :rtype: str\n    \"\"\"\n    field = cls.ormar_config.model_fields.get(field_name)\n    return field.get_alias() if field is not None else field_name\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.AliasMixin.get_column_name_from_alias","title":"<code>get_column_name_from_alias(alias)</code>  <code>classmethod</code>","text":"<p>Returns ormar field name for given db alias (column name in db). If field do not have alias it's returned as is. :param alias: :type alias: str :return: field name if set, otherwise passed alias (db name) :rtype: str</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef get_column_name_from_alias(cls, alias: str) -&gt; str:\n    \"\"\"\n    Returns ormar field name for given db alias (column name in db).\n    If field do not have alias it's returned as is.\n    :param alias:\n    :type alias: str\n    :return: field name if set, otherwise passed alias (db name)\n    :rtype: str\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field.get_alias() == alias:\n            return field_name\n    return alias  # if not found it's not an alias but actual name\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.AliasMixin.translate_aliases_to_columns","title":"<code>translate_aliases_to_columns(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Translates dictionary of model fields changing aliases into field names. If field has no alias the alias is already a field name. Only fields present in the dictionary are translated. :param new_kwargs: dict with aliases and their values :type new_kwargs: Dict :return: dict with fields names and their values :rtype: Dict</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef translate_aliases_to_columns(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Translates dictionary of model fields changing aliases into field names.\n    If field has no alias the alias is already a field name.\n    Only fields present in the dictionary are translated.\n    :param new_kwargs: dict with aliases and their values\n    :type new_kwargs: Dict\n    :return: dict with fields names and their values\n    :rtype: Dict\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field.get_alias() and field.get_alias() in new_kwargs:\n            new_kwargs[field_name] = new_kwargs.pop(field.get_alias())\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.AliasMixin.translate_columns_to_aliases","title":"<code>translate_columns_to_aliases(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Translates dictionary of model fields changing field names into aliases. If field has no alias the field name remains intact. Only fields present in the dictionary are translated. :param new_kwargs: dict with fields names and their values :type new_kwargs: Dict :return: dict with aliases and their values :rtype: Dict</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef translate_columns_to_aliases(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Translates dictionary of model fields changing field names into aliases.\n    If field has no alias the field name remains intact.\n    Only fields present in the dictionary are translated.\n    :param new_kwargs: dict with fields names and their values\n    :type new_kwargs: Dict\n    :return: dict with aliases and their values\n    :rtype: Dict\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field_name in new_kwargs:\n            new_kwargs[field.get_alias()] = new_kwargs.pop(field_name)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.ExcludableMixin","title":"<code>ExcludableMixin</code>","text":"<p>               Bases: <code>RelationMixin</code></p> <p>Used to include/exclude given set of fields on models during load and dict() calls.</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>class ExcludableMixin(RelationMixin):\n    \"\"\"\n    Used to include/exclude given set of fields on models during load and dict() calls.\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma: no cover\n        from ormar import Model\n        from ormar.models import ModelRow\n\n    @staticmethod\n    def get_child(\n        items: Union[Set, Dict, None], key: Optional[str] = None\n    ) -&gt; Union[Set, Dict, None]:\n        \"\"\"\n        Used to get nested dictionaries keys if they exists otherwise returns\n        passed items.\n        :param items: bag of items to include or exclude\n        :type items:  Union[Set, Dict, None]\n        :param key: name of the child to extract\n        :type key: str\n        :return: child extracted from items if exists\n        :rtype: Union[Set, Dict, None]\n        \"\"\"\n        if isinstance(items, dict):\n            return items.get(key, {})\n        return items\n\n    @staticmethod\n    def _populate_pk_column(\n        model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n        columns: List[str],\n        use_alias: bool = False,\n    ) -&gt; List[str]:\n        \"\"\"\n        Adds primary key column/alias (depends on use_alias flag) to list of\n        column names that are selected.\n\n        :param model: model on columns are selected\n        :type model: Type[\"Model\"]\n        :param columns: list of columns names\n        :type columns: List[str]\n        :param use_alias: flag to set if aliases or field names should be used\n        :type use_alias: bool\n        :return: list of columns names with pk column in it\n        :rtype: List[str]\n        \"\"\"\n        pk_alias = (\n            model.get_column_alias(model.ormar_config.pkname)\n            if use_alias\n            else model.ormar_config.pkname\n        )\n        if pk_alias not in columns:\n            columns.append(pk_alias)\n        return columns\n\n    @classmethod\n    def own_table_columns(\n        cls,\n        model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n        excludable: ExcludableItems,\n        alias: str = \"\",\n        use_alias: bool = False,\n        add_pk_columns: bool = True,\n    ) -&gt; List[str]:\n        \"\"\"\n        Returns list of aliases or field names for given model.\n        Aliases/names switch is use_alias flag.\n\n        If provided only fields included in fields will be returned.\n        If provided fields in exclude_fields will be excluded in return.\n\n        Primary key field is always added and cannot be excluded (will be added anyway).\n\n        :param add_pk_columns: flag if add primary key - always yes if ormar parses data\n        :type add_pk_columns: bool\n        :param alias: relation prefix\n        :type alias: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param model: model on columns are selected\n        :type model: Type[\"Model\"]\n        :param use_alias: flag if aliases or field names should be used\n        :type use_alias: bool\n        :return: list of column field names or aliases\n        :rtype: List[str]\n        \"\"\"\n        model_excludable = excludable.get(model_cls=model, alias=alias)  # type: ignore\n        columns = [\n            model.get_column_name_from_alias(col.name) if not use_alias else col.name\n            for col in model.ormar_config.table.columns\n        ]\n        field_names = [\n            model.get_column_name_from_alias(col.name)\n            for col in model.ormar_config.table.columns\n        ]\n        if model_excludable.include:\n            columns = [\n                col\n                for col, name in zip(columns, field_names)\n                if model_excludable.is_included(name)\n            ]\n        if model_excludable.exclude:\n            columns = [\n                col\n                for col, name in zip(columns, field_names)\n                if not model_excludable.is_excluded(name)\n            ]\n\n        # always has to return pk column for ormar to work\n        if add_pk_columns:\n            columns = cls._populate_pk_column(\n                model=model, columns=columns, use_alias=use_alias\n            )\n\n        return columns\n\n    @classmethod\n    def _update_excluded_with_related(cls, exclude: Union[Set, Dict, None]) -&gt; Set:\n        \"\"\"\n        Used during generation of the dict().\n        To avoid cyclical references and max recurrence limit nested models have to\n        exclude related models that are not mandatory.\n\n        For a main model (not nested) only nullable related field names are added to\n        exclusion, for nested models all related models are excluded.\n\n        :param exclude: set/dict with fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :return: set or dict with excluded fields added.\n        :rtype: Union[Set, Dict]\n        \"\"\"\n        exclude = exclude or set()\n        related_set = cls.extract_related_names()\n        if isinstance(exclude, set):\n            exclude = {s for s in exclude}\n            exclude = exclude.union(related_set)\n        elif isinstance(exclude, dict):\n            # relations are handled in ormar - take only own fields (ellipsis in dict)\n            exclude = {k for k, v in exclude.items() if v is Ellipsis}\n            exclude = exclude.union(related_set)\n        return exclude\n\n    @classmethod\n    def _update_excluded_with_pks_and_through(\n        cls, exclude: Set, exclude_primary_keys: bool, exclude_through_models: bool\n    ) -&gt; Set:\n        \"\"\"\n        Updates excluded names with name of pk column if exclude flag is set.\n\n        :param exclude: set of names to exclude\n        :type exclude: Set\n        :param exclude_primary_keys: flag if the primary keys should be excluded\n        :type exclude_primary_keys: bool\n        :return: set updated with pk if flag is set\n        :rtype: Set\n        \"\"\"\n        if exclude_primary_keys:\n            exclude.add(cls.ormar_config.pkname)\n        if exclude_through_models:\n            exclude = exclude.union(cls.extract_through_names())\n        return exclude\n\n    @classmethod\n    def get_names_to_exclude(cls, excludable: ExcludableItems, alias: str) -&gt; Set:\n        \"\"\"\n        Returns a set of models field names that should be explicitly excluded\n        during model initialization.\n\n        Those fields will be set to None to avoid ormar/pydantic setting default\n        values on them. They should be returned as None in any case.\n\n        Used in parsing data from database rows that construct Models by initializing\n        them with dicts constructed from those db rows.\n\n        :param alias: alias of current relation\n        :type alias: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :return: set of field names that should be excluded\n        :rtype: Set\n        \"\"\"\n        model = cast(Type[\"Model\"], cls)\n        model_excludable = excludable.get(model_cls=model, alias=alias)\n        fields_names = cls.extract_db_own_fields()\n        if model_excludable.include:\n            fields_to_keep = model_excludable.include.intersection(fields_names)\n        else:\n            fields_to_keep = fields_names\n\n        fields_to_exclude = fields_names - fields_to_keep\n\n        if model_excludable.exclude:\n            fields_to_exclude = fields_to_exclude.union(\n                model_excludable.exclude.intersection(fields_names)\n            )\n        fields_to_exclude = fields_to_exclude - {cls.ormar_config.pkname}\n\n        return fields_to_exclude\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.ExcludableMixin.get_child","title":"<code>get_child(items, key=None)</code>  <code>staticmethod</code>","text":"<p>Used to get nested dictionaries keys if they exists otherwise returns passed items. :param items: bag of items to include or exclude :type items:  Union[Set, Dict, None] :param key: name of the child to extract :type key: str :return: child extracted from items if exists :rtype: Union[Set, Dict, None]</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>@staticmethod\ndef get_child(\n    items: Union[Set, Dict, None], key: Optional[str] = None\n) -&gt; Union[Set, Dict, None]:\n    \"\"\"\n    Used to get nested dictionaries keys if they exists otherwise returns\n    passed items.\n    :param items: bag of items to include or exclude\n    :type items:  Union[Set, Dict, None]\n    :param key: name of the child to extract\n    :type key: str\n    :return: child extracted from items if exists\n    :rtype: Union[Set, Dict, None]\n    \"\"\"\n    if isinstance(items, dict):\n        return items.get(key, {})\n    return items\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.ExcludableMixin.get_names_to_exclude","title":"<code>get_names_to_exclude(excludable, alias)</code>  <code>classmethod</code>","text":"<p>Returns a set of models field names that should be explicitly excluded during model initialization.</p> <p>Those fields will be set to None to avoid ormar/pydantic setting default values on them. They should be returned as None in any case.</p> <p>Used in parsing data from database rows that construct Models by initializing them with dicts constructed from those db rows.</p> <p>:param alias: alias of current relation :type alias: str :param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :return: set of field names that should be excluded :rtype: Set</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>@classmethod\ndef get_names_to_exclude(cls, excludable: ExcludableItems, alias: str) -&gt; Set:\n    \"\"\"\n    Returns a set of models field names that should be explicitly excluded\n    during model initialization.\n\n    Those fields will be set to None to avoid ormar/pydantic setting default\n    values on them. They should be returned as None in any case.\n\n    Used in parsing data from database rows that construct Models by initializing\n    them with dicts constructed from those db rows.\n\n    :param alias: alias of current relation\n    :type alias: str\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :return: set of field names that should be excluded\n    :rtype: Set\n    \"\"\"\n    model = cast(Type[\"Model\"], cls)\n    model_excludable = excludable.get(model_cls=model, alias=alias)\n    fields_names = cls.extract_db_own_fields()\n    if model_excludable.include:\n        fields_to_keep = model_excludable.include.intersection(fields_names)\n    else:\n        fields_to_keep = fields_names\n\n    fields_to_exclude = fields_names - fields_to_keep\n\n    if model_excludable.exclude:\n        fields_to_exclude = fields_to_exclude.union(\n            model_excludable.exclude.intersection(fields_names)\n        )\n    fields_to_exclude = fields_to_exclude - {cls.ormar_config.pkname}\n\n    return fields_to_exclude\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.ExcludableMixin.own_table_columns","title":"<code>own_table_columns(model, excludable, alias='', use_alias=False, add_pk_columns=True)</code>  <code>classmethod</code>","text":"<p>Returns list of aliases or field names for given model. Aliases/names switch is use_alias flag.</p> <p>If provided only fields included in fields will be returned. If provided fields in exclude_fields will be excluded in return.</p> <p>Primary key field is always added and cannot be excluded (will be added anyway).</p> <p>:param add_pk_columns: flag if add primary key - always yes if ormar parses data :type add_pk_columns: bool :param alias: relation prefix :type alias: str :param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :param model: model on columns are selected :type model: Type[\"Model\"] :param use_alias: flag if aliases or field names should be used :type use_alias: bool :return: list of column field names or aliases :rtype: List[str]</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>@classmethod\ndef own_table_columns(\n    cls,\n    model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n    excludable: ExcludableItems,\n    alias: str = \"\",\n    use_alias: bool = False,\n    add_pk_columns: bool = True,\n) -&gt; List[str]:\n    \"\"\"\n    Returns list of aliases or field names for given model.\n    Aliases/names switch is use_alias flag.\n\n    If provided only fields included in fields will be returned.\n    If provided fields in exclude_fields will be excluded in return.\n\n    Primary key field is always added and cannot be excluded (will be added anyway).\n\n    :param add_pk_columns: flag if add primary key - always yes if ormar parses data\n    :type add_pk_columns: bool\n    :param alias: relation prefix\n    :type alias: str\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :param model: model on columns are selected\n    :type model: Type[\"Model\"]\n    :param use_alias: flag if aliases or field names should be used\n    :type use_alias: bool\n    :return: list of column field names or aliases\n    :rtype: List[str]\n    \"\"\"\n    model_excludable = excludable.get(model_cls=model, alias=alias)  # type: ignore\n    columns = [\n        model.get_column_name_from_alias(col.name) if not use_alias else col.name\n        for col in model.ormar_config.table.columns\n    ]\n    field_names = [\n        model.get_column_name_from_alias(col.name)\n        for col in model.ormar_config.table.columns\n    ]\n    if model_excludable.include:\n        columns = [\n            col\n            for col, name in zip(columns, field_names)\n            if model_excludable.is_included(name)\n        ]\n    if model_excludable.exclude:\n        columns = [\n            col\n            for col, name in zip(columns, field_names)\n            if not model_excludable.is_excluded(name)\n        ]\n\n    # always has to return pk column for ormar to work\n    if add_pk_columns:\n        columns = cls._populate_pk_column(\n            model=model, columns=columns, use_alias=use_alias\n        )\n\n    return columns\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.MergeModelMixin","title":"<code>MergeModelMixin</code>","text":"<p>Used to merge models instances returned by database, but already initialized to ormar Models.keys</p> <p>Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique.</p> Source code in <code>ormar/models/mixins/merge_mixin.py</code> <pre><code>class MergeModelMixin:\n    \"\"\"\n    Used to merge models instances returned by database,\n    but already initialized to ormar Models.keys\n\n    Models can duplicate during joins when parent model has multiple child rows,\n    in the end all parent (main) models should be unique.\n    \"\"\"\n\n    @classmethod\n    def _recursive_add(cls, model_group: List[\"Model\"]) -&gt; List[\"Model\"]:\n        \"\"\"\n        Instead of accumulating the model additions one by one, this recursively adds\n        the models. E.G.\n        [1, 2, 3, 4].accumulate_add() would give [3, 3, 4], then [6, 4], then [10]\n        where this method looks like\n        [1, 2, 3, 4].recursive_add() gives [[3], [7]], [10]\n        It's the same number of adds, but it gives better O(N) performance on sublists\n        \"\"\"\n        if len(model_group) &lt;= 1:\n            return model_group\n\n        added_values = []\n        iterable_group = iter(model_group)\n        for model in iterable_group:\n            next_model = next(iterable_group, None)\n            if next_model is not None:\n                combined = cls.merge_two_instances(next_model, model)\n            else:\n                combined = model\n            added_values.append(combined)\n\n        return cls._recursive_add(added_values)\n\n    @classmethod\n    def merge_instances_list(cls, result_rows: List[\"Model\"]) -&gt; List[\"Model\"]:\n        \"\"\"\n        Merges a list of models into list of unique models.\n\n        Models can duplicate during joins when parent model has multiple child rows,\n        in the end all parent (main) models should be unique.\n\n        :param result_rows: list of already initialized Models with child models\n        populated, each instance is one row in db and some models can duplicate\n        :type result_rows: List[\"Model\"]\n        :return: list of merged models where each main model is unique\n        :rtype: List[\"Model\"]\n        \"\"\"\n        merged_rows: List[\"Model\"] = []\n        grouped_instances: Dict = {}\n\n        for model in result_rows:\n            grouped_instances.setdefault(model.pk, []).append(model)\n\n        for group in grouped_instances.values():\n            model = cls._recursive_add(group)[0]\n            merged_rows.append(model)\n\n        return merged_rows\n\n    @classmethod\n    def merge_two_instances(\n        cls, one: \"Model\", other: \"Model\", relation_map: Optional[Dict] = None\n    ) -&gt; \"Model\":\n        \"\"\"\n        Merges current (other) Model and previous one (one) and returns the current\n        Model instance with data merged from previous one.\n\n        If needed it's calling itself recurrently and merges also children models.\n\n        :param relation_map: map of models relations to follow\n        :type relation_map: Dict\n        :param one: previous model instance\n        :type one: Model\n        :param other: current model instance\n        :type other: Model\n        :return: current Model instance with data merged from previous one.\n        :rtype: Model\n        \"\"\"\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(one._iterate_related_models())\n        )\n        for field_name in relation_map:\n            current_field = getattr(one, field_name)\n            other_value = getattr(other, field_name, [])\n            if isinstance(current_field, list):\n                value_to_set = cls._merge_items_lists(\n                    field_name=field_name,\n                    current_field=current_field,\n                    other_value=other_value,\n                    relation_map=relation_map,\n                )\n                setattr(other, field_name, value_to_set)\n            elif (\n                isinstance(current_field, ormar.Model)\n                and isinstance(other_value, ormar.Model)\n                and current_field.pk == other_value.pk\n            ):\n                setattr(\n                    other,\n                    field_name,\n                    cls.merge_two_instances(\n                        current_field,\n                        other_value,\n                        relation_map=one._skip_ellipsis(  # type: ignore\n                            relation_map, field_name, default_return=dict()\n                        ),\n                    ),\n                )\n        other.set_save_status(True)\n        return other\n\n    @classmethod\n    def _merge_items_lists(\n        cls,\n        field_name: str,\n        current_field: List,\n        other_value: List,\n        relation_map: Optional[Dict],\n    ) -&gt; List:\n        \"\"\"\n        Takes two list of nested models and process them going deeper\n        according with the map.\n\n        If model from one's list is in other -&gt; they are merged with relations\n        to follow passed from map.\n\n        If one's model is not in other it's simply appended to the list.\n\n        :param field_name: name of the current relation field\n        :type field_name: str\n        :param current_field: list of nested models from one model\n        :type current_field: List[Model]\n        :param other_value: list of nested models from other model\n        :type other_value: List[Model]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :return: merged list of models\n        :rtype: List[Model]\n        \"\"\"\n        value_to_set = [x for x in other_value]\n        for cur_field in current_field:\n            if cur_field in other_value:\n                old_value = next((x for x in other_value if x == cur_field), None)\n                new_val = cls.merge_two_instances(\n                    cur_field,\n                    cast(\"Model\", old_value),\n                    relation_map=cur_field._skip_ellipsis(  # type: ignore\n                        relation_map, field_name, default_return=dict()\n                    ),\n                )\n                value_to_set = [x for x in value_to_set if x != cur_field] + [new_val]\n            else:\n                value_to_set.append(cur_field)\n        return value_to_set\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.MergeModelMixin.merge_instances_list","title":"<code>merge_instances_list(result_rows)</code>  <code>classmethod</code>","text":"<p>Merges a list of models into list of unique models.</p> <p>Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique.</p> <p>:param result_rows: list of already initialized Models with child models populated, each instance is one row in db and some models can duplicate :type result_rows: List[\"Model\"] :return: list of merged models where each main model is unique :rtype: List[\"Model\"]</p> Source code in <code>ormar/models/mixins/merge_mixin.py</code> <pre><code>@classmethod\ndef merge_instances_list(cls, result_rows: List[\"Model\"]) -&gt; List[\"Model\"]:\n    \"\"\"\n    Merges a list of models into list of unique models.\n\n    Models can duplicate during joins when parent model has multiple child rows,\n    in the end all parent (main) models should be unique.\n\n    :param result_rows: list of already initialized Models with child models\n    populated, each instance is one row in db and some models can duplicate\n    :type result_rows: List[\"Model\"]\n    :return: list of merged models where each main model is unique\n    :rtype: List[\"Model\"]\n    \"\"\"\n    merged_rows: List[\"Model\"] = []\n    grouped_instances: Dict = {}\n\n    for model in result_rows:\n        grouped_instances.setdefault(model.pk, []).append(model)\n\n    for group in grouped_instances.values():\n        model = cls._recursive_add(group)[0]\n        merged_rows.append(model)\n\n    return merged_rows\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.MergeModelMixin.merge_two_instances","title":"<code>merge_two_instances(one, other, relation_map=None)</code>  <code>classmethod</code>","text":"<p>Merges current (other) Model and previous one (one) and returns the current Model instance with data merged from previous one.</p> <p>If needed it's calling itself recurrently and merges also children models.</p> <p>:param relation_map: map of models relations to follow :type relation_map: Dict :param one: previous model instance :type one: Model :param other: current model instance :type other: Model :return: current Model instance with data merged from previous one. :rtype: Model</p> Source code in <code>ormar/models/mixins/merge_mixin.py</code> <pre><code>@classmethod\ndef merge_two_instances(\n    cls, one: \"Model\", other: \"Model\", relation_map: Optional[Dict] = None\n) -&gt; \"Model\":\n    \"\"\"\n    Merges current (other) Model and previous one (one) and returns the current\n    Model instance with data merged from previous one.\n\n    If needed it's calling itself recurrently and merges also children models.\n\n    :param relation_map: map of models relations to follow\n    :type relation_map: Dict\n    :param one: previous model instance\n    :type one: Model\n    :param other: current model instance\n    :type other: Model\n    :return: current Model instance with data merged from previous one.\n    :rtype: Model\n    \"\"\"\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(one._iterate_related_models())\n    )\n    for field_name in relation_map:\n        current_field = getattr(one, field_name)\n        other_value = getattr(other, field_name, [])\n        if isinstance(current_field, list):\n            value_to_set = cls._merge_items_lists(\n                field_name=field_name,\n                current_field=current_field,\n                other_value=other_value,\n                relation_map=relation_map,\n            )\n            setattr(other, field_name, value_to_set)\n        elif (\n            isinstance(current_field, ormar.Model)\n            and isinstance(other_value, ormar.Model)\n            and current_field.pk == other_value.pk\n        ):\n            setattr(\n                other,\n                field_name,\n                cls.merge_two_instances(\n                    current_field,\n                    other_value,\n                    relation_map=one._skip_ellipsis(  # type: ignore\n                        relation_map, field_name, default_return=dict()\n                    ),\n                ),\n            )\n    other.set_save_status(True)\n    return other\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.PydanticMixin","title":"<code>PydanticMixin</code>","text":"<p>               Bases: <code>RelationMixin</code></p> Source code in <code>ormar/models/mixins/pydantic_mixin.py</code> <pre><code>class PydanticMixin(RelationMixin):\n    __cache__: Dict[str, Type[pydantic.BaseModel]] = {}\n\n    if TYPE_CHECKING:  # pragma: no cover\n        __pydantic_decorators__: DecoratorInfos\n        model_fields: Dict[str, FieldInfo]\n        _skip_ellipsis: Callable\n        _get_not_excluded_fields: Callable\n\n    @classmethod\n    def get_pydantic(\n        cls,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n    ) -&gt; Type[pydantic.BaseModel]:\n        \"\"\"\n        Returns a pydantic model out of ormar model.\n\n        Converts also nested ormar models into pydantic models.\n\n        Can be used to fully exclude certain fields in fastapi response and requests.\n\n        :param include: fields of own and nested models to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields of own and nested models to exclude\n        :type exclude: Union[Set, Dict, None]\n        \"\"\"\n        relation_map = translate_list_to_dict(cls._iterate_related_models())\n\n        return cls._convert_ormar_to_pydantic(\n            include=include, exclude=exclude, relation_map=relation_map\n        )\n\n    @classmethod\n    def _convert_ormar_to_pydantic(\n        cls,\n        relation_map: Dict[str, Any],\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n    ) -&gt; Type[pydantic.BaseModel]:\n        if include and isinstance(include, Set):\n            include = translate_list_to_dict(include)\n        if exclude and isinstance(exclude, Set):\n            exclude = translate_list_to_dict(exclude)\n        fields_dict: Dict[str, Any] = dict()\n        defaults: Dict[str, Any] = dict()\n        fields_to_process = cls._get_not_excluded_fields(\n            fields={*cls.ormar_config.model_fields.keys()},\n            include=include,\n            exclude=exclude,\n        )\n        fields_to_process.sort(\n            key=lambda x: list(cls.ormar_config.model_fields.keys()).index(x)\n        )\n\n        cache_key = f\"{cls.__name__}_{str(include)}_{str(exclude)}\"\n        if cache_key in cls.__cache__:\n            return cls.__cache__[cache_key]\n\n        for name in fields_to_process:\n            field = cls._determine_pydantic_field_type(\n                name=name,\n                defaults=defaults,\n                include=include,\n                exclude=exclude,\n                relation_map=relation_map,\n            )\n            if field is not None:\n                fields_dict[name] = field\n        model = type(\n            f\"{cls.__name__}_{''.join(choices(string.ascii_uppercase, k=3))}\",\n            (pydantic.BaseModel,),\n            {\"__annotations__\": fields_dict, **defaults},\n        )\n        model = cast(Type[pydantic.BaseModel], model)\n        cls._copy_field_validators(model=model)\n        cls.__cache__[cache_key] = model\n        return model\n\n    @classmethod\n    def _determine_pydantic_field_type(\n        cls,\n        name: str,\n        defaults: Dict,\n        include: Union[Set, Dict, None],\n        exclude: Union[Set, Dict, None],\n        relation_map: Dict[str, Any],\n    ) -&gt; Any:\n        field = cls.ormar_config.model_fields[name]\n        target: Any = None\n        if field.is_relation and name in relation_map:\n            target, default = cls._determined_included_relation_field_type(\n                name=name,\n                field=field,\n                include=include,\n                exclude=exclude,\n                defaults=defaults,\n                relation_map=relation_map,\n            )\n        elif not field.is_relation:\n            defaults[name] = cls.model_fields[name].default\n            target = field.__type__\n        if target is not None and field.nullable:\n            target = Optional[target]\n        return target\n\n    @classmethod\n    def _determined_included_relation_field_type(\n        cls,\n        name: str,\n        field: Union[BaseField, ForeignKeyField, ManyToManyField],\n        include: Union[Set, Dict, None],\n        exclude: Union[Set, Dict, None],\n        defaults: Dict,\n        relation_map: Dict[str, Any],\n    ) -&gt; Tuple[Type[BaseModel], Dict]:\n        target = field.to._convert_ormar_to_pydantic(\n            include=cls._skip_ellipsis(include, name),\n            exclude=cls._skip_ellipsis(exclude, name),\n            relation_map=cls._skip_ellipsis(relation_map, name, default_return=dict()),\n        )\n        if field.is_multi or field.virtual:\n            target = List[target]  # type: ignore\n        if field.nullable:\n            defaults[name] = None\n        return target, defaults\n\n    @classmethod\n    def _copy_field_validators(cls, model: Type[pydantic.BaseModel]) -&gt; None:\n        \"\"\"\n        Copy field validators from ormar model to generated pydantic model.\n        \"\"\"\n        filed_names = list(model.model_fields.keys())\n        cls.copy_selected_validators_type(\n            model=model, fields=filed_names, validator_type=\"field_validators\"\n        )\n        cls.copy_selected_validators_type(\n            model=model, fields=filed_names, validator_type=\"validators\"\n        )\n\n        class_validators = cls.__pydantic_decorators__.root_validators\n        model.__pydantic_decorators__.root_validators.update(\n            copy.deepcopy(class_validators)\n        )\n        model_validators = cls.__pydantic_decorators__.model_validators\n        model.__pydantic_decorators__.model_validators.update(\n            copy.deepcopy(model_validators)\n        )\n        model.model_rebuild(force=True)\n\n    @classmethod\n    def copy_selected_validators_type(\n        cls, model: Type[pydantic.BaseModel], fields: List[str], validator_type: str\n    ) -&gt; None:\n        \"\"\"\n        Copy field validators from ormar model to generated pydantic model.\n        \"\"\"\n        validators = getattr(cls.__pydantic_decorators__, validator_type)\n        for name, decorator in validators.items():\n            if any(field_name in decorator.info.fields for field_name in fields):\n                copied_decorator = copy.deepcopy(decorator)\n                copied_decorator.info.fields = [\n                    field_name\n                    for field_name in decorator.info.fields\n                    if field_name in fields\n                ]\n                getattr(model.__pydantic_decorators__, validator_type)[\n                    name\n                ] = copied_decorator\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.PydanticMixin.copy_selected_validators_type","title":"<code>copy_selected_validators_type(model, fields, validator_type)</code>  <code>classmethod</code>","text":"<p>Copy field validators from ormar model to generated pydantic model.</p> Source code in <code>ormar/models/mixins/pydantic_mixin.py</code> <pre><code>@classmethod\ndef copy_selected_validators_type(\n    cls, model: Type[pydantic.BaseModel], fields: List[str], validator_type: str\n) -&gt; None:\n    \"\"\"\n    Copy field validators from ormar model to generated pydantic model.\n    \"\"\"\n    validators = getattr(cls.__pydantic_decorators__, validator_type)\n    for name, decorator in validators.items():\n        if any(field_name in decorator.info.fields for field_name in fields):\n            copied_decorator = copy.deepcopy(decorator)\n            copied_decorator.info.fields = [\n                field_name\n                for field_name in decorator.info.fields\n                if field_name in fields\n            ]\n            getattr(model.__pydantic_decorators__, validator_type)[\n                name\n            ] = copied_decorator\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.PydanticMixin.get_pydantic","title":"<code>get_pydantic(*, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Returns a pydantic model out of ormar model.</p> <p>Converts also nested ormar models into pydantic models.</p> <p>Can be used to fully exclude certain fields in fastapi response and requests.</p> <p>:param include: fields of own and nested models to include :type include: Union[Set, Dict, None] :param exclude: fields of own and nested models to exclude :type exclude: Union[Set, Dict, None]</p> Source code in <code>ormar/models/mixins/pydantic_mixin.py</code> <pre><code>@classmethod\ndef get_pydantic(\n    cls,\n    *,\n    include: Union[Set, Dict, None] = None,\n    exclude: Union[Set, Dict, None] = None,\n) -&gt; Type[pydantic.BaseModel]:\n    \"\"\"\n    Returns a pydantic model out of ormar model.\n\n    Converts also nested ormar models into pydantic models.\n\n    Can be used to fully exclude certain fields in fastapi response and requests.\n\n    :param include: fields of own and nested models to include\n    :type include: Union[Set, Dict, None]\n    :param exclude: fields of own and nested models to exclude\n    :type exclude: Union[Set, Dict, None]\n    \"\"\"\n    relation_map = translate_list_to_dict(cls._iterate_related_models())\n\n    return cls._convert_ormar_to_pydantic(\n        include=include, exclude=exclude, relation_map=relation_map\n    )\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin","title":"<code>SavePrepareMixin</code>","text":"<p>               Bases: <code>RelationMixin</code>, <code>AliasMixin</code></p> <p>Used to prepare models to be saved in database</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>class SavePrepareMixin(RelationMixin, AliasMixin):\n    \"\"\"\n    Used to prepare models to be saved in database\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma: nocover\n        _skip_ellipsis: Callable\n        _json_fields: Set[str]\n        _bytes_fields: Set[str]\n        __pydantic_core_schema__: CoreSchema\n        __ormar_fields_validators__: Optional[\n            Dict[str, SchemaValidator | PluggableSchemaValidator]\n        ]\n\n    @classmethod\n    def prepare_model_to_save(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Combines all preparation methods before saving.\n        Removes primary key for if it's nullable or autoincrement pk field,\n        and it's set to None.\n        Substitute related models with their primary key values as fk column.\n        Populates the default values for field with default set and no value.\n        Translate columns into aliases (db names).\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict[str, str]\n        \"\"\"\n        new_kwargs = cls._remove_pk_from_kwargs(new_kwargs)\n        new_kwargs = cls._remove_not_ormar_fields(new_kwargs)\n        new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n        new_kwargs = cls.populate_default_values(new_kwargs)\n        new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n        new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n        return new_kwargs\n\n    @classmethod\n    def prepare_model_to_update(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Combines all preparation methods before updating.\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be updated\n        :rtype: Dict[str, str]\n        \"\"\"\n        new_kwargs = cls.parse_non_db_fields(new_kwargs)\n        new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n        new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n        new_kwargs = cls.dump_all_json_fields_to_str(new_kwargs)\n        new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n        new_kwargs = cls.translate_enum_columns(new_kwargs)\n        return new_kwargs\n\n    @classmethod\n    def translate_enum_columns(cls, new_kwargs: dict) -&gt; dict:\n        for key, value in new_kwargs.items():\n            if isinstance(value, Enum):\n                new_kwargs[key] = value.name\n        return new_kwargs\n\n    @classmethod\n    def _remove_not_ormar_fields(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Removes primary key for if it's nullable or autoincrement pk field,\n        and it's set to None.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict[str, str]\n        \"\"\"\n        ormar_fields = {k for k, v in cls.ormar_config.model_fields.items()}\n        new_kwargs = {k: v for k, v in new_kwargs.items() if k in ormar_fields}\n        return new_kwargs\n\n    @classmethod\n    def _remove_pk_from_kwargs(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Removes primary key for if it's nullable or autoincrement pk field,\n        and it's set to None.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict[str, str]\n        \"\"\"\n        pkname = cls.ormar_config.pkname\n        pk = cls.ormar_config.model_fields[pkname]\n        if new_kwargs.get(pkname, ormar.Undefined) is None and (\n            pk.nullable or pk.autoincrement\n        ):\n            del new_kwargs[pkname]\n        return new_kwargs\n\n    @classmethod\n    def parse_non_db_fields(cls, model_dict: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes uuid fields\n        to strings in bulk_update.\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for name, field in cls.ormar_config.model_fields.items():\n            if field.__type__ == uuid.UUID and name in model_dict:\n                parsers = {\"string\": lambda x: str(x), \"hex\": lambda x: \"%.32x\" % x.int}\n                uuid_format = field.column_type.uuid_format\n                parser: Callable[..., Any] = parsers.get(uuid_format, lambda x: x)\n                model_dict[name] = parser(model_dict[name])\n        return model_dict\n\n    @classmethod\n    def substitute_models_with_pks(cls, model_dict: Dict) -&gt; Dict:  # noqa  CCR001\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes all related\n        models that are stored as foreign keys to their fk value.\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for field in cls.extract_related_names():\n            field_value = model_dict.get(field, None)\n            if field_value is not None:\n                target_field = cls.ormar_config.model_fields[field]\n                target_pkname = target_field.to.ormar_config.pkname\n                if isinstance(field_value, ormar.Model):  # pragma: no cover\n                    pk_value = getattr(field_value, target_pkname)\n                    if not pk_value:\n                        raise ModelPersistenceError(\n                            f\"You cannot save {field_value.get_name()} \"\n                            f\"model without pk set!\"\n                        )\n                    model_dict[field] = pk_value\n                elif isinstance(field_value, (list, dict)) and field_value:\n                    if isinstance(field_value, list):\n                        model_dict[field] = [\n                            target.get(target_pkname) for target in field_value\n                        ]\n                    else:\n                        model_dict[field] = field_value.get(target_pkname)\n                else:\n                    model_dict.pop(field, None)\n        return model_dict\n\n    @classmethod\n    def reconvert_str_to_bytes(cls, model_dict: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes\n        all bytes fields that are represented as strings back into bytes.\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        bytes_base64_fields = {\n            name\n            for name, field in cls.ormar_config.model_fields.items()\n            if field.represent_as_base64_str\n        }\n        for key, value in model_dict.items():\n            if key in cls._bytes_fields and isinstance(value, str):\n                model_dict[key] = (\n                    value.encode(\"utf-8\")\n                    if key not in bytes_base64_fields\n                    else base64.b64decode(value)\n                )\n        return model_dict\n\n    @classmethod\n    def dump_all_json_fields_to_str(cls, model_dict: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes\n        all json fields into strings\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for key, value in model_dict.items():\n            if key in cls._json_fields:\n                model_dict[key] = encode_json(value)\n        return model_dict\n\n    @classmethod\n    def populate_default_values(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and populates the default\n        value on the fields that have the default value set, but no actual value was\n        passed by the user.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field_name not in new_kwargs and field.has_default(use_server=False):\n                new_kwargs[field_name] = field.get_default()\n            # clear fields with server_default set as None\n            if (\n                field.server_default is not None\n                and new_kwargs.get(field_name, None) is None\n            ):\n                new_kwargs.pop(field_name, None)\n        return new_kwargs\n\n    @classmethod\n    def validate_enums(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and validates the\n        fields with choices set to see if the value is allowed.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        validators = cls._build_individual_schema_validator()\n        for key, value in new_kwargs.items():\n            if key in validators:\n                validators[key].validate_python(value)\n        return new_kwargs\n\n    @classmethod\n    def _build_individual_schema_validator(cls) -&gt; Any:\n        if cls.__ormar_fields_validators__ is not None:\n            return cls.__ormar_fields_validators__\n        field_validators = {}\n        for key, field in cls._extract_pydantic_fields().items():\n            if cls.__pydantic_core_schema__[\"type\"] == \"definitions\":\n                schema = {\n                    \"type\": \"definitions\",\n                    \"schema\": field[\"schema\"],\n                    \"definitions\": cls.__pydantic_core_schema__[\"definitions\"],\n                }\n            else:\n                schema = field[\"schema\"]\n            field_validators[key] = create_schema_validator(\n                schema, cls, cls.__module__, cls.__qualname__, \"BaseModel\"\n            )\n        cls.__ormar_fields_validators__ = field_validators\n        return cls.__ormar_fields_validators__\n\n    @classmethod\n    def _extract_pydantic_fields(cls) -&gt; Any:\n        if cls.__pydantic_core_schema__[\"type\"] == \"model\":\n            return cls.__pydantic_core_schema__[\"schema\"][\"fields\"]\n        elif cls.__pydantic_core_schema__[\"type\"] == \"definitions\":\n            main_schema = cls.__pydantic_core_schema__[\"schema\"]\n            if \"schema_ref\" in main_schema:\n                reference_id = main_schema[\"schema_ref\"]\n                return next(\n                    ref\n                    for ref in cls.__pydantic_core_schema__[\"definitions\"]\n                    if ref[\"ref\"] == reference_id\n                )[\"schema\"][\"fields\"]\n            return main_schema[\"schema\"][\"fields\"]\n\n    @staticmethod\n    async def _upsert_model(\n        instance: \"Model\",\n        save_all: bool,\n        previous_model: Optional[\"Model\"],\n        relation_field: Optional[\"ForeignKeyField\"],\n        update_count: int,\n    ) -&gt; int:\n        \"\"\"\n        Method updates given instance if:\n\n        * instance is not saved or\n        * instance have no pk or\n        * save_all=True flag is set\n\n        and instance is not __pk_only__.\n\n        If relation leading to instance is a ManyToMany also the through model is saved\n\n        :param instance: current model to upsert\n        :type instance: Model\n        :param save_all: flag if all models should be saved or only not saved ones\n        :type save_all: bool\n        :param relation_field: field with relation\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        :param update_count: no of updated models\n        :type update_count: int\n        :return: no of updated models\n        :rtype: int\n        \"\"\"\n        if (\n            save_all or not instance.pk or not instance.saved\n        ) and not instance.__pk_only__:\n            await instance.upsert(__force_save__=True)\n            if relation_field and relation_field.is_multi:\n                await instance._upsert_through_model(\n                    instance=instance,\n                    relation_field=relation_field,\n                    previous_model=cast(\"Model\", previous_model),\n                )\n            update_count += 1\n        return update_count\n\n    @staticmethod\n    async def _upsert_through_model(\n        instance: \"Model\", previous_model: \"Model\", relation_field: \"ForeignKeyField\"\n    ) -&gt; None:\n        \"\"\"\n        Upsert through model for m2m relation.\n\n        :param instance: current model to upsert\n        :type instance: Model\n        :param relation_field: field with relation\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        \"\"\"\n        through_name = previous_model.ormar_config.model_fields[\n            relation_field.name\n        ].through.get_name()\n        through = getattr(instance, through_name)\n        if through:\n            through_dict = through.model_dump(exclude=through.extract_related_names())\n        else:\n            through_dict = {}\n        await getattr(\n            previous_model, relation_field.name\n        ).queryset_proxy.upsert_through_instance(instance, **through_dict)\n\n    async def _update_relation_list(\n        self,\n        fields_list: Collection[\"ForeignKeyField\"],\n        follow: bool,\n        save_all: bool,\n        relation_map: Dict,\n        update_count: int,\n    ) -&gt; int:\n        \"\"\"\n        Internal method used in save_related to follow deeper from\n        related models and update numbers of updated related instances.\n\n        :type save_all: flag if all models should be saved\n        :type save_all: bool\n        :param fields_list: list of ormar fields to follow and save\n        :type fields_list: Collection[\"ForeignKeyField\"]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :param update_count: internal parameter for recursive calls -\n        number of updated instances\n        :type update_count: int\n        :return: tuple of update count and visited\n        :rtype: int\n        \"\"\"\n        for field in fields_list:\n            values = self._get_field_values(name=field.name)\n            for value in values:\n                if follow:\n                    update_count = await value.save_related(\n                        follow=follow,\n                        save_all=save_all,\n                        relation_map=self._skip_ellipsis(  # type: ignore\n                            relation_map, field.name, default_return={}\n                        ),\n                        update_count=update_count,\n                        previous_model=self,\n                        relation_field=field,\n                    )\n                else:\n                    update_count = await value._upsert_model(\n                        instance=value,\n                        save_all=save_all,\n                        previous_model=self,\n                        relation_field=field,\n                        update_count=update_count,\n                    )\n        return update_count\n\n    def _get_field_values(self, name: str) -&gt; List:\n        \"\"\"\n        Extract field values and ensures it is a list.\n\n        :param name: name of the field\n        :type name: str\n        :return: list of values\n        :rtype: List\n        \"\"\"\n        values = getattr(self, name) or []\n        if not isinstance(values, list):\n            values = [values]\n        return values\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.dump_all_json_fields_to_str","title":"<code>dump_all_json_fields_to_str(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes all json fields into strings</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef dump_all_json_fields_to_str(cls, model_dict: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes\n    all json fields into strings\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for key, value in model_dict.items():\n        if key in cls._json_fields:\n            model_dict[key] = encode_json(value)\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.parse_non_db_fields","title":"<code>parse_non_db_fields(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes uuid fields to strings in bulk_update.</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef parse_non_db_fields(cls, model_dict: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes uuid fields\n    to strings in bulk_update.\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for name, field in cls.ormar_config.model_fields.items():\n        if field.__type__ == uuid.UUID and name in model_dict:\n            parsers = {\"string\": lambda x: str(x), \"hex\": lambda x: \"%.32x\" % x.int}\n            uuid_format = field.column_type.uuid_format\n            parser: Callable[..., Any] = parsers.get(uuid_format, lambda x: x)\n            model_dict[name] = parser(model_dict[name])\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.populate_default_values","title":"<code>populate_default_values(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and populates the default value on the fields that have the default value set, but no actual value was passed by the user.</p> <p>:param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef populate_default_values(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and populates the default\n    value on the fields that have the default value set, but no actual value was\n    passed by the user.\n\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field_name not in new_kwargs and field.has_default(use_server=False):\n            new_kwargs[field_name] = field.get_default()\n        # clear fields with server_default set as None\n        if (\n            field.server_default is not None\n            and new_kwargs.get(field_name, None) is None\n        ):\n            new_kwargs.pop(field_name, None)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.prepare_model_to_save","title":"<code>prepare_model_to_save(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Combines all preparation methods before saving. Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Substitute related models with their primary key values as fk column. Populates the default values for field with default set and no value. Translate columns into aliases (db names).</p> <p>:param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] :return: dictionary of model that is about to be saved :rtype: Dict[str, str]</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef prepare_model_to_save(cls, new_kwargs: dict) -&gt; dict:\n    \"\"\"\n    Combines all preparation methods before saving.\n    Removes primary key for if it's nullable or autoincrement pk field,\n    and it's set to None.\n    Substitute related models with their primary key values as fk column.\n    Populates the default values for field with default set and no value.\n    Translate columns into aliases (db names).\n\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict[str, str]\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict[str, str]\n    \"\"\"\n    new_kwargs = cls._remove_pk_from_kwargs(new_kwargs)\n    new_kwargs = cls._remove_not_ormar_fields(new_kwargs)\n    new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n    new_kwargs = cls.populate_default_values(new_kwargs)\n    new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n    new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.prepare_model_to_update","title":"<code>prepare_model_to_update(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Combines all preparation methods before updating. :param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] :return: dictionary of model that is about to be updated :rtype: Dict[str, str]</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef prepare_model_to_update(cls, new_kwargs: dict) -&gt; dict:\n    \"\"\"\n    Combines all preparation methods before updating.\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict[str, str]\n    :return: dictionary of model that is about to be updated\n    :rtype: Dict[str, str]\n    \"\"\"\n    new_kwargs = cls.parse_non_db_fields(new_kwargs)\n    new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n    new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n    new_kwargs = cls.dump_all_json_fields_to_str(new_kwargs)\n    new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n    new_kwargs = cls.translate_enum_columns(new_kwargs)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.reconvert_str_to_bytes","title":"<code>reconvert_str_to_bytes(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes all bytes fields that are represented as strings back into bytes.</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef reconvert_str_to_bytes(cls, model_dict: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes\n    all bytes fields that are represented as strings back into bytes.\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    bytes_base64_fields = {\n        name\n        for name, field in cls.ormar_config.model_fields.items()\n        if field.represent_as_base64_str\n    }\n    for key, value in model_dict.items():\n        if key in cls._bytes_fields and isinstance(value, str):\n            model_dict[key] = (\n                value.encode(\"utf-8\")\n                if key not in bytes_base64_fields\n                else base64.b64decode(value)\n            )\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.substitute_models_with_pks","title":"<code>substitute_models_with_pks(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes all related models that are stored as foreign keys to their fk value.</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef substitute_models_with_pks(cls, model_dict: Dict) -&gt; Dict:  # noqa  CCR001\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes all related\n    models that are stored as foreign keys to their fk value.\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for field in cls.extract_related_names():\n        field_value = model_dict.get(field, None)\n        if field_value is not None:\n            target_field = cls.ormar_config.model_fields[field]\n            target_pkname = target_field.to.ormar_config.pkname\n            if isinstance(field_value, ormar.Model):  # pragma: no cover\n                pk_value = getattr(field_value, target_pkname)\n                if not pk_value:\n                    raise ModelPersistenceError(\n                        f\"You cannot save {field_value.get_name()} \"\n                        f\"model without pk set!\"\n                    )\n                model_dict[field] = pk_value\n            elif isinstance(field_value, (list, dict)) and field_value:\n                if isinstance(field_value, list):\n                    model_dict[field] = [\n                        target.get(target_pkname) for target in field_value\n                    ]\n                else:\n                    model_dict[field] = field_value.get(target_pkname)\n            else:\n                model_dict.pop(field, None)\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/#ormar.models.mixins.SavePrepareMixin.validate_enums","title":"<code>validate_enums(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and validates the fields with choices set to see if the value is allowed.</p> <p>:param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef validate_enums(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and validates the\n    fields with choices set to see if the value is allowed.\n\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    validators = cls._build_individual_schema_validator()\n    for key, value in new_kwargs.items():\n        if key in validators:\n            validators[key].validate_python(value)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/alias_mixin/","title":"alias_mixin","text":""},{"location":"api/models/mixins/alias_mixin/#ormar.models.mixins.alias_mixin.AliasMixin","title":"<code>AliasMixin</code>","text":"<p>Used to translate field names into database column names.</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>class AliasMixin:\n    \"\"\"\n    Used to translate field names into database column names.\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma: no cover\n        from ormar.models.ormar_config import OrmarConfig\n\n        ormar_config: OrmarConfig\n\n    @classmethod\n    def get_column_alias(cls, field_name: str) -&gt; str:\n        \"\"\"\n        Returns db alias (column name in db) for given ormar field.\n        For fields without alias field name is returned.\n        :param field_name: name of the field to get alias from\n        :type field_name: str\n        :return: alias (db name) if set, otherwise passed name\n        :rtype: str\n        \"\"\"\n        field = cls.ormar_config.model_fields.get(field_name)\n        return field.get_alias() if field is not None else field_name\n\n    @classmethod\n    def get_column_name_from_alias(cls, alias: str) -&gt; str:\n        \"\"\"\n        Returns ormar field name for given db alias (column name in db).\n        If field do not have alias it's returned as is.\n        :param alias:\n        :type alias: str\n        :return: field name if set, otherwise passed alias (db name)\n        :rtype: str\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field.get_alias() == alias:\n                return field_name\n        return alias  # if not found it's not an alias but actual name\n\n    @classmethod\n    def translate_columns_to_aliases(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Translates dictionary of model fields changing field names into aliases.\n        If field has no alias the field name remains intact.\n        Only fields present in the dictionary are translated.\n        :param new_kwargs: dict with fields names and their values\n        :type new_kwargs: Dict\n        :return: dict with aliases and their values\n        :rtype: Dict\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field_name in new_kwargs:\n                new_kwargs[field.get_alias()] = new_kwargs.pop(field_name)\n        return new_kwargs\n\n    @classmethod\n    def translate_aliases_to_columns(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Translates dictionary of model fields changing aliases into field names.\n        If field has no alias the alias is already a field name.\n        Only fields present in the dictionary are translated.\n        :param new_kwargs: dict with aliases and their values\n        :type new_kwargs: Dict\n        :return: dict with fields names and their values\n        :rtype: Dict\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field.get_alias() and field.get_alias() in new_kwargs:\n                new_kwargs[field_name] = new_kwargs.pop(field.get_alias())\n        return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/alias_mixin/#ormar.models.mixins.alias_mixin.AliasMixin.get_column_alias","title":"<code>get_column_alias(field_name)</code>  <code>classmethod</code>","text":"<p>Returns db alias (column name in db) for given ormar field. For fields without alias field name is returned. :param field_name: name of the field to get alias from :type field_name: str :return: alias (db name) if set, otherwise passed name :rtype: str</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef get_column_alias(cls, field_name: str) -&gt; str:\n    \"\"\"\n    Returns db alias (column name in db) for given ormar field.\n    For fields without alias field name is returned.\n    :param field_name: name of the field to get alias from\n    :type field_name: str\n    :return: alias (db name) if set, otherwise passed name\n    :rtype: str\n    \"\"\"\n    field = cls.ormar_config.model_fields.get(field_name)\n    return field.get_alias() if field is not None else field_name\n</code></pre>"},{"location":"api/models/mixins/alias_mixin/#ormar.models.mixins.alias_mixin.AliasMixin.get_column_name_from_alias","title":"<code>get_column_name_from_alias(alias)</code>  <code>classmethod</code>","text":"<p>Returns ormar field name for given db alias (column name in db). If field do not have alias it's returned as is. :param alias: :type alias: str :return: field name if set, otherwise passed alias (db name) :rtype: str</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef get_column_name_from_alias(cls, alias: str) -&gt; str:\n    \"\"\"\n    Returns ormar field name for given db alias (column name in db).\n    If field do not have alias it's returned as is.\n    :param alias:\n    :type alias: str\n    :return: field name if set, otherwise passed alias (db name)\n    :rtype: str\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field.get_alias() == alias:\n            return field_name\n    return alias  # if not found it's not an alias but actual name\n</code></pre>"},{"location":"api/models/mixins/alias_mixin/#ormar.models.mixins.alias_mixin.AliasMixin.translate_aliases_to_columns","title":"<code>translate_aliases_to_columns(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Translates dictionary of model fields changing aliases into field names. If field has no alias the alias is already a field name. Only fields present in the dictionary are translated. :param new_kwargs: dict with aliases and their values :type new_kwargs: Dict :return: dict with fields names and their values :rtype: Dict</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef translate_aliases_to_columns(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Translates dictionary of model fields changing aliases into field names.\n    If field has no alias the alias is already a field name.\n    Only fields present in the dictionary are translated.\n    :param new_kwargs: dict with aliases and their values\n    :type new_kwargs: Dict\n    :return: dict with fields names and their values\n    :rtype: Dict\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field.get_alias() and field.get_alias() in new_kwargs:\n            new_kwargs[field_name] = new_kwargs.pop(field.get_alias())\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/alias_mixin/#ormar.models.mixins.alias_mixin.AliasMixin.translate_columns_to_aliases","title":"<code>translate_columns_to_aliases(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Translates dictionary of model fields changing field names into aliases. If field has no alias the field name remains intact. Only fields present in the dictionary are translated. :param new_kwargs: dict with fields names and their values :type new_kwargs: Dict :return: dict with aliases and their values :rtype: Dict</p> Source code in <code>ormar/models/mixins/alias_mixin.py</code> <pre><code>@classmethod\ndef translate_columns_to_aliases(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Translates dictionary of model fields changing field names into aliases.\n    If field has no alias the field name remains intact.\n    Only fields present in the dictionary are translated.\n    :param new_kwargs: dict with fields names and their values\n    :type new_kwargs: Dict\n    :return: dict with aliases and their values\n    :rtype: Dict\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field_name in new_kwargs:\n            new_kwargs[field.get_alias()] = new_kwargs.pop(field_name)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/excludable_mixin/","title":"excludable_mixin","text":""},{"location":"api/models/mixins/excludable_mixin/#ormar.models.mixins.excludable_mixin.ExcludableMixin","title":"<code>ExcludableMixin</code>","text":"<p>               Bases: <code>RelationMixin</code></p> <p>Used to include/exclude given set of fields on models during load and dict() calls.</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>class ExcludableMixin(RelationMixin):\n    \"\"\"\n    Used to include/exclude given set of fields on models during load and dict() calls.\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma: no cover\n        from ormar import Model\n        from ormar.models import ModelRow\n\n    @staticmethod\n    def get_child(\n        items: Union[Set, Dict, None], key: Optional[str] = None\n    ) -&gt; Union[Set, Dict, None]:\n        \"\"\"\n        Used to get nested dictionaries keys if they exists otherwise returns\n        passed items.\n        :param items: bag of items to include or exclude\n        :type items:  Union[Set, Dict, None]\n        :param key: name of the child to extract\n        :type key: str\n        :return: child extracted from items if exists\n        :rtype: Union[Set, Dict, None]\n        \"\"\"\n        if isinstance(items, dict):\n            return items.get(key, {})\n        return items\n\n    @staticmethod\n    def _populate_pk_column(\n        model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n        columns: List[str],\n        use_alias: bool = False,\n    ) -&gt; List[str]:\n        \"\"\"\n        Adds primary key column/alias (depends on use_alias flag) to list of\n        column names that are selected.\n\n        :param model: model on columns are selected\n        :type model: Type[\"Model\"]\n        :param columns: list of columns names\n        :type columns: List[str]\n        :param use_alias: flag to set if aliases or field names should be used\n        :type use_alias: bool\n        :return: list of columns names with pk column in it\n        :rtype: List[str]\n        \"\"\"\n        pk_alias = (\n            model.get_column_alias(model.ormar_config.pkname)\n            if use_alias\n            else model.ormar_config.pkname\n        )\n        if pk_alias not in columns:\n            columns.append(pk_alias)\n        return columns\n\n    @classmethod\n    def own_table_columns(\n        cls,\n        model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n        excludable: ExcludableItems,\n        alias: str = \"\",\n        use_alias: bool = False,\n        add_pk_columns: bool = True,\n    ) -&gt; List[str]:\n        \"\"\"\n        Returns list of aliases or field names for given model.\n        Aliases/names switch is use_alias flag.\n\n        If provided only fields included in fields will be returned.\n        If provided fields in exclude_fields will be excluded in return.\n\n        Primary key field is always added and cannot be excluded (will be added anyway).\n\n        :param add_pk_columns: flag if add primary key - always yes if ormar parses data\n        :type add_pk_columns: bool\n        :param alias: relation prefix\n        :type alias: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :param model: model on columns are selected\n        :type model: Type[\"Model\"]\n        :param use_alias: flag if aliases or field names should be used\n        :type use_alias: bool\n        :return: list of column field names or aliases\n        :rtype: List[str]\n        \"\"\"\n        model_excludable = excludable.get(model_cls=model, alias=alias)  # type: ignore\n        columns = [\n            model.get_column_name_from_alias(col.name) if not use_alias else col.name\n            for col in model.ormar_config.table.columns\n        ]\n        field_names = [\n            model.get_column_name_from_alias(col.name)\n            for col in model.ormar_config.table.columns\n        ]\n        if model_excludable.include:\n            columns = [\n                col\n                for col, name in zip(columns, field_names)\n                if model_excludable.is_included(name)\n            ]\n        if model_excludable.exclude:\n            columns = [\n                col\n                for col, name in zip(columns, field_names)\n                if not model_excludable.is_excluded(name)\n            ]\n\n        # always has to return pk column for ormar to work\n        if add_pk_columns:\n            columns = cls._populate_pk_column(\n                model=model, columns=columns, use_alias=use_alias\n            )\n\n        return columns\n\n    @classmethod\n    def _update_excluded_with_related(cls, exclude: Union[Set, Dict, None]) -&gt; Set:\n        \"\"\"\n        Used during generation of the dict().\n        To avoid cyclical references and max recurrence limit nested models have to\n        exclude related models that are not mandatory.\n\n        For a main model (not nested) only nullable related field names are added to\n        exclusion, for nested models all related models are excluded.\n\n        :param exclude: set/dict with fields to exclude\n        :type exclude: Union[Set, Dict, None]\n        :return: set or dict with excluded fields added.\n        :rtype: Union[Set, Dict]\n        \"\"\"\n        exclude = exclude or set()\n        related_set = cls.extract_related_names()\n        if isinstance(exclude, set):\n            exclude = {s for s in exclude}\n            exclude = exclude.union(related_set)\n        elif isinstance(exclude, dict):\n            # relations are handled in ormar - take only own fields (ellipsis in dict)\n            exclude = {k for k, v in exclude.items() if v is Ellipsis}\n            exclude = exclude.union(related_set)\n        return exclude\n\n    @classmethod\n    def _update_excluded_with_pks_and_through(\n        cls, exclude: Set, exclude_primary_keys: bool, exclude_through_models: bool\n    ) -&gt; Set:\n        \"\"\"\n        Updates excluded names with name of pk column if exclude flag is set.\n\n        :param exclude: set of names to exclude\n        :type exclude: Set\n        :param exclude_primary_keys: flag if the primary keys should be excluded\n        :type exclude_primary_keys: bool\n        :return: set updated with pk if flag is set\n        :rtype: Set\n        \"\"\"\n        if exclude_primary_keys:\n            exclude.add(cls.ormar_config.pkname)\n        if exclude_through_models:\n            exclude = exclude.union(cls.extract_through_names())\n        return exclude\n\n    @classmethod\n    def get_names_to_exclude(cls, excludable: ExcludableItems, alias: str) -&gt; Set:\n        \"\"\"\n        Returns a set of models field names that should be explicitly excluded\n        during model initialization.\n\n        Those fields will be set to None to avoid ormar/pydantic setting default\n        values on them. They should be returned as None in any case.\n\n        Used in parsing data from database rows that construct Models by initializing\n        them with dicts constructed from those db rows.\n\n        :param alias: alias of current relation\n        :type alias: str\n        :param excludable: structure of fields to include and exclude\n        :type excludable: ExcludableItems\n        :return: set of field names that should be excluded\n        :rtype: Set\n        \"\"\"\n        model = cast(Type[\"Model\"], cls)\n        model_excludable = excludable.get(model_cls=model, alias=alias)\n        fields_names = cls.extract_db_own_fields()\n        if model_excludable.include:\n            fields_to_keep = model_excludable.include.intersection(fields_names)\n        else:\n            fields_to_keep = fields_names\n\n        fields_to_exclude = fields_names - fields_to_keep\n\n        if model_excludable.exclude:\n            fields_to_exclude = fields_to_exclude.union(\n                model_excludable.exclude.intersection(fields_names)\n            )\n        fields_to_exclude = fields_to_exclude - {cls.ormar_config.pkname}\n\n        return fields_to_exclude\n</code></pre>"},{"location":"api/models/mixins/excludable_mixin/#ormar.models.mixins.excludable_mixin.ExcludableMixin.get_child","title":"<code>get_child(items, key=None)</code>  <code>staticmethod</code>","text":"<p>Used to get nested dictionaries keys if they exists otherwise returns passed items. :param items: bag of items to include or exclude :type items:  Union[Set, Dict, None] :param key: name of the child to extract :type key: str :return: child extracted from items if exists :rtype: Union[Set, Dict, None]</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>@staticmethod\ndef get_child(\n    items: Union[Set, Dict, None], key: Optional[str] = None\n) -&gt; Union[Set, Dict, None]:\n    \"\"\"\n    Used to get nested dictionaries keys if they exists otherwise returns\n    passed items.\n    :param items: bag of items to include or exclude\n    :type items:  Union[Set, Dict, None]\n    :param key: name of the child to extract\n    :type key: str\n    :return: child extracted from items if exists\n    :rtype: Union[Set, Dict, None]\n    \"\"\"\n    if isinstance(items, dict):\n        return items.get(key, {})\n    return items\n</code></pre>"},{"location":"api/models/mixins/excludable_mixin/#ormar.models.mixins.excludable_mixin.ExcludableMixin.get_names_to_exclude","title":"<code>get_names_to_exclude(excludable, alias)</code>  <code>classmethod</code>","text":"<p>Returns a set of models field names that should be explicitly excluded during model initialization.</p> <p>Those fields will be set to None to avoid ormar/pydantic setting default values on them. They should be returned as None in any case.</p> <p>Used in parsing data from database rows that construct Models by initializing them with dicts constructed from those db rows.</p> <p>:param alias: alias of current relation :type alias: str :param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :return: set of field names that should be excluded :rtype: Set</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>@classmethod\ndef get_names_to_exclude(cls, excludable: ExcludableItems, alias: str) -&gt; Set:\n    \"\"\"\n    Returns a set of models field names that should be explicitly excluded\n    during model initialization.\n\n    Those fields will be set to None to avoid ormar/pydantic setting default\n    values on them. They should be returned as None in any case.\n\n    Used in parsing data from database rows that construct Models by initializing\n    them with dicts constructed from those db rows.\n\n    :param alias: alias of current relation\n    :type alias: str\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :return: set of field names that should be excluded\n    :rtype: Set\n    \"\"\"\n    model = cast(Type[\"Model\"], cls)\n    model_excludable = excludable.get(model_cls=model, alias=alias)\n    fields_names = cls.extract_db_own_fields()\n    if model_excludable.include:\n        fields_to_keep = model_excludable.include.intersection(fields_names)\n    else:\n        fields_to_keep = fields_names\n\n    fields_to_exclude = fields_names - fields_to_keep\n\n    if model_excludable.exclude:\n        fields_to_exclude = fields_to_exclude.union(\n            model_excludable.exclude.intersection(fields_names)\n        )\n    fields_to_exclude = fields_to_exclude - {cls.ormar_config.pkname}\n\n    return fields_to_exclude\n</code></pre>"},{"location":"api/models/mixins/excludable_mixin/#ormar.models.mixins.excludable_mixin.ExcludableMixin.own_table_columns","title":"<code>own_table_columns(model, excludable, alias='', use_alias=False, add_pk_columns=True)</code>  <code>classmethod</code>","text":"<p>Returns list of aliases or field names for given model. Aliases/names switch is use_alias flag.</p> <p>If provided only fields included in fields will be returned. If provided fields in exclude_fields will be excluded in return.</p> <p>Primary key field is always added and cannot be excluded (will be added anyway).</p> <p>:param add_pk_columns: flag if add primary key - always yes if ormar parses data :type add_pk_columns: bool :param alias: relation prefix :type alias: str :param excludable: structure of fields to include and exclude :type excludable: ExcludableItems :param model: model on columns are selected :type model: Type[\"Model\"] :param use_alias: flag if aliases or field names should be used :type use_alias: bool :return: list of column field names or aliases :rtype: List[str]</p> Source code in <code>ormar/models/mixins/excludable_mixin.py</code> <pre><code>@classmethod\ndef own_table_columns(\n    cls,\n    model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n    excludable: ExcludableItems,\n    alias: str = \"\",\n    use_alias: bool = False,\n    add_pk_columns: bool = True,\n) -&gt; List[str]:\n    \"\"\"\n    Returns list of aliases or field names for given model.\n    Aliases/names switch is use_alias flag.\n\n    If provided only fields included in fields will be returned.\n    If provided fields in exclude_fields will be excluded in return.\n\n    Primary key field is always added and cannot be excluded (will be added anyway).\n\n    :param add_pk_columns: flag if add primary key - always yes if ormar parses data\n    :type add_pk_columns: bool\n    :param alias: relation prefix\n    :type alias: str\n    :param excludable: structure of fields to include and exclude\n    :type excludable: ExcludableItems\n    :param model: model on columns are selected\n    :type model: Type[\"Model\"]\n    :param use_alias: flag if aliases or field names should be used\n    :type use_alias: bool\n    :return: list of column field names or aliases\n    :rtype: List[str]\n    \"\"\"\n    model_excludable = excludable.get(model_cls=model, alias=alias)  # type: ignore\n    columns = [\n        model.get_column_name_from_alias(col.name) if not use_alias else col.name\n        for col in model.ormar_config.table.columns\n    ]\n    field_names = [\n        model.get_column_name_from_alias(col.name)\n        for col in model.ormar_config.table.columns\n    ]\n    if model_excludable.include:\n        columns = [\n            col\n            for col, name in zip(columns, field_names)\n            if model_excludable.is_included(name)\n        ]\n    if model_excludable.exclude:\n        columns = [\n            col\n            for col, name in zip(columns, field_names)\n            if not model_excludable.is_excluded(name)\n        ]\n\n    # always has to return pk column for ormar to work\n    if add_pk_columns:\n        columns = cls._populate_pk_column(\n            model=model, columns=columns, use_alias=use_alias\n        )\n\n    return columns\n</code></pre>"},{"location":"api/models/mixins/merge_mixin/","title":"merge_mixin","text":""},{"location":"api/models/mixins/merge_mixin/#ormar.models.mixins.merge_mixin.MergeModelMixin","title":"<code>MergeModelMixin</code>","text":"<p>Used to merge models instances returned by database, but already initialized to ormar Models.keys</p> <p>Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique.</p> Source code in <code>ormar/models/mixins/merge_mixin.py</code> <pre><code>class MergeModelMixin:\n    \"\"\"\n    Used to merge models instances returned by database,\n    but already initialized to ormar Models.keys\n\n    Models can duplicate during joins when parent model has multiple child rows,\n    in the end all parent (main) models should be unique.\n    \"\"\"\n\n    @classmethod\n    def _recursive_add(cls, model_group: List[\"Model\"]) -&gt; List[\"Model\"]:\n        \"\"\"\n        Instead of accumulating the model additions one by one, this recursively adds\n        the models. E.G.\n        [1, 2, 3, 4].accumulate_add() would give [3, 3, 4], then [6, 4], then [10]\n        where this method looks like\n        [1, 2, 3, 4].recursive_add() gives [[3], [7]], [10]\n        It's the same number of adds, but it gives better O(N) performance on sublists\n        \"\"\"\n        if len(model_group) &lt;= 1:\n            return model_group\n\n        added_values = []\n        iterable_group = iter(model_group)\n        for model in iterable_group:\n            next_model = next(iterable_group, None)\n            if next_model is not None:\n                combined = cls.merge_two_instances(next_model, model)\n            else:\n                combined = model\n            added_values.append(combined)\n\n        return cls._recursive_add(added_values)\n\n    @classmethod\n    def merge_instances_list(cls, result_rows: List[\"Model\"]) -&gt; List[\"Model\"]:\n        \"\"\"\n        Merges a list of models into list of unique models.\n\n        Models can duplicate during joins when parent model has multiple child rows,\n        in the end all parent (main) models should be unique.\n\n        :param result_rows: list of already initialized Models with child models\n        populated, each instance is one row in db and some models can duplicate\n        :type result_rows: List[\"Model\"]\n        :return: list of merged models where each main model is unique\n        :rtype: List[\"Model\"]\n        \"\"\"\n        merged_rows: List[\"Model\"] = []\n        grouped_instances: Dict = {}\n\n        for model in result_rows:\n            grouped_instances.setdefault(model.pk, []).append(model)\n\n        for group in grouped_instances.values():\n            model = cls._recursive_add(group)[0]\n            merged_rows.append(model)\n\n        return merged_rows\n\n    @classmethod\n    def merge_two_instances(\n        cls, one: \"Model\", other: \"Model\", relation_map: Optional[Dict] = None\n    ) -&gt; \"Model\":\n        \"\"\"\n        Merges current (other) Model and previous one (one) and returns the current\n        Model instance with data merged from previous one.\n\n        If needed it's calling itself recurrently and merges also children models.\n\n        :param relation_map: map of models relations to follow\n        :type relation_map: Dict\n        :param one: previous model instance\n        :type one: Model\n        :param other: current model instance\n        :type other: Model\n        :return: current Model instance with data merged from previous one.\n        :rtype: Model\n        \"\"\"\n        relation_map = (\n            relation_map\n            if relation_map is not None\n            else translate_list_to_dict(one._iterate_related_models())\n        )\n        for field_name in relation_map:\n            current_field = getattr(one, field_name)\n            other_value = getattr(other, field_name, [])\n            if isinstance(current_field, list):\n                value_to_set = cls._merge_items_lists(\n                    field_name=field_name,\n                    current_field=current_field,\n                    other_value=other_value,\n                    relation_map=relation_map,\n                )\n                setattr(other, field_name, value_to_set)\n            elif (\n                isinstance(current_field, ormar.Model)\n                and isinstance(other_value, ormar.Model)\n                and current_field.pk == other_value.pk\n            ):\n                setattr(\n                    other,\n                    field_name,\n                    cls.merge_two_instances(\n                        current_field,\n                        other_value,\n                        relation_map=one._skip_ellipsis(  # type: ignore\n                            relation_map, field_name, default_return=dict()\n                        ),\n                    ),\n                )\n        other.set_save_status(True)\n        return other\n\n    @classmethod\n    def _merge_items_lists(\n        cls,\n        field_name: str,\n        current_field: List,\n        other_value: List,\n        relation_map: Optional[Dict],\n    ) -&gt; List:\n        \"\"\"\n        Takes two list of nested models and process them going deeper\n        according with the map.\n\n        If model from one's list is in other -&gt; they are merged with relations\n        to follow passed from map.\n\n        If one's model is not in other it's simply appended to the list.\n\n        :param field_name: name of the current relation field\n        :type field_name: str\n        :param current_field: list of nested models from one model\n        :type current_field: List[Model]\n        :param other_value: list of nested models from other model\n        :type other_value: List[Model]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :return: merged list of models\n        :rtype: List[Model]\n        \"\"\"\n        value_to_set = [x for x in other_value]\n        for cur_field in current_field:\n            if cur_field in other_value:\n                old_value = next((x for x in other_value if x == cur_field), None)\n                new_val = cls.merge_two_instances(\n                    cur_field,\n                    cast(\"Model\", old_value),\n                    relation_map=cur_field._skip_ellipsis(  # type: ignore\n                        relation_map, field_name, default_return=dict()\n                    ),\n                )\n                value_to_set = [x for x in value_to_set if x != cur_field] + [new_val]\n            else:\n                value_to_set.append(cur_field)\n        return value_to_set\n</code></pre>"},{"location":"api/models/mixins/merge_mixin/#ormar.models.mixins.merge_mixin.MergeModelMixin.merge_instances_list","title":"<code>merge_instances_list(result_rows)</code>  <code>classmethod</code>","text":"<p>Merges a list of models into list of unique models.</p> <p>Models can duplicate during joins when parent model has multiple child rows, in the end all parent (main) models should be unique.</p> <p>:param result_rows: list of already initialized Models with child models populated, each instance is one row in db and some models can duplicate :type result_rows: List[\"Model\"] :return: list of merged models where each main model is unique :rtype: List[\"Model\"]</p> Source code in <code>ormar/models/mixins/merge_mixin.py</code> <pre><code>@classmethod\ndef merge_instances_list(cls, result_rows: List[\"Model\"]) -&gt; List[\"Model\"]:\n    \"\"\"\n    Merges a list of models into list of unique models.\n\n    Models can duplicate during joins when parent model has multiple child rows,\n    in the end all parent (main) models should be unique.\n\n    :param result_rows: list of already initialized Models with child models\n    populated, each instance is one row in db and some models can duplicate\n    :type result_rows: List[\"Model\"]\n    :return: list of merged models where each main model is unique\n    :rtype: List[\"Model\"]\n    \"\"\"\n    merged_rows: List[\"Model\"] = []\n    grouped_instances: Dict = {}\n\n    for model in result_rows:\n        grouped_instances.setdefault(model.pk, []).append(model)\n\n    for group in grouped_instances.values():\n        model = cls._recursive_add(group)[0]\n        merged_rows.append(model)\n\n    return merged_rows\n</code></pre>"},{"location":"api/models/mixins/merge_mixin/#ormar.models.mixins.merge_mixin.MergeModelMixin.merge_two_instances","title":"<code>merge_two_instances(one, other, relation_map=None)</code>  <code>classmethod</code>","text":"<p>Merges current (other) Model and previous one (one) and returns the current Model instance with data merged from previous one.</p> <p>If needed it's calling itself recurrently and merges also children models.</p> <p>:param relation_map: map of models relations to follow :type relation_map: Dict :param one: previous model instance :type one: Model :param other: current model instance :type other: Model :return: current Model instance with data merged from previous one. :rtype: Model</p> Source code in <code>ormar/models/mixins/merge_mixin.py</code> <pre><code>@classmethod\ndef merge_two_instances(\n    cls, one: \"Model\", other: \"Model\", relation_map: Optional[Dict] = None\n) -&gt; \"Model\":\n    \"\"\"\n    Merges current (other) Model and previous one (one) and returns the current\n    Model instance with data merged from previous one.\n\n    If needed it's calling itself recurrently and merges also children models.\n\n    :param relation_map: map of models relations to follow\n    :type relation_map: Dict\n    :param one: previous model instance\n    :type one: Model\n    :param other: current model instance\n    :type other: Model\n    :return: current Model instance with data merged from previous one.\n    :rtype: Model\n    \"\"\"\n    relation_map = (\n        relation_map\n        if relation_map is not None\n        else translate_list_to_dict(one._iterate_related_models())\n    )\n    for field_name in relation_map:\n        current_field = getattr(one, field_name)\n        other_value = getattr(other, field_name, [])\n        if isinstance(current_field, list):\n            value_to_set = cls._merge_items_lists(\n                field_name=field_name,\n                current_field=current_field,\n                other_value=other_value,\n                relation_map=relation_map,\n            )\n            setattr(other, field_name, value_to_set)\n        elif (\n            isinstance(current_field, ormar.Model)\n            and isinstance(other_value, ormar.Model)\n            and current_field.pk == other_value.pk\n        ):\n            setattr(\n                other,\n                field_name,\n                cls.merge_two_instances(\n                    current_field,\n                    other_value,\n                    relation_map=one._skip_ellipsis(  # type: ignore\n                        relation_map, field_name, default_return=dict()\n                    ),\n                ),\n            )\n    other.set_save_status(True)\n    return other\n</code></pre>"},{"location":"api/models/mixins/pydantic_mixin/","title":"pydantic_mixin","text":""},{"location":"api/models/mixins/pydantic_mixin/#ormar.models.mixins.pydantic_mixin.PydanticMixin","title":"<code>PydanticMixin</code>","text":"<p>               Bases: <code>RelationMixin</code></p> Source code in <code>ormar/models/mixins/pydantic_mixin.py</code> <pre><code>class PydanticMixin(RelationMixin):\n    __cache__: Dict[str, Type[pydantic.BaseModel]] = {}\n\n    if TYPE_CHECKING:  # pragma: no cover\n        __pydantic_decorators__: DecoratorInfos\n        model_fields: Dict[str, FieldInfo]\n        _skip_ellipsis: Callable\n        _get_not_excluded_fields: Callable\n\n    @classmethod\n    def get_pydantic(\n        cls,\n        *,\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n    ) -&gt; Type[pydantic.BaseModel]:\n        \"\"\"\n        Returns a pydantic model out of ormar model.\n\n        Converts also nested ormar models into pydantic models.\n\n        Can be used to fully exclude certain fields in fastapi response and requests.\n\n        :param include: fields of own and nested models to include\n        :type include: Union[Set, Dict, None]\n        :param exclude: fields of own and nested models to exclude\n        :type exclude: Union[Set, Dict, None]\n        \"\"\"\n        relation_map = translate_list_to_dict(cls._iterate_related_models())\n\n        return cls._convert_ormar_to_pydantic(\n            include=include, exclude=exclude, relation_map=relation_map\n        )\n\n    @classmethod\n    def _convert_ormar_to_pydantic(\n        cls,\n        relation_map: Dict[str, Any],\n        include: Union[Set, Dict, None] = None,\n        exclude: Union[Set, Dict, None] = None,\n    ) -&gt; Type[pydantic.BaseModel]:\n        if include and isinstance(include, Set):\n            include = translate_list_to_dict(include)\n        if exclude and isinstance(exclude, Set):\n            exclude = translate_list_to_dict(exclude)\n        fields_dict: Dict[str, Any] = dict()\n        defaults: Dict[str, Any] = dict()\n        fields_to_process = cls._get_not_excluded_fields(\n            fields={*cls.ormar_config.model_fields.keys()},\n            include=include,\n            exclude=exclude,\n        )\n        fields_to_process.sort(\n            key=lambda x: list(cls.ormar_config.model_fields.keys()).index(x)\n        )\n\n        cache_key = f\"{cls.__name__}_{str(include)}_{str(exclude)}\"\n        if cache_key in cls.__cache__:\n            return cls.__cache__[cache_key]\n\n        for name in fields_to_process:\n            field = cls._determine_pydantic_field_type(\n                name=name,\n                defaults=defaults,\n                include=include,\n                exclude=exclude,\n                relation_map=relation_map,\n            )\n            if field is not None:\n                fields_dict[name] = field\n        model = type(\n            f\"{cls.__name__}_{''.join(choices(string.ascii_uppercase, k=3))}\",\n            (pydantic.BaseModel,),\n            {\"__annotations__\": fields_dict, **defaults},\n        )\n        model = cast(Type[pydantic.BaseModel], model)\n        cls._copy_field_validators(model=model)\n        cls.__cache__[cache_key] = model\n        return model\n\n    @classmethod\n    def _determine_pydantic_field_type(\n        cls,\n        name: str,\n        defaults: Dict,\n        include: Union[Set, Dict, None],\n        exclude: Union[Set, Dict, None],\n        relation_map: Dict[str, Any],\n    ) -&gt; Any:\n        field = cls.ormar_config.model_fields[name]\n        target: Any = None\n        if field.is_relation and name in relation_map:\n            target, default = cls._determined_included_relation_field_type(\n                name=name,\n                field=field,\n                include=include,\n                exclude=exclude,\n                defaults=defaults,\n                relation_map=relation_map,\n            )\n        elif not field.is_relation:\n            defaults[name] = cls.model_fields[name].default\n            target = field.__type__\n        if target is not None and field.nullable:\n            target = Optional[target]\n        return target\n\n    @classmethod\n    def _determined_included_relation_field_type(\n        cls,\n        name: str,\n        field: Union[BaseField, ForeignKeyField, ManyToManyField],\n        include: Union[Set, Dict, None],\n        exclude: Union[Set, Dict, None],\n        defaults: Dict,\n        relation_map: Dict[str, Any],\n    ) -&gt; Tuple[Type[BaseModel], Dict]:\n        target = field.to._convert_ormar_to_pydantic(\n            include=cls._skip_ellipsis(include, name),\n            exclude=cls._skip_ellipsis(exclude, name),\n            relation_map=cls._skip_ellipsis(relation_map, name, default_return=dict()),\n        )\n        if field.is_multi or field.virtual:\n            target = List[target]  # type: ignore\n        if field.nullable:\n            defaults[name] = None\n        return target, defaults\n\n    @classmethod\n    def _copy_field_validators(cls, model: Type[pydantic.BaseModel]) -&gt; None:\n        \"\"\"\n        Copy field validators from ormar model to generated pydantic model.\n        \"\"\"\n        filed_names = list(model.model_fields.keys())\n        cls.copy_selected_validators_type(\n            model=model, fields=filed_names, validator_type=\"field_validators\"\n        )\n        cls.copy_selected_validators_type(\n            model=model, fields=filed_names, validator_type=\"validators\"\n        )\n\n        class_validators = cls.__pydantic_decorators__.root_validators\n        model.__pydantic_decorators__.root_validators.update(\n            copy.deepcopy(class_validators)\n        )\n        model_validators = cls.__pydantic_decorators__.model_validators\n        model.__pydantic_decorators__.model_validators.update(\n            copy.deepcopy(model_validators)\n        )\n        model.model_rebuild(force=True)\n\n    @classmethod\n    def copy_selected_validators_type(\n        cls, model: Type[pydantic.BaseModel], fields: List[str], validator_type: str\n    ) -&gt; None:\n        \"\"\"\n        Copy field validators from ormar model to generated pydantic model.\n        \"\"\"\n        validators = getattr(cls.__pydantic_decorators__, validator_type)\n        for name, decorator in validators.items():\n            if any(field_name in decorator.info.fields for field_name in fields):\n                copied_decorator = copy.deepcopy(decorator)\n                copied_decorator.info.fields = [\n                    field_name\n                    for field_name in decorator.info.fields\n                    if field_name in fields\n                ]\n                getattr(model.__pydantic_decorators__, validator_type)[\n                    name\n                ] = copied_decorator\n</code></pre>"},{"location":"api/models/mixins/pydantic_mixin/#ormar.models.mixins.pydantic_mixin.PydanticMixin.copy_selected_validators_type","title":"<code>copy_selected_validators_type(model, fields, validator_type)</code>  <code>classmethod</code>","text":"<p>Copy field validators from ormar model to generated pydantic model.</p> Source code in <code>ormar/models/mixins/pydantic_mixin.py</code> <pre><code>@classmethod\ndef copy_selected_validators_type(\n    cls, model: Type[pydantic.BaseModel], fields: List[str], validator_type: str\n) -&gt; None:\n    \"\"\"\n    Copy field validators from ormar model to generated pydantic model.\n    \"\"\"\n    validators = getattr(cls.__pydantic_decorators__, validator_type)\n    for name, decorator in validators.items():\n        if any(field_name in decorator.info.fields for field_name in fields):\n            copied_decorator = copy.deepcopy(decorator)\n            copied_decorator.info.fields = [\n                field_name\n                for field_name in decorator.info.fields\n                if field_name in fields\n            ]\n            getattr(model.__pydantic_decorators__, validator_type)[\n                name\n            ] = copied_decorator\n</code></pre>"},{"location":"api/models/mixins/pydantic_mixin/#ormar.models.mixins.pydantic_mixin.PydanticMixin.get_pydantic","title":"<code>get_pydantic(*, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Returns a pydantic model out of ormar model.</p> <p>Converts also nested ormar models into pydantic models.</p> <p>Can be used to fully exclude certain fields in fastapi response and requests.</p> <p>:param include: fields of own and nested models to include :type include: Union[Set, Dict, None] :param exclude: fields of own and nested models to exclude :type exclude: Union[Set, Dict, None]</p> Source code in <code>ormar/models/mixins/pydantic_mixin.py</code> <pre><code>@classmethod\ndef get_pydantic(\n    cls,\n    *,\n    include: Union[Set, Dict, None] = None,\n    exclude: Union[Set, Dict, None] = None,\n) -&gt; Type[pydantic.BaseModel]:\n    \"\"\"\n    Returns a pydantic model out of ormar model.\n\n    Converts also nested ormar models into pydantic models.\n\n    Can be used to fully exclude certain fields in fastapi response and requests.\n\n    :param include: fields of own and nested models to include\n    :type include: Union[Set, Dict, None]\n    :param exclude: fields of own and nested models to exclude\n    :type exclude: Union[Set, Dict, None]\n    \"\"\"\n    relation_map = translate_list_to_dict(cls._iterate_related_models())\n\n    return cls._convert_ormar_to_pydantic(\n        include=include, exclude=exclude, relation_map=relation_map\n    )\n</code></pre>"},{"location":"api/models/mixins/relation_mixin/","title":"relation_mixin","text":""},{"location":"api/models/mixins/relation_mixin/#ormar.models.mixins.relation_mixin.RelationMixin","title":"<code>RelationMixin</code>","text":"<p>Used to return relation fields/names etc. from given model</p> Source code in <code>ormar/models/mixins/relation_mixin.py</code> <pre><code>class RelationMixin:\n    \"\"\"\n    Used to return relation fields/names etc. from given model\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma no cover\n        from ormar.models.ormar_config import OrmarConfig\n\n        ormar_config: OrmarConfig\n        __relation_map__: Optional[List[str]]\n        _related_names: Optional[Set]\n        _through_names: Optional[Set]\n        _related_fields: Optional[List]\n        get_name: Callable\n\n    @classmethod\n    def extract_db_own_fields(cls) -&gt; Set:\n        \"\"\"\n        Returns only fields that are stored in the own database table, exclude all\n        related fields.\n        :return: set of model fields with relation fields excluded\n        :rtype: Set\n        \"\"\"\n        related_names = cls.extract_related_names()\n        self_fields = {\n            name\n            for name in cls.ormar_config.model_fields.keys()\n            if name not in related_names\n        }\n        return self_fields\n\n    @classmethod\n    def extract_related_fields(cls) -&gt; List[\"ForeignKeyField\"]:\n        \"\"\"\n        Returns List of ormar Fields for all relations declared on a model.\n        List is cached in cls._related_fields for quicker access.\n\n        :return: list of related fields\n        :rtype: List\n        \"\"\"\n        if cls._related_fields is not None:\n            return cls._related_fields\n\n        related_fields = []\n        for name in cls.extract_related_names().union(cls.extract_through_names()):\n            related_fields.append(\n                cast(\"ForeignKeyField\", cls.ormar_config.model_fields[name])\n            )\n        cls._related_fields = related_fields\n\n        return related_fields\n\n    @classmethod\n    def extract_through_names(cls) -&gt; Set[str]:\n        \"\"\"\n        Extracts related fields through names which are shortcuts to through models.\n\n        :return: set of related through fields names\n        :rtype: Set\n        \"\"\"\n        if cls._through_names is not None:\n            return cls._through_names\n\n        related_names = set()\n        for name, field in cls.ormar_config.model_fields.items():\n            if isinstance(field, BaseField) and field.is_through:\n                related_names.add(name)\n\n        cls._through_names = related_names\n        return related_names\n\n    @classmethod\n    def extract_related_names(cls) -&gt; Set[str]:\n        \"\"\"\n        Returns List of fields names for all relations declared on a model.\n        List is cached in cls._related_names for quicker access.\n\n        :return: set of related fields names\n        :rtype: Set\n        \"\"\"\n        if cls._related_names is not None:\n            return cls._related_names\n\n        related_names = set()\n        for name, field in cls.ormar_config.model_fields.items():\n            if (\n                isinstance(field, BaseField)\n                and field.is_relation\n                and not field.is_through\n                and not field.skip_field\n            ):\n                related_names.add(name)\n        cls._related_names = related_names\n\n        return related_names\n\n    @classmethod\n    def _extract_db_related_names(cls) -&gt; Set:\n        \"\"\"\n        Returns only fields that are stored in the own database table, exclude\n        related fields that are not stored as foreign keys on given model.\n        :return: set of model fields with non fk relation fields excluded\n        :rtype: Set\n        \"\"\"\n        related_names = cls.extract_related_names()\n        related_names = {\n            name\n            for name in related_names\n            if cls.ormar_config.model_fields[name].is_valid_uni_relation()\n        }\n        return related_names\n\n    @classmethod\n    def _iterate_related_models(  # noqa: CCR001\n        cls,\n        node_list: Optional[NodeList] = None,\n        parsed_map: Optional[Dict] = None,\n        source_relation: Optional[str] = None,\n        recurrent: bool = False,\n    ) -&gt; List[str]:\n        \"\"\"\n        Iterates related models recursively to extract relation strings of\n        nested not visited models.\n\n        :return: list of relation strings to be passed to select_related\n        :rtype: List[str]\n        \"\"\"\n        if not node_list:\n            if cls.__relation_map__:\n                return cls.__relation_map__\n            node_list = NodeList()\n            parsed_map = dict()\n            current_node = node_list.add(node_class=cls)\n        else:\n            current_node = node_list[-1]\n        relations = sorted(cls.extract_related_names())\n        processed_relations: List[str] = []\n        for relation in relations:\n            if not current_node.visited(relation):\n                target_model = cls.ormar_config.model_fields[relation].to\n                node_list.add(\n                    node_class=target_model,\n                    relation_name=relation,\n                    parent_node=current_node,\n                )\n                relation_key = f\"{cls.get_name()}_{relation}\"\n                parsed_map = cast(Dict, parsed_map)\n                deep_relations = parsed_map.get(relation_key)\n                if not deep_relations:\n                    deep_relations = target_model._iterate_related_models(\n                        source_relation=relation,\n                        node_list=node_list,\n                        recurrent=True,\n                        parsed_map=parsed_map,\n                    )\n                    parsed_map[relation_key] = deep_relations\n                processed_relations.extend(deep_relations)\n\n        result = cls._get_final_relations(processed_relations, source_relation)\n        if not recurrent:\n            cls.__relation_map__ = result\n        return result\n\n    @staticmethod\n    def _get_final_relations(\n        processed_relations: List, source_relation: Optional[str]\n    ) -&gt; List[str]:\n        \"\"\"\n        Helper method to prefix nested relation strings with current source relation\n\n        :param processed_relations: list of already processed relation str\n        :type processed_relations: List[str]\n        :param source_relation: name of the current relation\n        :type source_relation: str\n        :return: list of relation strings to be passed to select_related\n        :rtype: List[str]\n        \"\"\"\n        if processed_relations:\n            final_relations = [\n                f\"{source_relation + '__' if source_relation else ''}{relation}\"\n                for relation in processed_relations\n            ]\n        else:\n            final_relations = [source_relation] if source_relation else []\n        return final_relations\n</code></pre>"},{"location":"api/models/mixins/relation_mixin/#ormar.models.mixins.relation_mixin.RelationMixin.extract_db_own_fields","title":"<code>extract_db_own_fields()</code>  <code>classmethod</code>","text":"<p>Returns only fields that are stored in the own database table, exclude all related fields. :return: set of model fields with relation fields excluded :rtype: Set</p> Source code in <code>ormar/models/mixins/relation_mixin.py</code> <pre><code>@classmethod\ndef extract_db_own_fields(cls) -&gt; Set:\n    \"\"\"\n    Returns only fields that are stored in the own database table, exclude all\n    related fields.\n    :return: set of model fields with relation fields excluded\n    :rtype: Set\n    \"\"\"\n    related_names = cls.extract_related_names()\n    self_fields = {\n        name\n        for name in cls.ormar_config.model_fields.keys()\n        if name not in related_names\n    }\n    return self_fields\n</code></pre>"},{"location":"api/models/mixins/relation_mixin/#ormar.models.mixins.relation_mixin.RelationMixin.extract_related_fields","title":"<code>extract_related_fields()</code>  <code>classmethod</code>","text":"<p>Returns List of ormar Fields for all relations declared on a model. List is cached in cls._related_fields for quicker access.</p> <p>:return: list of related fields :rtype: List</p> Source code in <code>ormar/models/mixins/relation_mixin.py</code> <pre><code>@classmethod\ndef extract_related_fields(cls) -&gt; List[\"ForeignKeyField\"]:\n    \"\"\"\n    Returns List of ormar Fields for all relations declared on a model.\n    List is cached in cls._related_fields for quicker access.\n\n    :return: list of related fields\n    :rtype: List\n    \"\"\"\n    if cls._related_fields is not None:\n        return cls._related_fields\n\n    related_fields = []\n    for name in cls.extract_related_names().union(cls.extract_through_names()):\n        related_fields.append(\n            cast(\"ForeignKeyField\", cls.ormar_config.model_fields[name])\n        )\n    cls._related_fields = related_fields\n\n    return related_fields\n</code></pre>"},{"location":"api/models/mixins/relation_mixin/#ormar.models.mixins.relation_mixin.RelationMixin.extract_related_names","title":"<code>extract_related_names()</code>  <code>classmethod</code>","text":"<p>Returns List of fields names for all relations declared on a model. List is cached in cls._related_names for quicker access.</p> <p>:return: set of related fields names :rtype: Set</p> Source code in <code>ormar/models/mixins/relation_mixin.py</code> <pre><code>@classmethod\ndef extract_related_names(cls) -&gt; Set[str]:\n    \"\"\"\n    Returns List of fields names for all relations declared on a model.\n    List is cached in cls._related_names for quicker access.\n\n    :return: set of related fields names\n    :rtype: Set\n    \"\"\"\n    if cls._related_names is not None:\n        return cls._related_names\n\n    related_names = set()\n    for name, field in cls.ormar_config.model_fields.items():\n        if (\n            isinstance(field, BaseField)\n            and field.is_relation\n            and not field.is_through\n            and not field.skip_field\n        ):\n            related_names.add(name)\n    cls._related_names = related_names\n\n    return related_names\n</code></pre>"},{"location":"api/models/mixins/relation_mixin/#ormar.models.mixins.relation_mixin.RelationMixin.extract_through_names","title":"<code>extract_through_names()</code>  <code>classmethod</code>","text":"<p>Extracts related fields through names which are shortcuts to through models.</p> <p>:return: set of related through fields names :rtype: Set</p> Source code in <code>ormar/models/mixins/relation_mixin.py</code> <pre><code>@classmethod\ndef extract_through_names(cls) -&gt; Set[str]:\n    \"\"\"\n    Extracts related fields through names which are shortcuts to through models.\n\n    :return: set of related through fields names\n    :rtype: Set\n    \"\"\"\n    if cls._through_names is not None:\n        return cls._through_names\n\n    related_names = set()\n    for name, field in cls.ormar_config.model_fields.items():\n        if isinstance(field, BaseField) and field.is_through:\n            related_names.add(name)\n\n    cls._through_names = related_names\n    return related_names\n</code></pre>"},{"location":"api/models/mixins/save_mixin/","title":"save_mixin","text":""},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin","title":"<code>SavePrepareMixin</code>","text":"<p>               Bases: <code>RelationMixin</code>, <code>AliasMixin</code></p> <p>Used to prepare models to be saved in database</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>class SavePrepareMixin(RelationMixin, AliasMixin):\n    \"\"\"\n    Used to prepare models to be saved in database\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma: nocover\n        _skip_ellipsis: Callable\n        _json_fields: Set[str]\n        _bytes_fields: Set[str]\n        __pydantic_core_schema__: CoreSchema\n        __ormar_fields_validators__: Optional[\n            Dict[str, SchemaValidator | PluggableSchemaValidator]\n        ]\n\n    @classmethod\n    def prepare_model_to_save(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Combines all preparation methods before saving.\n        Removes primary key for if it's nullable or autoincrement pk field,\n        and it's set to None.\n        Substitute related models with their primary key values as fk column.\n        Populates the default values for field with default set and no value.\n        Translate columns into aliases (db names).\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict[str, str]\n        \"\"\"\n        new_kwargs = cls._remove_pk_from_kwargs(new_kwargs)\n        new_kwargs = cls._remove_not_ormar_fields(new_kwargs)\n        new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n        new_kwargs = cls.populate_default_values(new_kwargs)\n        new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n        new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n        return new_kwargs\n\n    @classmethod\n    def prepare_model_to_update(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Combines all preparation methods before updating.\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be updated\n        :rtype: Dict[str, str]\n        \"\"\"\n        new_kwargs = cls.parse_non_db_fields(new_kwargs)\n        new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n        new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n        new_kwargs = cls.dump_all_json_fields_to_str(new_kwargs)\n        new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n        new_kwargs = cls.translate_enum_columns(new_kwargs)\n        return new_kwargs\n\n    @classmethod\n    def translate_enum_columns(cls, new_kwargs: dict) -&gt; dict:\n        for key, value in new_kwargs.items():\n            if isinstance(value, Enum):\n                new_kwargs[key] = value.name\n        return new_kwargs\n\n    @classmethod\n    def _remove_not_ormar_fields(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Removes primary key for if it's nullable or autoincrement pk field,\n        and it's set to None.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict[str, str]\n        \"\"\"\n        ormar_fields = {k for k, v in cls.ormar_config.model_fields.items()}\n        new_kwargs = {k: v for k, v in new_kwargs.items() if k in ormar_fields}\n        return new_kwargs\n\n    @classmethod\n    def _remove_pk_from_kwargs(cls, new_kwargs: dict) -&gt; dict:\n        \"\"\"\n        Removes primary key for if it's nullable or autoincrement pk field,\n        and it's set to None.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict[str, str]\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict[str, str]\n        \"\"\"\n        pkname = cls.ormar_config.pkname\n        pk = cls.ormar_config.model_fields[pkname]\n        if new_kwargs.get(pkname, ormar.Undefined) is None and (\n            pk.nullable or pk.autoincrement\n        ):\n            del new_kwargs[pkname]\n        return new_kwargs\n\n    @classmethod\n    def parse_non_db_fields(cls, model_dict: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes uuid fields\n        to strings in bulk_update.\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for name, field in cls.ormar_config.model_fields.items():\n            if field.__type__ == uuid.UUID and name in model_dict:\n                parsers = {\"string\": lambda x: str(x), \"hex\": lambda x: \"%.32x\" % x.int}\n                uuid_format = field.column_type.uuid_format\n                parser: Callable[..., Any] = parsers.get(uuid_format, lambda x: x)\n                model_dict[name] = parser(model_dict[name])\n        return model_dict\n\n    @classmethod\n    def substitute_models_with_pks(cls, model_dict: Dict) -&gt; Dict:  # noqa  CCR001\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes all related\n        models that are stored as foreign keys to their fk value.\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for field in cls.extract_related_names():\n            field_value = model_dict.get(field, None)\n            if field_value is not None:\n                target_field = cls.ormar_config.model_fields[field]\n                target_pkname = target_field.to.ormar_config.pkname\n                if isinstance(field_value, ormar.Model):  # pragma: no cover\n                    pk_value = getattr(field_value, target_pkname)\n                    if not pk_value:\n                        raise ModelPersistenceError(\n                            f\"You cannot save {field_value.get_name()} \"\n                            f\"model without pk set!\"\n                        )\n                    model_dict[field] = pk_value\n                elif isinstance(field_value, (list, dict)) and field_value:\n                    if isinstance(field_value, list):\n                        model_dict[field] = [\n                            target.get(target_pkname) for target in field_value\n                        ]\n                    else:\n                        model_dict[field] = field_value.get(target_pkname)\n                else:\n                    model_dict.pop(field, None)\n        return model_dict\n\n    @classmethod\n    def reconvert_str_to_bytes(cls, model_dict: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes\n        all bytes fields that are represented as strings back into bytes.\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        bytes_base64_fields = {\n            name\n            for name, field in cls.ormar_config.model_fields.items()\n            if field.represent_as_base64_str\n        }\n        for key, value in model_dict.items():\n            if key in cls._bytes_fields and isinstance(value, str):\n                model_dict[key] = (\n                    value.encode(\"utf-8\")\n                    if key not in bytes_base64_fields\n                    else base64.b64decode(value)\n                )\n        return model_dict\n\n    @classmethod\n    def dump_all_json_fields_to_str(cls, model_dict: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and changes\n        all json fields into strings\n\n        :param model_dict: dictionary of model that is about to be saved\n        :type model_dict: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for key, value in model_dict.items():\n            if key in cls._json_fields:\n                model_dict[key] = encode_json(value)\n        return model_dict\n\n    @classmethod\n    def populate_default_values(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and populates the default\n        value on the fields that have the default value set, but no actual value was\n        passed by the user.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        for field_name, field in cls.ormar_config.model_fields.items():\n            if field_name not in new_kwargs and field.has_default(use_server=False):\n                new_kwargs[field_name] = field.get_default()\n            # clear fields with server_default set as None\n            if (\n                field.server_default is not None\n                and new_kwargs.get(field_name, None) is None\n            ):\n                new_kwargs.pop(field_name, None)\n        return new_kwargs\n\n    @classmethod\n    def validate_enums(cls, new_kwargs: Dict) -&gt; Dict:\n        \"\"\"\n        Receives dictionary of model that is about to be saved and validates the\n        fields with choices set to see if the value is allowed.\n\n        :param new_kwargs: dictionary of model that is about to be saved\n        :type new_kwargs: Dict\n        :return: dictionary of model that is about to be saved\n        :rtype: Dict\n        \"\"\"\n        validators = cls._build_individual_schema_validator()\n        for key, value in new_kwargs.items():\n            if key in validators:\n                validators[key].validate_python(value)\n        return new_kwargs\n\n    @classmethod\n    def _build_individual_schema_validator(cls) -&gt; Any:\n        if cls.__ormar_fields_validators__ is not None:\n            return cls.__ormar_fields_validators__\n        field_validators = {}\n        for key, field in cls._extract_pydantic_fields().items():\n            if cls.__pydantic_core_schema__[\"type\"] == \"definitions\":\n                schema = {\n                    \"type\": \"definitions\",\n                    \"schema\": field[\"schema\"],\n                    \"definitions\": cls.__pydantic_core_schema__[\"definitions\"],\n                }\n            else:\n                schema = field[\"schema\"]\n            field_validators[key] = create_schema_validator(\n                schema, cls, cls.__module__, cls.__qualname__, \"BaseModel\"\n            )\n        cls.__ormar_fields_validators__ = field_validators\n        return cls.__ormar_fields_validators__\n\n    @classmethod\n    def _extract_pydantic_fields(cls) -&gt; Any:\n        if cls.__pydantic_core_schema__[\"type\"] == \"model\":\n            return cls.__pydantic_core_schema__[\"schema\"][\"fields\"]\n        elif cls.__pydantic_core_schema__[\"type\"] == \"definitions\":\n            main_schema = cls.__pydantic_core_schema__[\"schema\"]\n            if \"schema_ref\" in main_schema:\n                reference_id = main_schema[\"schema_ref\"]\n                return next(\n                    ref\n                    for ref in cls.__pydantic_core_schema__[\"definitions\"]\n                    if ref[\"ref\"] == reference_id\n                )[\"schema\"][\"fields\"]\n            return main_schema[\"schema\"][\"fields\"]\n\n    @staticmethod\n    async def _upsert_model(\n        instance: \"Model\",\n        save_all: bool,\n        previous_model: Optional[\"Model\"],\n        relation_field: Optional[\"ForeignKeyField\"],\n        update_count: int,\n    ) -&gt; int:\n        \"\"\"\n        Method updates given instance if:\n\n        * instance is not saved or\n        * instance have no pk or\n        * save_all=True flag is set\n\n        and instance is not __pk_only__.\n\n        If relation leading to instance is a ManyToMany also the through model is saved\n\n        :param instance: current model to upsert\n        :type instance: Model\n        :param save_all: flag if all models should be saved or only not saved ones\n        :type save_all: bool\n        :param relation_field: field with relation\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        :param update_count: no of updated models\n        :type update_count: int\n        :return: no of updated models\n        :rtype: int\n        \"\"\"\n        if (\n            save_all or not instance.pk or not instance.saved\n        ) and not instance.__pk_only__:\n            await instance.upsert(__force_save__=True)\n            if relation_field and relation_field.is_multi:\n                await instance._upsert_through_model(\n                    instance=instance,\n                    relation_field=relation_field,\n                    previous_model=cast(\"Model\", previous_model),\n                )\n            update_count += 1\n        return update_count\n\n    @staticmethod\n    async def _upsert_through_model(\n        instance: \"Model\", previous_model: \"Model\", relation_field: \"ForeignKeyField\"\n    ) -&gt; None:\n        \"\"\"\n        Upsert through model for m2m relation.\n\n        :param instance: current model to upsert\n        :type instance: Model\n        :param relation_field: field with relation\n        :type relation_field: Optional[ForeignKeyField]\n        :param previous_model: previous model from which method came\n        :type previous_model: Model\n        \"\"\"\n        through_name = previous_model.ormar_config.model_fields[\n            relation_field.name\n        ].through.get_name()\n        through = getattr(instance, through_name)\n        if through:\n            through_dict = through.model_dump(exclude=through.extract_related_names())\n        else:\n            through_dict = {}\n        await getattr(\n            previous_model, relation_field.name\n        ).queryset_proxy.upsert_through_instance(instance, **through_dict)\n\n    async def _update_relation_list(\n        self,\n        fields_list: Collection[\"ForeignKeyField\"],\n        follow: bool,\n        save_all: bool,\n        relation_map: Dict,\n        update_count: int,\n    ) -&gt; int:\n        \"\"\"\n        Internal method used in save_related to follow deeper from\n        related models and update numbers of updated related instances.\n\n        :type save_all: flag if all models should be saved\n        :type save_all: bool\n        :param fields_list: list of ormar fields to follow and save\n        :type fields_list: Collection[\"ForeignKeyField\"]\n        :param relation_map: map of relations to follow\n        :type relation_map: Dict\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :param update_count: internal parameter for recursive calls -\n        number of updated instances\n        :type update_count: int\n        :return: tuple of update count and visited\n        :rtype: int\n        \"\"\"\n        for field in fields_list:\n            values = self._get_field_values(name=field.name)\n            for value in values:\n                if follow:\n                    update_count = await value.save_related(\n                        follow=follow,\n                        save_all=save_all,\n                        relation_map=self._skip_ellipsis(  # type: ignore\n                            relation_map, field.name, default_return={}\n                        ),\n                        update_count=update_count,\n                        previous_model=self,\n                        relation_field=field,\n                    )\n                else:\n                    update_count = await value._upsert_model(\n                        instance=value,\n                        save_all=save_all,\n                        previous_model=self,\n                        relation_field=field,\n                        update_count=update_count,\n                    )\n        return update_count\n\n    def _get_field_values(self, name: str) -&gt; List:\n        \"\"\"\n        Extract field values and ensures it is a list.\n\n        :param name: name of the field\n        :type name: str\n        :return: list of values\n        :rtype: List\n        \"\"\"\n        values = getattr(self, name) or []\n        if not isinstance(values, list):\n            values = [values]\n        return values\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.dump_all_json_fields_to_str","title":"<code>dump_all_json_fields_to_str(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes all json fields into strings</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef dump_all_json_fields_to_str(cls, model_dict: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes\n    all json fields into strings\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for key, value in model_dict.items():\n        if key in cls._json_fields:\n            model_dict[key] = encode_json(value)\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.parse_non_db_fields","title":"<code>parse_non_db_fields(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes uuid fields to strings in bulk_update.</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef parse_non_db_fields(cls, model_dict: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes uuid fields\n    to strings in bulk_update.\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for name, field in cls.ormar_config.model_fields.items():\n        if field.__type__ == uuid.UUID and name in model_dict:\n            parsers = {\"string\": lambda x: str(x), \"hex\": lambda x: \"%.32x\" % x.int}\n            uuid_format = field.column_type.uuid_format\n            parser: Callable[..., Any] = parsers.get(uuid_format, lambda x: x)\n            model_dict[name] = parser(model_dict[name])\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.populate_default_values","title":"<code>populate_default_values(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and populates the default value on the fields that have the default value set, but no actual value was passed by the user.</p> <p>:param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef populate_default_values(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and populates the default\n    value on the fields that have the default value set, but no actual value was\n    passed by the user.\n\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for field_name, field in cls.ormar_config.model_fields.items():\n        if field_name not in new_kwargs and field.has_default(use_server=False):\n            new_kwargs[field_name] = field.get_default()\n        # clear fields with server_default set as None\n        if (\n            field.server_default is not None\n            and new_kwargs.get(field_name, None) is None\n        ):\n            new_kwargs.pop(field_name, None)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.prepare_model_to_save","title":"<code>prepare_model_to_save(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Combines all preparation methods before saving. Removes primary key for if it's nullable or autoincrement pk field, and it's set to None. Substitute related models with their primary key values as fk column. Populates the default values for field with default set and no value. Translate columns into aliases (db names).</p> <p>:param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] :return: dictionary of model that is about to be saved :rtype: Dict[str, str]</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef prepare_model_to_save(cls, new_kwargs: dict) -&gt; dict:\n    \"\"\"\n    Combines all preparation methods before saving.\n    Removes primary key for if it's nullable or autoincrement pk field,\n    and it's set to None.\n    Substitute related models with their primary key values as fk column.\n    Populates the default values for field with default set and no value.\n    Translate columns into aliases (db names).\n\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict[str, str]\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict[str, str]\n    \"\"\"\n    new_kwargs = cls._remove_pk_from_kwargs(new_kwargs)\n    new_kwargs = cls._remove_not_ormar_fields(new_kwargs)\n    new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n    new_kwargs = cls.populate_default_values(new_kwargs)\n    new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n    new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.prepare_model_to_update","title":"<code>prepare_model_to_update(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Combines all preparation methods before updating. :param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict[str, str] :return: dictionary of model that is about to be updated :rtype: Dict[str, str]</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef prepare_model_to_update(cls, new_kwargs: dict) -&gt; dict:\n    \"\"\"\n    Combines all preparation methods before updating.\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict[str, str]\n    :return: dictionary of model that is about to be updated\n    :rtype: Dict[str, str]\n    \"\"\"\n    new_kwargs = cls.parse_non_db_fields(new_kwargs)\n    new_kwargs = cls.substitute_models_with_pks(new_kwargs)\n    new_kwargs = cls.reconvert_str_to_bytes(new_kwargs)\n    new_kwargs = cls.dump_all_json_fields_to_str(new_kwargs)\n    new_kwargs = cls.translate_columns_to_aliases(new_kwargs)\n    new_kwargs = cls.translate_enum_columns(new_kwargs)\n    return new_kwargs\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.reconvert_str_to_bytes","title":"<code>reconvert_str_to_bytes(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes all bytes fields that are represented as strings back into bytes.</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef reconvert_str_to_bytes(cls, model_dict: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes\n    all bytes fields that are represented as strings back into bytes.\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    bytes_base64_fields = {\n        name\n        for name, field in cls.ormar_config.model_fields.items()\n        if field.represent_as_base64_str\n    }\n    for key, value in model_dict.items():\n        if key in cls._bytes_fields and isinstance(value, str):\n            model_dict[key] = (\n                value.encode(\"utf-8\")\n                if key not in bytes_base64_fields\n                else base64.b64decode(value)\n            )\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.substitute_models_with_pks","title":"<code>substitute_models_with_pks(model_dict)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and changes all related models that are stored as foreign keys to their fk value.</p> <p>:param model_dict: dictionary of model that is about to be saved :type model_dict: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef substitute_models_with_pks(cls, model_dict: Dict) -&gt; Dict:  # noqa  CCR001\n    \"\"\"\n    Receives dictionary of model that is about to be saved and changes all related\n    models that are stored as foreign keys to their fk value.\n\n    :param model_dict: dictionary of model that is about to be saved\n    :type model_dict: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    for field in cls.extract_related_names():\n        field_value = model_dict.get(field, None)\n        if field_value is not None:\n            target_field = cls.ormar_config.model_fields[field]\n            target_pkname = target_field.to.ormar_config.pkname\n            if isinstance(field_value, ormar.Model):  # pragma: no cover\n                pk_value = getattr(field_value, target_pkname)\n                if not pk_value:\n                    raise ModelPersistenceError(\n                        f\"You cannot save {field_value.get_name()} \"\n                        f\"model without pk set!\"\n                    )\n                model_dict[field] = pk_value\n            elif isinstance(field_value, (list, dict)) and field_value:\n                if isinstance(field_value, list):\n                    model_dict[field] = [\n                        target.get(target_pkname) for target in field_value\n                    ]\n                else:\n                    model_dict[field] = field_value.get(target_pkname)\n            else:\n                model_dict.pop(field, None)\n    return model_dict\n</code></pre>"},{"location":"api/models/mixins/save_mixin/#ormar.models.mixins.save_mixin.SavePrepareMixin.validate_enums","title":"<code>validate_enums(new_kwargs)</code>  <code>classmethod</code>","text":"<p>Receives dictionary of model that is about to be saved and validates the fields with choices set to see if the value is allowed.</p> <p>:param new_kwargs: dictionary of model that is about to be saved :type new_kwargs: Dict :return: dictionary of model that is about to be saved :rtype: Dict</p> Source code in <code>ormar/models/mixins/save_mixin.py</code> <pre><code>@classmethod\ndef validate_enums(cls, new_kwargs: Dict) -&gt; Dict:\n    \"\"\"\n    Receives dictionary of model that is about to be saved and validates the\n    fields with choices set to see if the value is allowed.\n\n    :param new_kwargs: dictionary of model that is about to be saved\n    :type new_kwargs: Dict\n    :return: dictionary of model that is about to be saved\n    :rtype: Dict\n    \"\"\"\n    validators = cls._build_individual_schema_validator()\n    for key, value in new_kwargs.items():\n        if key in validators:\n            validators[key].validate_python(value)\n    return new_kwargs\n</code></pre>"},{"location":"api/protocols/","title":"protocols","text":""},{"location":"api/protocols/queryset_protocol/","title":"queryset_protocol","text":""},{"location":"api/protocols/relation_protocol/","title":"relation_protocol","text":""},{"location":"api/queryset/","title":"queryset","text":"<p>Contains QuerySet and different Query classes to allow for constructing of sql queries.</p>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor","title":"<code>FieldAccessor</code>","text":"<p>Helper to access ormar fields directly from Model class also for nested models attributes.</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>class FieldAccessor:\n    \"\"\"\n    Helper to access ormar fields directly from Model class also for nested\n    models attributes.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_model: Type[\"Model\"],\n        field: Optional[\"BaseField\"] = None,\n        model: Optional[Type[\"Model\"]] = None,\n        access_chain: str = \"\",\n    ) -&gt; None:\n        self._source_model = source_model\n        self._field = field\n        self._model = model\n        self._access_chain = access_chain\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"\n        Accessor return new accessor for each field and nested models.\n        Thanks to that operator overload is possible to use in filter.\n\n        :param item: attribute name\n        :type item: str\n        :return: FieldAccessor for field or nested model\n        :rtype: ormar.queryset.field_accessor.FieldAccessor\n        \"\"\"\n        if (\n            object.__getattribute__(self, \"_field\")\n            and item == object.__getattribute__(self, \"_field\").name\n        ):\n            return self._field\n\n        if (\n            object.__getattribute__(self, \"_model\")\n            and item\n            in object.__getattribute__(self, \"_model\").ormar_config.model_fields\n        ):\n            field = cast(\"Model\", self._model).ormar_config.model_fields[item]\n            if field.is_relation:\n                return FieldAccessor(\n                    source_model=self._source_model,\n                    model=field.to,\n                    access_chain=self._access_chain + f\"__{item}\",\n                )\n            else:\n                return FieldAccessor(\n                    source_model=self._source_model,\n                    field=field,\n                    access_chain=self._access_chain + f\"__{item}\",\n                )\n        return object.__getattribute__(self, item)  # pragma: no cover\n\n    def _check_field(self) -&gt; None:\n        if not self._field:\n            raise AttributeError(\n                \"Cannot filter by Model, you need to provide model name\"\n            )\n\n    def _select_operator(self, op: str, other: Any) -&gt; FilterGroup:\n        self._check_field()\n        filter_kwg = {self._access_chain + f\"__{METHODS_TO_OPERATORS[op]}\": other}\n        return FilterGroup(**filter_kwg)\n\n    def __eq__(self, other: Any) -&gt; FilterGroup:  # type: ignore\n        \"\"\"\n        overloaded to work as sql `column = &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__eq__\", other=other)\n\n    def __ge__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &gt;= &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__ge__\", other=other)\n\n    def __gt__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &gt; &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__gt__\", other=other)\n\n    def __le__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &lt;= &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__le__\", other=other)\n\n    def __lt__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &lt; &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__lt__\", other=other)\n\n    def __mod__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__mod__\", other=other)\n\n    def __lshift__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"in\", other=other)\n\n    def __rshift__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column IS NULL`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"isnull\", other=True)\n\n    def in_(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"in\", other=other)\n\n    def iexact(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column = &lt;VALUE&gt;` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"iexact\", other=other)\n\n    def contains(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"contains\", other=other)\n\n    def icontains(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;%'` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"icontains\", other=other)\n\n    def startswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '&lt;VALUE&gt;%'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"startswith\", other=other)\n\n    def istartswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"istartswith\", other=other)\n\n    def endswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"endswith\", other=other)\n\n    def iendswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"iendswith\", other=other)\n\n    def isnull(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column IS NULL` or `IS NOT NULL`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"isnull\", other=other)\n\n    def asc(self) -&gt; OrderAction:\n        \"\"\"\n        works as sql `column asc`\n\n        :return: OrderGroup for operator\n        :rtype: ormar.queryset.actions.OrderGroup\n        \"\"\"\n        return OrderAction(order_str=self._access_chain, model_cls=self._source_model)\n\n    def desc(self) -&gt; OrderAction:\n        \"\"\"\n        works as sql `column desc`\n\n        :return: OrderGroup for operator\n        :rtype: ormar.queryset.actions.OrderGroup\n        \"\"\"\n        return OrderAction(\n            order_str=\"-\" + self._access_chain, model_cls=self._source_model\n        )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__eq__","title":"<code>__eq__(other)</code>","text":"<p>overloaded to work as sql <code>column = &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __eq__(self, other: Any) -&gt; FilterGroup:  # type: ignore\n    \"\"\"\n    overloaded to work as sql `column = &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__eq__\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__ge__","title":"<code>__ge__(other)</code>","text":"<p>overloaded to work as sql <code>column &gt;= &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __ge__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &gt;= &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__ge__\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Accessor return new accessor for each field and nested models. Thanks to that operator overload is possible to use in filter.</p> <p>:param item: attribute name :type item: str :return: FieldAccessor for field or nested model :rtype: ormar.queryset.field_accessor.FieldAccessor</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    \"\"\"\n    Accessor return new accessor for each field and nested models.\n    Thanks to that operator overload is possible to use in filter.\n\n    :param item: attribute name\n    :type item: str\n    :return: FieldAccessor for field or nested model\n    :rtype: ormar.queryset.field_accessor.FieldAccessor\n    \"\"\"\n    if (\n        object.__getattribute__(self, \"_field\")\n        and item == object.__getattribute__(self, \"_field\").name\n    ):\n        return self._field\n\n    if (\n        object.__getattribute__(self, \"_model\")\n        and item\n        in object.__getattribute__(self, \"_model\").ormar_config.model_fields\n    ):\n        field = cast(\"Model\", self._model).ormar_config.model_fields[item]\n        if field.is_relation:\n            return FieldAccessor(\n                source_model=self._source_model,\n                model=field.to,\n                access_chain=self._access_chain + f\"__{item}\",\n            )\n        else:\n            return FieldAccessor(\n                source_model=self._source_model,\n                field=field,\n                access_chain=self._access_chain + f\"__{item}\",\n            )\n    return object.__getattribute__(self, item)  # pragma: no cover\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__gt__","title":"<code>__gt__(other)</code>","text":"<p>overloaded to work as sql <code>column &gt; &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __gt__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &gt; &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__gt__\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__le__","title":"<code>__le__(other)</code>","text":"<p>overloaded to work as sql <code>column &lt;= &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __le__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &lt;= &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__le__\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>overloaded to work as sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __lshift__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"in\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__lt__","title":"<code>__lt__(other)</code>","text":"<p>overloaded to work as sql <code>column &lt; &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __lt__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &lt; &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__lt__\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__mod__","title":"<code>__mod__(other)</code>","text":"<p>overloaded to work as sql <code>column LIKE '%&lt;VALUE&gt;%'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __mod__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__mod__\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.__rshift__","title":"<code>__rshift__(other)</code>","text":"<p>overloaded to work as sql <code>column IS NULL</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __rshift__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column IS NULL`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"isnull\", other=True)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.asc","title":"<code>asc()</code>","text":"<p>works as sql <code>column asc</code></p> <p>:return: OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def asc(self) -&gt; OrderAction:\n    \"\"\"\n    works as sql `column asc`\n\n    :return: OrderGroup for operator\n    :rtype: ormar.queryset.actions.OrderGroup\n    \"\"\"\n    return OrderAction(order_str=self._access_chain, model_cls=self._source_model)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.contains","title":"<code>contains(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;%'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def contains(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"contains\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.desc","title":"<code>desc()</code>","text":"<p>works as sql <code>column desc</code></p> <p>:return: OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def desc(self) -&gt; OrderAction:\n    \"\"\"\n    works as sql `column desc`\n\n    :return: OrderGroup for operator\n    :rtype: ormar.queryset.actions.OrderGroup\n    \"\"\"\n    return OrderAction(\n        order_str=\"-\" + self._access_chain, model_cls=self._source_model\n    )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.endswith","title":"<code>endswith(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def endswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"endswith\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.icontains","title":"<code>icontains(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;%'</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def icontains(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;%'` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"icontains\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.iendswith","title":"<code>iendswith(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;'</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def iendswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"iendswith\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.iexact","title":"<code>iexact(other)</code>","text":"<p>works as sql <code>column = &lt;VALUE&gt;</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def iexact(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column = &lt;VALUE&gt;` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"iexact\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.in_","title":"<code>in_(other)</code>","text":"<p>works as sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def in_(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"in\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.isnull","title":"<code>isnull(other)</code>","text":"<p>works as sql <code>column IS NULL</code> or <code>IS NOT NULL</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def isnull(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column IS NULL` or `IS NOT NULL`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"isnull\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.istartswith","title":"<code>istartswith(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;'</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def istartswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"istartswith\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FieldAccessor.startswith","title":"<code>startswith(other)</code>","text":"<p>works as sql <code>column LIKE '&lt;VALUE&gt;%'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def startswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '&lt;VALUE&gt;%'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"startswith\", other=other)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FilterAction","title":"<code>FilterAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Filter Actions is populated by queryset when filter() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>class FilterAction(QueryAction):\n    \"\"\"\n    Filter Actions is populated by queryset when filter() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(self, filter_str: str, value: Any, model_cls: Type[\"Model\"]) -&gt; None:\n        super().__init__(query_str=filter_str, model_cls=model_cls)\n        self.filter_value = value\n        self._escape_characters_in_clause()\n\n    def has_escaped_characters(self) -&gt; bool:\n        \"\"\"Check if value is a string that contains characters to escape\"\"\"\n        return isinstance(self.filter_value, str) and any(\n            c for c in ESCAPE_CHARACTERS if c in self.filter_value\n        )\n\n    def _split_value_into_parts(self, query_str: str) -&gt; None:\n        parts = query_str.split(\"__\")\n        if parts[-1] in FILTER_OPERATORS:\n            self.operator = parts[-1]\n            self.field_name = parts[-2]\n            self.related_parts = parts[:-2]\n        else:\n            self.operator = \"exact\"\n            self.field_name = parts[-1]\n            self.related_parts = parts[:-1]\n\n    def _escape_characters_in_clause(self) -&gt; None:\n        \"\"\"\n        Escapes the special characters [\"%\", \"_\"] if needed.\n        Adds `%` for `like` queries.\n\n        :raises QueryDefinitionError: if contains or icontains is used with\n        ormar model instance\n        :return: escaped value and flag if escaping is needed\n        :rtype: Tuple[Any, bool]\n        \"\"\"\n        self.has_escaped_character = False\n        if self.operator in [\n            \"contains\",\n            \"icontains\",\n            \"startswith\",\n            \"istartswith\",\n            \"endswith\",\n            \"iendswith\",\n        ]:\n            if isinstance(self.filter_value, ormar.Model):\n                raise QueryDefinitionError(\n                    \"You cannot use contains and icontains with instance of the Model\"\n                )\n            self.has_escaped_character = self.has_escaped_characters()\n            if self.has_escaped_character:\n                self._escape_chars()\n            self._prefix_suffix_quote()\n\n    def _escape_chars(self) -&gt; None:\n        \"\"\"Actually replaces chars to escape in value\"\"\"\n        for char in ESCAPE_CHARACTERS:\n            self.filter_value = self.filter_value.replace(char, f\"\\\\{char}\")\n\n    def _prefix_suffix_quote(self) -&gt; None:\n        \"\"\"\n        Adds % to the beginning of the value if operator checks for containment and not\n        starts with.\n\n        Adds % to the end of the value if operator checks for containment and not\n        end with.\n        :return:\n        :rtype:\n        \"\"\"\n        prefix = \"%\" if \"start\" not in self.operator else \"\"\n        sufix = \"%\" if \"end\" not in self.operator else \"\"\n        self.filter_value = f\"{prefix}{self.filter_value}{sufix}\"\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.BinaryExpression:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        if isinstance(self.filter_value, ormar.Model):\n            self.filter_value = self.filter_value.pk\n\n        op_attr = FILTER_OPERATORS[self.operator]\n        if self.operator == \"isnull\":\n            op_attr = \"is_\" if self.filter_value else \"isnot\"\n            filter_value = None\n        else:\n            filter_value = self.filter_value\n        if self.table_prefix:\n            aliased_table = (\n                self.source_model.ormar_config.alias_manager.prefixed_table_name(\n                    self.table_prefix, self.column.table\n                )\n            )\n            aliased_column = getattr(aliased_table.c, self.column.name)\n        else:\n            aliased_column = self.column\n        clause = getattr(aliased_column, op_attr)(filter_value)\n        if self.has_escaped_character:\n            clause.modifiers[\"escape\"] = \"\\\\\"\n        return clause\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FilterAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.BinaryExpression:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    if isinstance(self.filter_value, ormar.Model):\n        self.filter_value = self.filter_value.pk\n\n    op_attr = FILTER_OPERATORS[self.operator]\n    if self.operator == \"isnull\":\n        op_attr = \"is_\" if self.filter_value else \"isnot\"\n        filter_value = None\n    else:\n        filter_value = self.filter_value\n    if self.table_prefix:\n        aliased_table = (\n            self.source_model.ormar_config.alias_manager.prefixed_table_name(\n                self.table_prefix, self.column.table\n            )\n        )\n        aliased_column = getattr(aliased_table.c, self.column.name)\n    else:\n        aliased_column = self.column\n    clause = getattr(aliased_column, op_attr)(filter_value)\n    if self.has_escaped_character:\n        clause.modifiers[\"escape\"] = \"\\\\\"\n    return clause\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FilterAction.has_escaped_characters","title":"<code>has_escaped_characters()</code>","text":"<p>Check if value is a string that contains characters to escape</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>def has_escaped_characters(self) -&gt; bool:\n    \"\"\"Check if value is a string that contains characters to escape\"\"\"\n    return isinstance(self.filter_value, str) and any(\n        c for c in ESCAPE_CHARACTERS if c in self.filter_value\n    )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FilterQuery","title":"<code>FilterQuery</code>","text":"<p>Modifies the select query with given list of where/filter clauses.</p> Source code in <code>ormar/queryset/queries/filter_query.py</code> <pre><code>class FilterQuery:\n    \"\"\"\n    Modifies the select query with given list of where/filter clauses.\n    \"\"\"\n\n    def __init__(\n        self, filter_clauses: List[FilterAction], exclude: bool = False\n    ) -&gt; None:\n        self.exclude = exclude\n        self.filter_clauses = filter_clauses\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies all filter clauses if set.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.filter_clauses:\n            if len(self.filter_clauses) == 1:\n                clause = self.filter_clauses[0].get_text_clause()\n            else:\n                clause = sqlalchemy.sql.and_(\n                    *[x.get_text_clause() for x in self.filter_clauses]\n                )\n            clause = sqlalchemy.sql.not_(clause) if self.exclude else clause\n            expr = expr.where(clause)\n        return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.FilterQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies all filter clauses if set.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/filter_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies all filter clauses if set.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.filter_clauses:\n        if len(self.filter_clauses) == 1:\n            clause = self.filter_clauses[0].get_text_clause()\n        else:\n            clause = sqlalchemy.sql.and_(\n                *[x.get_text_clause() for x in self.filter_clauses]\n            )\n        clause = sqlalchemy.sql.not_(clause) if self.exclude else clause\n        expr = expr.where(clause)\n    return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.LimitQuery","title":"<code>LimitQuery</code>","text":"<p>Modifies the select query with limit clause.</p> Source code in <code>ormar/queryset/queries/limit_query.py</code> <pre><code>class LimitQuery:\n    \"\"\"\n    Modifies the select query with limit clause.\n    \"\"\"\n\n    def __init__(self, limit_count: Optional[int]) -&gt; None:\n        self.limit_count = limit_count\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies the limit clause.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n\n        if self.limit_count is not None:\n            expr = expr.limit(self.limit_count)\n\n        return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.LimitQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies the limit clause.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/limit_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies the limit clause.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n\n    if self.limit_count is not None:\n        expr = expr.limit(self.limit_count)\n\n    return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OffsetQuery","title":"<code>OffsetQuery</code>","text":"<p>Modifies the select query with offset if set</p> Source code in <code>ormar/queryset/queries/offset_query.py</code> <pre><code>class OffsetQuery:\n    \"\"\"\n    Modifies the select query with offset if set\n    \"\"\"\n\n    def __init__(self, query_offset: Optional[int]) -&gt; None:\n        self.query_offset = query_offset\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies the offset clause.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.query_offset:\n            expr = expr.offset(self.query_offset)\n        return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OffsetQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies the offset clause.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/offset_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies the offset clause.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.query_offset:\n        expr = expr.offset(self.query_offset)\n    return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderAction","title":"<code>OrderAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>class OrderAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, order_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        self.direction: str = \"\"\n        super().__init__(query_str=order_str, model_cls=model_cls)\n        self.is_source_model_order = False\n        if alias:\n            self.table_prefix = alias\n        if self.source_model == self.target_model and \"__\" not in self.related_str:\n            self.is_source_model_order = True\n\n    @property\n    def field_alias(self) -&gt; str:\n        return self.target_model.get_column_alias(self.field_name)\n\n    @property\n    def is_postgres_bool(self) -&gt; bool:\n        dialect = self.target_model.ormar_config.database._backend._dialect.name\n        field_type = self.target_model.ormar_config.model_fields[\n            self.field_name\n        ].__type__\n        return dialect == \"postgresql\" and field_type is bool\n\n    def get_field_name_text(self) -&gt; str:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n\n    def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Used in limit sub queries where you need to use aggregated functions\n        in order to order by columns not included in group by. For postgres bool\n        field it's using bool_or function as aggregates does not work with this type\n        of columns.\n\n        :return: min or max function to order\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        if self.direction == \"\":\n            function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n            return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n        function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        dialect = self.target_model.ormar_config.database._backend._dialect\n        quoter = dialect.identifier_preparer.quote\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        table_name = self.table.name\n        field_name = self.field_alias\n        if not prefix:\n            table_name = quoter(table_name)\n        else:\n            table_name = quoter(f\"{prefix}{table_name}\")\n        field_name = quoter(field_name)\n        return text(f\"{table_name}.{field_name} {self.direction}\")\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        if order_str.startswith(\"-\"):\n            self.direction = \"desc\"\n            order_str = order_str[1:]\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n        \"\"\"\n        Checks filter conditions to find if they apply to current join.\n\n        :param target_model: model which is now processed\n        :type target_model: Type[\"Model\"]\n        :param alias: prefix of the relation\n        :type alias: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderAction.check_if_filter_apply","title":"<code>check_if_filter_apply(target_model, alias)</code>","text":"<p>Checks filter conditions to find if they apply to current join.</p> <p>:param target_model: model which is now processed :type target_model: Type[\"Model\"] :param alias: prefix of the relation :type alias: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n    \"\"\"\n    Checks filter conditions to find if they apply to current join.\n\n    :param target_model: model which is now processed\n    :type target_model: Type[\"Model\"]\n    :param alias: prefix of the relation\n    :type alias: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderAction.get_field_name_text","title":"<code>get_field_name_text()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_field_name_text(self) -&gt; str:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderAction.get_min_or_max","title":"<code>get_min_or_max()</code>","text":"<p>Used in limit sub queries where you need to use aggregated functions in order to order by columns not included in group by. For postgres bool field it's using bool_or function as aggregates does not work with this type of columns.</p> <p>:return: min or max function to order :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Used in limit sub queries where you need to use aggregated functions\n    in order to order by columns not included in group by. For postgres bool\n    field it's using bool_or function as aggregates does not work with this type\n    of columns.\n\n    :return: min or max function to order\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    if self.direction == \"\":\n        function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n    function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n    return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    dialect = self.target_model.ormar_config.database._backend._dialect\n    quoter = dialect.identifier_preparer.quote\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    table_name = self.table.name\n    field_name = self.field_alias\n    if not prefix:\n        table_name = quoter(table_name)\n    else:\n        table_name = quoter(f\"{prefix}{table_name}\")\n    field_name = quoter(field_name)\n    return text(f\"{table_name}.{field_name} {self.direction}\")\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderQuery","title":"<code>OrderQuery</code>","text":"<p>Modifies the select query with given list of order_by clauses.</p> Source code in <code>ormar/queryset/queries/order_query.py</code> <pre><code>class OrderQuery:\n    \"\"\"\n    Modifies the select query with given list of order_by clauses.\n    \"\"\"\n\n    def __init__(self, sorted_orders: Dict) -&gt; None:\n        self.sorted_orders = sorted_orders\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies all order_by clauses if set.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.sorted_orders:\n            for order in list(self.sorted_orders.values()):\n                if order is not None:\n                    expr = expr.order_by(order)\n        return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.OrderQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies all order_by clauses if set.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/order_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies all order_by clauses if set.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.sorted_orders:\n        for order in list(self.sorted_orders.values()):\n            if order is not None:\n                expr = expr.order_by(order)\n    return expr\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet","title":"<code>QuerySet</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Main class to perform database queries, exposed on each model as objects attribute.</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>class QuerySet(Generic[T]):\n    \"\"\"\n    Main class to perform database queries, exposed on each model as objects attribute.\n    \"\"\"\n\n    def __init__(  # noqa CFQ002\n        self,\n        model_cls: Optional[Type[\"T\"]] = None,\n        filter_clauses: Optional[List] = None,\n        exclude_clauses: Optional[List] = None,\n        select_related: Optional[List] = None,\n        limit_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        excludable: Optional[\"ExcludableItems\"] = None,\n        order_bys: Optional[List] = None,\n        prefetch_related: Optional[List] = None,\n        limit_raw_sql: bool = False,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; None:\n        self.proxy_source_model = proxy_source_model\n        self.model_cls = model_cls\n        self.filter_clauses = [] if filter_clauses is None else filter_clauses\n        self.exclude_clauses = [] if exclude_clauses is None else exclude_clauses\n        self._select_related = [] if select_related is None else select_related\n        self._prefetch_related = [] if prefetch_related is None else prefetch_related\n        self.limit_count = limit_count\n        self.query_offset = offset\n        self._excludable = excludable or ormar.ExcludableItems()\n        self.order_bys = order_bys or []\n        self.limit_sql_raw = limit_raw_sql\n\n    @property\n    def model_config(self) -&gt; \"OrmarConfig\":\n        \"\"\"\n        Shortcut to model class OrmarConfig set on QuerySet model.\n\n        :return: OrmarConfig of the model\n        :rtype: model's OrmarConfig\n        \"\"\"\n        if not self.model_cls:  # pragma nocover\n            raise ValueError(\"Model class of QuerySet is not initialized\")\n        return self.model_cls.ormar_config\n\n    @property\n    def model(self) -&gt; Type[\"T\"]:\n        \"\"\"\n        Shortcut to model class set on QuerySet.\n\n        :return: model class\n        :rtype: Type[Model]\n        \"\"\"\n        if not self.model_cls:  # pragma nocover\n            raise ValueError(\"Model class of QuerySet is not initialized\")\n        return self.model_cls\n\n    def rebuild_self(  # noqa: CFQ002\n        self,\n        filter_clauses: Optional[List] = None,\n        exclude_clauses: Optional[List] = None,\n        select_related: Optional[List] = None,\n        limit_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        excludable: Optional[\"ExcludableItems\"] = None,\n        order_bys: Optional[List] = None,\n        prefetch_related: Optional[List] = None,\n        limit_raw_sql: Optional[bool] = None,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; \"QuerySet\":\n        \"\"\"\n        Method that returns new instance of queryset based on passed params,\n        all not passed params are taken from current values.\n        \"\"\"\n        overwrites = {\n            \"select_related\": \"_select_related\",\n            \"offset\": \"query_offset\",\n            \"excludable\": \"_excludable\",\n            \"prefetch_related\": \"_prefetch_related\",\n            \"limit_raw_sql\": \"limit_sql_raw\",\n        }\n        passed_args = locals()\n\n        def replace_if_none(arg_name: str) -&gt; Any:\n            if passed_args.get(arg_name) is None:\n                return getattr(self, overwrites.get(arg_name, arg_name))\n            return passed_args.get(arg_name)\n\n        return self.__class__(\n            model_cls=self.model_cls,\n            filter_clauses=replace_if_none(\"filter_clauses\"),\n            exclude_clauses=replace_if_none(\"exclude_clauses\"),\n            select_related=replace_if_none(\"select_related\"),\n            limit_count=replace_if_none(\"limit_count\"),\n            offset=replace_if_none(\"offset\"),\n            excludable=replace_if_none(\"excludable\"),\n            order_bys=replace_if_none(\"order_bys\"),\n            prefetch_related=replace_if_none(\"prefetch_related\"),\n            limit_raw_sql=replace_if_none(\"limit_raw_sql\"),\n            proxy_source_model=replace_if_none(\"proxy_source_model\"),\n        )\n\n    async def _prefetch_related_models(\n        self, models: List[\"T\"], rows: List\n    ) -&gt; List[\"T\"]:\n        \"\"\"\n        Performs prefetch query for selected models names.\n\n        :param models: list of already parsed main Models from main query\n        :type models: List[Model]\n        :param rows: database rows from main query\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models with prefetch models populated\n        :rtype: List[Model]\n        \"\"\"\n        query = PrefetchQuery(\n            model_cls=self.model,\n            excludable=self._excludable,\n            prefetch_related=self._prefetch_related,\n            select_related=self._select_related,\n            orders_by=self.order_bys,\n        )\n        return await query.prefetch_related(models=models)  # type: ignore\n\n    async def _process_query_result_rows(self, rows: List) -&gt; List[\"T\"]:\n        \"\"\"\n        Process database rows and initialize ormar Model from each of the rows.\n\n        :param rows: list of database rows from query result\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models\n        :rtype: List[Model]\n        \"\"\"\n        result_rows = []\n        for row in rows:\n            result_rows.append(\n                self.model.from_row(\n                    row=row,\n                    select_related=self._select_related,\n                    excludable=self._excludable,\n                    source_model=self.model,\n                    proxy_source_model=self.proxy_source_model,\n                )\n            )\n            await asyncio.sleep(0)\n\n        if result_rows:\n            return self.model.merge_instances_list(result_rows)  # type: ignore\n        return cast(List[\"T\"], result_rows)\n\n    def _resolve_filter_groups(\n        self, groups: Any\n    ) -&gt; Tuple[List[FilterGroup], List[str]]:\n        \"\"\"\n        Resolves filter groups to populate FilterAction params in group tree.\n\n        :param groups: tuple of FilterGroups\n        :type groups: Any\n        :return: list of resolver groups\n        :rtype: Tuple[List[FilterGroup], List[str]]\n        \"\"\"\n        filter_groups = []\n        select_related = self._select_related\n        if groups:\n            for group in groups:\n                if not isinstance(group, FilterGroup):\n                    raise QueryDefinitionError(\n                        \"Only ormar.and_ and ormar.or_ \"\n                        \"can be passed as filter positional\"\n                        \" arguments,\"\n                        \"other values need to be passed by\"\n                        \"keyword arguments\"\n                    )\n                _, select_related = group.resolve(\n                    model_cls=self.model,\n                    select_related=self._select_related,\n                    filter_clauses=self.filter_clauses,\n                )\n                filter_groups.append(group)\n        return filter_groups, select_related\n\n    @staticmethod\n    def check_single_result_rows_count(rows: Sequence[Optional[\"T\"]]) -&gt; None:\n        \"\"\"\n        Verifies if the result has one and only one row.\n\n        :param rows: one element list of Models\n        :type rows: List[Model]\n        \"\"\"\n        if not rows or rows[0] is None:\n            raise NoMatch()\n        if len(rows) &gt; 1:\n            raise MultipleMatches()\n\n    @property\n    def database(self) -&gt; databases.Database:\n        \"\"\"\n        Shortcut to models database from OrmarConfig class.\n\n        :return: database\n        :rtype: databases.Database\n        \"\"\"\n        return self.model_config.database\n\n    @property\n    def table(self) -&gt; sqlalchemy.Table:\n        \"\"\"\n        Shortcut to models table from OrmarConfig.\n\n        :return: database table\n        :rtype: sqlalchemy.Table\n        \"\"\"\n        return self.model_config.table\n\n    def build_select_expression(\n        self,\n        limit: Optional[int] = None,\n        offset: Optional[int] = None,\n        order_bys: Optional[List] = None,\n    ) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Constructs the actual database query used in the QuerySet.\n        If any of the params is not passed the QuerySet own value is used.\n\n        :param limit: number to limit the query\n        :type limit: int\n        :param offset: number to offset by\n        :type offset: int\n        :param order_bys: list of order-by fields names\n        :type order_bys: List\n        :return: built sqlalchemy select expression\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        qry = Query(\n            model_cls=self.model,\n            select_related=self._select_related,\n            filter_clauses=self.filter_clauses,\n            exclude_clauses=self.exclude_clauses,\n            offset=offset or self.query_offset,\n            excludable=self._excludable,\n            order_bys=order_bys or self.order_bys,\n            limit_raw_sql=self.limit_sql_raw,\n            limit_count=limit if limit is not None else self.limit_count,\n        )\n        exp = qry.build_select_expression()\n        # print(\"\\n\", exp.compile(compile_kwargs={\"literal_binds\": True}))\n        return exp\n\n    def filter(  # noqa: A003\n        self, *args: Any, _exclude: bool = False, **kwargs: Any\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows you to filter by any `Model` attribute/field\n        as well as to fetch instances, with a filter across an FK relationship.\n\n        You can use special filter suffix to change the filter operands:\n\n        *  exact - like `album__name__exact='Malibu'` (exact match)\n        *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n        *  contains - like `album__name__contains='Mal'` (sql like)\n        *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n        *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n        *  isnull - like `album__name__isnull=True` (sql is null)\n           (isnotnull `album__name__isnull=False` (sql is not null))\n        *  gt - like `position__gt=3` (sql &gt;)\n        *  gte - like `position__gte=3` (sql &gt;=)\n        *  lt - like `position__lt=3` (sql &lt;)\n        *  lte - like `position__lte=3` (sql &lt;=)\n        *  startswith - like `album__name__startswith='Mal'` (exact start match)\n        *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n        *  endswith - like `album__name__endswith='ibu'` (exact end match)\n        *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n        Note that you can also use python style filters - check the docs!\n\n        :param _exclude: flag if it should be exclude or filter\n        :type _exclude: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        filter_groups, select_related = self._resolve_filter_groups(groups=args)\n        qryclause = QueryClause(\n            model_cls=self.model,\n            select_related=select_related,\n            filter_clauses=self.filter_clauses,\n        )\n        filter_clauses, select_related = qryclause.prepare_filter(**kwargs)\n        filter_clauses = filter_clauses + filter_groups  # type: ignore\n        if _exclude:\n            exclude_clauses = filter_clauses\n            filter_clauses = self.filter_clauses\n        else:\n            exclude_clauses = self.exclude_clauses\n            filter_clauses = filter_clauses\n\n        return self.rebuild_self(\n            filter_clauses=filter_clauses,\n            exclude_clauses=exclude_clauses,\n            select_related=select_related,\n        )\n\n    def exclude(self, *args: Any, **kwargs: Any) -&gt; \"QuerySet[T]\":  # noqa: A003\n        \"\"\"\n        Works exactly the same as filter and all modifiers (suffixes) are the same,\n        but returns a *not* condition.\n\n        So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n        the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n        Note that all conditions are joined so if you pass multiple values it\n        becomes a union of conditions.\n\n        `exclude(name='John', age&gt;=35)` will become\n        `where not (name='John' and age&gt;=35)`\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        return self.filter(_exclude=True, *args, **kwargs)\n\n    def select_related(self, related: Union[List, str, FieldAccessor]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows to prefetch related models during the same query.\n\n        **With `select_related` always only one query is run against the database**,\n        meaning that one (sometimes complicated) join is generated and later nested\n        models are processed in python.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(related, list):\n            related = [related]\n        related = [\n            rel._access_chain if isinstance(rel, FieldAccessor) else rel\n            for rel in related\n        ]\n\n        related = sorted(list(set(list(self._select_related) + related)))\n        return self.rebuild_self(select_related=related)\n\n    def select_all(self, follow: bool = False) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        By default adds only directly related models.\n\n        If follow=True is set it adds also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        relations = list(self.model.extract_related_names())\n        if follow:\n            relations = self.model._iterate_related_models()\n        return self.rebuild_self(select_related=relations)\n\n    def prefetch_related(\n        self, related: Union[List, str, FieldAccessor]\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows to prefetch related models during query - but opposite to\n        `select_related` each subsequent model is fetched in a separate database query.\n\n        **With `prefetch_related` always one query per Model is run against the\n        database**, meaning that you will have multiple queries executed one\n        after another.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(related, list):\n            related = [related]\n        related = [\n            rel._access_chain if isinstance(rel, FieldAccessor) else rel\n            for rel in related\n        ]\n\n        related = list(set(list(self._prefetch_related) + related))\n        return self.rebuild_self(prefetch_related=related)\n\n    def fields(\n        self, columns: Union[List, str, Set, Dict], _is_exclude: bool = False\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `fields()` you can select subset of model columns to limit the data load.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related`\n        models (with nested notation).\n\n        You can select specified fields by passing a `str, List[str], Set[str] or\n        dict` with nested definition.\n\n        To include related models use notation\n        `{related_name}__{column}[__{optional_next} etc.]`.\n\n        `fields()` can be called several times, building up the columns to select.\n\n        If you include related models into `select_related()` call but you won't specify\n        columns for those models in fields - implies a list of all fields for\n        those nested models.\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even if\n        not explicitly included.\n\n        You can also pass fields to include as dictionary or set.\n\n        To mark a field as included in a dictionary use it's name as key\n        and ellipsis as value.\n\n        To traverse nested models use nested dictionaries.\n\n        To include fields at last level instead of nested dictionary a set can be used.\n\n        To include whole nested model specify model related field name and ellipsis.\n\n        :param _is_exclude: flag if it's exclude or include operation\n        :type _is_exclude: bool\n        :param columns: columns to include\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        excludable = ormar.ExcludableItems.from_excludable(self._excludable)\n        excludable.build(\n            items=columns,\n            model_cls=self.model_cls,  # type: ignore\n            is_exclude=_is_exclude,\n        )\n\n        return self.rebuild_self(excludable=excludable)\n\n    def exclude_fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `exclude_fields()` you can select subset of model columns that will\n        be excluded to limit the data load.\n\n        It's the opposite of `fields()` method so check documentation above\n        to see what options are available.\n\n        Especially check above how you can pass also nested dictionaries\n        and sets as a mask to exclude fields from whole hierarchy.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related` models\n        (with nested notation).\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even\n        if explicitly excluded.\n\n        :param columns: columns to exclude\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        return self.fields(columns=columns, _is_exclude=True)\n\n    def order_by(self, columns: Union[List, str, OrderAction]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `order_by()` you can order the results from database based on your\n        choice of fields.\n\n        You can provide a string with field name or list of strings with fields names.\n\n        Ordering in sql will be applied in order of names you provide in order_by.\n\n        By default if you do not provide ordering `ormar` explicitly orders by\n        all primary keys\n\n        If you are sorting by nested models that causes that the result rows are\n        unsorted by the main model `ormar` will combine those children rows into\n        one main model.\n\n        The main model will never duplicate in the result\n\n        To order by main model field just provide a field name\n\n        To sort on nested models separate field names with dunder '__'.\n\n        You can sort this way across all relation types -&gt; `ForeignKey`,\n        reverse virtual FK and `ManyToMany` fields.\n\n        To sort in descending order provide a hyphen in front of the field name\n\n        :param columns: columns by which models should be sorted\n        :type columns: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n\n        orders_by = [\n            (\n                OrderAction(order_str=x, model_cls=self.model_cls)  # type: ignore\n                if not isinstance(x, OrderAction)\n                else x\n            )\n            for x in columns\n        ]\n\n        order_bys = self.order_bys + [x for x in orders_by if x not in self.order_bys]\n        return self.rebuild_self(order_bys=order_bys)\n\n    async def values(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        exclude_through: bool = False,\n        _as_dict: bool = True,\n        _flatten: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of dictionaries with column values in order of the fields\n        passed or all fields from queried models.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param _flatten: internal parameter to flatten one element tuples\n        :type _flatten: bool\n        :param _as_dict: internal parameter if return dict or tuples\n        :type _as_dict: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields:  Union[List, str, Set, Dict]\n        \"\"\"\n        if fields:\n            return await self.fields(columns=fields).values(\n                _as_dict=_as_dict, _flatten=_flatten, exclude_through=exclude_through\n            )\n        expr = self.build_select_expression()\n        rows = await self.database.fetch_all(expr)\n        if not rows:\n            return []\n        alias_resolver = ReverseAliasResolver(\n            select_related=self._select_related,\n            excludable=self._excludable,\n            model_cls=self.model_cls,  # type: ignore\n            exclude_through=exclude_through,\n        )\n        column_map = alias_resolver.resolve_columns(\n            columns_names=list(cast(LegacyRow, rows[0]).keys())\n        )\n        result = [\n            {column_map.get(k): v for k, v in dict(x).items() if k in column_map}\n            for x in rows\n        ]\n        if _as_dict:\n            return result\n        if _flatten and self._excludable.include_entry_count() != 1:\n            raise QueryDefinitionError(\n                \"You cannot flatten values_list if more than one field is selected!\"\n            )\n        tuple_result = [tuple(x.values()) for x in result]\n        return tuple_result if not _flatten else [x[0] for x in tuple_result]\n\n    async def values_list(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        flatten: bool = False,\n        exclude_through: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of tuples with column values in order of the fields passed or\n        all fields from queried models.\n\n        When one field is passed you can flatten the list of tuples into list of values\n        of that single field.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields: Union[str, List[str]]\n        :param flatten: when one field is passed you can flatten the list of tuples\n        :type flatten: bool\n        \"\"\"\n        return await self.values(\n            fields=fields,\n            exclude_through=exclude_through,\n            _as_dict=False,\n            _flatten=flatten,\n        )\n\n    async def exists(self) -&gt; bool:\n        \"\"\"\n        Returns a bool value to confirm if there are rows matching the given criteria\n        (applied with `filter` and `exclude` if set).\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        expr = self.build_select_expression()\n        expr = sqlalchemy.exists(expr).select()\n        return await self.database.fetch_val(expr)\n\n    async def count(self, distinct: bool = True) -&gt; int:\n        \"\"\"\n        Returns number of rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n        If `distinct` is `True` (the default), this will return\n        the number of primary rows selected. If `False`,\n        the count will be the total number of rows returned\n        (including extra rows for `one-to-many` or `many-to-many`\n        left `select_related` table joins).\n        `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n        :param distinct: flag if the primary table rows should be distinct or not\n\n        :return: number of rows\n        :rtype: int\n        \"\"\"\n        expr = self.build_select_expression().alias(\"subquery_for_count\")\n        expr = sqlalchemy.func.count().select().select_from(expr)\n        if distinct:\n            pk_column_name = self.model.get_column_alias(self.model_config.pkname)\n            expr_distinct = expr.group_by(pk_column_name).alias(\"subquery_for_group\")\n            expr = sqlalchemy.func.count().select().select_from(expr_distinct)\n        return await self.database.fetch_val(expr)\n\n    async def _query_aggr_function(self, func_name: str, columns: List) -&gt; Any:\n        func = getattr(sqlalchemy.func, func_name)\n        select_actions = [\n            SelectAction(select_str=column, model_cls=self.model) for column in columns\n        ]\n        if func_name in [\"sum\", \"avg\"]:\n            if any(not x.is_numeric for x in select_actions):\n                raise QueryDefinitionError(\n                    \"You can use sum and svg only with\" \"numeric types of columns\"\n                )\n        select_columns = [x.apply_func(func, use_label=True) for x in select_actions]\n        expr = self.build_select_expression().alias(f\"subquery_for_{func_name}\")\n        expr = sqlalchemy.select(select_columns).select_from(expr)\n        # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n        result = await self.database.fetch_one(expr)\n        return dict(result) if len(result) &gt; 1 else result[0]  # type: ignore\n\n    async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns max value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: max value of column(s)\n        :rtype: Any\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"max\", columns=columns)\n\n    async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns min value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: min value of column(s)\n        :rtype: Any\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"min\", columns=columns)\n\n    async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns sum value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: sum value of columns\n        :rtype: int\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"sum\", columns=columns)\n\n    async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n        \"\"\"\n        Returns avg value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: avg value of columns\n        :rtype: Union[int, float, List]\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"avg\", columns=columns)\n\n    async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Updates the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of updated rows\n        :rtype: int\n        \"\"\"\n        if not each and not (self.filter_clauses or self.exclude_clauses):\n            raise QueryDefinitionError(\n                \"You cannot update without filtering the queryset first. \"\n                \"If you want to update all rows use update(each=True, **kwargs)\"\n            )\n\n        self_fields = self.model.extract_db_own_fields().union(\n            self.model.extract_related_names()\n        )\n        updates = {k: v for k, v in kwargs.items() if k in self_fields}\n        updates = self.model.validate_enums(updates)\n        updates = self.model.translate_columns_to_aliases(updates)\n\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n            self.table.update().values(**updates)\n        )\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        return await self.database.execute(expr)\n\n    async def delete(self, *args: Any, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Deletes from the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of deleted rows\n        :rtype:int\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).delete()\n        if not each and not (self.filter_clauses or self.exclude_clauses):\n            raise QueryDefinitionError(\n                \"You cannot delete without filtering the queryset first. \"\n                \"If you want to delete all rows use delete(each=True)\"\n            )\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n            self.table.delete()\n        )\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        return await self.database.execute(expr)\n\n    def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can paginate the result which is a combination of offset and limit clauses.\n        Limit is set to page size and offset is set to (page-1) * page_size.\n\n        :param page_size: numbers of items per page\n        :type page_size: int\n        :param page: page number\n        :type page: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if page &lt; 1 or page_size &lt; 1:\n            raise QueryDefinitionError(\"Page size and page have to be greater than 0.\")\n\n        limit_count = page_size\n        query_offset = (page - 1) * page_size\n        return self.rebuild_self(limit_count=limit_count, offset=query_offset)\n\n    def limit(\n        self, limit_count: int, limit_raw_sql: Optional[bool] = None\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can limit the results to desired number of parent models.\n\n        To limit the actual number of database query rows instead of number of main\n        models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n        :param limit_raw_sql: flag if raw sql should be limited\n        :type limit_raw_sql: bool\n        :param limit_count: number of models to limit\n        :type limit_count: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n        return self.rebuild_self(limit_count=limit_count, limit_raw_sql=limit_raw_sql)\n\n    def offset(\n        self, offset: int, limit_raw_sql: Optional[bool] = None\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can also offset the results by desired number of main models.\n\n        To offset the actual number of database query rows instead of number of main\n        models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n        :param limit_raw_sql: flag if raw sql should be offset\n        :type limit_raw_sql: bool\n        :param offset: numbers of models to offset\n        :type offset: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n        return self.rebuild_self(offset=offset, limit_raw_sql=limit_raw_sql)\n\n    async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).first()\n\n        expr = self.build_select_expression(\n            limit=1,\n            order_bys=(\n                [\n                    OrderAction(\n                        order_str=f\"{self.model.ormar_config.pkname}\",\n                        model_cls=self.model_cls,  # type: ignore\n                    )\n                ]\n                if not any([x.is_source_model_order for x in self.order_bys])\n                else []\n            )\n            + self.order_bys,\n        )\n        rows = await self.database.fetch_all(expr)\n        processed_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and processed_rows:\n            processed_rows = await self._prefetch_related_models(processed_rows, rows)\n        self.check_single_result_rows_count(processed_rows)\n        return processed_rows[0]  # type: ignore\n\n    async def first_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        If no match is found None will be returned.\n\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            return await self.first(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n    async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        If no match is found None will be returned.\n\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n    async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":  # noqa: CCR001\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).get()\n\n        if not self.filter_clauses:\n            expr = self.build_select_expression(\n                limit=1,\n                order_bys=(\n                    [\n                        OrderAction(\n                            order_str=f\"-{self.model.ormar_config.pkname}\",\n                            model_cls=self.model_cls,  # type: ignore\n                        )\n                    ]\n                    if not any([x.is_source_model_order for x in self.order_bys])\n                    else []\n                )\n                + self.order_bys,\n            )\n        else:\n            expr = self.build_select_expression()\n\n        rows = await self.database.fetch_all(expr)\n        processed_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and processed_rows:\n            processed_rows = await self._prefetch_related_models(processed_rows, rows)\n        self.check_single_result_rows_count(processed_rows)\n        return processed_rows[0]  # type: ignore\n\n    async def get_or_create(\n        self,\n        _defaults: Optional[Dict[str, Any]] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Tuple[\"T\", bool]:\n        \"\"\"\n        Combination of create and get methods.\n\n        Tries to get a row meeting the criteria for kwargs\n        and if `NoMatch` exception is raised\n        it creates a new one with given kwargs and _defaults.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :param _defaults: default values for creating object\n        :type _defaults: Optional[Dict[str, Any]]\n        :return: model instance and a boolean\n        :rtype: Tuple(\"T\", bool)\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs), False\n        except NoMatch:\n            _defaults = _defaults or {}\n            return await self.create(**{**kwargs, **_defaults}), True\n\n    async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Updates the model, or in case there is no match in database creates a new one.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: updated or created model\n        :rtype: Model\n        \"\"\"\n        pk_name = self.model_config.pkname\n        if \"pk\" in kwargs:\n            kwargs[pk_name] = kwargs.pop(\"pk\")\n        if pk_name not in kwargs or kwargs.get(pk_name) is None:\n            return await self.create(**kwargs)\n        model = await self.get(pk=kwargs[pk_name])\n        return await model.update(**kwargs)\n\n    async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n        \"\"\"\n        Returns all rows from a database for given model for set filter options.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).all()`.\n\n        If there are no rows meeting the criteria an empty list is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: list of returned models\n        :rtype: List[Model]\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).all()\n\n        expr = self.build_select_expression()\n        rows = await self.database.fetch_all(expr)\n        result_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and result_rows:\n            result_rows = await self._prefetch_related_models(result_rows, rows)\n\n        return result_rows\n\n    async def iterate(  # noqa: A003\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; AsyncGenerator[\"T\", None]:\n        \"\"\"\n        Return async iterable generator for all rows from a database for given model.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).iterate()`.\n\n        If there are no rows meeting the criteria an empty async generator is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: asynchronous iterable generator of returned models\n        :rtype: AsyncGenerator[Model]\n        \"\"\"\n\n        if self._prefetch_related:\n            raise QueryDefinitionError(\n                \"Prefetch related queries are not supported in iterators\"\n            )\n\n        if kwargs or args:\n            async for result in self.filter(*args, **kwargs).iterate():\n                yield result\n            return\n\n        expr = self.build_select_expression()\n\n        rows: list = []\n        last_primary_key = None\n        pk_alias = self.model.get_column_alias(self.model_config.pkname)\n\n        async for row in self.database.iterate(query=expr):\n            current_primary_key = row[pk_alias]\n            if last_primary_key == current_primary_key or last_primary_key is None:\n                last_primary_key = current_primary_key\n                rows.append(row)\n                continue\n\n            yield (await self._process_query_result_rows(rows))[0]\n            last_primary_key = current_primary_key\n            rows = [row]\n\n        if rows:\n            yield (await self._process_query_result_rows(rows))[0]\n\n    async def create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Creates the model instance, saves it in a database and returns the updates model\n        (with pk populated if not passed and autoincrement is set).\n\n        The allowed kwargs are `Model` fields names and proper value types.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: created model\n        :rtype: Model\n        \"\"\"\n        instance = self.model(**kwargs)\n        instance = await instance.save()\n        return instance\n\n    async def bulk_create(self, objects: List[\"T\"]) -&gt; None:\n        \"\"\"\n        Performs a bulk create in one database session to speed up the process.\n\n        Allows you to create multiple objects at once.\n\n        A valid list of `Model` objects needs to be passed.\n\n        Bulk operations do not send signals.\n\n        :param objects: list of ormar models already initialized and ready to save.\n        :type objects: List[Model]\n        \"\"\"\n\n        if not objects:\n            raise ModelListEmptyError(\"Bulk create objects are empty!\")\n\n        ready_objects = []\n        for obj in objects:\n            ready_objects.append(obj.prepare_model_to_save(obj.model_dump()))\n            await asyncio.sleep(0)  # Allow context switching to prevent blocking\n\n        # don't use execute_many, as in databases it's executed in a loop\n        # instead of using execute_many from drivers\n        expr = self.table.insert().values(ready_objects)\n        await self.database.execute(expr)\n\n        for obj in objects:\n            obj.set_save_status(True)\n\n    async def bulk_update(  # noqa:  CCR001\n        self, objects: List[\"T\"], columns: Optional[List[str]] = None\n    ) -&gt; None:\n        \"\"\"\n        Performs bulk update in one database session to speed up the process.\n\n        Allows you to update multiple instance at once.\n\n        All `Models` passed need to have primary key column populated.\n\n        You can also select which fields to update by passing `columns` list\n        as a list of string names.\n\n        Bulk operations do not send signals.\n\n        :param objects: list of ormar models\n        :type objects: List[Model]\n        :param columns: list of columns to update\n        :type columns: List[str]\n        \"\"\"\n        if not objects:\n            raise ModelListEmptyError(\"Bulk update objects are empty!\")\n\n        ready_objects = []\n        pk_name = self.model_config.pkname\n        if not columns:\n            columns = list(\n                self.model.extract_db_own_fields().union(\n                    self.model.extract_related_names()\n                )\n            )\n\n        if pk_name not in columns:\n            columns.append(pk_name)\n\n        columns = [self.model.get_column_alias(k) for k in columns]\n\n        for obj in objects:\n            new_kwargs = obj.model_dump()\n            if new_kwargs.get(pk_name) is None:\n                raise ModelPersistenceError(\n                    \"You cannot update unsaved objects. \"\n                    f\"{self.model.__name__} has to have {pk_name} filled.\"\n                )\n            new_kwargs = obj.prepare_model_to_update(new_kwargs)\n            ready_objects.append(\n                {\"new_\" + k: v for k, v in new_kwargs.items() if k in columns}\n            )\n            await asyncio.sleep(0)\n\n        pk_column = self.model_config.table.c.get(self.model.get_column_alias(pk_name))\n        pk_column_name = self.model.get_column_alias(pk_name)\n        table_columns = [c.name for c in self.model_config.table.c]\n        expr = self.table.update().where(\n            pk_column == bindparam(\"new_\" + pk_column_name)\n        )\n        expr = expr.values(\n            **{\n                k: bindparam(\"new_\" + k)\n                for k in columns\n                if k != pk_column_name and k in table_columns\n            }\n        )\n        # databases bind params only where query is passed as string\n        # otherwise it just passes all data to values and results in unconsumed columns\n        expr = str(expr)\n        await self.database.execute_many(expr, ready_objects)\n\n        for obj in objects:\n            obj.set_save_status(True)\n\n        await cast(\n            Type[\"Model\"], self.model_cls\n        ).ormar_config.signals.post_bulk_update.send(\n            sender=self.model_cls, instances=objects  # type: ignore\n        )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.database","title":"<code>database: databases.Database</code>  <code>property</code>","text":"<p>Shortcut to models database from OrmarConfig class.</p> <p>:return: database :rtype: databases.Database</p>"},{"location":"api/queryset/#ormar.queryset.QuerySet.model","title":"<code>model: Type[T]</code>  <code>property</code>","text":"<p>Shortcut to model class set on QuerySet.</p> <p>:return: model class :rtype: Type[Model]</p>"},{"location":"api/queryset/#ormar.queryset.QuerySet.model_config","title":"<code>model_config: OrmarConfig</code>  <code>property</code>","text":"<p>Shortcut to model class OrmarConfig set on QuerySet model.</p> <p>:return: OrmarConfig of the model :rtype: model's OrmarConfig</p>"},{"location":"api/queryset/#ormar.queryset.QuerySet.table","title":"<code>table: sqlalchemy.Table</code>  <code>property</code>","text":"<p>Shortcut to models table from OrmarConfig.</p> <p>:return: database table :rtype: sqlalchemy.Table</p>"},{"location":"api/queryset/#ormar.queryset.QuerySet.all","title":"<code>all(*args, **kwargs)</code>  <code>async</code>","text":"<p>Returns all rows from a database for given model for set filter options.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).all()</code>.</p> <p>If there are no rows meeting the criteria an empty list is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: list of returned models :rtype: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n    \"\"\"\n    Returns all rows from a database for given model for set filter options.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).all()`.\n\n    If there are no rows meeting the criteria an empty list is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: list of returned models\n    :rtype: List[Model]\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).all()\n\n    expr = self.build_select_expression()\n    rows = await self.database.fetch_all(expr)\n    result_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and result_rows:\n        result_rows = await self._prefetch_related_models(result_rows, rows)\n\n    return result_rows\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.avg","title":"<code>avg(columns)</code>  <code>async</code>","text":"<p>Returns avg value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: avg value of columns :rtype: Union[int, float, List]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n    \"\"\"\n    Returns avg value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: avg value of columns\n    :rtype: Union[int, float, List]\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"avg\", columns=columns)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.build_select_expression","title":"<code>build_select_expression(limit=None, offset=None, order_bys=None)</code>","text":"<p>Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used.</p> <p>:param limit: number to limit the query :type limit: int :param offset: number to offset by :type offset: int :param order_bys: list of order-by fields names :type order_bys: List :return: built sqlalchemy select expression :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def build_select_expression(\n    self,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None,\n    order_bys: Optional[List] = None,\n) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Constructs the actual database query used in the QuerySet.\n    If any of the params is not passed the QuerySet own value is used.\n\n    :param limit: number to limit the query\n    :type limit: int\n    :param offset: number to offset by\n    :type offset: int\n    :param order_bys: list of order-by fields names\n    :type order_bys: List\n    :return: built sqlalchemy select expression\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    qry = Query(\n        model_cls=self.model,\n        select_related=self._select_related,\n        filter_clauses=self.filter_clauses,\n        exclude_clauses=self.exclude_clauses,\n        offset=offset or self.query_offset,\n        excludable=self._excludable,\n        order_bys=order_bys or self.order_bys,\n        limit_raw_sql=self.limit_sql_raw,\n        limit_count=limit if limit is not None else self.limit_count,\n    )\n    exp = qry.build_select_expression()\n    # print(\"\\n\", exp.compile(compile_kwargs={\"literal_binds\": True}))\n    return exp\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.bulk_create","title":"<code>bulk_create(objects)</code>  <code>async</code>","text":"<p>Performs a bulk create in one database session to speed up the process.</p> <p>Allows you to create multiple objects at once.</p> <p>A valid list of <code>Model</code> objects needs to be passed.</p> <p>Bulk operations do not send signals.</p> <p>:param objects: list of ormar models already initialized and ready to save. :type objects: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def bulk_create(self, objects: List[\"T\"]) -&gt; None:\n    \"\"\"\n    Performs a bulk create in one database session to speed up the process.\n\n    Allows you to create multiple objects at once.\n\n    A valid list of `Model` objects needs to be passed.\n\n    Bulk operations do not send signals.\n\n    :param objects: list of ormar models already initialized and ready to save.\n    :type objects: List[Model]\n    \"\"\"\n\n    if not objects:\n        raise ModelListEmptyError(\"Bulk create objects are empty!\")\n\n    ready_objects = []\n    for obj in objects:\n        ready_objects.append(obj.prepare_model_to_save(obj.model_dump()))\n        await asyncio.sleep(0)  # Allow context switching to prevent blocking\n\n    # don't use execute_many, as in databases it's executed in a loop\n    # instead of using execute_many from drivers\n    expr = self.table.insert().values(ready_objects)\n    await self.database.execute(expr)\n\n    for obj in objects:\n        obj.set_save_status(True)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.bulk_update","title":"<code>bulk_update(objects, columns=None)</code>  <code>async</code>","text":"<p>Performs bulk update in one database session to speed up the process.</p> <p>Allows you to update multiple instance at once.</p> <p>All <code>Models</code> passed need to have primary key column populated.</p> <p>You can also select which fields to update by passing <code>columns</code> list as a list of string names.</p> <p>Bulk operations do not send signals.</p> <p>:param objects: list of ormar models :type objects: List[Model] :param columns: list of columns to update :type columns: List[str]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def bulk_update(  # noqa:  CCR001\n    self, objects: List[\"T\"], columns: Optional[List[str]] = None\n) -&gt; None:\n    \"\"\"\n    Performs bulk update in one database session to speed up the process.\n\n    Allows you to update multiple instance at once.\n\n    All `Models` passed need to have primary key column populated.\n\n    You can also select which fields to update by passing `columns` list\n    as a list of string names.\n\n    Bulk operations do not send signals.\n\n    :param objects: list of ormar models\n    :type objects: List[Model]\n    :param columns: list of columns to update\n    :type columns: List[str]\n    \"\"\"\n    if not objects:\n        raise ModelListEmptyError(\"Bulk update objects are empty!\")\n\n    ready_objects = []\n    pk_name = self.model_config.pkname\n    if not columns:\n        columns = list(\n            self.model.extract_db_own_fields().union(\n                self.model.extract_related_names()\n            )\n        )\n\n    if pk_name not in columns:\n        columns.append(pk_name)\n\n    columns = [self.model.get_column_alias(k) for k in columns]\n\n    for obj in objects:\n        new_kwargs = obj.model_dump()\n        if new_kwargs.get(pk_name) is None:\n            raise ModelPersistenceError(\n                \"You cannot update unsaved objects. \"\n                f\"{self.model.__name__} has to have {pk_name} filled.\"\n            )\n        new_kwargs = obj.prepare_model_to_update(new_kwargs)\n        ready_objects.append(\n            {\"new_\" + k: v for k, v in new_kwargs.items() if k in columns}\n        )\n        await asyncio.sleep(0)\n\n    pk_column = self.model_config.table.c.get(self.model.get_column_alias(pk_name))\n    pk_column_name = self.model.get_column_alias(pk_name)\n    table_columns = [c.name for c in self.model_config.table.c]\n    expr = self.table.update().where(\n        pk_column == bindparam(\"new_\" + pk_column_name)\n    )\n    expr = expr.values(\n        **{\n            k: bindparam(\"new_\" + k)\n            for k in columns\n            if k != pk_column_name and k in table_columns\n        }\n    )\n    # databases bind params only where query is passed as string\n    # otherwise it just passes all data to values and results in unconsumed columns\n    expr = str(expr)\n    await self.database.execute_many(expr, ready_objects)\n\n    for obj in objects:\n        obj.set_save_status(True)\n\n    await cast(\n        Type[\"Model\"], self.model_cls\n    ).ormar_config.signals.post_bulk_update.send(\n        sender=self.model_cls, instances=objects  # type: ignore\n    )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.check_single_result_rows_count","title":"<code>check_single_result_rows_count(rows)</code>  <code>staticmethod</code>","text":"<p>Verifies if the result has one and only one row.</p> <p>:param rows: one element list of Models :type rows: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>@staticmethod\ndef check_single_result_rows_count(rows: Sequence[Optional[\"T\"]]) -&gt; None:\n    \"\"\"\n    Verifies if the result has one and only one row.\n\n    :param rows: one element list of Models\n    :type rows: List[Model]\n    \"\"\"\n    if not rows or rows[0] is None:\n        raise NoMatch()\n    if len(rows) &gt; 1:\n        raise MultipleMatches()\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.count","title":"<code>count(distinct=True)</code>  <code>async</code>","text":"<p>Returns number of rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before). If <code>distinct</code> is <code>True</code> (the default), this will return the number of primary rows selected. If <code>False</code>, the count will be the total number of rows returned (including extra rows for <code>one-to-many</code> or <code>many-to-many</code> left <code>select_related</code> table joins). <code>False</code> is the legacy (buggy) behavior for workflows that depend on it.</p> <p>:param distinct: flag if the primary table rows should be distinct or not</p> <p>:return: number of rows :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def count(self, distinct: bool = True) -&gt; int:\n    \"\"\"\n    Returns number of rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n    If `distinct` is `True` (the default), this will return\n    the number of primary rows selected. If `False`,\n    the count will be the total number of rows returned\n    (including extra rows for `one-to-many` or `many-to-many`\n    left `select_related` table joins).\n    `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n    :param distinct: flag if the primary table rows should be distinct or not\n\n    :return: number of rows\n    :rtype: int\n    \"\"\"\n    expr = self.build_select_expression().alias(\"subquery_for_count\")\n    expr = sqlalchemy.func.count().select().select_from(expr)\n    if distinct:\n        pk_column_name = self.model.get_column_alias(self.model_config.pkname)\n        expr_distinct = expr.group_by(pk_column_name).alias(\"subquery_for_group\")\n        expr = sqlalchemy.func.count().select().select_from(expr_distinct)\n    return await self.database.fetch_val(expr)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.create","title":"<code>create(**kwargs)</code>  <code>async</code>","text":"<p>Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set).</p> <p>The allowed kwargs are <code>Model</code> fields names and proper value types.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: created model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Creates the model instance, saves it in a database and returns the updates model\n    (with pk populated if not passed and autoincrement is set).\n\n    The allowed kwargs are `Model` fields names and proper value types.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: created model\n    :rtype: Model\n    \"\"\"\n    instance = self.model(**kwargs)\n    instance = await instance.save()\n    return instance\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.delete","title":"<code>delete(*args, each=False, **kwargs)</code>  <code>async</code>","text":"<p>Deletes from the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of deleted rows :rtype:int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def delete(self, *args: Any, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Deletes from the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of deleted rows\n    :rtype:int\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).delete()\n    if not each and not (self.filter_clauses or self.exclude_clauses):\n        raise QueryDefinitionError(\n            \"You cannot delete without filtering the queryset first. \"\n            \"If you want to delete all rows use delete(each=True)\"\n        )\n    expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n        self.table.delete()\n    )\n    expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n        expr\n    )\n    return await self.database.execute(expr)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.exclude","title":"<code>exclude(*args, **kwargs)</code>","text":"<p>Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition.</p> <p>So if you use <code>filter(name='John')</code> which is <code>where name = 'John'</code> in SQL, the <code>exclude(name='John')</code> equals to <code>where name &lt;&gt; 'John'</code></p> <p>Note that all conditions are joined so if you pass multiple values it becomes a union of conditions.</p> <p><code>exclude(name='John', age&gt;=35)</code> will become <code>where not (name='John' and age&gt;=35)</code></p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def exclude(self, *args: Any, **kwargs: Any) -&gt; \"QuerySet[T]\":  # noqa: A003\n    \"\"\"\n    Works exactly the same as filter and all modifiers (suffixes) are the same,\n    but returns a *not* condition.\n\n    So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n    the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n    Note that all conditions are joined so if you pass multiple values it\n    becomes a union of conditions.\n\n    `exclude(name='John', age&gt;=35)` will become\n    `where not (name='John' and age&gt;=35)`\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    return self.filter(_exclude=True, *args, **kwargs)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.exclude_fields","title":"<code>exclude_fields(columns)</code>","text":"<p>With <code>exclude_fields()</code> you can select subset of model columns that will be excluded to limit the data load.</p> <p>It's the opposite of <code>fields()</code> method so check documentation above to see what options are available.</p> <p>Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if explicitly excluded.</p> <p>:param columns: columns to exclude :type columns: Union[List, str, Set, Dict] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def exclude_fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `exclude_fields()` you can select subset of model columns that will\n    be excluded to limit the data load.\n\n    It's the opposite of `fields()` method so check documentation above\n    to see what options are available.\n\n    Especially check above how you can pass also nested dictionaries\n    and sets as a mask to exclude fields from whole hierarchy.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related` models\n    (with nested notation).\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even\n    if explicitly excluded.\n\n    :param columns: columns to exclude\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    return self.fields(columns=columns, _is_exclude=True)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.exists","title":"<code>exists()</code>  <code>async</code>","text":"<p>Returns a bool value to confirm if there are rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set).</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def exists(self) -&gt; bool:\n    \"\"\"\n    Returns a bool value to confirm if there are rows matching the given criteria\n    (applied with `filter` and `exclude` if set).\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    expr = self.build_select_expression()\n    expr = sqlalchemy.exists(expr).select()\n    return await self.database.fetch_val(expr)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.fields","title":"<code>fields(columns, _is_exclude=False)</code>","text":"<p>With <code>fields()</code> you can select subset of model columns to limit the data load.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>You can select specified fields by passing a <code>str, List[str], Set[str] or dict</code> with nested definition.</p> <p>To include related models use notation <code>{related_name}__{column}[__{optional_next} etc.]</code>.</p> <p><code>fields()</code> can be called several times, building up the columns to select.</p> <p>If you include related models into <code>select_related()</code> call but you won't specify columns for those models in fields - implies a list of all fields for those nested models.</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if not explicitly included.</p> <p>You can also pass fields to include as dictionary or set.</p> <p>To mark a field as included in a dictionary use it's name as key and ellipsis as value.</p> <p>To traverse nested models use nested dictionaries.</p> <p>To include fields at last level instead of nested dictionary a set can be used.</p> <p>To include whole nested model specify model related field name and ellipsis.</p> <p>:param _is_exclude: flag if it's exclude or include operation :type _is_exclude: bool :param columns: columns to include :type columns: Union[List, str, Set, Dict] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def fields(\n    self, columns: Union[List, str, Set, Dict], _is_exclude: bool = False\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `fields()` you can select subset of model columns to limit the data load.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related`\n    models (with nested notation).\n\n    You can select specified fields by passing a `str, List[str], Set[str] or\n    dict` with nested definition.\n\n    To include related models use notation\n    `{related_name}__{column}[__{optional_next} etc.]`.\n\n    `fields()` can be called several times, building up the columns to select.\n\n    If you include related models into `select_related()` call but you won't specify\n    columns for those models in fields - implies a list of all fields for\n    those nested models.\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even if\n    not explicitly included.\n\n    You can also pass fields to include as dictionary or set.\n\n    To mark a field as included in a dictionary use it's name as key\n    and ellipsis as value.\n\n    To traverse nested models use nested dictionaries.\n\n    To include fields at last level instead of nested dictionary a set can be used.\n\n    To include whole nested model specify model related field name and ellipsis.\n\n    :param _is_exclude: flag if it's exclude or include operation\n    :type _is_exclude: bool\n    :param columns: columns to include\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    excludable = ormar.ExcludableItems.from_excludable(self._excludable)\n    excludable.build(\n        items=columns,\n        model_cls=self.model_cls,  # type: ignore\n        is_exclude=_is_exclude,\n    )\n\n    return self.rebuild_self(excludable=excludable)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.filter","title":"<code>filter(*args, _exclude=False, **kwargs)</code>","text":"<p>Allows you to filter by any <code>Model</code> attribute/field as well as to fetch instances, with a filter across an FK relationship.</p> <p>You can use special filter suffix to change the filter operands:</p> <ul> <li>exact - like <code>album__name__exact='Malibu'</code> (exact match)</li> <li>iexact - like <code>album__name__iexact='malibu'</code> (exact match case insensitive)</li> <li>contains - like <code>album__name__contains='Mal'</code> (sql like)</li> <li>icontains - like <code>album__name__icontains='mal'</code> (sql like case insensitive)</li> <li>in - like <code>album__name__in=['Malibu', 'Barclay']</code> (sql in)</li> <li>isnull - like <code>album__name__isnull=True</code> (sql is null)    (isnotnull <code>album__name__isnull=False</code> (sql is not null))</li> <li>gt - like <code>position__gt=3</code> (sql &gt;)</li> <li>gte - like <code>position__gte=3</code> (sql &gt;=)</li> <li>lt - like <code>position__lt=3</code> (sql &lt;)</li> <li>lte - like <code>position__lte=3</code> (sql &lt;=)</li> <li>startswith - like <code>album__name__startswith='Mal'</code> (exact start match)</li> <li>istartswith - like <code>album__name__istartswith='mal'</code> (case insensitive)</li> <li>endswith - like <code>album__name__endswith='ibu'</code> (exact end match)</li> <li>iendswith - like <code>album__name__iendswith='IBU'</code> (case insensitive)</li> </ul> <p>Note that you can also use python style filters - check the docs!</p> <p>:param _exclude: flag if it should be exclude or filter :type _exclude: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def filter(  # noqa: A003\n    self, *args: Any, _exclude: bool = False, **kwargs: Any\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows you to filter by any `Model` attribute/field\n    as well as to fetch instances, with a filter across an FK relationship.\n\n    You can use special filter suffix to change the filter operands:\n\n    *  exact - like `album__name__exact='Malibu'` (exact match)\n    *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n    *  contains - like `album__name__contains='Mal'` (sql like)\n    *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n    *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n    *  isnull - like `album__name__isnull=True` (sql is null)\n       (isnotnull `album__name__isnull=False` (sql is not null))\n    *  gt - like `position__gt=3` (sql &gt;)\n    *  gte - like `position__gte=3` (sql &gt;=)\n    *  lt - like `position__lt=3` (sql &lt;)\n    *  lte - like `position__lte=3` (sql &lt;=)\n    *  startswith - like `album__name__startswith='Mal'` (exact start match)\n    *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n    *  endswith - like `album__name__endswith='ibu'` (exact end match)\n    *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n    Note that you can also use python style filters - check the docs!\n\n    :param _exclude: flag if it should be exclude or filter\n    :type _exclude: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    filter_groups, select_related = self._resolve_filter_groups(groups=args)\n    qryclause = QueryClause(\n        model_cls=self.model,\n        select_related=select_related,\n        filter_clauses=self.filter_clauses,\n    )\n    filter_clauses, select_related = qryclause.prepare_filter(**kwargs)\n    filter_clauses = filter_clauses + filter_groups  # type: ignore\n    if _exclude:\n        exclude_clauses = filter_clauses\n        filter_clauses = self.filter_clauses\n    else:\n        exclude_clauses = self.exclude_clauses\n        filter_clauses = filter_clauses\n\n    return self.rebuild_self(\n        filter_clauses=filter_clauses,\n        exclude_clauses=exclude_clauses,\n        select_related=select_related,\n    )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.first","title":"<code>first(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).first()\n\n    expr = self.build_select_expression(\n        limit=1,\n        order_bys=(\n            [\n                OrderAction(\n                    order_str=f\"{self.model.ormar_config.pkname}\",\n                    model_cls=self.model_cls,  # type: ignore\n                )\n            ]\n            if not any([x.is_source_model_order for x in self.order_bys])\n            else []\n        )\n        + self.order_bys,\n    )\n    rows = await self.database.fetch_all(expr)\n    processed_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and processed_rows:\n        processed_rows = await self._prefetch_related_models(processed_rows, rows)\n    self.check_single_result_rows_count(processed_rows)\n    return processed_rows[0]  # type: ignore\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.first_or_none","title":"<code>first_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>If no match is found None will be returned.</p> <p>:raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def first_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    If no match is found None will be returned.\n\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        return await self.first(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.get","title":"<code>get(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":  # noqa: CCR001\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).get()\n\n    if not self.filter_clauses:\n        expr = self.build_select_expression(\n            limit=1,\n            order_bys=(\n                [\n                    OrderAction(\n                        order_str=f\"-{self.model.ormar_config.pkname}\",\n                        model_cls=self.model_cls,  # type: ignore\n                    )\n                ]\n                if not any([x.is_source_model_order for x in self.order_bys])\n                else []\n            )\n            + self.order_bys,\n        )\n    else:\n        expr = self.build_select_expression()\n\n    rows = await self.database.fetch_all(expr)\n    processed_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and processed_rows:\n        processed_rows = await self._prefetch_related_models(processed_rows, rows)\n    self.check_single_result_rows_count(processed_rows)\n    return processed_rows[0]  # type: ignore\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.get_or_create","title":"<code>get_or_create(_defaults=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Combination of create and get methods.</p> <p>Tries to get a row meeting the criteria for kwargs and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :param _defaults: default values for creating object :type _defaults: Optional[Dict[str, Any]] :return: model instance and a boolean :rtype: Tuple(\"T\", bool)</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get_or_create(\n    self,\n    _defaults: Optional[Dict[str, Any]] = None,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Tuple[\"T\", bool]:\n    \"\"\"\n    Combination of create and get methods.\n\n    Tries to get a row meeting the criteria for kwargs\n    and if `NoMatch` exception is raised\n    it creates a new one with given kwargs and _defaults.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :param _defaults: default values for creating object\n    :type _defaults: Optional[Dict[str, Any]]\n    :return: model instance and a boolean\n    :rtype: Tuple(\"T\", bool)\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs), False\n    except NoMatch:\n        _defaults = _defaults or {}\n        return await self.create(**{**kwargs, **_defaults}), True\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.get_or_none","title":"<code>get_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>If no match is found None will be returned.</p> <p>:raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    If no match is found None will be returned.\n\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.iterate","title":"<code>iterate(*args, **kwargs)</code>  <code>async</code>","text":"<p>Return async iterable generator for all rows from a database for given model.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).iterate()</code>.</p> <p>If there are no rows meeting the criteria an empty async generator is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: asynchronous iterable generator of returned models :rtype: AsyncGenerator[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def iterate(  # noqa: A003\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; AsyncGenerator[\"T\", None]:\n    \"\"\"\n    Return async iterable generator for all rows from a database for given model.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).iterate()`.\n\n    If there are no rows meeting the criteria an empty async generator is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: asynchronous iterable generator of returned models\n    :rtype: AsyncGenerator[Model]\n    \"\"\"\n\n    if self._prefetch_related:\n        raise QueryDefinitionError(\n            \"Prefetch related queries are not supported in iterators\"\n        )\n\n    if kwargs or args:\n        async for result in self.filter(*args, **kwargs).iterate():\n            yield result\n        return\n\n    expr = self.build_select_expression()\n\n    rows: list = []\n    last_primary_key = None\n    pk_alias = self.model.get_column_alias(self.model_config.pkname)\n\n    async for row in self.database.iterate(query=expr):\n        current_primary_key = row[pk_alias]\n        if last_primary_key == current_primary_key or last_primary_key is None:\n            last_primary_key = current_primary_key\n            rows.append(row)\n            continue\n\n        yield (await self._process_query_result_rows(rows))[0]\n        last_primary_key = current_primary_key\n        rows = [row]\n\n    if rows:\n        yield (await self._process_query_result_rows(rows))[0]\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.limit","title":"<code>limit(limit_count, limit_raw_sql=None)</code>","text":"<p>You can limit the results to desired number of parent models.</p> <p>To limit the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <p>:param limit_raw_sql: flag if raw sql should be limited :type limit_raw_sql: bool :param limit_count: number of models to limit :type limit_count: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def limit(\n    self, limit_count: int, limit_raw_sql: Optional[bool] = None\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can limit the results to desired number of parent models.\n\n    To limit the actual number of database query rows instead of number of main\n    models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n    :param limit_raw_sql: flag if raw sql should be limited\n    :type limit_raw_sql: bool\n    :param limit_count: number of models to limit\n    :type limit_count: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n    return self.rebuild_self(limit_count=limit_count, limit_raw_sql=limit_raw_sql)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.max","title":"<code>max(columns)</code>  <code>async</code>","text":"<p>Returns max value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: max value of column(s) :rtype: Any</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns max value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: max value of column(s)\n    :rtype: Any\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"max\", columns=columns)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.min","title":"<code>min(columns)</code>  <code>async</code>","text":"<p>Returns min value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: min value of column(s) :rtype: Any</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns min value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: min value of column(s)\n    :rtype: Any\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"min\", columns=columns)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.offset","title":"<code>offset(offset, limit_raw_sql=None)</code>","text":"<p>You can also offset the results by desired number of main models.</p> <p>To offset the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <p>:param limit_raw_sql: flag if raw sql should be offset :type limit_raw_sql: bool :param offset: numbers of models to offset :type offset: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def offset(\n    self, offset: int, limit_raw_sql: Optional[bool] = None\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can also offset the results by desired number of main models.\n\n    To offset the actual number of database query rows instead of number of main\n    models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n    :param limit_raw_sql: flag if raw sql should be offset\n    :type limit_raw_sql: bool\n    :param offset: numbers of models to offset\n    :type offset: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n    return self.rebuild_self(offset=offset, limit_raw_sql=limit_raw_sql)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.order_by","title":"<code>order_by(columns)</code>","text":"<p>With <code>order_by()</code> you can order the results from database based on your choice of fields.</p> <p>You can provide a string with field name or list of strings with fields names.</p> <p>Ordering in sql will be applied in order of names you provide in order_by.</p> <p>By default if you do not provide ordering <code>ormar</code> explicitly orders by all primary keys</p> <p>If you are sorting by nested models that causes that the result rows are unsorted by the main model <code>ormar</code> will combine those children rows into one main model.</p> <p>The main model will never duplicate in the result</p> <p>To order by main model field just provide a field name</p> <p>To sort on nested models separate field names with dunder '__'.</p> <p>You can sort this way across all relation types -&gt; <code>ForeignKey</code>, reverse virtual FK and <code>ManyToMany</code> fields.</p> <p>To sort in descending order provide a hyphen in front of the field name</p> <p>:param columns: columns by which models should be sorted :type columns: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def order_by(self, columns: Union[List, str, OrderAction]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `order_by()` you can order the results from database based on your\n    choice of fields.\n\n    You can provide a string with field name or list of strings with fields names.\n\n    Ordering in sql will be applied in order of names you provide in order_by.\n\n    By default if you do not provide ordering `ormar` explicitly orders by\n    all primary keys\n\n    If you are sorting by nested models that causes that the result rows are\n    unsorted by the main model `ormar` will combine those children rows into\n    one main model.\n\n    The main model will never duplicate in the result\n\n    To order by main model field just provide a field name\n\n    To sort on nested models separate field names with dunder '__'.\n\n    You can sort this way across all relation types -&gt; `ForeignKey`,\n    reverse virtual FK and `ManyToMany` fields.\n\n    To sort in descending order provide a hyphen in front of the field name\n\n    :param columns: columns by which models should be sorted\n    :type columns: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n\n    orders_by = [\n        (\n            OrderAction(order_str=x, model_cls=self.model_cls)  # type: ignore\n            if not isinstance(x, OrderAction)\n            else x\n        )\n        for x in columns\n    ]\n\n    order_bys = self.order_bys + [x for x in orders_by if x not in self.order_bys]\n    return self.rebuild_self(order_bys=order_bys)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.paginate","title":"<code>paginate(page, page_size=20)</code>","text":"<p>You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size.</p> <p>:param page_size: numbers of items per page :type page_size: int :param page: page number :type page: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can paginate the result which is a combination of offset and limit clauses.\n    Limit is set to page size and offset is set to (page-1) * page_size.\n\n    :param page_size: numbers of items per page\n    :type page_size: int\n    :param page: page number\n    :type page: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if page &lt; 1 or page_size &lt; 1:\n        raise QueryDefinitionError(\"Page size and page have to be greater than 0.\")\n\n    limit_count = page_size\n    query_offset = (page - 1) * page_size\n    return self.rebuild_self(limit_count=limit_count, offset=query_offset)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.prefetch_related","title":"<code>prefetch_related(related)</code>","text":"<p>Allows to prefetch related models during query - but opposite to <code>select_related</code> each subsequent model is fetched in a separate database query.</p> <p>With <code>prefetch_related</code> always one query per Model is run against the database, meaning that you will have multiple queries executed one after another.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def prefetch_related(\n    self, related: Union[List, str, FieldAccessor]\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows to prefetch related models during query - but opposite to\n    `select_related` each subsequent model is fetched in a separate database query.\n\n    **With `prefetch_related` always one query per Model is run against the\n    database**, meaning that you will have multiple queries executed one\n    after another.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(related, list):\n        related = [related]\n    related = [\n        rel._access_chain if isinstance(rel, FieldAccessor) else rel\n        for rel in related\n    ]\n\n    related = list(set(list(self._prefetch_related) + related))\n    return self.rebuild_self(prefetch_related=related)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.rebuild_self","title":"<code>rebuild_self(filter_clauses=None, exclude_clauses=None, select_related=None, limit_count=None, offset=None, excludable=None, order_bys=None, prefetch_related=None, limit_raw_sql=None, proxy_source_model=None)</code>","text":"<p>Method that returns new instance of queryset based on passed params, all not passed params are taken from current values.</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def rebuild_self(  # noqa: CFQ002\n    self,\n    filter_clauses: Optional[List] = None,\n    exclude_clauses: Optional[List] = None,\n    select_related: Optional[List] = None,\n    limit_count: Optional[int] = None,\n    offset: Optional[int] = None,\n    excludable: Optional[\"ExcludableItems\"] = None,\n    order_bys: Optional[List] = None,\n    prefetch_related: Optional[List] = None,\n    limit_raw_sql: Optional[bool] = None,\n    proxy_source_model: Optional[Type[\"Model\"]] = None,\n) -&gt; \"QuerySet\":\n    \"\"\"\n    Method that returns new instance of queryset based on passed params,\n    all not passed params are taken from current values.\n    \"\"\"\n    overwrites = {\n        \"select_related\": \"_select_related\",\n        \"offset\": \"query_offset\",\n        \"excludable\": \"_excludable\",\n        \"prefetch_related\": \"_prefetch_related\",\n        \"limit_raw_sql\": \"limit_sql_raw\",\n    }\n    passed_args = locals()\n\n    def replace_if_none(arg_name: str) -&gt; Any:\n        if passed_args.get(arg_name) is None:\n            return getattr(self, overwrites.get(arg_name, arg_name))\n        return passed_args.get(arg_name)\n\n    return self.__class__(\n        model_cls=self.model_cls,\n        filter_clauses=replace_if_none(\"filter_clauses\"),\n        exclude_clauses=replace_if_none(\"exclude_clauses\"),\n        select_related=replace_if_none(\"select_related\"),\n        limit_count=replace_if_none(\"limit_count\"),\n        offset=replace_if_none(\"offset\"),\n        excludable=replace_if_none(\"excludable\"),\n        order_bys=replace_if_none(\"order_bys\"),\n        prefetch_related=replace_if_none(\"prefetch_related\"),\n        limit_raw_sql=replace_if_none(\"limit_raw_sql\"),\n        proxy_source_model=replace_if_none(\"proxy_source_model\"),\n    )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.select_all","title":"<code>select_all(follow=False)</code>","text":"<p>By default adds only directly related models.</p> <p>If follow=True is set it adds also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def select_all(self, follow: bool = False) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    By default adds only directly related models.\n\n    If follow=True is set it adds also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    relations = list(self.model.extract_related_names())\n    if follow:\n        relations = self.model._iterate_related_models()\n    return self.rebuild_self(select_related=relations)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.select_related","title":"<code>select_related(related)</code>","text":"<p>Allows to prefetch related models during the same query.</p> <p>With <code>select_related</code> always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def select_related(self, related: Union[List, str, FieldAccessor]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows to prefetch related models during the same query.\n\n    **With `select_related` always only one query is run against the database**,\n    meaning that one (sometimes complicated) join is generated and later nested\n    models are processed in python.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(related, list):\n        related = [related]\n    related = [\n        rel._access_chain if isinstance(rel, FieldAccessor) else rel\n        for rel in related\n    ]\n\n    related = sorted(list(set(list(self._select_related) + related)))\n    return self.rebuild_self(select_related=related)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.sum","title":"<code>sum(columns)</code>  <code>async</code>","text":"<p>Returns sum value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: sum value of columns :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns sum value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: sum value of columns\n    :rtype: int\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"sum\", columns=columns)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.update","title":"<code>update(each=False, **kwargs)</code>  <code>async</code>","text":"<p>Updates the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of updated rows :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Updates the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of updated rows\n    :rtype: int\n    \"\"\"\n    if not each and not (self.filter_clauses or self.exclude_clauses):\n        raise QueryDefinitionError(\n            \"You cannot update without filtering the queryset first. \"\n            \"If you want to update all rows use update(each=True, **kwargs)\"\n        )\n\n    self_fields = self.model.extract_db_own_fields().union(\n        self.model.extract_related_names()\n    )\n    updates = {k: v for k, v in kwargs.items() if k in self_fields}\n    updates = self.model.validate_enums(updates)\n    updates = self.model.translate_columns_to_aliases(updates)\n\n    expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n        self.table.update().values(**updates)\n    )\n    expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n        expr\n    )\n    return await self.database.execute(expr)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.update_or_create","title":"<code>update_or_create(**kwargs)</code>  <code>async</code>","text":"<p>Updates the model, or in case there is no match in database creates a new one.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: updated or created model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Updates the model, or in case there is no match in database creates a new one.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: updated or created model\n    :rtype: Model\n    \"\"\"\n    pk_name = self.model_config.pkname\n    if \"pk\" in kwargs:\n        kwargs[pk_name] = kwargs.pop(\"pk\")\n    if pk_name not in kwargs or kwargs.get(pk_name) is None:\n        return await self.create(**kwargs)\n    model = await self.get(pk=kwargs[pk_name])\n    return await model.update(**kwargs)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.values","title":"<code>values(fields=None, exclude_through=False, _as_dict=True, _flatten=False)</code>  <code>async</code>","text":"<p>Return a list of dictionaries with column values in order of the fields passed or all fields from queried models.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param _flatten: internal parameter to flatten one element tuples :type _flatten: bool :param _as_dict: internal parameter if return dict or tuples :type _as_dict: bool :param fields: field name or list of field names to extract from db :type fields:  Union[List, str, Set, Dict]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def values(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    exclude_through: bool = False,\n    _as_dict: bool = True,\n    _flatten: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of dictionaries with column values in order of the fields\n    passed or all fields from queried models.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param _flatten: internal parameter to flatten one element tuples\n    :type _flatten: bool\n    :param _as_dict: internal parameter if return dict or tuples\n    :type _as_dict: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields:  Union[List, str, Set, Dict]\n    \"\"\"\n    if fields:\n        return await self.fields(columns=fields).values(\n            _as_dict=_as_dict, _flatten=_flatten, exclude_through=exclude_through\n        )\n    expr = self.build_select_expression()\n    rows = await self.database.fetch_all(expr)\n    if not rows:\n        return []\n    alias_resolver = ReverseAliasResolver(\n        select_related=self._select_related,\n        excludable=self._excludable,\n        model_cls=self.model_cls,  # type: ignore\n        exclude_through=exclude_through,\n    )\n    column_map = alias_resolver.resolve_columns(\n        columns_names=list(cast(LegacyRow, rows[0]).keys())\n    )\n    result = [\n        {column_map.get(k): v for k, v in dict(x).items() if k in column_map}\n        for x in rows\n    ]\n    if _as_dict:\n        return result\n    if _flatten and self._excludable.include_entry_count() != 1:\n        raise QueryDefinitionError(\n            \"You cannot flatten values_list if more than one field is selected!\"\n        )\n    tuple_result = [tuple(x.values()) for x in result]\n    return tuple_result if not _flatten else [x[0] for x in tuple_result]\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.QuerySet.values_list","title":"<code>values_list(fields=None, flatten=False, exclude_through=False)</code>  <code>async</code>","text":"<p>Return a list of tuples with column values in order of the fields passed or all fields from queried models.</p> <p>When one field is passed you can flatten the list of tuples into list of values of that single field.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param fields: field name or list of field names to extract from db :type fields: Union[str, List[str]] :param flatten: when one field is passed you can flatten the list of tuples :type flatten: bool</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def values_list(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    flatten: bool = False,\n    exclude_through: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of tuples with column values in order of the fields passed or\n    all fields from queried models.\n\n    When one field is passed you can flatten the list of tuples into list of values\n    of that single field.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields: Union[str, List[str]]\n    :param flatten: when one field is passed you can flatten the list of tuples\n    :type flatten: bool\n    \"\"\"\n    return await self.values(\n        fields=fields,\n        exclude_through=exclude_through,\n        _as_dict=False,\n        _flatten=flatten,\n    )\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.SelectAction","title":"<code>SelectAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/select_action.py</code> <pre><code>class SelectAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, select_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        super().__init__(query_str=select_str, model_cls=model_cls)\n        if alias:  # pragma: no cover\n            self.table_prefix = alias\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    @property\n    def is_numeric(self) -&gt; bool:\n        return self.get_target_field_type() in [int, float, decimal.Decimal]\n\n    def get_target_field_type(self) -&gt; Any:\n        return self.target_model.ormar_config.model_fields[self.field_name].__type__\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        alias = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return sqlalchemy.text(f\"{alias}{self.field_name}\")\n\n    def apply_func(\n        self, func: Callable, use_label: bool = True\n    ) -&gt; sqlalchemy.sql.expression.TextClause:\n        result = func(self.get_text_clause())\n        if use_label:\n            rel_prefix = f\"{self.related_str}__\" if self.related_str else \"\"\n            result = result.label(f\"{rel_prefix}{self.field_name}\")\n        return result\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.and_","title":"<code>and_(*args, **kwargs)</code>","text":"<p>Construct and filter from nested groups and keyword arguments</p> <p>:param args: nested filter groups :type args: Tuple[FilterGroup] :param kwargs: fields names and proper value types :type kwargs: Any :return: FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def and_(*args: FilterGroup, **kwargs: Any) -&gt; FilterGroup:\n    \"\"\"\n    Construct and filter from nested groups and keyword arguments\n\n    :param args: nested filter groups\n    :type args: Tuple[FilterGroup]\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: FilterGroup ready to be resolved\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return FilterGroup(_filter_type=FilterType.AND, *args, **kwargs)\n</code></pre>"},{"location":"api/queryset/#ormar.queryset.or_","title":"<code>or_(*args, **kwargs)</code>","text":"<p>Construct or filter from nested groups and keyword arguments</p> <p>:param args: nested filter groups :type args: Tuple[FilterGroup] :param kwargs: fields names and proper value types :type kwargs: Any :return: FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def or_(*args: FilterGroup, **kwargs: Any) -&gt; FilterGroup:\n    \"\"\"\n    Construct or filter from nested groups and keyword arguments\n\n    :param args: nested filter groups\n    :type args: Tuple[FilterGroup]\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: FilterGroup ready to be resolved\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return FilterGroup(_filter_type=FilterType.OR, *args, **kwargs)\n</code></pre>"},{"location":"api/queryset/clause/","title":"clause","text":""},{"location":"api/queryset/clause/#ormar.queryset.clause.FilterGroup","title":"<code>FilterGroup</code>","text":"<p>Filter groups are used in complex queries condition to group and and or clauses in where condition</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>class FilterGroup:\n    \"\"\"\n    Filter groups are used in complex queries condition to group and and or\n    clauses in where condition\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        _filter_type: FilterType = FilterType.AND,\n        _exclude: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        self.filter_type = _filter_type\n        self.exclude = _exclude\n        self._nested_groups: List[\"FilterGroup\"] = list(args)\n        self._resolved = False\n        self.is_source_model_filter = False\n        self._kwargs_dict = kwargs\n        self.actions: List[FilterAction] = []\n\n    def __and__(self, other: \"FilterGroup\") -&gt; \"FilterGroup\":\n        return FilterGroup(self, other)\n\n    def __or__(self, other: \"FilterGroup\") -&gt; \"FilterGroup\":\n        return FilterGroup(self, other, _filter_type=FilterType.OR)\n\n    def __invert__(self) -&gt; \"FilterGroup\":\n        self.exclude = not self.exclude\n        return self\n\n    def resolve(\n        self,\n        model_cls: Type[\"Model\"],\n        select_related: Optional[List] = None,\n        filter_clauses: Optional[List] = None,\n    ) -&gt; Tuple[List[FilterAction], List[str]]:\n        \"\"\"\n        Resolves the FilterGroups actions to use proper target model, replace\n        complex relation prefixes if needed and nested groups also resolved.\n\n        :param model_cls: model from which the query is run\n        :type model_cls: Type[\"Model\"]\n        :param select_related: list of models to join\n        :type select_related: List[str]\n        :param filter_clauses: list of filter conditions\n        :type filter_clauses: List[FilterAction]\n        :return: list of filter conditions and select_related list\n        :rtype: Tuple[List[FilterAction], List[str]]\n        \"\"\"\n        select_related = select_related if select_related is not None else []\n        filter_clauses = filter_clauses if filter_clauses is not None else []\n        qryclause = QueryClause(\n            model_cls=model_cls,\n            select_related=select_related,\n            filter_clauses=filter_clauses,\n        )\n        own_filter_clauses, select_related = qryclause.prepare_filter(\n            _own_only=True, **self._kwargs_dict\n        )\n        self.actions = own_filter_clauses\n        filter_clauses = filter_clauses + own_filter_clauses\n        self._resolved = True\n        if self._nested_groups:\n            for group in self._nested_groups:\n                (filter_clauses, select_related) = group.resolve(\n                    model_cls=model_cls,\n                    select_related=select_related,\n                    filter_clauses=filter_clauses,\n                )\n        return filter_clauses, select_related\n\n    def _iter(self) -&gt; Generator:\n        \"\"\"\n        Iterates all actions in a tree\n        :return: generator yielding from own actions and nested groups\n        :rtype: Generator\n        \"\"\"\n        for group in self._nested_groups:\n            yield from group._iter()\n        yield from self.actions\n\n    def _get_text_clauses(self) -&gt; List[sqlalchemy.sql.expression.TextClause]:\n        \"\"\"\n        Helper to return list of text queries from actions and nested groups\n        :return: list of text queries from actions and nested groups\n        :rtype: List[sqlalchemy.sql.elements.TextClause]\n        \"\"\"\n        return [x.get_text_clause() for x in self._nested_groups] + [\n            x.get_text_clause() for x in self.actions\n        ]\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Returns all own actions and nested groups conditions compiled and joined\n        inside parentheses.\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        if self.filter_type == FilterType.AND:\n            clause = sqlalchemy.sql.and_(*self._get_text_clauses()).self_group()\n        else:\n            clause = sqlalchemy.sql.or_(*self._get_text_clauses()).self_group()\n        if self.exclude:\n            clause = sqlalchemy.sql.not_(clause)\n        return clause\n</code></pre>"},{"location":"api/queryset/clause/#ormar.queryset.clause.FilterGroup.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Returns all own actions and nested groups conditions compiled and joined inside parentheses. Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Returns all own actions and nested groups conditions compiled and joined\n    inside parentheses.\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    if self.filter_type == FilterType.AND:\n        clause = sqlalchemy.sql.and_(*self._get_text_clauses()).self_group()\n    else:\n        clause = sqlalchemy.sql.or_(*self._get_text_clauses()).self_group()\n    if self.exclude:\n        clause = sqlalchemy.sql.not_(clause)\n    return clause\n</code></pre>"},{"location":"api/queryset/clause/#ormar.queryset.clause.FilterGroup.resolve","title":"<code>resolve(model_cls, select_related=None, filter_clauses=None)</code>","text":"<p>Resolves the FilterGroups actions to use proper target model, replace complex relation prefixes if needed and nested groups also resolved.</p> <p>:param model_cls: model from which the query is run :type model_cls: Type[\"Model\"] :param select_related: list of models to join :type select_related: List[str] :param filter_clauses: list of filter conditions :type filter_clauses: List[FilterAction] :return: list of filter conditions and select_related list :rtype: Tuple[List[FilterAction], List[str]]</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def resolve(\n    self,\n    model_cls: Type[\"Model\"],\n    select_related: Optional[List] = None,\n    filter_clauses: Optional[List] = None,\n) -&gt; Tuple[List[FilterAction], List[str]]:\n    \"\"\"\n    Resolves the FilterGroups actions to use proper target model, replace\n    complex relation prefixes if needed and nested groups also resolved.\n\n    :param model_cls: model from which the query is run\n    :type model_cls: Type[\"Model\"]\n    :param select_related: list of models to join\n    :type select_related: List[str]\n    :param filter_clauses: list of filter conditions\n    :type filter_clauses: List[FilterAction]\n    :return: list of filter conditions and select_related list\n    :rtype: Tuple[List[FilterAction], List[str]]\n    \"\"\"\n    select_related = select_related if select_related is not None else []\n    filter_clauses = filter_clauses if filter_clauses is not None else []\n    qryclause = QueryClause(\n        model_cls=model_cls,\n        select_related=select_related,\n        filter_clauses=filter_clauses,\n    )\n    own_filter_clauses, select_related = qryclause.prepare_filter(\n        _own_only=True, **self._kwargs_dict\n    )\n    self.actions = own_filter_clauses\n    filter_clauses = filter_clauses + own_filter_clauses\n    self._resolved = True\n    if self._nested_groups:\n        for group in self._nested_groups:\n            (filter_clauses, select_related) = group.resolve(\n                model_cls=model_cls,\n                select_related=select_related,\n                filter_clauses=filter_clauses,\n            )\n    return filter_clauses, select_related\n</code></pre>"},{"location":"api/queryset/clause/#ormar.queryset.clause.QueryClause","title":"<code>QueryClause</code>","text":"<p>Constructs FilterActions from strings passed as arguments</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>class QueryClause:\n    \"\"\"\n    Constructs FilterActions from strings passed as arguments\n    \"\"\"\n\n    def __init__(\n        self, model_cls: Type[\"Model\"], filter_clauses: List, select_related: List\n    ) -&gt; None:\n        self._select_related = select_related[:]\n        self.filter_clauses = filter_clauses[:]\n\n        self.model_cls = model_cls\n        self.table = self.model_cls.ormar_config.table\n\n    def prepare_filter(  # noqa: A003\n        self, _own_only: bool = False, **kwargs: Any\n    ) -&gt; Tuple[List[FilterAction], List[str]]:\n        \"\"\"\n        Main external access point that processes the clauses into sqlalchemy text\n        clauses and updates select_related list with implicit related tables\n        mentioned in select_related strings but not included in select_related.\n\n        :param _own_only:\n        :type _own_only:\n        :param kwargs: key, value pair with column names and values\n        :type kwargs: Any\n        :return: Tuple with list of where clauses and updated select_related list\n        :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]\n        \"\"\"\n        if kwargs.get(\"pk\"):\n            pk_name = self.model_cls.get_column_alias(\n                self.model_cls.ormar_config.pkname\n            )\n            kwargs[pk_name] = kwargs.pop(\"pk\")\n\n        filter_clauses, select_related = self._populate_filter_clauses(\n            _own_only=_own_only, **kwargs\n        )\n\n        return filter_clauses, select_related\n\n    def _populate_filter_clauses(\n        self, _own_only: bool, **kwargs: Any\n    ) -&gt; Tuple[List[FilterAction], List[str]]:\n        \"\"\"\n        Iterates all clauses and extracts used operator and field from related\n        models if needed. Based on the chain of related names the target table\n        is determined and the final clause is escaped if needed and compiled.\n\n        :param kwargs: key, value pair with column names and values\n        :type kwargs: Any\n        :return: Tuple with list of where clauses and updated select_related list\n        :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]\n        \"\"\"\n        filter_clauses = self.filter_clauses\n        own_filter_clauses = []\n        select_related = list(self._select_related)\n\n        for key, value in kwargs.items():\n            filter_action = FilterAction(\n                filter_str=key, value=value, model_cls=self.model_cls\n            )\n            select_related = filter_action.update_select_related(\n                select_related=select_related\n            )\n\n            own_filter_clauses.append(filter_action)\n\n        self._register_complex_duplicates(select_related)\n        filter_clauses = self._switch_filter_action_prefixes(\n            filter_clauses=filter_clauses + own_filter_clauses\n        )\n        if _own_only:\n            return own_filter_clauses, select_related\n        return filter_clauses, select_related\n\n    def _register_complex_duplicates(self, select_related: List[str]) -&gt; None:\n        \"\"\"\n        Checks if duplicate aliases are presented which can happen in self relation\n        or when two joins end with the same pair of models.\n\n        If there are duplicates, the all duplicated joins are registered as source\n        model and whole relation key (not just last relation name).\n\n        :param select_related: list of relation strings\n        :type select_related: List[str]\n        :return: None\n        :rtype: None\n        \"\"\"\n        prefixes = self._parse_related_prefixes(select_related=select_related)\n\n        manager = self.model_cls.ormar_config.alias_manager\n        filtered_prefixes = sorted(prefixes, key=lambda x: x.table_prefix)\n        grouped = itertools.groupby(filtered_prefixes, key=lambda x: x.table_prefix)\n        for _, group in grouped:\n            sorted_group = sorted(\n                group, key=lambda x: len(x.relation_str), reverse=True\n            )\n            for prefix in sorted_group[:-1]:\n                if prefix.alias_key not in manager:\n                    manager.add_alias(alias_key=prefix.alias_key)\n\n    def _parse_related_prefixes(self, select_related: List[str]) -&gt; List[Prefix]:\n        \"\"\"\n        Walks all relation strings and parses the target models and prefixes.\n\n        :param select_related: list of relation strings\n        :type select_related: List[str]\n        :return: list of parsed prefixes\n        :rtype: List[Prefix]\n        \"\"\"\n        prefixes: List[Prefix] = []\n        for related in select_related:\n            prefix = Prefix(\n                self.model_cls,\n                *get_relationship_alias_model_and_str(\n                    self.model_cls, related.split(\"__\")\n                ),\n            )\n            prefixes.append(prefix)\n        return prefixes\n\n    def _switch_filter_action_prefixes(\n        self, filter_clauses: List[FilterAction]\n    ) -&gt; List[FilterAction]:\n        \"\"\"\n        Substitutes aliases for filter action if the complex key (whole relation str) is\n        present in alias_manager.\n\n        :param filter_clauses: raw list of actions\n        :type filter_clauses: List[FilterAction]\n        :return: list of actions with aliases changed if needed\n        :rtype: List[FilterAction]\n        \"\"\"\n\n        for action in filter_clauses:\n            if isinstance(action, FilterGroup):\n                for action2 in action._iter():\n                    self._verify_prefix_and_switch(action2)\n            else:\n                self._verify_prefix_and_switch(action)\n        return filter_clauses\n\n    def _verify_prefix_and_switch(self, action: \"FilterAction\") -&gt; None:\n        \"\"\"\n        Helper to switch prefix to complex relation one if required\n        :param action: action to switch prefix in\n        :type action: ormar.queryset.actions.filter_action.FilterAction\n        \"\"\"\n        manager = self.model_cls.ormar_config.alias_manager\n        new_alias = manager.resolve_relation_alias(self.model_cls, action.related_str)\n        if \"__\" in action.related_str and new_alias:\n            action.table_prefix = new_alias\n</code></pre>"},{"location":"api/queryset/clause/#ormar.queryset.clause.QueryClause.prepare_filter","title":"<code>prepare_filter(_own_only=False, **kwargs)</code>","text":"<p>Main external access point that processes the clauses into sqlalchemy text clauses and updates select_related list with implicit related tables mentioned in select_related strings but not included in select_related.</p> <p>:param _own_only: :type _own_only: :param kwargs: key, value pair with column names and values :type kwargs: Any :return: Tuple with list of where clauses and updated select_related list :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def prepare_filter(  # noqa: A003\n    self, _own_only: bool = False, **kwargs: Any\n) -&gt; Tuple[List[FilterAction], List[str]]:\n    \"\"\"\n    Main external access point that processes the clauses into sqlalchemy text\n    clauses and updates select_related list with implicit related tables\n    mentioned in select_related strings but not included in select_related.\n\n    :param _own_only:\n    :type _own_only:\n    :param kwargs: key, value pair with column names and values\n    :type kwargs: Any\n    :return: Tuple with list of where clauses and updated select_related list\n    :rtype: Tuple[List[sqlalchemy.sql.elements.TextClause], List[str]]\n    \"\"\"\n    if kwargs.get(\"pk\"):\n        pk_name = self.model_cls.get_column_alias(\n            self.model_cls.ormar_config.pkname\n        )\n        kwargs[pk_name] = kwargs.pop(\"pk\")\n\n    filter_clauses, select_related = self._populate_filter_clauses(\n        _own_only=_own_only, **kwargs\n    )\n\n    return filter_clauses, select_related\n</code></pre>"},{"location":"api/queryset/clause/#ormar.queryset.clause.and_","title":"<code>and_(*args, **kwargs)</code>","text":"<p>Construct and filter from nested groups and keyword arguments</p> <p>:param args: nested filter groups :type args: Tuple[FilterGroup] :param kwargs: fields names and proper value types :type kwargs: Any :return: FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def and_(*args: FilterGroup, **kwargs: Any) -&gt; FilterGroup:\n    \"\"\"\n    Construct and filter from nested groups and keyword arguments\n\n    :param args: nested filter groups\n    :type args: Tuple[FilterGroup]\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: FilterGroup ready to be resolved\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return FilterGroup(_filter_type=FilterType.AND, *args, **kwargs)\n</code></pre>"},{"location":"api/queryset/clause/#ormar.queryset.clause.or_","title":"<code>or_(*args, **kwargs)</code>","text":"<p>Construct or filter from nested groups and keyword arguments</p> <p>:param args: nested filter groups :type args: Tuple[FilterGroup] :param kwargs: fields names and proper value types :type kwargs: Any :return: FilterGroup ready to be resolved :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/clause.py</code> <pre><code>def or_(*args: FilterGroup, **kwargs: Any) -&gt; FilterGroup:\n    \"\"\"\n    Construct or filter from nested groups and keyword arguments\n\n    :param args: nested filter groups\n    :type args: Tuple[FilterGroup]\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: FilterGroup ready to be resolved\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return FilterGroup(_filter_type=FilterType.OR, *args, **kwargs)\n</code></pre>"},{"location":"api/queryset/field_accessor/","title":"field_accessor","text":""},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor","title":"<code>FieldAccessor</code>","text":"<p>Helper to access ormar fields directly from Model class also for nested models attributes.</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>class FieldAccessor:\n    \"\"\"\n    Helper to access ormar fields directly from Model class also for nested\n    models attributes.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_model: Type[\"Model\"],\n        field: Optional[\"BaseField\"] = None,\n        model: Optional[Type[\"Model\"]] = None,\n        access_chain: str = \"\",\n    ) -&gt; None:\n        self._source_model = source_model\n        self._field = field\n        self._model = model\n        self._access_chain = access_chain\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"\n        Accessor return new accessor for each field and nested models.\n        Thanks to that operator overload is possible to use in filter.\n\n        :param item: attribute name\n        :type item: str\n        :return: FieldAccessor for field or nested model\n        :rtype: ormar.queryset.field_accessor.FieldAccessor\n        \"\"\"\n        if (\n            object.__getattribute__(self, \"_field\")\n            and item == object.__getattribute__(self, \"_field\").name\n        ):\n            return self._field\n\n        if (\n            object.__getattribute__(self, \"_model\")\n            and item\n            in object.__getattribute__(self, \"_model\").ormar_config.model_fields\n        ):\n            field = cast(\"Model\", self._model).ormar_config.model_fields[item]\n            if field.is_relation:\n                return FieldAccessor(\n                    source_model=self._source_model,\n                    model=field.to,\n                    access_chain=self._access_chain + f\"__{item}\",\n                )\n            else:\n                return FieldAccessor(\n                    source_model=self._source_model,\n                    field=field,\n                    access_chain=self._access_chain + f\"__{item}\",\n                )\n        return object.__getattribute__(self, item)  # pragma: no cover\n\n    def _check_field(self) -&gt; None:\n        if not self._field:\n            raise AttributeError(\n                \"Cannot filter by Model, you need to provide model name\"\n            )\n\n    def _select_operator(self, op: str, other: Any) -&gt; FilterGroup:\n        self._check_field()\n        filter_kwg = {self._access_chain + f\"__{METHODS_TO_OPERATORS[op]}\": other}\n        return FilterGroup(**filter_kwg)\n\n    def __eq__(self, other: Any) -&gt; FilterGroup:  # type: ignore\n        \"\"\"\n        overloaded to work as sql `column = &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__eq__\", other=other)\n\n    def __ge__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &gt;= &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__ge__\", other=other)\n\n    def __gt__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &gt; &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__gt__\", other=other)\n\n    def __le__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &lt;= &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__le__\", other=other)\n\n    def __lt__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column &lt; &lt;VALUE&gt;`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__lt__\", other=other)\n\n    def __mod__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"__mod__\", other=other)\n\n    def __lshift__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"in\", other=other)\n\n    def __rshift__(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        overloaded to work as sql `column IS NULL`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"isnull\", other=True)\n\n    def in_(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"in\", other=other)\n\n    def iexact(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column = &lt;VALUE&gt;` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"iexact\", other=other)\n\n    def contains(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"contains\", other=other)\n\n    def icontains(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;%'` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"icontains\", other=other)\n\n    def startswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '&lt;VALUE&gt;%'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"startswith\", other=other)\n\n    def istartswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"istartswith\", other=other)\n\n    def endswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;'`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"endswith\", other=other)\n\n    def iendswith(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"iendswith\", other=other)\n\n    def isnull(self, other: Any) -&gt; FilterGroup:\n        \"\"\"\n        works as sql `column IS NULL` or `IS NOT NULL`\n\n        :param other: value to check agains operator\n        :type other: str\n        :return: FilterGroup for operator\n        :rtype: ormar.queryset.clause.FilterGroup\n        \"\"\"\n        return self._select_operator(op=\"isnull\", other=other)\n\n    def asc(self) -&gt; OrderAction:\n        \"\"\"\n        works as sql `column asc`\n\n        :return: OrderGroup for operator\n        :rtype: ormar.queryset.actions.OrderGroup\n        \"\"\"\n        return OrderAction(order_str=self._access_chain, model_cls=self._source_model)\n\n    def desc(self) -&gt; OrderAction:\n        \"\"\"\n        works as sql `column desc`\n\n        :return: OrderGroup for operator\n        :rtype: ormar.queryset.actions.OrderGroup\n        \"\"\"\n        return OrderAction(\n            order_str=\"-\" + self._access_chain, model_cls=self._source_model\n        )\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__eq__","title":"<code>__eq__(other)</code>","text":"<p>overloaded to work as sql <code>column = &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __eq__(self, other: Any) -&gt; FilterGroup:  # type: ignore\n    \"\"\"\n    overloaded to work as sql `column = &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__eq__\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__ge__","title":"<code>__ge__(other)</code>","text":"<p>overloaded to work as sql <code>column &gt;= &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __ge__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &gt;= &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__ge__\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Accessor return new accessor for each field and nested models. Thanks to that operator overload is possible to use in filter.</p> <p>:param item: attribute name :type item: str :return: FieldAccessor for field or nested model :rtype: ormar.queryset.field_accessor.FieldAccessor</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    \"\"\"\n    Accessor return new accessor for each field and nested models.\n    Thanks to that operator overload is possible to use in filter.\n\n    :param item: attribute name\n    :type item: str\n    :return: FieldAccessor for field or nested model\n    :rtype: ormar.queryset.field_accessor.FieldAccessor\n    \"\"\"\n    if (\n        object.__getattribute__(self, \"_field\")\n        and item == object.__getattribute__(self, \"_field\").name\n    ):\n        return self._field\n\n    if (\n        object.__getattribute__(self, \"_model\")\n        and item\n        in object.__getattribute__(self, \"_model\").ormar_config.model_fields\n    ):\n        field = cast(\"Model\", self._model).ormar_config.model_fields[item]\n        if field.is_relation:\n            return FieldAccessor(\n                source_model=self._source_model,\n                model=field.to,\n                access_chain=self._access_chain + f\"__{item}\",\n            )\n        else:\n            return FieldAccessor(\n                source_model=self._source_model,\n                field=field,\n                access_chain=self._access_chain + f\"__{item}\",\n            )\n    return object.__getattribute__(self, item)  # pragma: no cover\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__gt__","title":"<code>__gt__(other)</code>","text":"<p>overloaded to work as sql <code>column &gt; &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __gt__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &gt; &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__gt__\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__le__","title":"<code>__le__(other)</code>","text":"<p>overloaded to work as sql <code>column &lt;= &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __le__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &lt;= &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__le__\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>overloaded to work as sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __lshift__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"in\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__lt__","title":"<code>__lt__(other)</code>","text":"<p>overloaded to work as sql <code>column &lt; &lt;VALUE&gt;</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __lt__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column &lt; &lt;VALUE&gt;`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__lt__\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__mod__","title":"<code>__mod__(other)</code>","text":"<p>overloaded to work as sql <code>column LIKE '%&lt;VALUE&gt;%'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __mod__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"__mod__\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.__rshift__","title":"<code>__rshift__(other)</code>","text":"<p>overloaded to work as sql <code>column IS NULL</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def __rshift__(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    overloaded to work as sql `column IS NULL`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"isnull\", other=True)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.asc","title":"<code>asc()</code>","text":"<p>works as sql <code>column asc</code></p> <p>:return: OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def asc(self) -&gt; OrderAction:\n    \"\"\"\n    works as sql `column asc`\n\n    :return: OrderGroup for operator\n    :rtype: ormar.queryset.actions.OrderGroup\n    \"\"\"\n    return OrderAction(order_str=self._access_chain, model_cls=self._source_model)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.contains","title":"<code>contains(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;%'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def contains(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;%'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"contains\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.desc","title":"<code>desc()</code>","text":"<p>works as sql <code>column desc</code></p> <p>:return: OrderGroup for operator :rtype: ormar.queryset.actions.OrderGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def desc(self) -&gt; OrderAction:\n    \"\"\"\n    works as sql `column desc`\n\n    :return: OrderGroup for operator\n    :rtype: ormar.queryset.actions.OrderGroup\n    \"\"\"\n    return OrderAction(\n        order_str=\"-\" + self._access_chain, model_cls=self._source_model\n    )\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.endswith","title":"<code>endswith(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def endswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"endswith\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.icontains","title":"<code>icontains(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;%'</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def icontains(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;%'` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"icontains\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.iendswith","title":"<code>iendswith(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;'</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def iendswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"iendswith\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.iexact","title":"<code>iexact(other)</code>","text":"<p>works as sql <code>column = &lt;VALUE&gt;</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def iexact(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column = &lt;VALUE&gt;` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"iexact\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.in_","title":"<code>in_(other)</code>","text":"<p>works as sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def in_(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;,...)`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"in\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.isnull","title":"<code>isnull(other)</code>","text":"<p>works as sql <code>column IS NULL</code> or <code>IS NOT NULL</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def isnull(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column IS NULL` or `IS NOT NULL`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"isnull\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.istartswith","title":"<code>istartswith(other)</code>","text":"<p>works as sql <code>column LIKE '%&lt;VALUE&gt;'</code> case-insensitive</p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def istartswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '%&lt;VALUE&gt;'` case-insensitive\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"istartswith\", other=other)\n</code></pre>"},{"location":"api/queryset/field_accessor/#ormar.queryset.field_accessor.FieldAccessor.startswith","title":"<code>startswith(other)</code>","text":"<p>works as sql <code>column LIKE '&lt;VALUE&gt;%'</code></p> <p>:param other: value to check agains operator :type other: str :return: FilterGroup for operator :rtype: ormar.queryset.clause.FilterGroup</p> Source code in <code>ormar/queryset/field_accessor.py</code> <pre><code>def startswith(self, other: Any) -&gt; FilterGroup:\n    \"\"\"\n    works as sql `column LIKE '&lt;VALUE&gt;%'`\n\n    :param other: value to check agains operator\n    :type other: str\n    :return: FilterGroup for operator\n    :rtype: ormar.queryset.clause.FilterGroup\n    \"\"\"\n    return self._select_operator(op=\"startswith\", other=other)\n</code></pre>"},{"location":"api/queryset/join/","title":"join","text":""},{"location":"api/queryset/join/#ormar.queryset.join.SqlJoin","title":"<code>SqlJoin</code>","text":"Source code in <code>ormar/queryset/join.py</code> <pre><code>class SqlJoin:\n    def __init__(  # noqa:  CFQ002\n        self,\n        used_aliases: List,\n        select_from: sqlalchemy.sql.select,\n        columns: List[sqlalchemy.Column],\n        excludable: \"ExcludableItems\",\n        order_columns: Optional[List[\"OrderAction\"]],\n        sorted_orders: Dict,\n        main_model: Type[\"Model\"],\n        relation_name: str,\n        relation_str: str,\n        related_models: Any = None,\n        own_alias: str = \"\",\n        source_model: Optional[Type[\"Model\"]] = None,\n        already_sorted: Optional[Dict] = None,\n    ) -&gt; None:\n        self.relation_name = relation_name\n        self.related_models = related_models or []\n        self.select_from = select_from\n        self.columns = columns\n        self.excludable = excludable\n\n        self.order_columns = order_columns\n        self.sorted_orders = sorted_orders\n        self.already_sorted = already_sorted or dict()\n\n        self.main_model = main_model\n        self.own_alias = own_alias\n        self.used_aliases = used_aliases\n        self.target_field = self.main_model.ormar_config.model_fields[\n            self.relation_name\n        ]\n\n        self._next_model: Optional[Type[\"Model\"]] = None\n        self._next_alias: Optional[str] = None\n\n        self.relation_str = relation_str\n        self.source_model = source_model\n\n    @property\n    def next_model(self) -&gt; Type[\"Model\"]:\n        if not self._next_model:  # pragma: nocover\n            raise RelationshipInstanceError(\n                \"Cannot link to related table if relation.to model is not set.\"\n            )\n        return self._next_model\n\n    @next_model.setter\n    def next_model(self, value: Type[\"Model\"]) -&gt; None:\n        self._next_model = value\n\n    @property\n    def next_alias(self) -&gt; str:\n        if not self._next_alias:  # pragma: nocover\n            raise RelationshipInstanceError(\"Alias for given relation not found.\")\n        return self._next_alias\n\n    @next_alias.setter\n    def next_alias(self, value: str) -&gt; None:\n        self._next_alias = value\n\n    @property\n    def alias_manager(self) -&gt; AliasManager:\n        \"\"\"\n        Shortcut for ormar's model AliasManager stored on OrmarConfig.\n\n        :return: alias manager from model's OrmarConfig\n        :rtype: AliasManager\n        \"\"\"\n        return self.main_model.ormar_config.alias_manager\n\n    @property\n    def to_table(self) -&gt; sqlalchemy.Table:\n        \"\"\"\n        Shortcut to table name of the next model\n        :return: name of the target table\n        :rtype: str\n        \"\"\"\n        return self.next_model.ormar_config.table\n\n    def _on_clause(\n        self,\n        previous_alias: str,\n        from_table_name: str,\n        from_column_name: str,\n        to_table_name: str,\n        to_column_name: str,\n    ) -&gt; text:\n        \"\"\"\n        Receives aliases and names of both ends of the join and combines them\n        into one text clause used in joins.\n\n        :param previous_alias: alias of previous table\n        :type previous_alias: str\n        :param from_table_name: from table name\n        :type from_table_name: str\n        :param from_column_name: from column name\n        :type from_column_name: str\n        :param to_table_name: to table name\n        :type to_table_name: str\n        :param to_column_name: to column name\n        :type to_column_name: str\n        :return: clause combining all strings\n        :rtype: sqlalchemy.text\n        \"\"\"\n        dialect = self.main_model.ormar_config.database._backend._dialect\n        quoter = dialect.identifier_preparer.quote\n        left_part = (\n            f\"{quoter(f'{self.next_alias}_{to_table_name}')}.{quoter(to_column_name)}\"\n        )\n        if not previous_alias:\n            right_part = f\"{quoter(from_table_name)}.{quoter(from_column_name)}\"\n        else:\n            right_part = (\n                f\"{quoter(f'{previous_alias}_{from_table_name}')}.{from_column_name}\"\n            )\n\n        return text(f\"{left_part}={right_part}\")\n\n    def build_join(self) -&gt; Tuple[List, sqlalchemy.sql.select, List, Dict]:\n        \"\"\"\n        Main external access point for building a join.\n        Splits the join definition, updates fields and exclude_fields if needed,\n        handles switching to through models for m2m relations, returns updated lists of\n        used_aliases and sort_orders.\n\n        :return: list of used aliases, select from, list of aliased columns, sort orders\n        :rtype: Tuple[List[str], Join, List[TextClause], Dict]\n        \"\"\"\n        if self.target_field.is_multi:\n            self._process_m2m_through_table()\n\n        self.next_model = self.target_field.to\n        self._forward_join()\n\n        self._process_following_joins()\n\n        return (self.used_aliases, self.select_from, self.columns, self.sorted_orders)\n\n    def _forward_join(self) -&gt; None:\n        \"\"\"\n        Process actual join.\n        Registers complex relation join on encountering of the duplicated alias.\n        \"\"\"\n        self.next_alias = self.alias_manager.resolve_relation_alias(\n            from_model=self.target_field.owner, relation_name=self.relation_name\n        )\n        if self.next_alias not in self.used_aliases:\n            self._process_join()\n        else:\n            if \"__\" in self.relation_str and self.source_model:\n                relation_key = f\"{self.source_model.get_name()}_{self.relation_str}\"\n                if relation_key not in self.alias_manager:\n                    self.next_alias = self.alias_manager.add_alias(\n                        alias_key=relation_key\n                    )\n                else:\n                    self.next_alias = self.alias_manager[relation_key]\n                self._process_join()\n\n    def _process_following_joins(self) -&gt; None:\n        \"\"\"\n        Iterates through nested models to create subsequent joins.\n        \"\"\"\n        for related_name in self.related_models:\n            remainder = None\n            if (\n                isinstance(self.related_models, dict)\n                and self.related_models[related_name]\n            ):\n                remainder = self.related_models[related_name]\n            self._process_deeper_join(related_name=related_name, remainder=remainder)\n\n    def _process_deeper_join(self, related_name: str, remainder: Any) -&gt; None:\n        \"\"\"\n        Creates nested recurrent instance of SqlJoin for each nested join table,\n        updating needed return params here as a side effect.\n\n        Updated are:\n\n        * self.used_aliases,\n        * self.select_from,\n        * self.columns,\n        * self.sorted_orders,\n\n        :param related_name: name of the relation to follow\n        :type related_name: str\n        :param remainder: deeper tables if there are more nested joins\n        :type remainder: Any\n        \"\"\"\n        sql_join = SqlJoin(\n            used_aliases=self.used_aliases,\n            select_from=self.select_from,\n            columns=self.columns,\n            excludable=self.excludable,\n            order_columns=self.order_columns,\n            sorted_orders=self.sorted_orders,\n            main_model=self.next_model,\n            relation_name=related_name,\n            related_models=remainder,\n            relation_str=\"__\".join([self.relation_str, related_name]),\n            own_alias=self.next_alias,\n            source_model=self.source_model or self.main_model,\n            already_sorted=self.already_sorted,\n        )\n        (\n            self.used_aliases,\n            self.select_from,\n            self.columns,\n            self.sorted_orders,\n        ) = sql_join.build_join()\n\n    def _process_m2m_through_table(self) -&gt; None:\n        \"\"\"\n        Process Through table of the ManyToMany relation so that source table is\n        linked to the through table (one additional join)\n\n        Replaces needed parameters like:\n\n        * self.next_model,\n        * self.next_alias,\n        * self.relation_name,\n        * self.own_alias,\n        * self.target_field\n\n        To point to through model\n        \"\"\"\n        new_part = self._process_m2m_related_name_change()\n\n        self.next_model = self.target_field.through\n        self._forward_join()\n\n        self.relation_name = new_part\n        self.own_alias = self.next_alias\n        self.target_field = self.next_model.ormar_config.model_fields[\n            self.relation_name\n        ]\n\n    def _process_m2m_related_name_change(self, reverse: bool = False) -&gt; str:\n        \"\"\"\n        Extracts relation name to link join through the Through model declared on\n        relation field.\n\n        Changes the same names in order_by queries if they are present.\n\n        :param reverse: flag if it's on_clause lookup - use reverse fields\n        :type reverse: bool\n        :return: new relation name switched to through model field\n        :rtype: str\n        \"\"\"\n        target_field = self.target_field\n        is_primary_self_ref = (\n            target_field.self_reference\n            and self.relation_name == target_field.self_reference_primary\n        )\n        if (is_primary_self_ref and not reverse) or (\n            not is_primary_self_ref and reverse\n        ):\n            new_part = target_field.default_source_field_name()  # type: ignore\n        else:\n            new_part = target_field.default_target_field_name()  # type: ignore\n        return new_part\n\n    def _process_join(self) -&gt; None:  # noqa: CFQ002\n        \"\"\"\n        Resolves to and from column names and table names.\n\n        Produces on_clause.\n\n        Performs actual join updating select_from parameter.\n\n        Adds aliases of required column to list of columns to include in query.\n\n        Updates the used aliases list directly.\n\n        Process order_by causes for non m2m relations.\n\n        \"\"\"\n        to_key, from_key = self._get_to_and_from_keys()\n\n        on_clause = self._on_clause(\n            previous_alias=self.own_alias,\n            from_table_name=self.target_field.owner.ormar_config.tablename,\n            from_column_name=from_key,\n            to_table_name=self.to_table.name,\n            to_column_name=to_key,\n        )\n        target_table = self.alias_manager.prefixed_table_name(\n            self.next_alias, self.to_table\n        )\n        self.select_from = sqlalchemy.sql.outerjoin(\n            self.select_from, target_table, on_clause\n        )\n\n        self._get_order_bys()\n\n        self_related_fields = self.next_model.own_table_columns(\n            model=self.next_model,\n            excludable=self.excludable,\n            alias=self.next_alias,\n            use_alias=True,\n        )\n        self.columns.extend(\n            self.alias_manager.prefixed_columns(\n                self.next_alias, target_table, self_related_fields\n            )\n        )\n        self.used_aliases.append(self.next_alias)\n\n    def _set_default_primary_key_order_by(self) -&gt; None:\n        for order_by in self.next_model.ormar_config.orders_by:\n            clause = ormar.OrderAction(\n                order_str=order_by, model_cls=self.next_model, alias=self.next_alias\n            )\n            self.sorted_orders[clause] = clause.get_text_clause()\n\n    def _verify_allowed_order_field(self, order_by: str) -&gt; None:\n        \"\"\"\n        Verifies if proper field string is used.\n        :param order_by: string with order by definition\n        :type order_by: str\n        \"\"\"\n        parts = order_by.split(\"__\")\n        if len(parts) &gt; 2 or parts[0] != self.target_field.through.get_name():\n            raise ModelDefinitionError(\n                \"You can order the relation only \" \"by related or link table columns!\"\n            )\n\n    def _get_alias_and_model(self, order_by: str) -&gt; Tuple[str, Type[\"Model\"]]:\n        \"\"\"\n        Returns proper model and alias to be applied in the clause.\n\n        :param order_by: string with order by definition\n        :type order_by: str\n        :return: alias and model to be used in clause\n        :rtype: Tuple[str, Type[\"Model\"]]\n        \"\"\"\n        if self.target_field.is_multi and \"__\" in order_by:\n            self._verify_allowed_order_field(order_by=order_by)\n            alias = self.next_alias\n            model = self.target_field.owner\n        elif self.target_field.is_multi:\n            alias = self.alias_manager.resolve_relation_alias(\n                from_model=self.target_field.through,\n                relation_name=cast(\n                    \"ManyToManyField\", self.target_field\n                ).default_target_field_name(),\n            )\n            model = self.target_field.to\n        else:\n            alias = self.alias_manager.resolve_relation_alias(\n                from_model=self.target_field.owner, relation_name=self.target_field.name\n            )\n            model = self.target_field.to\n\n        return alias, model\n\n    def _get_order_bys(self) -&gt; None:  # noqa: CCR001\n        \"\"\"\n        Triggers construction of order bys if they are given.\n        Otherwise by default each table is sorted by a primary key column asc.\n        \"\"\"\n        alias = self.next_alias\n        current_table_sorted = False\n        if f\"{alias}_{self.next_model.get_name()}\" in self.already_sorted:\n            current_table_sorted = True\n        if self.order_columns:\n            for condition in self.order_columns:\n                if condition.check_if_filter_apply(\n                    target_model=self.next_model, alias=alias\n                ):\n                    current_table_sorted = True\n                    self.sorted_orders[condition] = condition.get_text_clause()\n                    self.already_sorted[\n                        f\"{self.next_alias}_{self.next_model.get_name()}\"\n                    ] = condition\n        if self.target_field.orders_by and not current_table_sorted:\n            current_table_sorted = True\n            for order_by in self.target_field.orders_by:\n                alias, model = self._get_alias_and_model(order_by=order_by)\n                clause = ormar.OrderAction(\n                    order_str=order_by, model_cls=model, alias=alias\n                )\n                self.sorted_orders[clause] = clause.get_text_clause()\n                self.already_sorted[f\"{alias}_{model.get_name()}\"] = clause\n\n        if not current_table_sorted and not self.target_field.is_multi:\n            self._set_default_primary_key_order_by()\n\n    def _get_to_and_from_keys(self) -&gt; Tuple[str, str]:\n        \"\"\"\n        Based on the relation type, name of the relation and previous models and parts\n        stored in JoinParameters it resolves the current to and from keys, which are\n        different for ManyToMany relation, ForeignKey and reverse related of relations.\n\n        :return: to key and from key\n        :rtype: Tuple[str, str]\n        \"\"\"\n        if self.target_field.is_multi:\n            to_key = self._process_m2m_related_name_change(reverse=True)\n            from_key = self.main_model.get_column_alias(\n                self.main_model.ormar_config.pkname\n            )\n\n        elif self.target_field.virtual:\n            to_field = self.target_field.get_related_name()\n            to_key = self.target_field.to.get_column_alias(to_field)\n            from_key = self.main_model.get_column_alias(\n                self.main_model.ormar_config.pkname\n            )\n\n        else:\n            to_key = self.target_field.to.get_column_alias(\n                self.target_field.to.ormar_config.pkname\n            )\n            from_key = self.main_model.get_column_alias(self.relation_name)\n\n        return to_key, from_key\n</code></pre>"},{"location":"api/queryset/join/#ormar.queryset.join.SqlJoin.alias_manager","title":"<code>alias_manager: AliasManager</code>  <code>property</code>","text":"<p>Shortcut for ormar's model AliasManager stored on OrmarConfig.</p> <p>:return: alias manager from model's OrmarConfig :rtype: AliasManager</p>"},{"location":"api/queryset/join/#ormar.queryset.join.SqlJoin.to_table","title":"<code>to_table: sqlalchemy.Table</code>  <code>property</code>","text":"<p>Shortcut to table name of the next model :return: name of the target table :rtype: str</p>"},{"location":"api/queryset/join/#ormar.queryset.join.SqlJoin.build_join","title":"<code>build_join()</code>","text":"<p>Main external access point for building a join. Splits the join definition, updates fields and exclude_fields if needed, handles switching to through models for m2m relations, returns updated lists of used_aliases and sort_orders.</p> <p>:return: list of used aliases, select from, list of aliased columns, sort orders :rtype: Tuple[List[str], Join, List[TextClause], Dict]</p> Source code in <code>ormar/queryset/join.py</code> <pre><code>def build_join(self) -&gt; Tuple[List, sqlalchemy.sql.select, List, Dict]:\n    \"\"\"\n    Main external access point for building a join.\n    Splits the join definition, updates fields and exclude_fields if needed,\n    handles switching to through models for m2m relations, returns updated lists of\n    used_aliases and sort_orders.\n\n    :return: list of used aliases, select from, list of aliased columns, sort orders\n    :rtype: Tuple[List[str], Join, List[TextClause], Dict]\n    \"\"\"\n    if self.target_field.is_multi:\n        self._process_m2m_through_table()\n\n    self.next_model = self.target_field.to\n    self._forward_join()\n\n    self._process_following_joins()\n\n    return (self.used_aliases, self.select_from, self.columns, self.sorted_orders)\n</code></pre>"},{"location":"api/queryset/queryset/","title":"queryset","text":""},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet","title":"<code>QuerySet</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Main class to perform database queries, exposed on each model as objects attribute.</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>class QuerySet(Generic[T]):\n    \"\"\"\n    Main class to perform database queries, exposed on each model as objects attribute.\n    \"\"\"\n\n    def __init__(  # noqa CFQ002\n        self,\n        model_cls: Optional[Type[\"T\"]] = None,\n        filter_clauses: Optional[List] = None,\n        exclude_clauses: Optional[List] = None,\n        select_related: Optional[List] = None,\n        limit_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        excludable: Optional[\"ExcludableItems\"] = None,\n        order_bys: Optional[List] = None,\n        prefetch_related: Optional[List] = None,\n        limit_raw_sql: bool = False,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; None:\n        self.proxy_source_model = proxy_source_model\n        self.model_cls = model_cls\n        self.filter_clauses = [] if filter_clauses is None else filter_clauses\n        self.exclude_clauses = [] if exclude_clauses is None else exclude_clauses\n        self._select_related = [] if select_related is None else select_related\n        self._prefetch_related = [] if prefetch_related is None else prefetch_related\n        self.limit_count = limit_count\n        self.query_offset = offset\n        self._excludable = excludable or ormar.ExcludableItems()\n        self.order_bys = order_bys or []\n        self.limit_sql_raw = limit_raw_sql\n\n    @property\n    def model_config(self) -&gt; \"OrmarConfig\":\n        \"\"\"\n        Shortcut to model class OrmarConfig set on QuerySet model.\n\n        :return: OrmarConfig of the model\n        :rtype: model's OrmarConfig\n        \"\"\"\n        if not self.model_cls:  # pragma nocover\n            raise ValueError(\"Model class of QuerySet is not initialized\")\n        return self.model_cls.ormar_config\n\n    @property\n    def model(self) -&gt; Type[\"T\"]:\n        \"\"\"\n        Shortcut to model class set on QuerySet.\n\n        :return: model class\n        :rtype: Type[Model]\n        \"\"\"\n        if not self.model_cls:  # pragma nocover\n            raise ValueError(\"Model class of QuerySet is not initialized\")\n        return self.model_cls\n\n    def rebuild_self(  # noqa: CFQ002\n        self,\n        filter_clauses: Optional[List] = None,\n        exclude_clauses: Optional[List] = None,\n        select_related: Optional[List] = None,\n        limit_count: Optional[int] = None,\n        offset: Optional[int] = None,\n        excludable: Optional[\"ExcludableItems\"] = None,\n        order_bys: Optional[List] = None,\n        prefetch_related: Optional[List] = None,\n        limit_raw_sql: Optional[bool] = None,\n        proxy_source_model: Optional[Type[\"Model\"]] = None,\n    ) -&gt; \"QuerySet\":\n        \"\"\"\n        Method that returns new instance of queryset based on passed params,\n        all not passed params are taken from current values.\n        \"\"\"\n        overwrites = {\n            \"select_related\": \"_select_related\",\n            \"offset\": \"query_offset\",\n            \"excludable\": \"_excludable\",\n            \"prefetch_related\": \"_prefetch_related\",\n            \"limit_raw_sql\": \"limit_sql_raw\",\n        }\n        passed_args = locals()\n\n        def replace_if_none(arg_name: str) -&gt; Any:\n            if passed_args.get(arg_name) is None:\n                return getattr(self, overwrites.get(arg_name, arg_name))\n            return passed_args.get(arg_name)\n\n        return self.__class__(\n            model_cls=self.model_cls,\n            filter_clauses=replace_if_none(\"filter_clauses\"),\n            exclude_clauses=replace_if_none(\"exclude_clauses\"),\n            select_related=replace_if_none(\"select_related\"),\n            limit_count=replace_if_none(\"limit_count\"),\n            offset=replace_if_none(\"offset\"),\n            excludable=replace_if_none(\"excludable\"),\n            order_bys=replace_if_none(\"order_bys\"),\n            prefetch_related=replace_if_none(\"prefetch_related\"),\n            limit_raw_sql=replace_if_none(\"limit_raw_sql\"),\n            proxy_source_model=replace_if_none(\"proxy_source_model\"),\n        )\n\n    async def _prefetch_related_models(\n        self, models: List[\"T\"], rows: List\n    ) -&gt; List[\"T\"]:\n        \"\"\"\n        Performs prefetch query for selected models names.\n\n        :param models: list of already parsed main Models from main query\n        :type models: List[Model]\n        :param rows: database rows from main query\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models with prefetch models populated\n        :rtype: List[Model]\n        \"\"\"\n        query = PrefetchQuery(\n            model_cls=self.model,\n            excludable=self._excludable,\n            prefetch_related=self._prefetch_related,\n            select_related=self._select_related,\n            orders_by=self.order_bys,\n        )\n        return await query.prefetch_related(models=models)  # type: ignore\n\n    async def _process_query_result_rows(self, rows: List) -&gt; List[\"T\"]:\n        \"\"\"\n        Process database rows and initialize ormar Model from each of the rows.\n\n        :param rows: list of database rows from query result\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models\n        :rtype: List[Model]\n        \"\"\"\n        result_rows = []\n        for row in rows:\n            result_rows.append(\n                self.model.from_row(\n                    row=row,\n                    select_related=self._select_related,\n                    excludable=self._excludable,\n                    source_model=self.model,\n                    proxy_source_model=self.proxy_source_model,\n                )\n            )\n            await asyncio.sleep(0)\n\n        if result_rows:\n            return self.model.merge_instances_list(result_rows)  # type: ignore\n        return cast(List[\"T\"], result_rows)\n\n    def _resolve_filter_groups(\n        self, groups: Any\n    ) -&gt; Tuple[List[FilterGroup], List[str]]:\n        \"\"\"\n        Resolves filter groups to populate FilterAction params in group tree.\n\n        :param groups: tuple of FilterGroups\n        :type groups: Any\n        :return: list of resolver groups\n        :rtype: Tuple[List[FilterGroup], List[str]]\n        \"\"\"\n        filter_groups = []\n        select_related = self._select_related\n        if groups:\n            for group in groups:\n                if not isinstance(group, FilterGroup):\n                    raise QueryDefinitionError(\n                        \"Only ormar.and_ and ormar.or_ \"\n                        \"can be passed as filter positional\"\n                        \" arguments,\"\n                        \"other values need to be passed by\"\n                        \"keyword arguments\"\n                    )\n                _, select_related = group.resolve(\n                    model_cls=self.model,\n                    select_related=self._select_related,\n                    filter_clauses=self.filter_clauses,\n                )\n                filter_groups.append(group)\n        return filter_groups, select_related\n\n    @staticmethod\n    def check_single_result_rows_count(rows: Sequence[Optional[\"T\"]]) -&gt; None:\n        \"\"\"\n        Verifies if the result has one and only one row.\n\n        :param rows: one element list of Models\n        :type rows: List[Model]\n        \"\"\"\n        if not rows or rows[0] is None:\n            raise NoMatch()\n        if len(rows) &gt; 1:\n            raise MultipleMatches()\n\n    @property\n    def database(self) -&gt; databases.Database:\n        \"\"\"\n        Shortcut to models database from OrmarConfig class.\n\n        :return: database\n        :rtype: databases.Database\n        \"\"\"\n        return self.model_config.database\n\n    @property\n    def table(self) -&gt; sqlalchemy.Table:\n        \"\"\"\n        Shortcut to models table from OrmarConfig.\n\n        :return: database table\n        :rtype: sqlalchemy.Table\n        \"\"\"\n        return self.model_config.table\n\n    def build_select_expression(\n        self,\n        limit: Optional[int] = None,\n        offset: Optional[int] = None,\n        order_bys: Optional[List] = None,\n    ) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Constructs the actual database query used in the QuerySet.\n        If any of the params is not passed the QuerySet own value is used.\n\n        :param limit: number to limit the query\n        :type limit: int\n        :param offset: number to offset by\n        :type offset: int\n        :param order_bys: list of order-by fields names\n        :type order_bys: List\n        :return: built sqlalchemy select expression\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        qry = Query(\n            model_cls=self.model,\n            select_related=self._select_related,\n            filter_clauses=self.filter_clauses,\n            exclude_clauses=self.exclude_clauses,\n            offset=offset or self.query_offset,\n            excludable=self._excludable,\n            order_bys=order_bys or self.order_bys,\n            limit_raw_sql=self.limit_sql_raw,\n            limit_count=limit if limit is not None else self.limit_count,\n        )\n        exp = qry.build_select_expression()\n        # print(\"\\n\", exp.compile(compile_kwargs={\"literal_binds\": True}))\n        return exp\n\n    def filter(  # noqa: A003\n        self, *args: Any, _exclude: bool = False, **kwargs: Any\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows you to filter by any `Model` attribute/field\n        as well as to fetch instances, with a filter across an FK relationship.\n\n        You can use special filter suffix to change the filter operands:\n\n        *  exact - like `album__name__exact='Malibu'` (exact match)\n        *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n        *  contains - like `album__name__contains='Mal'` (sql like)\n        *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n        *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n        *  isnull - like `album__name__isnull=True` (sql is null)\n           (isnotnull `album__name__isnull=False` (sql is not null))\n        *  gt - like `position__gt=3` (sql &gt;)\n        *  gte - like `position__gte=3` (sql &gt;=)\n        *  lt - like `position__lt=3` (sql &lt;)\n        *  lte - like `position__lte=3` (sql &lt;=)\n        *  startswith - like `album__name__startswith='Mal'` (exact start match)\n        *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n        *  endswith - like `album__name__endswith='ibu'` (exact end match)\n        *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n        Note that you can also use python style filters - check the docs!\n\n        :param _exclude: flag if it should be exclude or filter\n        :type _exclude: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        filter_groups, select_related = self._resolve_filter_groups(groups=args)\n        qryclause = QueryClause(\n            model_cls=self.model,\n            select_related=select_related,\n            filter_clauses=self.filter_clauses,\n        )\n        filter_clauses, select_related = qryclause.prepare_filter(**kwargs)\n        filter_clauses = filter_clauses + filter_groups  # type: ignore\n        if _exclude:\n            exclude_clauses = filter_clauses\n            filter_clauses = self.filter_clauses\n        else:\n            exclude_clauses = self.exclude_clauses\n            filter_clauses = filter_clauses\n\n        return self.rebuild_self(\n            filter_clauses=filter_clauses,\n            exclude_clauses=exclude_clauses,\n            select_related=select_related,\n        )\n\n    def exclude(self, *args: Any, **kwargs: Any) -&gt; \"QuerySet[T]\":  # noqa: A003\n        \"\"\"\n        Works exactly the same as filter and all modifiers (suffixes) are the same,\n        but returns a *not* condition.\n\n        So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n        the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n        Note that all conditions are joined so if you pass multiple values it\n        becomes a union of conditions.\n\n        `exclude(name='John', age&gt;=35)` will become\n        `where not (name='John' and age&gt;=35)`\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        return self.filter(_exclude=True, *args, **kwargs)\n\n    def select_related(self, related: Union[List, str, FieldAccessor]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows to prefetch related models during the same query.\n\n        **With `select_related` always only one query is run against the database**,\n        meaning that one (sometimes complicated) join is generated and later nested\n        models are processed in python.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(related, list):\n            related = [related]\n        related = [\n            rel._access_chain if isinstance(rel, FieldAccessor) else rel\n            for rel in related\n        ]\n\n        related = sorted(list(set(list(self._select_related) + related)))\n        return self.rebuild_self(select_related=related)\n\n    def select_all(self, follow: bool = False) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        By default adds only directly related models.\n\n        If follow=True is set it adds also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        relations = list(self.model.extract_related_names())\n        if follow:\n            relations = self.model._iterate_related_models()\n        return self.rebuild_self(select_related=relations)\n\n    def prefetch_related(\n        self, related: Union[List, str, FieldAccessor]\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Allows to prefetch related models during query - but opposite to\n        `select_related` each subsequent model is fetched in a separate database query.\n\n        **With `prefetch_related` always one query per Model is run against the\n        database**, meaning that you will have multiple queries executed one\n        after another.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(related, list):\n            related = [related]\n        related = [\n            rel._access_chain if isinstance(rel, FieldAccessor) else rel\n            for rel in related\n        ]\n\n        related = list(set(list(self._prefetch_related) + related))\n        return self.rebuild_self(prefetch_related=related)\n\n    def fields(\n        self, columns: Union[List, str, Set, Dict], _is_exclude: bool = False\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `fields()` you can select subset of model columns to limit the data load.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related`\n        models (with nested notation).\n\n        You can select specified fields by passing a `str, List[str], Set[str] or\n        dict` with nested definition.\n\n        To include related models use notation\n        `{related_name}__{column}[__{optional_next} etc.]`.\n\n        `fields()` can be called several times, building up the columns to select.\n\n        If you include related models into `select_related()` call but you won't specify\n        columns for those models in fields - implies a list of all fields for\n        those nested models.\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even if\n        not explicitly included.\n\n        You can also pass fields to include as dictionary or set.\n\n        To mark a field as included in a dictionary use it's name as key\n        and ellipsis as value.\n\n        To traverse nested models use nested dictionaries.\n\n        To include fields at last level instead of nested dictionary a set can be used.\n\n        To include whole nested model specify model related field name and ellipsis.\n\n        :param _is_exclude: flag if it's exclude or include operation\n        :type _is_exclude: bool\n        :param columns: columns to include\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        excludable = ormar.ExcludableItems.from_excludable(self._excludable)\n        excludable.build(\n            items=columns,\n            model_cls=self.model_cls,  # type: ignore\n            is_exclude=_is_exclude,\n        )\n\n        return self.rebuild_self(excludable=excludable)\n\n    def exclude_fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `exclude_fields()` you can select subset of model columns that will\n        be excluded to limit the data load.\n\n        It's the opposite of `fields()` method so check documentation above\n        to see what options are available.\n\n        Especially check above how you can pass also nested dictionaries\n        and sets as a mask to exclude fields from whole hierarchy.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related` models\n        (with nested notation).\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even\n        if explicitly excluded.\n\n        :param columns: columns to exclude\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        return self.fields(columns=columns, _is_exclude=True)\n\n    def order_by(self, columns: Union[List, str, OrderAction]) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        With `order_by()` you can order the results from database based on your\n        choice of fields.\n\n        You can provide a string with field name or list of strings with fields names.\n\n        Ordering in sql will be applied in order of names you provide in order_by.\n\n        By default if you do not provide ordering `ormar` explicitly orders by\n        all primary keys\n\n        If you are sorting by nested models that causes that the result rows are\n        unsorted by the main model `ormar` will combine those children rows into\n        one main model.\n\n        The main model will never duplicate in the result\n\n        To order by main model field just provide a field name\n\n        To sort on nested models separate field names with dunder '__'.\n\n        You can sort this way across all relation types -&gt; `ForeignKey`,\n        reverse virtual FK and `ManyToMany` fields.\n\n        To sort in descending order provide a hyphen in front of the field name\n\n        :param columns: columns by which models should be sorted\n        :type columns: Union[List, str]\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n\n        orders_by = [\n            (\n                OrderAction(order_str=x, model_cls=self.model_cls)  # type: ignore\n                if not isinstance(x, OrderAction)\n                else x\n            )\n            for x in columns\n        ]\n\n        order_bys = self.order_bys + [x for x in orders_by if x not in self.order_bys]\n        return self.rebuild_self(order_bys=order_bys)\n\n    async def values(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        exclude_through: bool = False,\n        _as_dict: bool = True,\n        _flatten: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of dictionaries with column values in order of the fields\n        passed or all fields from queried models.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param _flatten: internal parameter to flatten one element tuples\n        :type _flatten: bool\n        :param _as_dict: internal parameter if return dict or tuples\n        :type _as_dict: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields:  Union[List, str, Set, Dict]\n        \"\"\"\n        if fields:\n            return await self.fields(columns=fields).values(\n                _as_dict=_as_dict, _flatten=_flatten, exclude_through=exclude_through\n            )\n        expr = self.build_select_expression()\n        rows = await self.database.fetch_all(expr)\n        if not rows:\n            return []\n        alias_resolver = ReverseAliasResolver(\n            select_related=self._select_related,\n            excludable=self._excludable,\n            model_cls=self.model_cls,  # type: ignore\n            exclude_through=exclude_through,\n        )\n        column_map = alias_resolver.resolve_columns(\n            columns_names=list(cast(LegacyRow, rows[0]).keys())\n        )\n        result = [\n            {column_map.get(k): v for k, v in dict(x).items() if k in column_map}\n            for x in rows\n        ]\n        if _as_dict:\n            return result\n        if _flatten and self._excludable.include_entry_count() != 1:\n            raise QueryDefinitionError(\n                \"You cannot flatten values_list if more than one field is selected!\"\n            )\n        tuple_result = [tuple(x.values()) for x in result]\n        return tuple_result if not _flatten else [x[0] for x in tuple_result]\n\n    async def values_list(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        flatten: bool = False,\n        exclude_through: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of tuples with column values in order of the fields passed or\n        all fields from queried models.\n\n        When one field is passed you can flatten the list of tuples into list of values\n        of that single field.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields: Union[str, List[str]]\n        :param flatten: when one field is passed you can flatten the list of tuples\n        :type flatten: bool\n        \"\"\"\n        return await self.values(\n            fields=fields,\n            exclude_through=exclude_through,\n            _as_dict=False,\n            _flatten=flatten,\n        )\n\n    async def exists(self) -&gt; bool:\n        \"\"\"\n        Returns a bool value to confirm if there are rows matching the given criteria\n        (applied with `filter` and `exclude` if set).\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        expr = self.build_select_expression()\n        expr = sqlalchemy.exists(expr).select()\n        return await self.database.fetch_val(expr)\n\n    async def count(self, distinct: bool = True) -&gt; int:\n        \"\"\"\n        Returns number of rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n        If `distinct` is `True` (the default), this will return\n        the number of primary rows selected. If `False`,\n        the count will be the total number of rows returned\n        (including extra rows for `one-to-many` or `many-to-many`\n        left `select_related` table joins).\n        `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n        :param distinct: flag if the primary table rows should be distinct or not\n\n        :return: number of rows\n        :rtype: int\n        \"\"\"\n        expr = self.build_select_expression().alias(\"subquery_for_count\")\n        expr = sqlalchemy.func.count().select().select_from(expr)\n        if distinct:\n            pk_column_name = self.model.get_column_alias(self.model_config.pkname)\n            expr_distinct = expr.group_by(pk_column_name).alias(\"subquery_for_group\")\n            expr = sqlalchemy.func.count().select().select_from(expr_distinct)\n        return await self.database.fetch_val(expr)\n\n    async def _query_aggr_function(self, func_name: str, columns: List) -&gt; Any:\n        func = getattr(sqlalchemy.func, func_name)\n        select_actions = [\n            SelectAction(select_str=column, model_cls=self.model) for column in columns\n        ]\n        if func_name in [\"sum\", \"avg\"]:\n            if any(not x.is_numeric for x in select_actions):\n                raise QueryDefinitionError(\n                    \"You can use sum and svg only with\" \"numeric types of columns\"\n                )\n        select_columns = [x.apply_func(func, use_label=True) for x in select_actions]\n        expr = self.build_select_expression().alias(f\"subquery_for_{func_name}\")\n        expr = sqlalchemy.select(select_columns).select_from(expr)\n        # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n        result = await self.database.fetch_one(expr)\n        return dict(result) if len(result) &gt; 1 else result[0]  # type: ignore\n\n    async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns max value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: max value of column(s)\n        :rtype: Any\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"max\", columns=columns)\n\n    async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns min value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: min value of column(s)\n        :rtype: Any\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"min\", columns=columns)\n\n    async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns sum value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: sum value of columns\n        :rtype: int\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"sum\", columns=columns)\n\n    async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n        \"\"\"\n        Returns avg value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: avg value of columns\n        :rtype: Union[int, float, List]\n        \"\"\"\n        if not isinstance(columns, list):\n            columns = [columns]\n        return await self._query_aggr_function(func_name=\"avg\", columns=columns)\n\n    async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Updates the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of updated rows\n        :rtype: int\n        \"\"\"\n        if not each and not (self.filter_clauses or self.exclude_clauses):\n            raise QueryDefinitionError(\n                \"You cannot update without filtering the queryset first. \"\n                \"If you want to update all rows use update(each=True, **kwargs)\"\n            )\n\n        self_fields = self.model.extract_db_own_fields().union(\n            self.model.extract_related_names()\n        )\n        updates = {k: v for k, v in kwargs.items() if k in self_fields}\n        updates = self.model.validate_enums(updates)\n        updates = self.model.translate_columns_to_aliases(updates)\n\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n            self.table.update().values(**updates)\n        )\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        return await self.database.execute(expr)\n\n    async def delete(self, *args: Any, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Deletes from the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of deleted rows\n        :rtype:int\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).delete()\n        if not each and not (self.filter_clauses or self.exclude_clauses):\n            raise QueryDefinitionError(\n                \"You cannot delete without filtering the queryset first. \"\n                \"If you want to delete all rows use delete(each=True)\"\n            )\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n            self.table.delete()\n        )\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        return await self.database.execute(expr)\n\n    def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can paginate the result which is a combination of offset and limit clauses.\n        Limit is set to page size and offset is set to (page-1) * page_size.\n\n        :param page_size: numbers of items per page\n        :type page_size: int\n        :param page: page number\n        :type page: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if page &lt; 1 or page_size &lt; 1:\n            raise QueryDefinitionError(\"Page size and page have to be greater than 0.\")\n\n        limit_count = page_size\n        query_offset = (page - 1) * page_size\n        return self.rebuild_self(limit_count=limit_count, offset=query_offset)\n\n    def limit(\n        self, limit_count: int, limit_raw_sql: Optional[bool] = None\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can limit the results to desired number of parent models.\n\n        To limit the actual number of database query rows instead of number of main\n        models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n        :param limit_raw_sql: flag if raw sql should be limited\n        :type limit_raw_sql: bool\n        :param limit_count: number of models to limit\n        :type limit_count: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n        return self.rebuild_self(limit_count=limit_count, limit_raw_sql=limit_raw_sql)\n\n    def offset(\n        self, offset: int, limit_raw_sql: Optional[bool] = None\n    ) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        You can also offset the results by desired number of main models.\n\n        To offset the actual number of database query rows instead of number of main\n        models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n        :param limit_raw_sql: flag if raw sql should be offset\n        :type limit_raw_sql: bool\n        :param offset: numbers of models to offset\n        :type offset: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n        return self.rebuild_self(offset=offset, limit_raw_sql=limit_raw_sql)\n\n    async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).first()\n\n        expr = self.build_select_expression(\n            limit=1,\n            order_bys=(\n                [\n                    OrderAction(\n                        order_str=f\"{self.model.ormar_config.pkname}\",\n                        model_cls=self.model_cls,  # type: ignore\n                    )\n                ]\n                if not any([x.is_source_model_order for x in self.order_bys])\n                else []\n            )\n            + self.order_bys,\n        )\n        rows = await self.database.fetch_all(expr)\n        processed_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and processed_rows:\n            processed_rows = await self._prefetch_related_models(processed_rows, rows)\n        self.check_single_result_rows_count(processed_rows)\n        return processed_rows[0]  # type: ignore\n\n    async def first_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        If no match is found None will be returned.\n\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            return await self.first(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n    async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        If no match is found None will be returned.\n\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n    async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":  # noqa: CCR001\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).get()\n\n        if not self.filter_clauses:\n            expr = self.build_select_expression(\n                limit=1,\n                order_bys=(\n                    [\n                        OrderAction(\n                            order_str=f\"-{self.model.ormar_config.pkname}\",\n                            model_cls=self.model_cls,  # type: ignore\n                        )\n                    ]\n                    if not any([x.is_source_model_order for x in self.order_bys])\n                    else []\n                )\n                + self.order_bys,\n            )\n        else:\n            expr = self.build_select_expression()\n\n        rows = await self.database.fetch_all(expr)\n        processed_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and processed_rows:\n            processed_rows = await self._prefetch_related_models(processed_rows, rows)\n        self.check_single_result_rows_count(processed_rows)\n        return processed_rows[0]  # type: ignore\n\n    async def get_or_create(\n        self,\n        _defaults: Optional[Dict[str, Any]] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Tuple[\"T\", bool]:\n        \"\"\"\n        Combination of create and get methods.\n\n        Tries to get a row meeting the criteria for kwargs\n        and if `NoMatch` exception is raised\n        it creates a new one with given kwargs and _defaults.\n\n        Passing a criteria is actually calling filter(*args, **kwargs) method described\n        below.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :param _defaults: default values for creating object\n        :type _defaults: Optional[Dict[str, Any]]\n        :return: model instance and a boolean\n        :rtype: Tuple(\"T\", bool)\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs), False\n        except NoMatch:\n            _defaults = _defaults or {}\n            return await self.create(**{**kwargs, **_defaults}), True\n\n    async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Updates the model, or in case there is no match in database creates a new one.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: updated or created model\n        :rtype: Model\n        \"\"\"\n        pk_name = self.model_config.pkname\n        if \"pk\" in kwargs:\n            kwargs[pk_name] = kwargs.pop(\"pk\")\n        if pk_name not in kwargs or kwargs.get(pk_name) is None:\n            return await self.create(**kwargs)\n        model = await self.get(pk=kwargs[pk_name])\n        return await model.update(**kwargs)\n\n    async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n        \"\"\"\n        Returns all rows from a database for given model for set filter options.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).all()`.\n\n        If there are no rows meeting the criteria an empty list is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: list of returned models\n        :rtype: List[Model]\n        \"\"\"\n        if kwargs or args:\n            return await self.filter(*args, **kwargs).all()\n\n        expr = self.build_select_expression()\n        rows = await self.database.fetch_all(expr)\n        result_rows = await self._process_query_result_rows(rows)\n        if self._prefetch_related and result_rows:\n            result_rows = await self._prefetch_related_models(result_rows, rows)\n\n        return result_rows\n\n    async def iterate(  # noqa: A003\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; AsyncGenerator[\"T\", None]:\n        \"\"\"\n        Return async iterable generator for all rows from a database for given model.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).iterate()`.\n\n        If there are no rows meeting the criteria an empty async generator is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: asynchronous iterable generator of returned models\n        :rtype: AsyncGenerator[Model]\n        \"\"\"\n\n        if self._prefetch_related:\n            raise QueryDefinitionError(\n                \"Prefetch related queries are not supported in iterators\"\n            )\n\n        if kwargs or args:\n            async for result in self.filter(*args, **kwargs).iterate():\n                yield result\n            return\n\n        expr = self.build_select_expression()\n\n        rows: list = []\n        last_primary_key = None\n        pk_alias = self.model.get_column_alias(self.model_config.pkname)\n\n        async for row in self.database.iterate(query=expr):\n            current_primary_key = row[pk_alias]\n            if last_primary_key == current_primary_key or last_primary_key is None:\n                last_primary_key = current_primary_key\n                rows.append(row)\n                continue\n\n            yield (await self._process_query_result_rows(rows))[0]\n            last_primary_key = current_primary_key\n            rows = [row]\n\n        if rows:\n            yield (await self._process_query_result_rows(rows))[0]\n\n    async def create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Creates the model instance, saves it in a database and returns the updates model\n        (with pk populated if not passed and autoincrement is set).\n\n        The allowed kwargs are `Model` fields names and proper value types.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: created model\n        :rtype: Model\n        \"\"\"\n        instance = self.model(**kwargs)\n        instance = await instance.save()\n        return instance\n\n    async def bulk_create(self, objects: List[\"T\"]) -&gt; None:\n        \"\"\"\n        Performs a bulk create in one database session to speed up the process.\n\n        Allows you to create multiple objects at once.\n\n        A valid list of `Model` objects needs to be passed.\n\n        Bulk operations do not send signals.\n\n        :param objects: list of ormar models already initialized and ready to save.\n        :type objects: List[Model]\n        \"\"\"\n\n        if not objects:\n            raise ModelListEmptyError(\"Bulk create objects are empty!\")\n\n        ready_objects = []\n        for obj in objects:\n            ready_objects.append(obj.prepare_model_to_save(obj.model_dump()))\n            await asyncio.sleep(0)  # Allow context switching to prevent blocking\n\n        # don't use execute_many, as in databases it's executed in a loop\n        # instead of using execute_many from drivers\n        expr = self.table.insert().values(ready_objects)\n        await self.database.execute(expr)\n\n        for obj in objects:\n            obj.set_save_status(True)\n\n    async def bulk_update(  # noqa:  CCR001\n        self, objects: List[\"T\"], columns: Optional[List[str]] = None\n    ) -&gt; None:\n        \"\"\"\n        Performs bulk update in one database session to speed up the process.\n\n        Allows you to update multiple instance at once.\n\n        All `Models` passed need to have primary key column populated.\n\n        You can also select which fields to update by passing `columns` list\n        as a list of string names.\n\n        Bulk operations do not send signals.\n\n        :param objects: list of ormar models\n        :type objects: List[Model]\n        :param columns: list of columns to update\n        :type columns: List[str]\n        \"\"\"\n        if not objects:\n            raise ModelListEmptyError(\"Bulk update objects are empty!\")\n\n        ready_objects = []\n        pk_name = self.model_config.pkname\n        if not columns:\n            columns = list(\n                self.model.extract_db_own_fields().union(\n                    self.model.extract_related_names()\n                )\n            )\n\n        if pk_name not in columns:\n            columns.append(pk_name)\n\n        columns = [self.model.get_column_alias(k) for k in columns]\n\n        for obj in objects:\n            new_kwargs = obj.model_dump()\n            if new_kwargs.get(pk_name) is None:\n                raise ModelPersistenceError(\n                    \"You cannot update unsaved objects. \"\n                    f\"{self.model.__name__} has to have {pk_name} filled.\"\n                )\n            new_kwargs = obj.prepare_model_to_update(new_kwargs)\n            ready_objects.append(\n                {\"new_\" + k: v for k, v in new_kwargs.items() if k in columns}\n            )\n            await asyncio.sleep(0)\n\n        pk_column = self.model_config.table.c.get(self.model.get_column_alias(pk_name))\n        pk_column_name = self.model.get_column_alias(pk_name)\n        table_columns = [c.name for c in self.model_config.table.c]\n        expr = self.table.update().where(\n            pk_column == bindparam(\"new_\" + pk_column_name)\n        )\n        expr = expr.values(\n            **{\n                k: bindparam(\"new_\" + k)\n                for k in columns\n                if k != pk_column_name and k in table_columns\n            }\n        )\n        # databases bind params only where query is passed as string\n        # otherwise it just passes all data to values and results in unconsumed columns\n        expr = str(expr)\n        await self.database.execute_many(expr, ready_objects)\n\n        for obj in objects:\n            obj.set_save_status(True)\n\n        await cast(\n            Type[\"Model\"], self.model_cls\n        ).ormar_config.signals.post_bulk_update.send(\n            sender=self.model_cls, instances=objects  # type: ignore\n        )\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.database","title":"<code>database: databases.Database</code>  <code>property</code>","text":"<p>Shortcut to models database from OrmarConfig class.</p> <p>:return: database :rtype: databases.Database</p>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.model","title":"<code>model: Type[T]</code>  <code>property</code>","text":"<p>Shortcut to model class set on QuerySet.</p> <p>:return: model class :rtype: Type[Model]</p>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.model_config","title":"<code>model_config: OrmarConfig</code>  <code>property</code>","text":"<p>Shortcut to model class OrmarConfig set on QuerySet model.</p> <p>:return: OrmarConfig of the model :rtype: model's OrmarConfig</p>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.table","title":"<code>table: sqlalchemy.Table</code>  <code>property</code>","text":"<p>Shortcut to models table from OrmarConfig.</p> <p>:return: database table :rtype: sqlalchemy.Table</p>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.all","title":"<code>all(*args, **kwargs)</code>  <code>async</code>","text":"<p>Returns all rows from a database for given model for set filter options.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).all()</code>.</p> <p>If there are no rows meeting the criteria an empty list is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: list of returned models :rtype: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n    \"\"\"\n    Returns all rows from a database for given model for set filter options.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).all()`.\n\n    If there are no rows meeting the criteria an empty list is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: list of returned models\n    :rtype: List[Model]\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).all()\n\n    expr = self.build_select_expression()\n    rows = await self.database.fetch_all(expr)\n    result_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and result_rows:\n        result_rows = await self._prefetch_related_models(result_rows, rows)\n\n    return result_rows\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.avg","title":"<code>avg(columns)</code>  <code>async</code>","text":"<p>Returns avg value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: avg value of columns :rtype: Union[int, float, List]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n    \"\"\"\n    Returns avg value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: avg value of columns\n    :rtype: Union[int, float, List]\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"avg\", columns=columns)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.build_select_expression","title":"<code>build_select_expression(limit=None, offset=None, order_bys=None)</code>","text":"<p>Constructs the actual database query used in the QuerySet. If any of the params is not passed the QuerySet own value is used.</p> <p>:param limit: number to limit the query :type limit: int :param offset: number to offset by :type offset: int :param order_bys: list of order-by fields names :type order_bys: List :return: built sqlalchemy select expression :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def build_select_expression(\n    self,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None,\n    order_bys: Optional[List] = None,\n) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Constructs the actual database query used in the QuerySet.\n    If any of the params is not passed the QuerySet own value is used.\n\n    :param limit: number to limit the query\n    :type limit: int\n    :param offset: number to offset by\n    :type offset: int\n    :param order_bys: list of order-by fields names\n    :type order_bys: List\n    :return: built sqlalchemy select expression\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    qry = Query(\n        model_cls=self.model,\n        select_related=self._select_related,\n        filter_clauses=self.filter_clauses,\n        exclude_clauses=self.exclude_clauses,\n        offset=offset or self.query_offset,\n        excludable=self._excludable,\n        order_bys=order_bys or self.order_bys,\n        limit_raw_sql=self.limit_sql_raw,\n        limit_count=limit if limit is not None else self.limit_count,\n    )\n    exp = qry.build_select_expression()\n    # print(\"\\n\", exp.compile(compile_kwargs={\"literal_binds\": True}))\n    return exp\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.bulk_create","title":"<code>bulk_create(objects)</code>  <code>async</code>","text":"<p>Performs a bulk create in one database session to speed up the process.</p> <p>Allows you to create multiple objects at once.</p> <p>A valid list of <code>Model</code> objects needs to be passed.</p> <p>Bulk operations do not send signals.</p> <p>:param objects: list of ormar models already initialized and ready to save. :type objects: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def bulk_create(self, objects: List[\"T\"]) -&gt; None:\n    \"\"\"\n    Performs a bulk create in one database session to speed up the process.\n\n    Allows you to create multiple objects at once.\n\n    A valid list of `Model` objects needs to be passed.\n\n    Bulk operations do not send signals.\n\n    :param objects: list of ormar models already initialized and ready to save.\n    :type objects: List[Model]\n    \"\"\"\n\n    if not objects:\n        raise ModelListEmptyError(\"Bulk create objects are empty!\")\n\n    ready_objects = []\n    for obj in objects:\n        ready_objects.append(obj.prepare_model_to_save(obj.model_dump()))\n        await asyncio.sleep(0)  # Allow context switching to prevent blocking\n\n    # don't use execute_many, as in databases it's executed in a loop\n    # instead of using execute_many from drivers\n    expr = self.table.insert().values(ready_objects)\n    await self.database.execute(expr)\n\n    for obj in objects:\n        obj.set_save_status(True)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.bulk_update","title":"<code>bulk_update(objects, columns=None)</code>  <code>async</code>","text":"<p>Performs bulk update in one database session to speed up the process.</p> <p>Allows you to update multiple instance at once.</p> <p>All <code>Models</code> passed need to have primary key column populated.</p> <p>You can also select which fields to update by passing <code>columns</code> list as a list of string names.</p> <p>Bulk operations do not send signals.</p> <p>:param objects: list of ormar models :type objects: List[Model] :param columns: list of columns to update :type columns: List[str]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def bulk_update(  # noqa:  CCR001\n    self, objects: List[\"T\"], columns: Optional[List[str]] = None\n) -&gt; None:\n    \"\"\"\n    Performs bulk update in one database session to speed up the process.\n\n    Allows you to update multiple instance at once.\n\n    All `Models` passed need to have primary key column populated.\n\n    You can also select which fields to update by passing `columns` list\n    as a list of string names.\n\n    Bulk operations do not send signals.\n\n    :param objects: list of ormar models\n    :type objects: List[Model]\n    :param columns: list of columns to update\n    :type columns: List[str]\n    \"\"\"\n    if not objects:\n        raise ModelListEmptyError(\"Bulk update objects are empty!\")\n\n    ready_objects = []\n    pk_name = self.model_config.pkname\n    if not columns:\n        columns = list(\n            self.model.extract_db_own_fields().union(\n                self.model.extract_related_names()\n            )\n        )\n\n    if pk_name not in columns:\n        columns.append(pk_name)\n\n    columns = [self.model.get_column_alias(k) for k in columns]\n\n    for obj in objects:\n        new_kwargs = obj.model_dump()\n        if new_kwargs.get(pk_name) is None:\n            raise ModelPersistenceError(\n                \"You cannot update unsaved objects. \"\n                f\"{self.model.__name__} has to have {pk_name} filled.\"\n            )\n        new_kwargs = obj.prepare_model_to_update(new_kwargs)\n        ready_objects.append(\n            {\"new_\" + k: v for k, v in new_kwargs.items() if k in columns}\n        )\n        await asyncio.sleep(0)\n\n    pk_column = self.model_config.table.c.get(self.model.get_column_alias(pk_name))\n    pk_column_name = self.model.get_column_alias(pk_name)\n    table_columns = [c.name for c in self.model_config.table.c]\n    expr = self.table.update().where(\n        pk_column == bindparam(\"new_\" + pk_column_name)\n    )\n    expr = expr.values(\n        **{\n            k: bindparam(\"new_\" + k)\n            for k in columns\n            if k != pk_column_name and k in table_columns\n        }\n    )\n    # databases bind params only where query is passed as string\n    # otherwise it just passes all data to values and results in unconsumed columns\n    expr = str(expr)\n    await self.database.execute_many(expr, ready_objects)\n\n    for obj in objects:\n        obj.set_save_status(True)\n\n    await cast(\n        Type[\"Model\"], self.model_cls\n    ).ormar_config.signals.post_bulk_update.send(\n        sender=self.model_cls, instances=objects  # type: ignore\n    )\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.check_single_result_rows_count","title":"<code>check_single_result_rows_count(rows)</code>  <code>staticmethod</code>","text":"<p>Verifies if the result has one and only one row.</p> <p>:param rows: one element list of Models :type rows: List[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>@staticmethod\ndef check_single_result_rows_count(rows: Sequence[Optional[\"T\"]]) -&gt; None:\n    \"\"\"\n    Verifies if the result has one and only one row.\n\n    :param rows: one element list of Models\n    :type rows: List[Model]\n    \"\"\"\n    if not rows or rows[0] is None:\n        raise NoMatch()\n    if len(rows) &gt; 1:\n        raise MultipleMatches()\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.count","title":"<code>count(distinct=True)</code>  <code>async</code>","text":"<p>Returns number of rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before). If <code>distinct</code> is <code>True</code> (the default), this will return the number of primary rows selected. If <code>False</code>, the count will be the total number of rows returned (including extra rows for <code>one-to-many</code> or <code>many-to-many</code> left <code>select_related</code> table joins). <code>False</code> is the legacy (buggy) behavior for workflows that depend on it.</p> <p>:param distinct: flag if the primary table rows should be distinct or not</p> <p>:return: number of rows :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def count(self, distinct: bool = True) -&gt; int:\n    \"\"\"\n    Returns number of rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n    If `distinct` is `True` (the default), this will return\n    the number of primary rows selected. If `False`,\n    the count will be the total number of rows returned\n    (including extra rows for `one-to-many` or `many-to-many`\n    left `select_related` table joins).\n    `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n    :param distinct: flag if the primary table rows should be distinct or not\n\n    :return: number of rows\n    :rtype: int\n    \"\"\"\n    expr = self.build_select_expression().alias(\"subquery_for_count\")\n    expr = sqlalchemy.func.count().select().select_from(expr)\n    if distinct:\n        pk_column_name = self.model.get_column_alias(self.model_config.pkname)\n        expr_distinct = expr.group_by(pk_column_name).alias(\"subquery_for_group\")\n        expr = sqlalchemy.func.count().select().select_from(expr_distinct)\n    return await self.database.fetch_val(expr)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.create","title":"<code>create(**kwargs)</code>  <code>async</code>","text":"<p>Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set).</p> <p>The allowed kwargs are <code>Model</code> fields names and proper value types.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: created model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Creates the model instance, saves it in a database and returns the updates model\n    (with pk populated if not passed and autoincrement is set).\n\n    The allowed kwargs are `Model` fields names and proper value types.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: created model\n    :rtype: Model\n    \"\"\"\n    instance = self.model(**kwargs)\n    instance = await instance.save()\n    return instance\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.delete","title":"<code>delete(*args, each=False, **kwargs)</code>  <code>async</code>","text":"<p>Deletes from the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of deleted rows :rtype:int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def delete(self, *args: Any, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Deletes from the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of deleted rows\n    :rtype:int\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).delete()\n    if not each and not (self.filter_clauses or self.exclude_clauses):\n        raise QueryDefinitionError(\n            \"You cannot delete without filtering the queryset first. \"\n            \"If you want to delete all rows use delete(each=True)\"\n        )\n    expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n        self.table.delete()\n    )\n    expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n        expr\n    )\n    return await self.database.execute(expr)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.exclude","title":"<code>exclude(*args, **kwargs)</code>","text":"<p>Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition.</p> <p>So if you use <code>filter(name='John')</code> which is <code>where name = 'John'</code> in SQL, the <code>exclude(name='John')</code> equals to <code>where name &lt;&gt; 'John'</code></p> <p>Note that all conditions are joined so if you pass multiple values it becomes a union of conditions.</p> <p><code>exclude(name='John', age&gt;=35)</code> will become <code>where not (name='John' and age&gt;=35)</code></p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def exclude(self, *args: Any, **kwargs: Any) -&gt; \"QuerySet[T]\":  # noqa: A003\n    \"\"\"\n    Works exactly the same as filter and all modifiers (suffixes) are the same,\n    but returns a *not* condition.\n\n    So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n    the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n    Note that all conditions are joined so if you pass multiple values it\n    becomes a union of conditions.\n\n    `exclude(name='John', age&gt;=35)` will become\n    `where not (name='John' and age&gt;=35)`\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    return self.filter(_exclude=True, *args, **kwargs)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.exclude_fields","title":"<code>exclude_fields(columns)</code>","text":"<p>With <code>exclude_fields()</code> you can select subset of model columns that will be excluded to limit the data load.</p> <p>It's the opposite of <code>fields()</code> method so check documentation above to see what options are available.</p> <p>Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if explicitly excluded.</p> <p>:param columns: columns to exclude :type columns: Union[List, str, Set, Dict] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def exclude_fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `exclude_fields()` you can select subset of model columns that will\n    be excluded to limit the data load.\n\n    It's the opposite of `fields()` method so check documentation above\n    to see what options are available.\n\n    Especially check above how you can pass also nested dictionaries\n    and sets as a mask to exclude fields from whole hierarchy.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related` models\n    (with nested notation).\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even\n    if explicitly excluded.\n\n    :param columns: columns to exclude\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    return self.fields(columns=columns, _is_exclude=True)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.exists","title":"<code>exists()</code>  <code>async</code>","text":"<p>Returns a bool value to confirm if there are rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set).</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def exists(self) -&gt; bool:\n    \"\"\"\n    Returns a bool value to confirm if there are rows matching the given criteria\n    (applied with `filter` and `exclude` if set).\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    expr = self.build_select_expression()\n    expr = sqlalchemy.exists(expr).select()\n    return await self.database.fetch_val(expr)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.fields","title":"<code>fields(columns, _is_exclude=False)</code>","text":"<p>With <code>fields()</code> you can select subset of model columns to limit the data load.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>You can select specified fields by passing a <code>str, List[str], Set[str] or dict</code> with nested definition.</p> <p>To include related models use notation <code>{related_name}__{column}[__{optional_next} etc.]</code>.</p> <p><code>fields()</code> can be called several times, building up the columns to select.</p> <p>If you include related models into <code>select_related()</code> call but you won't specify columns for those models in fields - implies a list of all fields for those nested models.</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if not explicitly included.</p> <p>You can also pass fields to include as dictionary or set.</p> <p>To mark a field as included in a dictionary use it's name as key and ellipsis as value.</p> <p>To traverse nested models use nested dictionaries.</p> <p>To include fields at last level instead of nested dictionary a set can be used.</p> <p>To include whole nested model specify model related field name and ellipsis.</p> <p>:param _is_exclude: flag if it's exclude or include operation :type _is_exclude: bool :param columns: columns to include :type columns: Union[List, str, Set, Dict] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def fields(\n    self, columns: Union[List, str, Set, Dict], _is_exclude: bool = False\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `fields()` you can select subset of model columns to limit the data load.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related`\n    models (with nested notation).\n\n    You can select specified fields by passing a `str, List[str], Set[str] or\n    dict` with nested definition.\n\n    To include related models use notation\n    `{related_name}__{column}[__{optional_next} etc.]`.\n\n    `fields()` can be called several times, building up the columns to select.\n\n    If you include related models into `select_related()` call but you won't specify\n    columns for those models in fields - implies a list of all fields for\n    those nested models.\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even if\n    not explicitly included.\n\n    You can also pass fields to include as dictionary or set.\n\n    To mark a field as included in a dictionary use it's name as key\n    and ellipsis as value.\n\n    To traverse nested models use nested dictionaries.\n\n    To include fields at last level instead of nested dictionary a set can be used.\n\n    To include whole nested model specify model related field name and ellipsis.\n\n    :param _is_exclude: flag if it's exclude or include operation\n    :type _is_exclude: bool\n    :param columns: columns to include\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    excludable = ormar.ExcludableItems.from_excludable(self._excludable)\n    excludable.build(\n        items=columns,\n        model_cls=self.model_cls,  # type: ignore\n        is_exclude=_is_exclude,\n    )\n\n    return self.rebuild_self(excludable=excludable)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.filter","title":"<code>filter(*args, _exclude=False, **kwargs)</code>","text":"<p>Allows you to filter by any <code>Model</code> attribute/field as well as to fetch instances, with a filter across an FK relationship.</p> <p>You can use special filter suffix to change the filter operands:</p> <ul> <li>exact - like <code>album__name__exact='Malibu'</code> (exact match)</li> <li>iexact - like <code>album__name__iexact='malibu'</code> (exact match case insensitive)</li> <li>contains - like <code>album__name__contains='Mal'</code> (sql like)</li> <li>icontains - like <code>album__name__icontains='mal'</code> (sql like case insensitive)</li> <li>in - like <code>album__name__in=['Malibu', 'Barclay']</code> (sql in)</li> <li>isnull - like <code>album__name__isnull=True</code> (sql is null)    (isnotnull <code>album__name__isnull=False</code> (sql is not null))</li> <li>gt - like <code>position__gt=3</code> (sql &gt;)</li> <li>gte - like <code>position__gte=3</code> (sql &gt;=)</li> <li>lt - like <code>position__lt=3</code> (sql &lt;)</li> <li>lte - like <code>position__lte=3</code> (sql &lt;=)</li> <li>startswith - like <code>album__name__startswith='Mal'</code> (exact start match)</li> <li>istartswith - like <code>album__name__istartswith='mal'</code> (case insensitive)</li> <li>endswith - like <code>album__name__endswith='ibu'</code> (exact end match)</li> <li>iendswith - like <code>album__name__iendswith='IBU'</code> (case insensitive)</li> </ul> <p>Note that you can also use python style filters - check the docs!</p> <p>:param _exclude: flag if it should be exclude or filter :type _exclude: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def filter(  # noqa: A003\n    self, *args: Any, _exclude: bool = False, **kwargs: Any\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows you to filter by any `Model` attribute/field\n    as well as to fetch instances, with a filter across an FK relationship.\n\n    You can use special filter suffix to change the filter operands:\n\n    *  exact - like `album__name__exact='Malibu'` (exact match)\n    *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n    *  contains - like `album__name__contains='Mal'` (sql like)\n    *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n    *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n    *  isnull - like `album__name__isnull=True` (sql is null)\n       (isnotnull `album__name__isnull=False` (sql is not null))\n    *  gt - like `position__gt=3` (sql &gt;)\n    *  gte - like `position__gte=3` (sql &gt;=)\n    *  lt - like `position__lt=3` (sql &lt;)\n    *  lte - like `position__lte=3` (sql &lt;=)\n    *  startswith - like `album__name__startswith='Mal'` (exact start match)\n    *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n    *  endswith - like `album__name__endswith='ibu'` (exact end match)\n    *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n    Note that you can also use python style filters - check the docs!\n\n    :param _exclude: flag if it should be exclude or filter\n    :type _exclude: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    filter_groups, select_related = self._resolve_filter_groups(groups=args)\n    qryclause = QueryClause(\n        model_cls=self.model,\n        select_related=select_related,\n        filter_clauses=self.filter_clauses,\n    )\n    filter_clauses, select_related = qryclause.prepare_filter(**kwargs)\n    filter_clauses = filter_clauses + filter_groups  # type: ignore\n    if _exclude:\n        exclude_clauses = filter_clauses\n        filter_clauses = self.filter_clauses\n    else:\n        exclude_clauses = self.exclude_clauses\n        filter_clauses = filter_clauses\n\n    return self.rebuild_self(\n        filter_clauses=filter_clauses,\n        exclude_clauses=exclude_clauses,\n        select_related=select_related,\n    )\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.first","title":"<code>first(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).first()\n\n    expr = self.build_select_expression(\n        limit=1,\n        order_bys=(\n            [\n                OrderAction(\n                    order_str=f\"{self.model.ormar_config.pkname}\",\n                    model_cls=self.model_cls,  # type: ignore\n                )\n            ]\n            if not any([x.is_source_model_order for x in self.order_bys])\n            else []\n        )\n        + self.order_bys,\n    )\n    rows = await self.database.fetch_all(expr)\n    processed_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and processed_rows:\n        processed_rows = await self._prefetch_related_models(processed_rows, rows)\n    self.check_single_result_rows_count(processed_rows)\n    return processed_rows[0]  # type: ignore\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.first_or_none","title":"<code>first_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>If no match is found None will be returned.</p> <p>:raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def first_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    If no match is found None will be returned.\n\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        return await self.first(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.get","title":"<code>get(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":  # noqa: CCR001\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    if kwargs or args:\n        return await self.filter(*args, **kwargs).get()\n\n    if not self.filter_clauses:\n        expr = self.build_select_expression(\n            limit=1,\n            order_bys=(\n                [\n                    OrderAction(\n                        order_str=f\"-{self.model.ormar_config.pkname}\",\n                        model_cls=self.model_cls,  # type: ignore\n                    )\n                ]\n                if not any([x.is_source_model_order for x in self.order_bys])\n                else []\n            )\n            + self.order_bys,\n        )\n    else:\n        expr = self.build_select_expression()\n\n    rows = await self.database.fetch_all(expr)\n    processed_rows = await self._process_query_result_rows(rows)\n    if self._prefetch_related and processed_rows:\n        processed_rows = await self._prefetch_related_models(processed_rows, rows)\n    self.check_single_result_rows_count(processed_rows)\n    return processed_rows[0]  # type: ignore\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.get_or_create","title":"<code>get_or_create(_defaults=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Combination of create and get methods.</p> <p>Tries to get a row meeting the criteria for kwargs and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :param _defaults: default values for creating object :type _defaults: Optional[Dict[str, Any]] :return: model instance and a boolean :rtype: Tuple(\"T\", bool)</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get_or_create(\n    self,\n    _defaults: Optional[Dict[str, Any]] = None,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Tuple[\"T\", bool]:\n    \"\"\"\n    Combination of create and get methods.\n\n    Tries to get a row meeting the criteria for kwargs\n    and if `NoMatch` exception is raised\n    it creates a new one with given kwargs and _defaults.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :param _defaults: default values for creating object\n    :type _defaults: Optional[Dict[str, Any]]\n    :return: model instance and a boolean\n    :rtype: Tuple(\"T\", bool)\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs), False\n    except NoMatch:\n        _defaults = _defaults or {}\n        return await self.create(**{**kwargs, **_defaults}), True\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.get_or_none","title":"<code>get_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <p>If no match is found None will be returned.</p> <p>:raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing a criteria is actually calling filter(*args, **kwargs) method described\n    below.\n\n    If no match is found None will be returned.\n\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.iterate","title":"<code>iterate(*args, **kwargs)</code>  <code>async</code>","text":"<p>Return async iterable generator for all rows from a database for given model.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).iterate()</code>.</p> <p>If there are no rows meeting the criteria an empty async generator is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: asynchronous iterable generator of returned models :rtype: AsyncGenerator[Model]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def iterate(  # noqa: A003\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; AsyncGenerator[\"T\", None]:\n    \"\"\"\n    Return async iterable generator for all rows from a database for given model.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).iterate()`.\n\n    If there are no rows meeting the criteria an empty async generator is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: asynchronous iterable generator of returned models\n    :rtype: AsyncGenerator[Model]\n    \"\"\"\n\n    if self._prefetch_related:\n        raise QueryDefinitionError(\n            \"Prefetch related queries are not supported in iterators\"\n        )\n\n    if kwargs or args:\n        async for result in self.filter(*args, **kwargs).iterate():\n            yield result\n        return\n\n    expr = self.build_select_expression()\n\n    rows: list = []\n    last_primary_key = None\n    pk_alias = self.model.get_column_alias(self.model_config.pkname)\n\n    async for row in self.database.iterate(query=expr):\n        current_primary_key = row[pk_alias]\n        if last_primary_key == current_primary_key or last_primary_key is None:\n            last_primary_key = current_primary_key\n            rows.append(row)\n            continue\n\n        yield (await self._process_query_result_rows(rows))[0]\n        last_primary_key = current_primary_key\n        rows = [row]\n\n    if rows:\n        yield (await self._process_query_result_rows(rows))[0]\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.limit","title":"<code>limit(limit_count, limit_raw_sql=None)</code>","text":"<p>You can limit the results to desired number of parent models.</p> <p>To limit the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <p>:param limit_raw_sql: flag if raw sql should be limited :type limit_raw_sql: bool :param limit_count: number of models to limit :type limit_count: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def limit(\n    self, limit_count: int, limit_raw_sql: Optional[bool] = None\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can limit the results to desired number of parent models.\n\n    To limit the actual number of database query rows instead of number of main\n    models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n    :param limit_raw_sql: flag if raw sql should be limited\n    :type limit_raw_sql: bool\n    :param limit_count: number of models to limit\n    :type limit_count: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n    return self.rebuild_self(limit_count=limit_count, limit_raw_sql=limit_raw_sql)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.max","title":"<code>max(columns)</code>  <code>async</code>","text":"<p>Returns max value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: max value of column(s) :rtype: Any</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns max value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: max value of column(s)\n    :rtype: Any\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"max\", columns=columns)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.min","title":"<code>min(columns)</code>  <code>async</code>","text":"<p>Returns min value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: min value of column(s) :rtype: Any</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns min value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: min value of column(s)\n    :rtype: Any\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"min\", columns=columns)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.offset","title":"<code>offset(offset, limit_raw_sql=None)</code>","text":"<p>You can also offset the results by desired number of main models.</p> <p>To offset the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <p>:param limit_raw_sql: flag if raw sql should be offset :type limit_raw_sql: bool :param offset: numbers of models to offset :type offset: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def offset(\n    self, offset: int, limit_raw_sql: Optional[bool] = None\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can also offset the results by desired number of main models.\n\n    To offset the actual number of database query rows instead of number of main\n    models use the `limit_raw_sql` parameter flag, and set it to `True`.\n\n    :param limit_raw_sql: flag if raw sql should be offset\n    :type limit_raw_sql: bool\n    :param offset: numbers of models to offset\n    :type offset: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    limit_raw_sql = self.limit_sql_raw if limit_raw_sql is None else limit_raw_sql\n    return self.rebuild_self(offset=offset, limit_raw_sql=limit_raw_sql)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.order_by","title":"<code>order_by(columns)</code>","text":"<p>With <code>order_by()</code> you can order the results from database based on your choice of fields.</p> <p>You can provide a string with field name or list of strings with fields names.</p> <p>Ordering in sql will be applied in order of names you provide in order_by.</p> <p>By default if you do not provide ordering <code>ormar</code> explicitly orders by all primary keys</p> <p>If you are sorting by nested models that causes that the result rows are unsorted by the main model <code>ormar</code> will combine those children rows into one main model.</p> <p>The main model will never duplicate in the result</p> <p>To order by main model field just provide a field name</p> <p>To sort on nested models separate field names with dunder '__'.</p> <p>You can sort this way across all relation types -&gt; <code>ForeignKey</code>, reverse virtual FK and <code>ManyToMany</code> fields.</p> <p>To sort in descending order provide a hyphen in front of the field name</p> <p>:param columns: columns by which models should be sorted :type columns: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def order_by(self, columns: Union[List, str, OrderAction]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    With `order_by()` you can order the results from database based on your\n    choice of fields.\n\n    You can provide a string with field name or list of strings with fields names.\n\n    Ordering in sql will be applied in order of names you provide in order_by.\n\n    By default if you do not provide ordering `ormar` explicitly orders by\n    all primary keys\n\n    If you are sorting by nested models that causes that the result rows are\n    unsorted by the main model `ormar` will combine those children rows into\n    one main model.\n\n    The main model will never duplicate in the result\n\n    To order by main model field just provide a field name\n\n    To sort on nested models separate field names with dunder '__'.\n\n    You can sort this way across all relation types -&gt; `ForeignKey`,\n    reverse virtual FK and `ManyToMany` fields.\n\n    To sort in descending order provide a hyphen in front of the field name\n\n    :param columns: columns by which models should be sorted\n    :type columns: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n\n    orders_by = [\n        (\n            OrderAction(order_str=x, model_cls=self.model_cls)  # type: ignore\n            if not isinstance(x, OrderAction)\n            else x\n        )\n        for x in columns\n    ]\n\n    order_bys = self.order_bys + [x for x in orders_by if x not in self.order_bys]\n    return self.rebuild_self(order_bys=order_bys)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.paginate","title":"<code>paginate(page, page_size=20)</code>","text":"<p>You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size.</p> <p>:param page_size: numbers of items per page :type page_size: int :param page: page number :type page: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    You can paginate the result which is a combination of offset and limit clauses.\n    Limit is set to page size and offset is set to (page-1) * page_size.\n\n    :param page_size: numbers of items per page\n    :type page_size: int\n    :param page: page number\n    :type page: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if page &lt; 1 or page_size &lt; 1:\n        raise QueryDefinitionError(\"Page size and page have to be greater than 0.\")\n\n    limit_count = page_size\n    query_offset = (page - 1) * page_size\n    return self.rebuild_self(limit_count=limit_count, offset=query_offset)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.prefetch_related","title":"<code>prefetch_related(related)</code>","text":"<p>Allows to prefetch related models during query - but opposite to <code>select_related</code> each subsequent model is fetched in a separate database query.</p> <p>With <code>prefetch_related</code> always one query per Model is run against the database, meaning that you will have multiple queries executed one after another.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def prefetch_related(\n    self, related: Union[List, str, FieldAccessor]\n) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows to prefetch related models during query - but opposite to\n    `select_related` each subsequent model is fetched in a separate database query.\n\n    **With `prefetch_related` always one query per Model is run against the\n    database**, meaning that you will have multiple queries executed one\n    after another.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(related, list):\n        related = [related]\n    related = [\n        rel._access_chain if isinstance(rel, FieldAccessor) else rel\n        for rel in related\n    ]\n\n    related = list(set(list(self._prefetch_related) + related))\n    return self.rebuild_self(prefetch_related=related)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.rebuild_self","title":"<code>rebuild_self(filter_clauses=None, exclude_clauses=None, select_related=None, limit_count=None, offset=None, excludable=None, order_bys=None, prefetch_related=None, limit_raw_sql=None, proxy_source_model=None)</code>","text":"<p>Method that returns new instance of queryset based on passed params, all not passed params are taken from current values.</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def rebuild_self(  # noqa: CFQ002\n    self,\n    filter_clauses: Optional[List] = None,\n    exclude_clauses: Optional[List] = None,\n    select_related: Optional[List] = None,\n    limit_count: Optional[int] = None,\n    offset: Optional[int] = None,\n    excludable: Optional[\"ExcludableItems\"] = None,\n    order_bys: Optional[List] = None,\n    prefetch_related: Optional[List] = None,\n    limit_raw_sql: Optional[bool] = None,\n    proxy_source_model: Optional[Type[\"Model\"]] = None,\n) -&gt; \"QuerySet\":\n    \"\"\"\n    Method that returns new instance of queryset based on passed params,\n    all not passed params are taken from current values.\n    \"\"\"\n    overwrites = {\n        \"select_related\": \"_select_related\",\n        \"offset\": \"query_offset\",\n        \"excludable\": \"_excludable\",\n        \"prefetch_related\": \"_prefetch_related\",\n        \"limit_raw_sql\": \"limit_sql_raw\",\n    }\n    passed_args = locals()\n\n    def replace_if_none(arg_name: str) -&gt; Any:\n        if passed_args.get(arg_name) is None:\n            return getattr(self, overwrites.get(arg_name, arg_name))\n        return passed_args.get(arg_name)\n\n    return self.__class__(\n        model_cls=self.model_cls,\n        filter_clauses=replace_if_none(\"filter_clauses\"),\n        exclude_clauses=replace_if_none(\"exclude_clauses\"),\n        select_related=replace_if_none(\"select_related\"),\n        limit_count=replace_if_none(\"limit_count\"),\n        offset=replace_if_none(\"offset\"),\n        excludable=replace_if_none(\"excludable\"),\n        order_bys=replace_if_none(\"order_bys\"),\n        prefetch_related=replace_if_none(\"prefetch_related\"),\n        limit_raw_sql=replace_if_none(\"limit_raw_sql\"),\n        proxy_source_model=replace_if_none(\"proxy_source_model\"),\n    )\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.select_all","title":"<code>select_all(follow=False)</code>","text":"<p>By default adds only directly related models.</p> <p>If follow=True is set it adds also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def select_all(self, follow: bool = False) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    By default adds only directly related models.\n\n    If follow=True is set it adds also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    relations = list(self.model.extract_related_names())\n    if follow:\n        relations = self.model._iterate_related_models()\n    return self.rebuild_self(select_related=relations)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.select_related","title":"<code>select_related(related)</code>","text":"<p>Allows to prefetch related models during the same query.</p> <p>With <code>select_related</code> always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>def select_related(self, related: Union[List, str, FieldAccessor]) -&gt; \"QuerySet[T]\":\n    \"\"\"\n    Allows to prefetch related models during the same query.\n\n    **With `select_related` always only one query is run against the database**,\n    meaning that one (sometimes complicated) join is generated and later nested\n    models are processed in python.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    if not isinstance(related, list):\n        related = [related]\n    related = [\n        rel._access_chain if isinstance(rel, FieldAccessor) else rel\n        for rel in related\n    ]\n\n    related = sorted(list(set(list(self._select_related) + related)))\n    return self.rebuild_self(select_related=related)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.sum","title":"<code>sum(columns)</code>  <code>async</code>","text":"<p>Returns sum value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: sum value of columns :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns sum value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: sum value of columns\n    :rtype: int\n    \"\"\"\n    if not isinstance(columns, list):\n        columns = [columns]\n    return await self._query_aggr_function(func_name=\"sum\", columns=columns)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.update","title":"<code>update(each=False, **kwargs)</code>  <code>async</code>","text":"<p>Updates the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of updated rows :rtype: int</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Updates the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of updated rows\n    :rtype: int\n    \"\"\"\n    if not each and not (self.filter_clauses or self.exclude_clauses):\n        raise QueryDefinitionError(\n            \"You cannot update without filtering the queryset first. \"\n            \"If you want to update all rows use update(each=True, **kwargs)\"\n        )\n\n    self_fields = self.model.extract_db_own_fields().union(\n        self.model.extract_related_names()\n    )\n    updates = {k: v for k, v in kwargs.items() if k in self_fields}\n    updates = self.model.validate_enums(updates)\n    updates = self.model.translate_columns_to_aliases(updates)\n\n    expr = FilterQuery(filter_clauses=self.filter_clauses).apply(\n        self.table.update().values(**updates)\n    )\n    expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n        expr\n    )\n    return await self.database.execute(expr)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.update_or_create","title":"<code>update_or_create(**kwargs)</code>  <code>async</code>","text":"<p>Updates the model, or in case there is no match in database creates a new one.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: updated or created model :rtype: Model</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Updates the model, or in case there is no match in database creates a new one.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: updated or created model\n    :rtype: Model\n    \"\"\"\n    pk_name = self.model_config.pkname\n    if \"pk\" in kwargs:\n        kwargs[pk_name] = kwargs.pop(\"pk\")\n    if pk_name not in kwargs or kwargs.get(pk_name) is None:\n        return await self.create(**kwargs)\n    model = await self.get(pk=kwargs[pk_name])\n    return await model.update(**kwargs)\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.values","title":"<code>values(fields=None, exclude_through=False, _as_dict=True, _flatten=False)</code>  <code>async</code>","text":"<p>Return a list of dictionaries with column values in order of the fields passed or all fields from queried models.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param _flatten: internal parameter to flatten one element tuples :type _flatten: bool :param _as_dict: internal parameter if return dict or tuples :type _as_dict: bool :param fields: field name or list of field names to extract from db :type fields:  Union[List, str, Set, Dict]</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def values(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    exclude_through: bool = False,\n    _as_dict: bool = True,\n    _flatten: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of dictionaries with column values in order of the fields\n    passed or all fields from queried models.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param _flatten: internal parameter to flatten one element tuples\n    :type _flatten: bool\n    :param _as_dict: internal parameter if return dict or tuples\n    :type _as_dict: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields:  Union[List, str, Set, Dict]\n    \"\"\"\n    if fields:\n        return await self.fields(columns=fields).values(\n            _as_dict=_as_dict, _flatten=_flatten, exclude_through=exclude_through\n        )\n    expr = self.build_select_expression()\n    rows = await self.database.fetch_all(expr)\n    if not rows:\n        return []\n    alias_resolver = ReverseAliasResolver(\n        select_related=self._select_related,\n        excludable=self._excludable,\n        model_cls=self.model_cls,  # type: ignore\n        exclude_through=exclude_through,\n    )\n    column_map = alias_resolver.resolve_columns(\n        columns_names=list(cast(LegacyRow, rows[0]).keys())\n    )\n    result = [\n        {column_map.get(k): v for k, v in dict(x).items() if k in column_map}\n        for x in rows\n    ]\n    if _as_dict:\n        return result\n    if _flatten and self._excludable.include_entry_count() != 1:\n        raise QueryDefinitionError(\n            \"You cannot flatten values_list if more than one field is selected!\"\n        )\n    tuple_result = [tuple(x.values()) for x in result]\n    return tuple_result if not _flatten else [x[0] for x in tuple_result]\n</code></pre>"},{"location":"api/queryset/queryset/#ormar.queryset.queryset.QuerySet.values_list","title":"<code>values_list(fields=None, flatten=False, exclude_through=False)</code>  <code>async</code>","text":"<p>Return a list of tuples with column values in order of the fields passed or all fields from queried models.</p> <p>When one field is passed you can flatten the list of tuples into list of values of that single field.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param fields: field name or list of field names to extract from db :type fields: Union[str, List[str]] :param flatten: when one field is passed you can flatten the list of tuples :type flatten: bool</p> Source code in <code>ormar/queryset/queryset.py</code> <pre><code>async def values_list(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    flatten: bool = False,\n    exclude_through: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of tuples with column values in order of the fields passed or\n    all fields from queried models.\n\n    When one field is passed you can flatten the list of tuples into list of values\n    of that single field.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields: Union[str, List[str]]\n    :param flatten: when one field is passed you can flatten the list of tuples\n    :type flatten: bool\n    \"\"\"\n    return await self.values(\n        fields=fields,\n        exclude_through=exclude_through,\n        _as_dict=False,\n        _flatten=flatten,\n    )\n</code></pre>"},{"location":"api/queryset/reverse_alias_resolver/","title":"reverse_alias_resolver","text":""},{"location":"api/queryset/reverse_alias_resolver/#ormar.queryset.reverse_alias_resolver.ReverseAliasResolver","title":"<code>ReverseAliasResolver</code>","text":"<p>Class is used to reverse resolve table aliases into relation strings to parse raw data columns and replace table prefixes with full relation string</p> Source code in <code>ormar/queryset/reverse_alias_resolver.py</code> <pre><code>class ReverseAliasResolver:\n    \"\"\"\n    Class is used to reverse resolve table aliases into relation strings\n    to parse raw data columns and replace table prefixes with full relation string\n    \"\"\"\n\n    def __init__(\n        self,\n        model_cls: Type[\"Model\"],\n        excludable: \"ExcludableItems\",\n        select_related: List[str],\n        exclude_through: bool = False,\n    ) -&gt; None:\n        self.select_related = select_related\n        self.model_cls = model_cls\n        self.reversed_aliases = (\n            self.model_cls.ormar_config.alias_manager.reversed_aliases\n        )\n        self.excludable = excludable\n        self.exclude_through = exclude_through\n\n        self._fields: Dict[str, \"ForeignKeyField\"] = dict()\n        self._prefixes: Dict[str, str] = dict()\n        self._previous_prefixes: List[str] = [\"\"]\n        self._resolved_names: Dict[str, str] = dict()\n\n    def resolve_columns(self, columns_names: List[str]) -&gt; Dict:\n        \"\"\"\n        Takes raw query prefixed column and resolves the prefixes to\n        relation strings (relation names connected with dunders).\n\n        :param columns_names: list of column names with prefixes from query\n        :type columns_names: List[str]\n        :return: dictionary of prefix: resolved names\n        :rtype: Union[None, Dict[str, str]]\n        \"\"\"\n        self._create_prefixes_map()\n        for column_name in columns_names:\n            column_parts = column_name.split(\"_\")\n            potential_prefix = column_parts[0]\n            if potential_prefix in self.reversed_aliases:\n                self._resolve_column_with_prefix(\n                    column_name=column_name, prefix=potential_prefix\n                )\n            else:\n                allowed_columns = self.model_cls.own_table_columns(\n                    model=self.model_cls,\n                    excludable=self.excludable,\n                    add_pk_columns=False,\n                )\n                if column_name in allowed_columns:\n                    self._resolved_names[column_name] = column_name\n\n        return self._resolved_names\n\n    def _resolve_column_with_prefix(self, column_name: str, prefix: str) -&gt; None:\n        \"\"\"\n        Takes the prefixed column, checks if field should be excluded, and if not\n        it proceeds to replace prefix of a table with full relation string.\n\n        Sample: translates: \"xsd12df_name\" -&gt; into: \"posts__user__name\"\n\n        :param column_name: prefixed name of the column\n        :type column_name: str\n        :param prefix: extracted prefix\n        :type prefix: str\n        \"\"\"\n        relation = self.reversed_aliases.get(prefix, None)\n        relation_str = self._prefixes.get(relation, None)\n        field = self._fields.get(relation, None)\n        if relation_str is None or field is None:\n            return\n        is_through = field.is_multi and field.through.get_name() in relation_str\n        if self._check_if_field_is_excluded(\n            prefix=prefix, field=field, is_through=is_through\n        ):\n            return\n\n        target_model = field.through if is_through else field.to\n        allowed_columns = target_model.own_table_columns(\n            model=target_model,\n            excludable=self.excludable,\n            alias=prefix,\n            add_pk_columns=False,\n        )\n        new_column_name = column_name.replace(f\"{prefix}_\", \"\")\n        if new_column_name in allowed_columns:\n            self._resolved_names[column_name] = column_name.replace(\n                f\"{prefix}_\", f\"{relation_str}__\"\n            )\n\n    def _check_if_field_is_excluded(\n        self, prefix: str, field: \"ForeignKeyField\", is_through: bool\n    ) -&gt; bool:\n        \"\"\"\n        Checks if given relation is excluded in current query.\n\n        Note that in contrary to other queryset methods here you can exclude the\n        in-between models but keep the end columns, which does not make sense\n        when parsing the raw data into models.\n\n        So in relation category -&gt; category_x_post -&gt; post -&gt; user you can exclude\n        category_x_post and post models but can keep the user one. (in ormar model\n        context that is not possible as if you would exclude through and post model\n        there would be no way to reach user model).\n\n        Exclusions happen on a model before the current one, so we need to move back\n        in chain of model by one or by two (m2m relations have through model in between)\n\n        :param prefix: table alias\n        :type prefix: str\n        :param field: field with relation\n        :type field: ForeignKeyField\n        :param is_through: flag if current table is a through table\n        :type is_through: bool\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        shift, field_name = 1, field.name\n        if is_through:\n            field_name = field.through.get_name()\n        elif field.is_multi:\n            shift = 2\n        previous_excludable = self._get_previous_excludable(\n            prefix=prefix, field=field, shift=shift\n        )\n        return previous_excludable.is_excluded(field_name)\n\n    def _get_previous_excludable(\n        self, prefix: str, field: \"ForeignKeyField\", shift: int = 1\n    ) -&gt; \"Excludable\":\n        \"\"\"\n        Returns excludable related to model previous in chain of models.\n        Used to check if current model should be excluded.\n\n        :param prefix: prefix of a current table\n        :type prefix: str\n        :param field: field with relation\n        :type field: ForeignKeyField\n        :param shift: how many model back to go - for m2m it's 2 due to through models\n        :type shift: int\n        :return: excludable for previous model\n        :rtype: Excludable\n        \"\"\"\n        if prefix not in self._previous_prefixes:\n            self._previous_prefixes.append(prefix)\n        previous_prefix_ind = self._previous_prefixes.index(prefix)\n        previous_prefix = (\n            self._previous_prefixes[previous_prefix_ind - shift]\n            if previous_prefix_ind &gt; (shift - 1)\n            else \"\"\n        )\n        return self.excludable.get(field.owner, alias=previous_prefix)\n\n    def _create_prefixes_map(self) -&gt; None:\n        \"\"\"\n        Creates a map of alias manager aliases keys to relation strings.\n        I.e in alias manager you can have alias user_roles: xas12ad\n\n        This method will create entry user_roles: roles, where roles is a name of\n        relation on user model.\n\n        Will also keep the relation field in separate dictionary so we can later\n        extract field names and owner models.\n\n        \"\"\"\n        for related in self.select_related:\n            model_cls = self.model_cls\n            related_split = related.split(\"__\")\n            related_str = \"\"\n            for relation in related_split:\n                previous_related_str = f\"{related_str}__\" if related_str else \"\"\n                new_related_str = previous_related_str + relation\n                field = model_cls.ormar_config.model_fields[relation]\n                field = cast(\"ForeignKeyField\", field)\n                prefix_name = self._handle_through_fields_and_prefix(\n                    model_cls=model_cls,\n                    field=field,\n                    previous_related_str=previous_related_str,\n                    relation=relation,\n                )\n\n                self._prefixes[prefix_name] = new_related_str\n                self._fields[prefix_name] = field\n                model_cls = field.to\n                related_str = new_related_str\n\n    def _handle_through_fields_and_prefix(\n        self,\n        model_cls: Type[\"Model\"],\n        field: \"ForeignKeyField\",\n        previous_related_str: str,\n        relation: str,\n    ) -&gt; str:\n        \"\"\"\n        Registers through models for m2m relations and switches prefix for\n        the one linking from through model to target model.\n\n        For other relations returns current model name + relation name as prefix.\n        Nested relations are a chain of relation names with __ in between.\n\n        :param model_cls: model of current relation\n        :type model_cls: Type[\"Model\"]\n        :param field: field with relation\n        :type field: ForeignKeyField\n        :param previous_related_str: concatenated chain linked with \"__\"\n        :type previous_related_str: str\n        :param relation: name of the current relation in chain\n        :type relation: str\n        :return: name of prefix to populate\n        :rtype: str\n        \"\"\"\n        prefix_name = f\"{model_cls.get_name()}_{relation}\"\n        if field.is_multi:\n            through_name = field.through.get_name()\n            if not self.exclude_through:\n                self._fields[prefix_name] = field\n                new_through_str = previous_related_str + through_name\n                self._prefixes[prefix_name] = new_through_str\n            prefix_name = f\"{through_name}_{field.default_target_field_name()}\"\n        return prefix_name\n</code></pre>"},{"location":"api/queryset/reverse_alias_resolver/#ormar.queryset.reverse_alias_resolver.ReverseAliasResolver.resolve_columns","title":"<code>resolve_columns(columns_names)</code>","text":"<p>Takes raw query prefixed column and resolves the prefixes to relation strings (relation names connected with dunders).</p> <p>:param columns_names: list of column names with prefixes from query :type columns_names: List[str] :return: dictionary of prefix: resolved names :rtype: Union[None, Dict[str, str]]</p> Source code in <code>ormar/queryset/reverse_alias_resolver.py</code> <pre><code>def resolve_columns(self, columns_names: List[str]) -&gt; Dict:\n    \"\"\"\n    Takes raw query prefixed column and resolves the prefixes to\n    relation strings (relation names connected with dunders).\n\n    :param columns_names: list of column names with prefixes from query\n    :type columns_names: List[str]\n    :return: dictionary of prefix: resolved names\n    :rtype: Union[None, Dict[str, str]]\n    \"\"\"\n    self._create_prefixes_map()\n    for column_name in columns_names:\n        column_parts = column_name.split(\"_\")\n        potential_prefix = column_parts[0]\n        if potential_prefix in self.reversed_aliases:\n            self._resolve_column_with_prefix(\n                column_name=column_name, prefix=potential_prefix\n            )\n        else:\n            allowed_columns = self.model_cls.own_table_columns(\n                model=self.model_cls,\n                excludable=self.excludable,\n                add_pk_columns=False,\n            )\n            if column_name in allowed_columns:\n                self._resolved_names[column_name] = column_name\n\n    return self._resolved_names\n</code></pre>"},{"location":"api/queryset/utils/","title":"utils","text":""},{"location":"api/queryset/utils/#ormar.queryset.utils.check_node_not_dict_or_not_last_node","title":"<code>check_node_not_dict_or_not_last_node(part, is_last, current_level)</code>","text":"<p>Checks if given name is not present in the current level of the structure. Checks if given name is not the last name in the split list of parts. Checks if the given name in current level is not a dictionary.</p> <p>All those checks verify if there is a need for deeper traversal.</p> <p>:param part: :type part: str :param is_last: flag to check if last element :type is_last: bool :param current_level: current level of the traversed structure :type current_level: Any :return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def check_node_not_dict_or_not_last_node(\n    part: str, is_last: bool, current_level: Any\n) -&gt; bool:\n    \"\"\"\n    Checks if given name is not present in the current level of the structure.\n    Checks if given name is not the last name in the split list of parts.\n    Checks if the given name in current level is not a dictionary.\n\n    All those checks verify if there is a need for deeper traversal.\n\n    :param part:\n    :type part: str\n    :param is_last: flag to check if last element\n    :type is_last: bool\n    :param current_level: current level of the traversed structure\n    :type current_level: Any\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return (part not in current_level and not is_last) or (\n        part in current_level and not isinstance(current_level[part], dict)\n    )\n</code></pre>"},{"location":"api/queryset/utils/#ormar.queryset.utils.convert_set_to_required_dict","title":"<code>convert_set_to_required_dict(set_to_convert)</code>","text":"<p>Converts set to dictionary of required keys. Required key is Ellipsis.</p> <p>:param set_to_convert: set to convert to dict :type set_to_convert: set :return: set converted to dict of ellipsis :rtype: Dict</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def convert_set_to_required_dict(set_to_convert: set) -&gt; Dict:\n    \"\"\"\n    Converts set to dictionary of required keys.\n    Required key is Ellipsis.\n\n    :param set_to_convert: set to convert to dict\n    :type set_to_convert: set\n    :return: set converted to dict of ellipsis\n    :rtype: Dict\n    \"\"\"\n    new_dict = dict()\n    for key in set_to_convert:\n        new_dict[key] = Ellipsis\n    return new_dict\n</code></pre>"},{"location":"api/queryset/utils/#ormar.queryset.utils.get_relationship_alias_model_and_str","title":"<code>get_relationship_alias_model_and_str(source_model, related_parts)</code>","text":"<p>Walks the relation to retrieve the actual model on which the clause should be constructed, extracts alias based on last relation leading to target model. :param related_parts: list of related names extracted from string :type related_parts: Union[List, List[str]] :param source_model: model from which relation starts :type source_model: Type[Model] :return: table prefix, target model and relation string :rtype: Tuple[str, Type[\"Model\"], str]</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def get_relationship_alias_model_and_str(\n    source_model: Type[\"Model\"], related_parts: List\n) -&gt; Tuple[str, Type[\"Model\"], str, bool]:\n    \"\"\"\n    Walks the relation to retrieve the actual model on which the clause should be\n    constructed, extracts alias based on last relation leading to target model.\n    :param related_parts: list of related names extracted from string\n    :type related_parts: Union[List, List[str]]\n    :param source_model: model from which relation starts\n    :type source_model: Type[Model]\n    :return: table prefix, target model and relation string\n    :rtype: Tuple[str, Type[\"Model\"], str]\n    \"\"\"\n    table_prefix = \"\"\n    is_through = False\n    target_model = source_model\n    previous_model = target_model\n    previous_models = [target_model]\n    manager = target_model.ormar_config.alias_manager\n    for relation in related_parts[:]:\n        related_field = target_model.ormar_config.model_fields[relation]\n\n        if related_field.is_through:\n            (previous_model, relation, is_through) = _process_through_field(\n                related_parts=related_parts,\n                relation=relation,\n                related_field=related_field,\n                previous_model=previous_model,\n                previous_models=previous_models,\n            )\n        if related_field.is_multi:\n            previous_model = related_field.through\n            relation = related_field.default_target_field_name()  # type: ignore\n        table_prefix = manager.resolve_relation_alias(\n            from_model=previous_model, relation_name=relation\n        )\n        target_model = related_field.to\n        previous_model = target_model\n        if not is_through:\n            previous_models.append(previous_model)\n    relation_str = \"__\".join(related_parts)\n\n    return table_prefix, target_model, relation_str, is_through\n</code></pre>"},{"location":"api/queryset/utils/#ormar.queryset.utils.subtract_dict","title":"<code>subtract_dict(current_dict, updating_dict)</code>","text":"<p>Update one dict with another but with regard for nested keys.</p> <p>That way nested sets are unionised, dicts updated and only other values are overwritten.</p> <p>:param current_dict: dict to update :type current_dict: Dict[str, ellipsis] :param updating_dict: dict with values to update :type updating_dict: Dict :return: combination of both dicts :rtype: Dict</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def subtract_dict(current_dict: Any, updating_dict: Any) -&gt; Dict:  # noqa: CCR001\n    \"\"\"\n    Update one dict with another but with regard for nested keys.\n\n    That way nested sets are unionised, dicts updated and\n    only other values are overwritten.\n\n    :param current_dict: dict to update\n    :type current_dict: Dict[str, ellipsis]\n    :param updating_dict: dict with values to update\n    :type updating_dict: Dict\n    :return: combination of both dicts\n    :rtype: Dict\n    \"\"\"\n    for key, value in updating_dict.items():\n        old_key = current_dict.get(key, {})\n        new_value: Optional[Union[Dict, Set]] = None\n        if not old_key:\n            continue\n        if isinstance(value, set) and isinstance(old_key, set):\n            new_value = old_key.difference(value)\n        elif isinstance(value, (set, collections.abc.Mapping)) and isinstance(\n            old_key, (set, collections.abc.Mapping)\n        ):\n            value = (\n                convert_set_to_required_dict(value)\n                if not isinstance(value, collections.abc.Mapping)\n                else value\n            )\n            old_key = (\n                convert_set_to_required_dict(old_key)\n                if not isinstance(old_key, collections.abc.Mapping)\n                else old_key\n            )\n            new_value = subtract_dict(old_key, value)\n\n        if new_value:\n            current_dict[key] = new_value\n        else:\n            current_dict.pop(key, None)\n    return current_dict\n</code></pre>"},{"location":"api/queryset/utils/#ormar.queryset.utils.translate_list_to_dict","title":"<code>translate_list_to_dict(list_to_trans, default=...)</code>","text":"<p>Splits the list of strings by '__' and converts them to dictionary with nested models grouped by parent model. That way each model appears only once in the whole dictionary and children are grouped under parent name.</p> <p>Default required key ise Ellipsis like in pydantic.</p> <p>:param list_to_trans: input list :type list_to_trans: Union[List, Set] :param default: value to use as a default value :type default: Any :param is_order: flag if change affects order_by clauses are they require special default value with sort order. :type is_order: bool :return: converted to dictionary input list :rtype: Dict</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def translate_list_to_dict(  # noqa: CCR001\n    list_to_trans: Union[List, Set], default: Any = ...\n) -&gt; Dict:\n    \"\"\"\n    Splits the list of strings by '__' and converts them to dictionary with nested\n    models grouped by parent model. That way each model appears only once in the whole\n    dictionary and children are grouped under parent name.\n\n    Default required key ise Ellipsis like in pydantic.\n\n    :param list_to_trans: input list\n    :type list_to_trans: Union[List, Set]\n    :param default: value to use as a default value\n    :type default: Any\n    :param is_order: flag if change affects order_by clauses are they require special\n    default value with sort order.\n    :type is_order: bool\n    :return: converted to dictionary input list\n    :rtype: Dict\n    \"\"\"\n    new_dict: Dict = dict()\n    for path in list_to_trans:\n        current_level = new_dict\n        parts = path.split(\"__\")\n        def_val: Any = copy.deepcopy(default)\n        for ind, part in enumerate(parts):\n            is_last = ind == len(parts) - 1\n            if check_node_not_dict_or_not_last_node(\n                part=part, is_last=is_last, current_level=current_level\n            ):\n                current_level[part] = dict()\n            elif part not in current_level:\n                current_level[part] = def_val\n            current_level = current_level[part]\n    return new_dict\n</code></pre>"},{"location":"api/queryset/utils/#ormar.queryset.utils.update","title":"<code>update(current_dict, updating_dict)</code>","text":"<p>Update one dict with another but with regard for nested keys.</p> <p>That way nested sets are unionised, dicts updated and only other values are overwritten.</p> <p>:param current_dict: dict to update :type current_dict: Dict[str, ellipsis] :param updating_dict: dict with values to update :type updating_dict: Dict :return: combination of both dicts :rtype: Dict</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def update(current_dict: Any, updating_dict: Any) -&gt; Dict:  # noqa: CCR001\n    \"\"\"\n    Update one dict with another but with regard for nested keys.\n\n    That way nested sets are unionised, dicts updated and\n    only other values are overwritten.\n\n    :param current_dict: dict to update\n    :type current_dict: Dict[str, ellipsis]\n    :param updating_dict: dict with values to update\n    :type updating_dict: Dict\n    :return: combination of both dicts\n    :rtype: Dict\n    \"\"\"\n    if current_dict is Ellipsis:\n        current_dict = dict()\n    for key, value in updating_dict.items():\n        if isinstance(value, collections.abc.Mapping):\n            old_key = current_dict.get(key, {})\n            if isinstance(old_key, set):\n                old_key = convert_set_to_required_dict(old_key)\n            current_dict[key] = update(old_key, value)\n        elif isinstance(value, set) and isinstance(current_dict.get(key), set):\n            current_dict[key] = current_dict.get(key).union(value)\n        else:\n            current_dict[key] = value\n    return current_dict\n</code></pre>"},{"location":"api/queryset/utils/#ormar.queryset.utils.update_dict_from_list","title":"<code>update_dict_from_list(curr_dict, list_to_update)</code>","text":"<p>Converts the list into dictionary and later performs special update, where nested keys that are sets or dicts are combined and not overwritten.</p> <p>:param curr_dict: dict to update :type curr_dict: Dict :param list_to_update: list with values to update the dict :type list_to_update: List[str] :return: updated dict :rtype: Dict</p> Source code in <code>ormar/queryset/utils.py</code> <pre><code>def update_dict_from_list(curr_dict: Dict, list_to_update: Union[List, Set]) -&gt; Dict:\n    \"\"\"\n    Converts the list into dictionary and later performs special update, where\n    nested keys that are sets or dicts are combined and not overwritten.\n\n    :param curr_dict: dict to update\n    :type curr_dict: Dict\n    :param list_to_update: list with values to update the dict\n    :type list_to_update: List[str]\n    :return: updated dict\n    :rtype: Dict\n    \"\"\"\n    updated_dict = copy.copy(curr_dict)\n    dict_to_update = translate_list_to_dict(list_to_update)\n    update(updated_dict, dict_to_update)\n    return updated_dict\n</code></pre>"},{"location":"api/queryset/actions/","title":"actions","text":""},{"location":"api/queryset/actions/#ormar.queryset.actions.FilterAction","title":"<code>FilterAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Filter Actions is populated by queryset when filter() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>class FilterAction(QueryAction):\n    \"\"\"\n    Filter Actions is populated by queryset when filter() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(self, filter_str: str, value: Any, model_cls: Type[\"Model\"]) -&gt; None:\n        super().__init__(query_str=filter_str, model_cls=model_cls)\n        self.filter_value = value\n        self._escape_characters_in_clause()\n\n    def has_escaped_characters(self) -&gt; bool:\n        \"\"\"Check if value is a string that contains characters to escape\"\"\"\n        return isinstance(self.filter_value, str) and any(\n            c for c in ESCAPE_CHARACTERS if c in self.filter_value\n        )\n\n    def _split_value_into_parts(self, query_str: str) -&gt; None:\n        parts = query_str.split(\"__\")\n        if parts[-1] in FILTER_OPERATORS:\n            self.operator = parts[-1]\n            self.field_name = parts[-2]\n            self.related_parts = parts[:-2]\n        else:\n            self.operator = \"exact\"\n            self.field_name = parts[-1]\n            self.related_parts = parts[:-1]\n\n    def _escape_characters_in_clause(self) -&gt; None:\n        \"\"\"\n        Escapes the special characters [\"%\", \"_\"] if needed.\n        Adds `%` for `like` queries.\n\n        :raises QueryDefinitionError: if contains or icontains is used with\n        ormar model instance\n        :return: escaped value and flag if escaping is needed\n        :rtype: Tuple[Any, bool]\n        \"\"\"\n        self.has_escaped_character = False\n        if self.operator in [\n            \"contains\",\n            \"icontains\",\n            \"startswith\",\n            \"istartswith\",\n            \"endswith\",\n            \"iendswith\",\n        ]:\n            if isinstance(self.filter_value, ormar.Model):\n                raise QueryDefinitionError(\n                    \"You cannot use contains and icontains with instance of the Model\"\n                )\n            self.has_escaped_character = self.has_escaped_characters()\n            if self.has_escaped_character:\n                self._escape_chars()\n            self._prefix_suffix_quote()\n\n    def _escape_chars(self) -&gt; None:\n        \"\"\"Actually replaces chars to escape in value\"\"\"\n        for char in ESCAPE_CHARACTERS:\n            self.filter_value = self.filter_value.replace(char, f\"\\\\{char}\")\n\n    def _prefix_suffix_quote(self) -&gt; None:\n        \"\"\"\n        Adds % to the beginning of the value if operator checks for containment and not\n        starts with.\n\n        Adds % to the end of the value if operator checks for containment and not\n        end with.\n        :return:\n        :rtype:\n        \"\"\"\n        prefix = \"%\" if \"start\" not in self.operator else \"\"\n        sufix = \"%\" if \"end\" not in self.operator else \"\"\n        self.filter_value = f\"{prefix}{self.filter_value}{sufix}\"\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.BinaryExpression:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        if isinstance(self.filter_value, ormar.Model):\n            self.filter_value = self.filter_value.pk\n\n        op_attr = FILTER_OPERATORS[self.operator]\n        if self.operator == \"isnull\":\n            op_attr = \"is_\" if self.filter_value else \"isnot\"\n            filter_value = None\n        else:\n            filter_value = self.filter_value\n        if self.table_prefix:\n            aliased_table = (\n                self.source_model.ormar_config.alias_manager.prefixed_table_name(\n                    self.table_prefix, self.column.table\n                )\n            )\n            aliased_column = getattr(aliased_table.c, self.column.name)\n        else:\n            aliased_column = self.column\n        clause = getattr(aliased_column, op_attr)(filter_value)\n        if self.has_escaped_character:\n            clause.modifiers[\"escape\"] = \"\\\\\"\n        return clause\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.FilterAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.BinaryExpression:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    if isinstance(self.filter_value, ormar.Model):\n        self.filter_value = self.filter_value.pk\n\n    op_attr = FILTER_OPERATORS[self.operator]\n    if self.operator == \"isnull\":\n        op_attr = \"is_\" if self.filter_value else \"isnot\"\n        filter_value = None\n    else:\n        filter_value = self.filter_value\n    if self.table_prefix:\n        aliased_table = (\n            self.source_model.ormar_config.alias_manager.prefixed_table_name(\n                self.table_prefix, self.column.table\n            )\n        )\n        aliased_column = getattr(aliased_table.c, self.column.name)\n    else:\n        aliased_column = self.column\n    clause = getattr(aliased_column, op_attr)(filter_value)\n    if self.has_escaped_character:\n        clause.modifiers[\"escape\"] = \"\\\\\"\n    return clause\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.FilterAction.has_escaped_characters","title":"<code>has_escaped_characters()</code>","text":"<p>Check if value is a string that contains characters to escape</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>def has_escaped_characters(self) -&gt; bool:\n    \"\"\"Check if value is a string that contains characters to escape\"\"\"\n    return isinstance(self.filter_value, str) and any(\n        c for c in ESCAPE_CHARACTERS if c in self.filter_value\n    )\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.OrderAction","title":"<code>OrderAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>class OrderAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, order_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        self.direction: str = \"\"\n        super().__init__(query_str=order_str, model_cls=model_cls)\n        self.is_source_model_order = False\n        if alias:\n            self.table_prefix = alias\n        if self.source_model == self.target_model and \"__\" not in self.related_str:\n            self.is_source_model_order = True\n\n    @property\n    def field_alias(self) -&gt; str:\n        return self.target_model.get_column_alias(self.field_name)\n\n    @property\n    def is_postgres_bool(self) -&gt; bool:\n        dialect = self.target_model.ormar_config.database._backend._dialect.name\n        field_type = self.target_model.ormar_config.model_fields[\n            self.field_name\n        ].__type__\n        return dialect == \"postgresql\" and field_type is bool\n\n    def get_field_name_text(self) -&gt; str:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n\n    def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Used in limit sub queries where you need to use aggregated functions\n        in order to order by columns not included in group by. For postgres bool\n        field it's using bool_or function as aggregates does not work with this type\n        of columns.\n\n        :return: min or max function to order\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        if self.direction == \"\":\n            function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n            return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n        function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        dialect = self.target_model.ormar_config.database._backend._dialect\n        quoter = dialect.identifier_preparer.quote\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        table_name = self.table.name\n        field_name = self.field_alias\n        if not prefix:\n            table_name = quoter(table_name)\n        else:\n            table_name = quoter(f\"{prefix}{table_name}\")\n        field_name = quoter(field_name)\n        return text(f\"{table_name}.{field_name} {self.direction}\")\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        if order_str.startswith(\"-\"):\n            self.direction = \"desc\"\n            order_str = order_str[1:]\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n        \"\"\"\n        Checks filter conditions to find if they apply to current join.\n\n        :param target_model: model which is now processed\n        :type target_model: Type[\"Model\"]\n        :param alias: prefix of the relation\n        :type alias: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.OrderAction.check_if_filter_apply","title":"<code>check_if_filter_apply(target_model, alias)</code>","text":"<p>Checks filter conditions to find if they apply to current join.</p> <p>:param target_model: model which is now processed :type target_model: Type[\"Model\"] :param alias: prefix of the relation :type alias: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n    \"\"\"\n    Checks filter conditions to find if they apply to current join.\n\n    :param target_model: model which is now processed\n    :type target_model: Type[\"Model\"]\n    :param alias: prefix of the relation\n    :type alias: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.OrderAction.get_field_name_text","title":"<code>get_field_name_text()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_field_name_text(self) -&gt; str:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.OrderAction.get_min_or_max","title":"<code>get_min_or_max()</code>","text":"<p>Used in limit sub queries where you need to use aggregated functions in order to order by columns not included in group by. For postgres bool field it's using bool_or function as aggregates does not work with this type of columns.</p> <p>:return: min or max function to order :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Used in limit sub queries where you need to use aggregated functions\n    in order to order by columns not included in group by. For postgres bool\n    field it's using bool_or function as aggregates does not work with this type\n    of columns.\n\n    :return: min or max function to order\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    if self.direction == \"\":\n        function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n    function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n    return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.OrderAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    dialect = self.target_model.ormar_config.database._backend._dialect\n    quoter = dialect.identifier_preparer.quote\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    table_name = self.table.name\n    field_name = self.field_alias\n    if not prefix:\n        table_name = quoter(table_name)\n    else:\n        table_name = quoter(f\"{prefix}{table_name}\")\n    field_name = quoter(field_name)\n    return text(f\"{table_name}.{field_name} {self.direction}\")\n</code></pre>"},{"location":"api/queryset/actions/#ormar.queryset.actions.SelectAction","title":"<code>SelectAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/select_action.py</code> <pre><code>class SelectAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, select_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        super().__init__(query_str=select_str, model_cls=model_cls)\n        if alias:  # pragma: no cover\n            self.table_prefix = alias\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    @property\n    def is_numeric(self) -&gt; bool:\n        return self.get_target_field_type() in [int, float, decimal.Decimal]\n\n    def get_target_field_type(self) -&gt; Any:\n        return self.target_model.ormar_config.model_fields[self.field_name].__type__\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        alias = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return sqlalchemy.text(f\"{alias}{self.field_name}\")\n\n    def apply_func(\n        self, func: Callable, use_label: bool = True\n    ) -&gt; sqlalchemy.sql.expression.TextClause:\n        result = func(self.get_text_clause())\n        if use_label:\n            rel_prefix = f\"{self.related_str}__\" if self.related_str else \"\"\n            result = result.label(f\"{rel_prefix}{self.field_name}\")\n        return result\n</code></pre>"},{"location":"api/queryset/actions/filter_action/","title":"filter_action","text":""},{"location":"api/queryset/actions/filter_action/#ormar.queryset.actions.filter_action.FilterAction","title":"<code>FilterAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Filter Actions is populated by queryset when filter() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>class FilterAction(QueryAction):\n    \"\"\"\n    Filter Actions is populated by queryset when filter() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(self, filter_str: str, value: Any, model_cls: Type[\"Model\"]) -&gt; None:\n        super().__init__(query_str=filter_str, model_cls=model_cls)\n        self.filter_value = value\n        self._escape_characters_in_clause()\n\n    def has_escaped_characters(self) -&gt; bool:\n        \"\"\"Check if value is a string that contains characters to escape\"\"\"\n        return isinstance(self.filter_value, str) and any(\n            c for c in ESCAPE_CHARACTERS if c in self.filter_value\n        )\n\n    def _split_value_into_parts(self, query_str: str) -&gt; None:\n        parts = query_str.split(\"__\")\n        if parts[-1] in FILTER_OPERATORS:\n            self.operator = parts[-1]\n            self.field_name = parts[-2]\n            self.related_parts = parts[:-2]\n        else:\n            self.operator = \"exact\"\n            self.field_name = parts[-1]\n            self.related_parts = parts[:-1]\n\n    def _escape_characters_in_clause(self) -&gt; None:\n        \"\"\"\n        Escapes the special characters [\"%\", \"_\"] if needed.\n        Adds `%` for `like` queries.\n\n        :raises QueryDefinitionError: if contains or icontains is used with\n        ormar model instance\n        :return: escaped value and flag if escaping is needed\n        :rtype: Tuple[Any, bool]\n        \"\"\"\n        self.has_escaped_character = False\n        if self.operator in [\n            \"contains\",\n            \"icontains\",\n            \"startswith\",\n            \"istartswith\",\n            \"endswith\",\n            \"iendswith\",\n        ]:\n            if isinstance(self.filter_value, ormar.Model):\n                raise QueryDefinitionError(\n                    \"You cannot use contains and icontains with instance of the Model\"\n                )\n            self.has_escaped_character = self.has_escaped_characters()\n            if self.has_escaped_character:\n                self._escape_chars()\n            self._prefix_suffix_quote()\n\n    def _escape_chars(self) -&gt; None:\n        \"\"\"Actually replaces chars to escape in value\"\"\"\n        for char in ESCAPE_CHARACTERS:\n            self.filter_value = self.filter_value.replace(char, f\"\\\\{char}\")\n\n    def _prefix_suffix_quote(self) -&gt; None:\n        \"\"\"\n        Adds % to the beginning of the value if operator checks for containment and not\n        starts with.\n\n        Adds % to the end of the value if operator checks for containment and not\n        end with.\n        :return:\n        :rtype:\n        \"\"\"\n        prefix = \"%\" if \"start\" not in self.operator else \"\"\n        sufix = \"%\" if \"end\" not in self.operator else \"\"\n        self.filter_value = f\"{prefix}{self.filter_value}{sufix}\"\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.BinaryExpression:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        if isinstance(self.filter_value, ormar.Model):\n            self.filter_value = self.filter_value.pk\n\n        op_attr = FILTER_OPERATORS[self.operator]\n        if self.operator == \"isnull\":\n            op_attr = \"is_\" if self.filter_value else \"isnot\"\n            filter_value = None\n        else:\n            filter_value = self.filter_value\n        if self.table_prefix:\n            aliased_table = (\n                self.source_model.ormar_config.alias_manager.prefixed_table_name(\n                    self.table_prefix, self.column.table\n                )\n            )\n            aliased_column = getattr(aliased_table.c, self.column.name)\n        else:\n            aliased_column = self.column\n        clause = getattr(aliased_column, op_attr)(filter_value)\n        if self.has_escaped_character:\n            clause.modifiers[\"escape\"] = \"\\\\\"\n        return clause\n</code></pre>"},{"location":"api/queryset/actions/filter_action/#ormar.queryset.actions.filter_action.FilterAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.BinaryExpression:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    if isinstance(self.filter_value, ormar.Model):\n        self.filter_value = self.filter_value.pk\n\n    op_attr = FILTER_OPERATORS[self.operator]\n    if self.operator == \"isnull\":\n        op_attr = \"is_\" if self.filter_value else \"isnot\"\n        filter_value = None\n    else:\n        filter_value = self.filter_value\n    if self.table_prefix:\n        aliased_table = (\n            self.source_model.ormar_config.alias_manager.prefixed_table_name(\n                self.table_prefix, self.column.table\n            )\n        )\n        aliased_column = getattr(aliased_table.c, self.column.name)\n    else:\n        aliased_column = self.column\n    clause = getattr(aliased_column, op_attr)(filter_value)\n    if self.has_escaped_character:\n        clause.modifiers[\"escape\"] = \"\\\\\"\n    return clause\n</code></pre>"},{"location":"api/queryset/actions/filter_action/#ormar.queryset.actions.filter_action.FilterAction.has_escaped_characters","title":"<code>has_escaped_characters()</code>","text":"<p>Check if value is a string that contains characters to escape</p> Source code in <code>ormar/queryset/actions/filter_action.py</code> <pre><code>def has_escaped_characters(self) -&gt; bool:\n    \"\"\"Check if value is a string that contains characters to escape\"\"\"\n    return isinstance(self.filter_value, str) and any(\n        c for c in ESCAPE_CHARACTERS if c in self.filter_value\n    )\n</code></pre>"},{"location":"api/queryset/actions/order_action/","title":"order_action","text":""},{"location":"api/queryset/actions/order_action/#ormar.queryset.actions.order_action.OrderAction","title":"<code>OrderAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>class OrderAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, order_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        self.direction: str = \"\"\n        super().__init__(query_str=order_str, model_cls=model_cls)\n        self.is_source_model_order = False\n        if alias:\n            self.table_prefix = alias\n        if self.source_model == self.target_model and \"__\" not in self.related_str:\n            self.is_source_model_order = True\n\n    @property\n    def field_alias(self) -&gt; str:\n        return self.target_model.get_column_alias(self.field_name)\n\n    @property\n    def is_postgres_bool(self) -&gt; bool:\n        dialect = self.target_model.ormar_config.database._backend._dialect.name\n        field_type = self.target_model.ormar_config.model_fields[\n            self.field_name\n        ].__type__\n        return dialect == \"postgresql\" and field_type is bool\n\n    def get_field_name_text(self) -&gt; str:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n\n    def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Used in limit sub queries where you need to use aggregated functions\n        in order to order by columns not included in group by. For postgres bool\n        field it's using bool_or function as aggregates does not work with this type\n        of columns.\n\n        :return: min or max function to order\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        if self.direction == \"\":\n            function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n            return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n        function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        \"\"\"\n        Escapes characters if it's required.\n        Substitutes values of the models if value is a ormar Model with its pk value.\n        Compiles the clause.\n\n        :return: complied and escaped clause\n        :rtype: sqlalchemy.sql.elements.TextClause\n        \"\"\"\n        dialect = self.target_model.ormar_config.database._backend._dialect\n        quoter = dialect.identifier_preparer.quote\n        prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        table_name = self.table.name\n        field_name = self.field_alias\n        if not prefix:\n            table_name = quoter(table_name)\n        else:\n            table_name = quoter(f\"{prefix}{table_name}\")\n        field_name = quoter(field_name)\n        return text(f\"{table_name}.{field_name} {self.direction}\")\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        if order_str.startswith(\"-\"):\n            self.direction = \"desc\"\n            order_str = order_str[1:]\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n        \"\"\"\n        Checks filter conditions to find if they apply to current join.\n\n        :param target_model: model which is now processed\n        :type target_model: Type[\"Model\"]\n        :param alias: prefix of the relation\n        :type alias: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/queryset/actions/order_action/#ormar.queryset.actions.order_action.OrderAction.check_if_filter_apply","title":"<code>check_if_filter_apply(target_model, alias)</code>","text":"<p>Checks filter conditions to find if they apply to current join.</p> <p>:param target_model: model which is now processed :type target_model: Type[\"Model\"] :param alias: prefix of the relation :type alias: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def check_if_filter_apply(self, target_model: Type[\"Model\"], alias: str) -&gt; bool:\n    \"\"\"\n    Checks filter conditions to find if they apply to current join.\n\n    :param target_model: model which is now processed\n    :type target_model: Type[\"Model\"]\n    :param alias: prefix of the relation\n    :type alias: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return target_model == self.target_model and alias == self.table_prefix\n</code></pre>"},{"location":"api/queryset/actions/order_action/#ormar.queryset.actions.order_action.OrderAction.get_field_name_text","title":"<code>get_field_name_text()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_field_name_text(self) -&gt; str:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    return f\"{prefix}{self.table}\" f\".{self.field_alias}\"\n</code></pre>"},{"location":"api/queryset/actions/order_action/#ormar.queryset.actions.order_action.OrderAction.get_min_or_max","title":"<code>get_min_or_max()</code>","text":"<p>Used in limit sub queries where you need to use aggregated functions in order to order by columns not included in group by. For postgres bool field it's using bool_or function as aggregates does not work with this type of columns.</p> <p>:return: min or max function to order :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_min_or_max(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Used in limit sub queries where you need to use aggregated functions\n    in order to order by columns not included in group by. For postgres bool\n    field it's using bool_or function as aggregates does not work with this type\n    of columns.\n\n    :return: min or max function to order\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    if self.direction == \"\":\n        function = \"min\" if not self.is_postgres_bool else \"bool_or\"\n        return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias})\")\n    function = \"max\" if not self.is_postgres_bool else \"bool_or\"\n    return text(f\"{function}({prefix}{self.table}\" f\".{self.field_alias}) desc\")\n</code></pre>"},{"location":"api/queryset/actions/order_action/#ormar.queryset.actions.order_action.OrderAction.get_text_clause","title":"<code>get_text_clause()</code>","text":"<p>Escapes characters if it's required. Substitutes values of the models if value is a ormar Model with its pk value. Compiles the clause.</p> <p>:return: complied and escaped clause :rtype: sqlalchemy.sql.elements.TextClause</p> Source code in <code>ormar/queryset/actions/order_action.py</code> <pre><code>def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n    \"\"\"\n    Escapes characters if it's required.\n    Substitutes values of the models if value is a ormar Model with its pk value.\n    Compiles the clause.\n\n    :return: complied and escaped clause\n    :rtype: sqlalchemy.sql.elements.TextClause\n    \"\"\"\n    dialect = self.target_model.ormar_config.database._backend._dialect\n    quoter = dialect.identifier_preparer.quote\n    prefix = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n    table_name = self.table.name\n    field_name = self.field_alias\n    if not prefix:\n        table_name = quoter(table_name)\n    else:\n        table_name = quoter(f\"{prefix}{table_name}\")\n    field_name = quoter(field_name)\n    return text(f\"{table_name}.{field_name} {self.direction}\")\n</code></pre>"},{"location":"api/queryset/actions/query_action/","title":"query_action","text":""},{"location":"api/queryset/actions/query_action/#ormar.queryset.actions.query_action.QueryAction","title":"<code>QueryAction</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base QueryAction class with common params for Filter and Order actions.</p> Source code in <code>ormar/queryset/actions/query_action.py</code> <pre><code>class QueryAction(abc.ABC):\n    \"\"\"\n    Base QueryAction class with common params for Filter and Order actions.\n    \"\"\"\n\n    def __init__(self, query_str: str, model_cls: Type[\"Model\"]) -&gt; None:\n        self.query_str = query_str\n        self.field_name: str = \"\"\n        self.related_parts: List[str] = []\n        self.related_str: str = \"\"\n\n        self.table_prefix = \"\"\n        self.source_model = model_cls\n        self.target_model = model_cls\n        self.is_through = False\n\n        self._split_value_into_parts(query_str)\n        self._determine_filter_target_table()\n\n    def __eq__(self, other: object) -&gt; bool:  # pragma: no cover\n        if not isinstance(other, QueryAction):\n            return False\n        return self.query_str == other.query_str\n\n    def __hash__(self) -&gt; Any:\n        return hash((self.table_prefix, self.query_str))\n\n    @abc.abstractmethod\n    def _split_value_into_parts(self, query_str: str) -&gt; None:  # pragma: no cover\n        \"\"\"\n        Splits string into related parts and field_name\n        :param query_str: query action string to split (i..e filter or order by)\n        :type query_str: str\n        \"\"\"\n        pass\n\n    @abc.abstractmethod\n    def get_text_clause(\n        self,\n    ) -&gt; sqlalchemy.sql.expression.TextClause:  # pragma: no cover\n        pass\n\n    @property\n    def table(self) -&gt; sqlalchemy.Table:\n        \"\"\"Shortcut to sqlalchemy Table of filtered target model\"\"\"\n        return self.target_model.ormar_config.table\n\n    @property\n    def column(self) -&gt; sqlalchemy.Column:\n        \"\"\"Shortcut to sqlalchemy column of filtered target model\"\"\"\n        aliased_name = self.target_model.get_column_alias(self.field_name)\n        return self.target_model.ormar_config.table.columns[aliased_name]\n\n    def update_select_related(self, select_related: List[str]) -&gt; List[str]:\n        \"\"\"\n        Updates list of select related with related part included in the filter key.\n        That way If you want to just filter by relation you do not have to provide\n        select_related separately.\n\n        :param select_related: list of relation join strings\n        :type select_related: List[str]\n        :return: list of relation joins with implied joins from filter added\n        :rtype: List[str]\n        \"\"\"\n        select_related = select_related[:]\n        if self.related_str and not any(\n            rel.startswith(self.related_str) for rel in select_related\n        ):\n            select_related.append(self.related_str)\n        return select_related\n\n    def _determine_filter_target_table(self) -&gt; None:\n        \"\"\"\n        Walks the relation to retrieve the actual model on which the clause should be\n        constructed, extracts alias based on last relation leading to target model.\n        \"\"\"\n        (\n            self.table_prefix,\n            self.target_model,\n            self.related_str,\n            self.is_through,\n        ) = get_relationship_alias_model_and_str(self.source_model, self.related_parts)\n</code></pre>"},{"location":"api/queryset/actions/query_action/#ormar.queryset.actions.query_action.QueryAction.column","title":"<code>column: sqlalchemy.Column</code>  <code>property</code>","text":"<p>Shortcut to sqlalchemy column of filtered target model</p>"},{"location":"api/queryset/actions/query_action/#ormar.queryset.actions.query_action.QueryAction.table","title":"<code>table: sqlalchemy.Table</code>  <code>property</code>","text":"<p>Shortcut to sqlalchemy Table of filtered target model</p>"},{"location":"api/queryset/actions/query_action/#ormar.queryset.actions.query_action.QueryAction.update_select_related","title":"<code>update_select_related(select_related)</code>","text":"<p>Updates list of select related with related part included in the filter key. That way If you want to just filter by relation you do not have to provide select_related separately.</p> <p>:param select_related: list of relation join strings :type select_related: List[str] :return: list of relation joins with implied joins from filter added :rtype: List[str]</p> Source code in <code>ormar/queryset/actions/query_action.py</code> <pre><code>def update_select_related(self, select_related: List[str]) -&gt; List[str]:\n    \"\"\"\n    Updates list of select related with related part included in the filter key.\n    That way If you want to just filter by relation you do not have to provide\n    select_related separately.\n\n    :param select_related: list of relation join strings\n    :type select_related: List[str]\n    :return: list of relation joins with implied joins from filter added\n    :rtype: List[str]\n    \"\"\"\n    select_related = select_related[:]\n    if self.related_str and not any(\n        rel.startswith(self.related_str) for rel in select_related\n    ):\n        select_related.append(self.related_str)\n    return select_related\n</code></pre>"},{"location":"api/queryset/actions/select_action/","title":"select_action","text":""},{"location":"api/queryset/actions/select_action/#ormar.queryset.actions.select_action.SelectAction","title":"<code>SelectAction</code>","text":"<p>               Bases: <code>QueryAction</code></p> <p>Order Actions is populated by queryset when order_by() is called.</p> <p>All required params are extracted but kept raw until actual filter clause value is required -&gt; then the action is converted into text() clause.</p> <p>Extracted in order to easily change table prefixes on complex relations.</p> Source code in <code>ormar/queryset/actions/select_action.py</code> <pre><code>class SelectAction(QueryAction):\n    \"\"\"\n    Order Actions is populated by queryset when order_by() is called.\n\n    All required params are extracted but kept raw until actual filter clause value\n    is required -&gt; then the action is converted into text() clause.\n\n    Extracted in order to easily change table prefixes on complex relations.\n    \"\"\"\n\n    def __init__(\n        self, select_str: str, model_cls: Type[\"Model\"], alias: Optional[str] = None\n    ) -&gt; None:\n        super().__init__(query_str=select_str, model_cls=model_cls)\n        if alias:  # pragma: no cover\n            self.table_prefix = alias\n\n    def _split_value_into_parts(self, order_str: str) -&gt; None:\n        parts = order_str.split(\"__\")\n        self.field_name = parts[-1]\n        self.related_parts = parts[:-1]\n\n    @property\n    def is_numeric(self) -&gt; bool:\n        return self.get_target_field_type() in [int, float, decimal.Decimal]\n\n    def get_target_field_type(self) -&gt; Any:\n        return self.target_model.ormar_config.model_fields[self.field_name].__type__\n\n    def get_text_clause(self) -&gt; sqlalchemy.sql.expression.TextClause:\n        alias = f\"{self.table_prefix}_\" if self.table_prefix else \"\"\n        return sqlalchemy.text(f\"{alias}{self.field_name}\")\n\n    def apply_func(\n        self, func: Callable, use_label: bool = True\n    ) -&gt; sqlalchemy.sql.expression.TextClause:\n        result = func(self.get_text_clause())\n        if use_label:\n            rel_prefix = f\"{self.related_str}__\" if self.related_str else \"\"\n            result = result.label(f\"{rel_prefix}{self.field_name}\")\n        return result\n</code></pre>"},{"location":"api/queryset/queries/","title":"queries","text":""},{"location":"api/queryset/queries/#ormar.queryset.queries.FilterQuery","title":"<code>FilterQuery</code>","text":"<p>Modifies the select query with given list of where/filter clauses.</p> Source code in <code>ormar/queryset/queries/filter_query.py</code> <pre><code>class FilterQuery:\n    \"\"\"\n    Modifies the select query with given list of where/filter clauses.\n    \"\"\"\n\n    def __init__(\n        self, filter_clauses: List[FilterAction], exclude: bool = False\n    ) -&gt; None:\n        self.exclude = exclude\n        self.filter_clauses = filter_clauses\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies all filter clauses if set.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.filter_clauses:\n            if len(self.filter_clauses) == 1:\n                clause = self.filter_clauses[0].get_text_clause()\n            else:\n                clause = sqlalchemy.sql.and_(\n                    *[x.get_text_clause() for x in self.filter_clauses]\n                )\n            clause = sqlalchemy.sql.not_(clause) if self.exclude else clause\n            expr = expr.where(clause)\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.FilterQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies all filter clauses if set.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/filter_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies all filter clauses if set.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.filter_clauses:\n        if len(self.filter_clauses) == 1:\n            clause = self.filter_clauses[0].get_text_clause()\n        else:\n            clause = sqlalchemy.sql.and_(\n                *[x.get_text_clause() for x in self.filter_clauses]\n            )\n        clause = sqlalchemy.sql.not_(clause) if self.exclude else clause\n        expr = expr.where(clause)\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.LimitQuery","title":"<code>LimitQuery</code>","text":"<p>Modifies the select query with limit clause.</p> Source code in <code>ormar/queryset/queries/limit_query.py</code> <pre><code>class LimitQuery:\n    \"\"\"\n    Modifies the select query with limit clause.\n    \"\"\"\n\n    def __init__(self, limit_count: Optional[int]) -&gt; None:\n        self.limit_count = limit_count\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies the limit clause.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n\n        if self.limit_count is not None:\n            expr = expr.limit(self.limit_count)\n\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.LimitQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies the limit clause.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/limit_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies the limit clause.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n\n    if self.limit_count is not None:\n        expr = expr.limit(self.limit_count)\n\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.OffsetQuery","title":"<code>OffsetQuery</code>","text":"<p>Modifies the select query with offset if set</p> Source code in <code>ormar/queryset/queries/offset_query.py</code> <pre><code>class OffsetQuery:\n    \"\"\"\n    Modifies the select query with offset if set\n    \"\"\"\n\n    def __init__(self, query_offset: Optional[int]) -&gt; None:\n        self.query_offset = query_offset\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies the offset clause.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.query_offset:\n            expr = expr.offset(self.query_offset)\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.OffsetQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies the offset clause.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/offset_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies the offset clause.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.query_offset:\n        expr = expr.offset(self.query_offset)\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.OrderQuery","title":"<code>OrderQuery</code>","text":"<p>Modifies the select query with given list of order_by clauses.</p> Source code in <code>ormar/queryset/queries/order_query.py</code> <pre><code>class OrderQuery:\n    \"\"\"\n    Modifies the select query with given list of order_by clauses.\n    \"\"\"\n\n    def __init__(self, sorted_orders: Dict) -&gt; None:\n        self.sorted_orders = sorted_orders\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies all order_by clauses if set.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.sorted_orders:\n            for order in list(self.sorted_orders.values()):\n                if order is not None:\n                    expr = expr.order_by(order)\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.OrderQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies all order_by clauses if set.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/order_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies all order_by clauses if set.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.sorted_orders:\n        for order in list(self.sorted_orders.values()):\n            if order is not None:\n                expr = expr.order_by(order)\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.PrefetchQuery","title":"<code>PrefetchQuery</code>","text":"<p>Query used to fetch related models in subsequent queries. Each model is fetched only ones by the name of the relation. That means that for each prefetch_related entry next query is issued to database.</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class PrefetchQuery:\n    \"\"\"\n    Query used to fetch related models in subsequent queries.\n    Each model is fetched only ones by the name of the relation.\n    That means that for each prefetch_related entry next query is issued to database.\n    \"\"\"\n\n    def __init__(  # noqa: CFQ002\n        self,\n        model_cls: Type[\"Model\"],\n        excludable: \"ExcludableItems\",\n        prefetch_related: List,\n        select_related: List,\n        orders_by: List[\"OrderAction\"],\n    ) -&gt; None:\n        self.model = model_cls\n        self.excludable = excludable\n        self.select_dict = translate_list_to_dict(select_related, default={})\n        self.prefetch_dict = translate_list_to_dict(prefetch_related, default={})\n        self.orders_by = orders_by\n        self.load_tasks: List[Node] = []\n\n    async def prefetch_related(self, models: Sequence[\"Model\"]) -&gt; Sequence[\"Model\"]:\n        \"\"\"\n        Main entry point for prefetch_query.\n\n        Receives list of already initialized parent models with all children from\n        select_related already populated. Receives also list of row sql result rows\n        as it's quicker to extract ids that way instead of calling each model.\n\n        Returns list with related models already prefetched and set.\n\n        :param models: list of already instantiated models from main query\n        :type models: Sequence[Model]\n        :param rows: row sql result of the main query before the prefetch\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models with children prefetched\n        :rtype: List[Model]\n        \"\"\"\n        parent_task = RootNode(models=cast(List[\"Model\"], models))\n        self._build_load_tree(\n            prefetch_dict=self.prefetch_dict,\n            select_dict=self.select_dict,\n            parent=parent_task,\n            model=self.model,\n        )\n        await parent_task.load_data()\n        parent_task.reload_tree()\n        return parent_task.models\n\n    def _build_load_tree(\n        self,\n        select_dict: Dict,\n        prefetch_dict: Dict,\n        parent: Node,\n        model: Type[\"Model\"],\n    ) -&gt; None:\n        \"\"\"\n        Build a tree of already loaded nodes and nodes that need\n        to be loaded through the prefetch query.\n\n        :param select_dict: dictionary wth select query structure\n        :type select_dict: Dict\n        :param prefetch_dict: dictionary with prefetch query structure\n        :type prefetch_dict: Dict\n        :param parent: parent Node\n        :type parent: Node\n        :param model: currently processed model\n        :type model: Model\n        \"\"\"\n        for related in prefetch_dict.keys():\n            relation_field = cast(\n                \"ForeignKeyField\", model.ormar_config.model_fields[related]\n            )\n            if related in select_dict:\n                task: Node = AlreadyLoadedNode(\n                    relation_field=relation_field, parent=parent\n                )\n            else:\n                task = LoadNode(\n                    relation_field=relation_field,\n                    excludable=self.excludable,\n                    orders_by=self.orders_by,\n                    parent=parent,\n                    source_model=self.model,\n                )\n            if prefetch_dict:\n                self._build_load_tree(\n                    select_dict=select_dict.get(related, {}),\n                    prefetch_dict=prefetch_dict.get(related, {}),\n                    parent=task,\n                    model=model.ormar_config.model_fields[related].to,\n                )\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.PrefetchQuery.prefetch_related","title":"<code>prefetch_related(models)</code>  <code>async</code>","text":"<p>Main entry point for prefetch_query.</p> <p>Receives list of already initialized parent models with all children from select_related already populated. Receives also list of row sql result rows as it's quicker to extract ids that way instead of calling each model.</p> <p>Returns list with related models already prefetched and set.</p> <p>:param models: list of already instantiated models from main query :type models: Sequence[Model] :param rows: row sql result of the main query before the prefetch :type rows: List[sqlalchemy.engine.result.RowProxy] :return: list of models with children prefetched :rtype: List[Model]</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>async def prefetch_related(self, models: Sequence[\"Model\"]) -&gt; Sequence[\"Model\"]:\n    \"\"\"\n    Main entry point for prefetch_query.\n\n    Receives list of already initialized parent models with all children from\n    select_related already populated. Receives also list of row sql result rows\n    as it's quicker to extract ids that way instead of calling each model.\n\n    Returns list with related models already prefetched and set.\n\n    :param models: list of already instantiated models from main query\n    :type models: Sequence[Model]\n    :param rows: row sql result of the main query before the prefetch\n    :type rows: List[sqlalchemy.engine.result.RowProxy]\n    :return: list of models with children prefetched\n    :rtype: List[Model]\n    \"\"\"\n    parent_task = RootNode(models=cast(List[\"Model\"], models))\n    self._build_load_tree(\n        prefetch_dict=self.prefetch_dict,\n        select_dict=self.select_dict,\n        parent=parent_task,\n        model=self.model,\n    )\n    await parent_task.load_data()\n    parent_task.reload_tree()\n    return parent_task.models\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.Query","title":"<code>Query</code>","text":"Source code in <code>ormar/queryset/queries/query.py</code> <pre><code>class Query:\n    def __init__(  # noqa CFQ002\n        self,\n        model_cls: Type[\"Model\"],\n        filter_clauses: List[FilterAction],\n        exclude_clauses: List[FilterAction],\n        select_related: List,\n        limit_count: Optional[int],\n        offset: Optional[int],\n        excludable: \"ExcludableItems\",\n        order_bys: Optional[List[\"OrderAction\"]],\n        limit_raw_sql: bool,\n    ) -&gt; None:\n        self.query_offset = offset\n        self.limit_count = limit_count\n        self._select_related = select_related[:]\n        self.filter_clauses = filter_clauses[:]\n        self.exclude_clauses = exclude_clauses[:]\n        self.excludable = excludable\n\n        self.model_cls = model_cls\n        self.table = self.model_cls.ormar_config.table\n\n        self.used_aliases: List[str] = []\n\n        self.select_from: Union[Join, Table, List[str]] = []\n        self.columns = [sqlalchemy.Column]\n        self.order_columns = order_bys\n        self.sorted_orders: Dict[OrderAction, text] = {}\n        self._init_sorted_orders()\n\n        self.limit_raw_sql = limit_raw_sql\n\n    def _init_sorted_orders(self) -&gt; None:\n        \"\"\"\n        Initialize empty order_by dict to be populated later during the query call\n        \"\"\"\n        if self.order_columns:\n            for clause in self.order_columns:\n                self.sorted_orders[clause] = None\n\n    def apply_order_bys_for_primary_model(self) -&gt; None:  # noqa: CCR001\n        \"\"\"\n        Applies order_by queries on main model when it's used as a subquery.\n        That way the subquery with limit and offset only on main model has proper\n        sorting applied and correct models are fetched.\n        \"\"\"\n        current_table_sorted = False\n        if self.order_columns:\n            for clause in self.order_columns:\n                if clause.is_source_model_order:\n                    current_table_sorted = True\n                    self.sorted_orders[clause] = clause.get_text_clause()\n\n        if not current_table_sorted:\n            self._apply_default_model_sorting()\n\n    def _apply_default_model_sorting(self) -&gt; None:\n        \"\"\"\n        Applies orders_by from model OrmarConfig (if provided), if it was not provided\n        it was filled by metaclass, so it's always there and falls back to pk column\n        \"\"\"\n        for order_by in self.model_cls.ormar_config.orders_by:\n            clause = ormar.OrderAction(order_str=order_by, model_cls=self.model_cls)\n            self.sorted_orders[clause] = clause.get_text_clause()\n\n    def _pagination_query_required(self) -&gt; bool:\n        \"\"\"\n        Checks if limit or offset are set, the flag limit_sql_raw is not set\n        and query has select_related applied. Otherwise we can limit/offset normally\n        at the end of whole query.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return bool(\n            (self.limit_count or self.query_offset)\n            and not self.limit_raw_sql\n            and self._select_related\n        )\n\n    def build_select_expression(self) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Main entry point from outside (after proper initialization).\n\n        Extracts columns list to fetch,\n        construct all required joins for select related,\n        then applies all conditional and sort clauses.\n\n        Returns ready to run query with all joins and clauses.\n\n        :return: ready to run query with all joins and clauses.\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        self_related_fields = self.model_cls.own_table_columns(\n            model=self.model_cls, excludable=self.excludable, use_alias=True\n        )\n        self.columns = self.model_cls.ormar_config.alias_manager.prefixed_columns(\n            \"\", self.table, self_related_fields\n        )\n        self.apply_order_bys_for_primary_model()\n        self.select_from = self.table\n\n        related_models = group_related_list(self._select_related)\n\n        for related in related_models:\n            remainder = None\n            if isinstance(related_models, dict) and related_models[related]:\n                remainder = related_models[related]\n            sql_join = SqlJoin(\n                used_aliases=self.used_aliases,\n                select_from=self.select_from,\n                columns=self.columns,\n                excludable=self.excludable,\n                order_columns=self.order_columns,\n                sorted_orders=self.sorted_orders,\n                main_model=self.model_cls,\n                relation_name=related,\n                relation_str=related,\n                related_models=remainder,\n            )\n\n            (\n                self.used_aliases,\n                self.select_from,\n                self.columns,\n                self.sorted_orders,\n            ) = sql_join.build_join()\n\n        if self._pagination_query_required():\n            limit_qry, on_clause = self._build_pagination_condition()\n            self.select_from = sqlalchemy.sql.join(\n                self.select_from, limit_qry, on_clause\n            )\n\n        expr = sqlalchemy.sql.select(self.columns)\n        expr = expr.select_from(self.select_from)\n\n        expr = self._apply_expression_modifiers(expr)\n\n        # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n        self._reset_query_parameters()\n\n        return expr\n\n    def _build_pagination_condition(\n        self,\n    ) -&gt; Tuple[\n        sqlalchemy.sql.expression.TextClause, sqlalchemy.sql.expression.TextClause\n    ]:\n        \"\"\"\n        In order to apply limit and offset on main table in join only\n        (otherwise you can get only partially constructed main model\n        if number of children exceeds the applied limit and select_related is used)\n\n        Used also to change first and get() without argument behaviour.\n        Needed only if limit or offset are set, the flag limit_sql_raw is not set\n        and query has select_related applied. Otherwise we can limit/offset normally\n        at the end of whole query.\n\n        The condition is added to filters to filter out desired number of main model\n        primary key values. Whole query is used to determine the values.\n        \"\"\"\n        pk_alias = self.model_cls.get_column_alias(self.model_cls.ormar_config.pkname)\n        pk_aliased_name = f\"{self.table.name}.{pk_alias}\"\n        qry_text = sqlalchemy.text(f\"{pk_aliased_name}\")\n        maxes = {}\n        for order in list(self.sorted_orders.keys()):\n            if order is not None and order.get_field_name_text() != pk_aliased_name:\n                aliased_col = order.get_field_name_text()\n                # maxes[aliased_col] = order.get_text_clause()\n                maxes[aliased_col] = order.get_min_or_max()\n            elif order.get_field_name_text() == pk_aliased_name:\n                maxes[pk_aliased_name] = order.get_text_clause()\n\n        limit_qry = sqlalchemy.sql.select([qry_text])\n        limit_qry = limit_qry.select_from(self.select_from)\n        limit_qry = FilterQuery(filter_clauses=self.filter_clauses).apply(limit_qry)\n        limit_qry = FilterQuery(\n            filter_clauses=self.exclude_clauses, exclude=True\n        ).apply(limit_qry)\n        limit_qry = limit_qry.group_by(qry_text)\n        for order_by in maxes.values():\n            limit_qry = limit_qry.order_by(order_by)\n        limit_qry = LimitQuery(limit_count=self.limit_count).apply(limit_qry)\n        limit_qry = OffsetQuery(query_offset=self.query_offset).apply(limit_qry)\n        limit_qry = limit_qry.alias(\"limit_query\")\n        on_clause = sqlalchemy.text(\n            f\"limit_query.{pk_alias}={self.table.name}.{pk_alias}\"\n        )\n        return limit_qry, on_clause\n\n    def _apply_expression_modifiers(\n        self, expr: sqlalchemy.sql.select\n    ) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Receives the select query (might be join) and applies:\n        * Filter clauses\n        * Exclude filter clauses\n        * Limit clauses\n        * Offset clauses\n        * Order by clauses\n\n        Returns complete ready to run query.\n\n        :param expr: select expression before clauses\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: expression with all present clauses applied\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(expr)\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        if not self._pagination_query_required():\n            expr = LimitQuery(limit_count=self.limit_count).apply(expr)\n            expr = OffsetQuery(query_offset=self.query_offset).apply(expr)\n        expr = OrderQuery(sorted_orders=self.sorted_orders).apply(expr)\n        return expr\n\n    def _reset_query_parameters(self) -&gt; None:\n        \"\"\"\n        Although it should be created each time before the call we reset the key params\n        anyway.\n        \"\"\"\n        self.select_from = []\n        self.columns = []\n        self.used_aliases = []\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.Query.apply_order_bys_for_primary_model","title":"<code>apply_order_bys_for_primary_model()</code>","text":"<p>Applies order_by queries on main model when it's used as a subquery. That way the subquery with limit and offset only on main model has proper sorting applied and correct models are fetched.</p> Source code in <code>ormar/queryset/queries/query.py</code> <pre><code>def apply_order_bys_for_primary_model(self) -&gt; None:  # noqa: CCR001\n    \"\"\"\n    Applies order_by queries on main model when it's used as a subquery.\n    That way the subquery with limit and offset only on main model has proper\n    sorting applied and correct models are fetched.\n    \"\"\"\n    current_table_sorted = False\n    if self.order_columns:\n        for clause in self.order_columns:\n            if clause.is_source_model_order:\n                current_table_sorted = True\n                self.sorted_orders[clause] = clause.get_text_clause()\n\n    if not current_table_sorted:\n        self._apply_default_model_sorting()\n</code></pre>"},{"location":"api/queryset/queries/#ormar.queryset.queries.Query.build_select_expression","title":"<code>build_select_expression()</code>","text":"<p>Main entry point from outside (after proper initialization).</p> <p>Extracts columns list to fetch, construct all required joins for select related, then applies all conditional and sort clauses.</p> <p>Returns ready to run query with all joins and clauses.</p> <p>:return: ready to run query with all joins and clauses. :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/query.py</code> <pre><code>def build_select_expression(self) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Main entry point from outside (after proper initialization).\n\n    Extracts columns list to fetch,\n    construct all required joins for select related,\n    then applies all conditional and sort clauses.\n\n    Returns ready to run query with all joins and clauses.\n\n    :return: ready to run query with all joins and clauses.\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    self_related_fields = self.model_cls.own_table_columns(\n        model=self.model_cls, excludable=self.excludable, use_alias=True\n    )\n    self.columns = self.model_cls.ormar_config.alias_manager.prefixed_columns(\n        \"\", self.table, self_related_fields\n    )\n    self.apply_order_bys_for_primary_model()\n    self.select_from = self.table\n\n    related_models = group_related_list(self._select_related)\n\n    for related in related_models:\n        remainder = None\n        if isinstance(related_models, dict) and related_models[related]:\n            remainder = related_models[related]\n        sql_join = SqlJoin(\n            used_aliases=self.used_aliases,\n            select_from=self.select_from,\n            columns=self.columns,\n            excludable=self.excludable,\n            order_columns=self.order_columns,\n            sorted_orders=self.sorted_orders,\n            main_model=self.model_cls,\n            relation_name=related,\n            relation_str=related,\n            related_models=remainder,\n        )\n\n        (\n            self.used_aliases,\n            self.select_from,\n            self.columns,\n            self.sorted_orders,\n        ) = sql_join.build_join()\n\n    if self._pagination_query_required():\n        limit_qry, on_clause = self._build_pagination_condition()\n        self.select_from = sqlalchemy.sql.join(\n            self.select_from, limit_qry, on_clause\n        )\n\n    expr = sqlalchemy.sql.select(self.columns)\n    expr = expr.select_from(self.select_from)\n\n    expr = self._apply_expression_modifiers(expr)\n\n    # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n    self._reset_query_parameters()\n\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/filter_query/","title":"filter_query","text":""},{"location":"api/queryset/queries/filter_query/#ormar.queryset.queries.filter_query.FilterQuery","title":"<code>FilterQuery</code>","text":"<p>Modifies the select query with given list of where/filter clauses.</p> Source code in <code>ormar/queryset/queries/filter_query.py</code> <pre><code>class FilterQuery:\n    \"\"\"\n    Modifies the select query with given list of where/filter clauses.\n    \"\"\"\n\n    def __init__(\n        self, filter_clauses: List[FilterAction], exclude: bool = False\n    ) -&gt; None:\n        self.exclude = exclude\n        self.filter_clauses = filter_clauses\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies all filter clauses if set.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.filter_clauses:\n            if len(self.filter_clauses) == 1:\n                clause = self.filter_clauses[0].get_text_clause()\n            else:\n                clause = sqlalchemy.sql.and_(\n                    *[x.get_text_clause() for x in self.filter_clauses]\n                )\n            clause = sqlalchemy.sql.not_(clause) if self.exclude else clause\n            expr = expr.where(clause)\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/filter_query/#ormar.queryset.queries.filter_query.FilterQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies all filter clauses if set.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/filter_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies all filter clauses if set.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.filter_clauses:\n        if len(self.filter_clauses) == 1:\n            clause = self.filter_clauses[0].get_text_clause()\n        else:\n            clause = sqlalchemy.sql.and_(\n                *[x.get_text_clause() for x in self.filter_clauses]\n            )\n        clause = sqlalchemy.sql.not_(clause) if self.exclude else clause\n        expr = expr.where(clause)\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/limit_query/","title":"limit_query","text":""},{"location":"api/queryset/queries/limit_query/#ormar.queryset.queries.limit_query.LimitQuery","title":"<code>LimitQuery</code>","text":"<p>Modifies the select query with limit clause.</p> Source code in <code>ormar/queryset/queries/limit_query.py</code> <pre><code>class LimitQuery:\n    \"\"\"\n    Modifies the select query with limit clause.\n    \"\"\"\n\n    def __init__(self, limit_count: Optional[int]) -&gt; None:\n        self.limit_count = limit_count\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies the limit clause.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n\n        if self.limit_count is not None:\n            expr = expr.limit(self.limit_count)\n\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/limit_query/#ormar.queryset.queries.limit_query.LimitQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies the limit clause.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/limit_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies the limit clause.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n\n    if self.limit_count is not None:\n        expr = expr.limit(self.limit_count)\n\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/offset_query/","title":"offset_query","text":""},{"location":"api/queryset/queries/offset_query/#ormar.queryset.queries.offset_query.OffsetQuery","title":"<code>OffsetQuery</code>","text":"<p>Modifies the select query with offset if set</p> Source code in <code>ormar/queryset/queries/offset_query.py</code> <pre><code>class OffsetQuery:\n    \"\"\"\n    Modifies the select query with offset if set\n    \"\"\"\n\n    def __init__(self, query_offset: Optional[int]) -&gt; None:\n        self.query_offset = query_offset\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies the offset clause.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.query_offset:\n            expr = expr.offset(self.query_offset)\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/offset_query/#ormar.queryset.queries.offset_query.OffsetQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies the offset clause.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/offset_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies the offset clause.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.query_offset:\n        expr = expr.offset(self.query_offset)\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/order_query/","title":"order_query","text":""},{"location":"api/queryset/queries/order_query/#ormar.queryset.queries.order_query.OrderQuery","title":"<code>OrderQuery</code>","text":"<p>Modifies the select query with given list of order_by clauses.</p> Source code in <code>ormar/queryset/queries/order_query.py</code> <pre><code>class OrderQuery:\n    \"\"\"\n    Modifies the select query with given list of order_by clauses.\n    \"\"\"\n\n    def __init__(self, sorted_orders: Dict) -&gt; None:\n        self.sorted_orders = sorted_orders\n\n    def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Applies all order_by clauses if set.\n\n        :param expr: query to modify\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: modified query\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        if self.sorted_orders:\n            for order in list(self.sorted_orders.values()):\n                if order is not None:\n                    expr = expr.order_by(order)\n        return expr\n</code></pre>"},{"location":"api/queryset/queries/order_query/#ormar.queryset.queries.order_query.OrderQuery.apply","title":"<code>apply(expr)</code>","text":"<p>Applies all order_by clauses if set.</p> <p>:param expr: query to modify :type expr: sqlalchemy.sql.selectable.Select :return: modified query :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/order_query.py</code> <pre><code>def apply(self, expr: sqlalchemy.sql.select) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Applies all order_by clauses if set.\n\n    :param expr: query to modify\n    :type expr: sqlalchemy.sql.selectable.Select\n    :return: modified query\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    if self.sorted_orders:\n        for order in list(self.sorted_orders.values()):\n            if order is not None:\n                expr = expr.order_by(order)\n    return expr\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/","title":"prefetch_query","text":""},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.AlreadyLoadedNode","title":"<code>AlreadyLoadedNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Node that was already loaded in select statement</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class AlreadyLoadedNode(Node):\n    \"\"\"\n    Node that was already loaded in select statement\n    \"\"\"\n\n    def __init__(self, relation_field: \"ForeignKeyField\", parent: \"Node\") -&gt; None:\n        super().__init__(relation_field=relation_field, parent=parent)\n        self.use_alias = False\n        self._extract_own_models()\n\n    def _extract_own_models(self) -&gt; None:\n        \"\"\"\n        Extract own models that were already fetched and attached to root node\n        \"\"\"\n        for model in self.parent.models:\n            child_models = getattr(model, self.relation_field.name)\n            if isinstance(child_models, list):\n                self.models.extend(child_models)\n            elif child_models:\n                self.models.append(child_models)\n\n    async def load_data(self) -&gt; None:\n        \"\"\"\n        Triggers a data load in the child nodes\n        \"\"\"\n        for child in self.children:\n            await child.load_data()\n\n    def reload_tree(self) -&gt; None:\n        \"\"\"\n        After data was loaded we reload whole tree from the bottom\n        to include freshly loaded nodes\n        \"\"\"\n        for child in self.children:\n            child.reload_tree()\n\n    def extract_related_ids(self, column_name: str) -&gt; List:\n        \"\"\"\n        Extracts the selected column(s) values from own models.\n        Those values are used to construct filter clauses and populate child models.\n\n        :param column_name: names of the column(s) that holds the relation info\n        :type column_name: Union[str, List[str]]\n        :return: List of extracted values of relation columns\n        :rtype: List\n        \"\"\"\n        list_of_ids = UniqueList()\n        for model in self.models:\n            child = getattr(model, column_name)\n            if isinstance(child, ormar.Model):\n                list_of_ids.append(child.pk)\n            elif child is not None:\n                list_of_ids.append(child)\n        return list_of_ids\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.AlreadyLoadedNode.extract_related_ids","title":"<code>extract_related_ids(column_name)</code>","text":"<p>Extracts the selected column(s) values from own models. Those values are used to construct filter clauses and populate child models.</p> <p>:param column_name: names of the column(s) that holds the relation info :type column_name: Union[str, List[str]] :return: List of extracted values of relation columns :rtype: List</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>def extract_related_ids(self, column_name: str) -&gt; List:\n    \"\"\"\n    Extracts the selected column(s) values from own models.\n    Those values are used to construct filter clauses and populate child models.\n\n    :param column_name: names of the column(s) that holds the relation info\n    :type column_name: Union[str, List[str]]\n    :return: List of extracted values of relation columns\n    :rtype: List\n    \"\"\"\n    list_of_ids = UniqueList()\n    for model in self.models:\n        child = getattr(model, column_name)\n        if isinstance(child, ormar.Model):\n            list_of_ids.append(child.pk)\n        elif child is not None:\n            list_of_ids.append(child)\n    return list_of_ids\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.AlreadyLoadedNode.load_data","title":"<code>load_data()</code>  <code>async</code>","text":"<p>Triggers a data load in the child nodes</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>async def load_data(self) -&gt; None:\n    \"\"\"\n    Triggers a data load in the child nodes\n    \"\"\"\n    for child in self.children:\n        await child.load_data()\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.AlreadyLoadedNode.reload_tree","title":"<code>reload_tree()</code>","text":"<p>After data was loaded we reload whole tree from the bottom to include freshly loaded nodes</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>def reload_tree(self) -&gt; None:\n    \"\"\"\n    After data was loaded we reload whole tree from the bottom\n    to include freshly loaded nodes\n    \"\"\"\n    for child in self.children:\n        child.reload_tree()\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.LoadNode","title":"<code>LoadNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Nodes that actually need to be fetched from database in the prefetch query</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class LoadNode(Node):\n    \"\"\"\n    Nodes that actually need to be fetched from database in the prefetch query\n    \"\"\"\n\n    def __init__(\n        self,\n        relation_field: \"ForeignKeyField\",\n        excludable: \"ExcludableItems\",\n        orders_by: List[\"OrderAction\"],\n        parent: \"Node\",\n        source_model: Type[\"Model\"],\n    ) -&gt; None:\n        super().__init__(relation_field=relation_field, parent=parent)\n        self.excludable = excludable\n        self.exclude_prefix: str = \"\"\n        self.orders_by = orders_by\n        self.use_alias = True\n        self.grouped_models: Dict[Any, List[\"Model\"]] = dict()\n        self.source_model = source_model\n\n    async def load_data(self) -&gt; None:\n        \"\"\"\n        Ensures that at least primary key columns from current model are included in\n        the query.\n\n        Gets the filter values from the parent model and runs the query.\n\n        Triggers a data load in child tasks.\n        \"\"\"\n        self._update_excludable_with_related_pks()\n        if self.relation_field.is_multi:\n            query_target = self.relation_field.through\n            select_related = [self.target_name]\n        else:\n            query_target = self.relation_field.to\n            select_related = []\n\n        filter_clauses = self.get_filter_for_prefetch()\n\n        if filter_clauses:\n            qry = Query(\n                model_cls=query_target,\n                select_related=select_related,\n                filter_clauses=filter_clauses,\n                exclude_clauses=[],\n                offset=None,\n                limit_count=None,\n                excludable=self.excludable,\n                order_bys=self._extract_own_order_bys(),\n                limit_raw_sql=False,\n            )\n            expr = qry.build_select_expression()\n            logger.debug(\n                expr.compile(\n                    dialect=self.source_model.ormar_config.database._backend._dialect,\n                    compile_kwargs={\"literal_binds\": True},\n                )\n            )\n            self.rows = await query_target.ormar_config.database.fetch_all(expr)\n\n            for child in self.children:\n                await child.load_data()\n\n    def _update_excludable_with_related_pks(self) -&gt; None:\n        \"\"\"\n        Makes sure that excludable is populated with own model primary keys values\n        if the excludable has the exclude/include clauses\n        \"\"\"\n        related_field_names = self.relation_field.get_related_field_name()\n        alias_manager = self.relation_field.to.ormar_config.alias_manager\n        relation_key = self._build_relation_key()\n        self.exclude_prefix = alias_manager.resolve_relation_alias_after_complex(\n            source_model=self.source_model,\n            relation_str=relation_key,\n            relation_field=self.relation_field,\n        )\n        if self.relation_field.is_multi:\n            self.table_prefix = self.exclude_prefix\n        target_model = self.relation_field.to\n        model_excludable = self.excludable.get(\n            model_cls=target_model, alias=self.exclude_prefix\n        )\n        # includes nested pks if not included already\n        for related_name in related_field_names:\n            if model_excludable.include and not model_excludable.is_included(\n                related_name\n            ):\n                model_excludable.set_values({related_name}, is_exclude=False)\n\n    def _build_relation_string(self) -&gt; str:\n        node: Union[LoadNode, Node] = self\n        relation = node.relation_field.name\n        while not isinstance(node.parent, RootNode):\n            relation = node.parent.relation_field.name + \"__\" + relation\n            node = node.parent\n        return relation\n\n    def _build_relation_key(self) -&gt; str:\n        relation_key = self._build_relation_string()\n        return relation_key\n\n    def _extract_own_order_bys(self) -&gt; List[\"OrderAction\"]:\n        \"\"\"\n        Extracts list of order actions related to current model.\n        Since same model can happen multiple times in a tree we check not only the\n        match on given model but also that path from relation tree matches the\n        path in order action.\n\n        :return: list of order actions related to current model\n        :rtype: List[OrderAction]\n        \"\"\"\n        own_order_bys = []\n        own_path = self._get_full_tree_path()\n        for order_by in self.orders_by:\n            if (\n                order_by.target_model == self.relation_field.to\n                and order_by.related_str.endswith(f\"{own_path}\")\n            ):\n                order_by.is_source_model_order = True\n                order_by.table_prefix = self.table_prefix\n                own_order_bys.append(order_by)\n        return own_order_bys\n\n    def _get_full_tree_path(self) -&gt; str:\n        \"\"\"\n        Iterates the nodes to extract path from root node.\n\n        :return: path from root node\n        :rtype: str\n        \"\"\"\n        node: Node = self\n        relation_str = node.relation_field.name\n        while not isinstance(node.parent, RootNode):\n            node = node.parent\n            relation_str = f\"{node.relation_field.name}__{relation_str}\"\n        return relation_str\n\n    def extract_related_ids(self, column_name: str) -&gt; List:\n        \"\"\"\n        Extracts the selected column(s) values from own models.\n        Those values are used to construct filter clauses and populate child models.\n\n        :param column_names: names of the column(s) that holds the relation info\n        :type column_names: Union[str, List[str]]\n        :return: List of extracted values of relation columns\n        :rtype: List\n        \"\"\"\n        column_name = self._prefix_column_names_with_table_prefix(\n            column_name=column_name\n        )\n        return self._extract_simple_relation_keys(column_name=column_name)\n\n    def _prefix_column_names_with_table_prefix(self, column_name: str) -&gt; str:\n        return (f\"{self.table_prefix}_\" if self.table_prefix else \"\") + column_name\n\n    def _extract_simple_relation_keys(self, column_name: str) -&gt; List:\n        \"\"\"\n        Extracts simple relation keys values.\n\n        :param column_name: names of the column(s) that holds the relation info\n        :type column_name: str\n        :return: List of extracted values of relation columns\n        :rtype: List\n        \"\"\"\n        list_of_ids = UniqueList()\n        for row in self.rows:\n            if row[column_name]:\n                list_of_ids.append(row[column_name])\n        return list_of_ids\n\n    def reload_tree(self) -&gt; None:\n        \"\"\"\n        Instantiates models from loaded database rows.\n        Groups those instances by relation key for easy extract per parent.\n        Triggers same for child nodes and then populates\n        the parent node with own related models\n        \"\"\"\n        if self.rows:\n            self._instantiate_models()\n            self._group_models_by_relation_key()\n            for child in self.children:\n                child.reload_tree()\n            self._populate_parent_models()\n\n    def _instantiate_models(self) -&gt; None:\n        \"\"\"\n        Iterates the rows and initializes instances of ormar.Models.\n        Each model is instantiated only once (they can be duplicates for m2m relation\n        when multiple parent models refer to same child model since the query have to\n        also include the through model - hence full rows are unique, but related\n        models without through models can be not unique).\n        \"\"\"\n        fields_to_exclude = self.relation_field.to.get_names_to_exclude(\n            excludable=self.excludable, alias=self.exclude_prefix\n        )\n        parsed_rows: Dict[Tuple, \"Model\"] = {}\n        for row in self.rows:\n            item = self.relation_field.to.extract_prefixed_table_columns(\n                item={},\n                row=row,\n                table_prefix=self.table_prefix,\n                excludable=self.excludable,\n            )\n            hashable_item = self._hash_item(item)\n            instance = parsed_rows.setdefault(\n                hashable_item,\n                self.relation_field.to(**item, **{\"__excluded__\": fields_to_exclude}),\n            )\n            self.models.append(instance)\n\n    def _hash_item(self, item: Dict) -&gt; Tuple:\n        \"\"\"\n        Converts model dictionary into tuple to make it hashable and allow to use it\n        as a dictionary key - used to ensure unique instances of related models.\n\n        :param item: instance dictionary\n        :type item: Dict\n        :return: tuple out of model dictionary\n        :rtype: Tuple\n        \"\"\"\n        result = []\n        for key, value in sorted(item.items()):\n            result.append(\n                (key, self._hash_item(value) if isinstance(value, dict) else value)\n            )\n        return tuple(result)\n\n    def _group_models_by_relation_key(self) -&gt; None:\n        \"\"\"\n        Groups own models by relation keys so it's easy later to extract those models\n        when iterating parent models. Note that order is important as it reflects\n        order by issued by the user.\n        \"\"\"\n        relation_key = self.relation_field.get_related_field_alias()\n        for index, row in enumerate(self.rows):\n            key = row[relation_key]\n            current_group = self.grouped_models.setdefault(key, [])\n            current_group.append(self.models[index])\n\n    def _populate_parent_models(self) -&gt; None:\n        \"\"\"\n        Populate parent node models with own child models from grouped dictionary\n        \"\"\"\n        relation_key = self._get_relation_key_linking_models()\n        for model in self.parent.models:\n            children = self._get_own_models_related_to_parent(\n                model=model, relation_key=relation_key\n            )\n            for child in children:\n                setattr(model, self.relation_field.name, child)\n\n    def _get_relation_key_linking_models(self) -&gt; Tuple[str, str]:\n        \"\"\"\n        Extract names and aliases of relation columns to use\n        in linking between own models and parent models\n\n        :return: tuple of name and alias of relation columns\n        :rtype: List[Tuple[str, str]]\n        \"\"\"\n        column_name = self.relation_field.get_model_relation_fields(False)\n        column_alias = self.relation_field.get_model_relation_fields(True)\n        return column_name, column_alias\n\n    def _get_own_models_related_to_parent(\n        self, model: \"Model\", relation_key: Tuple[str, str]\n    ) -&gt; List[\"Model\"]:\n        \"\"\"\n        Extracts related column values from parent and based on this key gets the\n        own grouped models.\n\n        :param model: parent model from parent node\n        :type model: Model\n        :param relation_key: name and aliases linking relations\n        :type relation_key: List[Tuple[str, str]]\n        :return: list of own models to set on parent\n        :rtype: List[Model]\n        \"\"\"\n        column_name, column_alias = relation_key\n        model_value = getattr(model, column_name)\n        if isinstance(model_value, ormar.Model):\n            model_value = model_value.pk\n        return self.grouped_models.get(model_value, [])\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.LoadNode.extract_related_ids","title":"<code>extract_related_ids(column_name)</code>","text":"<p>Extracts the selected column(s) values from own models. Those values are used to construct filter clauses and populate child models.</p> <p>:param column_names: names of the column(s) that holds the relation info :type column_names: Union[str, List[str]] :return: List of extracted values of relation columns :rtype: List</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>def extract_related_ids(self, column_name: str) -&gt; List:\n    \"\"\"\n    Extracts the selected column(s) values from own models.\n    Those values are used to construct filter clauses and populate child models.\n\n    :param column_names: names of the column(s) that holds the relation info\n    :type column_names: Union[str, List[str]]\n    :return: List of extracted values of relation columns\n    :rtype: List\n    \"\"\"\n    column_name = self._prefix_column_names_with_table_prefix(\n        column_name=column_name\n    )\n    return self._extract_simple_relation_keys(column_name=column_name)\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.LoadNode.load_data","title":"<code>load_data()</code>  <code>async</code>","text":"<p>Ensures that at least primary key columns from current model are included in the query.</p> <p>Gets the filter values from the parent model and runs the query.</p> <p>Triggers a data load in child tasks.</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>async def load_data(self) -&gt; None:\n    \"\"\"\n    Ensures that at least primary key columns from current model are included in\n    the query.\n\n    Gets the filter values from the parent model and runs the query.\n\n    Triggers a data load in child tasks.\n    \"\"\"\n    self._update_excludable_with_related_pks()\n    if self.relation_field.is_multi:\n        query_target = self.relation_field.through\n        select_related = [self.target_name]\n    else:\n        query_target = self.relation_field.to\n        select_related = []\n\n    filter_clauses = self.get_filter_for_prefetch()\n\n    if filter_clauses:\n        qry = Query(\n            model_cls=query_target,\n            select_related=select_related,\n            filter_clauses=filter_clauses,\n            exclude_clauses=[],\n            offset=None,\n            limit_count=None,\n            excludable=self.excludable,\n            order_bys=self._extract_own_order_bys(),\n            limit_raw_sql=False,\n        )\n        expr = qry.build_select_expression()\n        logger.debug(\n            expr.compile(\n                dialect=self.source_model.ormar_config.database._backend._dialect,\n                compile_kwargs={\"literal_binds\": True},\n            )\n        )\n        self.rows = await query_target.ormar_config.database.fetch_all(expr)\n\n        for child in self.children:\n            await child.load_data()\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.LoadNode.reload_tree","title":"<code>reload_tree()</code>","text":"<p>Instantiates models from loaded database rows. Groups those instances by relation key for easy extract per parent. Triggers same for child nodes and then populates the parent node with own related models</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>def reload_tree(self) -&gt; None:\n    \"\"\"\n    Instantiates models from loaded database rows.\n    Groups those instances by relation key for easy extract per parent.\n    Triggers same for child nodes and then populates\n    the parent node with own related models\n    \"\"\"\n    if self.rows:\n        self._instantiate_models()\n        self._group_models_by_relation_key()\n        for child in self.children:\n            child.reload_tree()\n        self._populate_parent_models()\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base Node use to build a query tree and divide job into already loaded models and the ones that still need to be fetched from database</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class Node(abc.ABC):\n    \"\"\"\n    Base Node use to build a query tree and divide job into already loaded models\n    and the ones that still need to be fetched from database\n    \"\"\"\n\n    def __init__(self, relation_field: \"ForeignKeyField\", parent: \"Node\") -&gt; None:\n        self.parent = parent\n        self.children: List[\"Node\"] = []\n        if self.parent:\n            self.parent.children.append(self)\n        self.relation_field = relation_field\n        self.table_prefix = \"\"\n        self.rows: List = []\n        self.models: List[\"Model\"] = []\n        self.use_alias: bool = False\n\n    @property\n    def target_name(self) -&gt; str:\n        \"\"\"\n        Return the name of the relation that is used to\n        fetch excludes/includes from the excludable mixin\n        as well as specifying the target to join in m2m relations\n\n        :return: name of the relation\n        :rtype: str\n        \"\"\"\n        if (\n            self.relation_field.self_reference\n            and self.relation_field.self_reference_primary == self.relation_field.name\n        ):\n            return self.relation_field.default_source_field_name()\n        else:\n            return self.relation_field.default_target_field_name()\n\n    @abstractmethod\n    def extract_related_ids(self, column_name: str) -&gt; List:  # pragma: no cover\n        pass\n\n    @abstractmethod\n    def reload_tree(self) -&gt; None:  # pragma: no cover\n        pass\n\n    @abstractmethod\n    async def load_data(self) -&gt; None:  # pragma: no cover\n        pass\n\n    def get_filter_for_prefetch(self) -&gt; List[\"FilterAction\"]:\n        \"\"\"\n        Populates where clause with condition to return only models within the\n        set of extracted ids.\n        If there are no ids for relation the empty list is returned.\n\n        :return: list of filter clauses based on original models\n        :rtype: List[sqlalchemy.sql.elements.TextClause]\n        \"\"\"\n        column_name = self.relation_field.get_model_relation_fields(\n            self.parent.use_alias\n        )\n\n        ids = self.parent.extract_related_ids(column_name=column_name)\n\n        if ids:\n            return self._prepare_filter_clauses(ids=ids)\n        return []\n\n    def _prepare_filter_clauses(self, ids: List) -&gt; List[\"FilterAction\"]:\n        \"\"\"\n        Gets the list of ids and construct a list of filter queries on\n        extracted appropriate column names\n\n        :param ids: list of ids that should be used to fetch data\n        :type ids: List\n        :return: list of filter actions to use in query\n        :rtype: List[\"FilterAction\"]\n        \"\"\"\n        clause_target = self.relation_field.get_filter_clause_target()\n        filter_column = self.relation_field.get_related_field_alias()\n        qryclause = QueryClause(\n            model_cls=clause_target,\n            select_related=[],\n            filter_clauses=[],\n        )\n        kwargs = {f\"{cast(str, filter_column)}__in\": ids}\n        filter_clauses, _ = qryclause.prepare_filter(_own_only=False, **kwargs)\n        return filter_clauses\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.Node.target_name","title":"<code>target_name: str</code>  <code>property</code>","text":"<p>Return the name of the relation that is used to fetch excludes/includes from the excludable mixin as well as specifying the target to join in m2m relations</p> <p>:return: name of the relation :rtype: str</p>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.Node.get_filter_for_prefetch","title":"<code>get_filter_for_prefetch()</code>","text":"<p>Populates where clause with condition to return only models within the set of extracted ids. If there are no ids for relation the empty list is returned.</p> <p>:return: list of filter clauses based on original models :rtype: List[sqlalchemy.sql.elements.TextClause]</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>def get_filter_for_prefetch(self) -&gt; List[\"FilterAction\"]:\n    \"\"\"\n    Populates where clause with condition to return only models within the\n    set of extracted ids.\n    If there are no ids for relation the empty list is returned.\n\n    :return: list of filter clauses based on original models\n    :rtype: List[sqlalchemy.sql.elements.TextClause]\n    \"\"\"\n    column_name = self.relation_field.get_model_relation_fields(\n        self.parent.use_alias\n    )\n\n    ids = self.parent.extract_related_ids(column_name=column_name)\n\n    if ids:\n        return self._prepare_filter_clauses(ids=ids)\n    return []\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.PrefetchQuery","title":"<code>PrefetchQuery</code>","text":"<p>Query used to fetch related models in subsequent queries. Each model is fetched only ones by the name of the relation. That means that for each prefetch_related entry next query is issued to database.</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class PrefetchQuery:\n    \"\"\"\n    Query used to fetch related models in subsequent queries.\n    Each model is fetched only ones by the name of the relation.\n    That means that for each prefetch_related entry next query is issued to database.\n    \"\"\"\n\n    def __init__(  # noqa: CFQ002\n        self,\n        model_cls: Type[\"Model\"],\n        excludable: \"ExcludableItems\",\n        prefetch_related: List,\n        select_related: List,\n        orders_by: List[\"OrderAction\"],\n    ) -&gt; None:\n        self.model = model_cls\n        self.excludable = excludable\n        self.select_dict = translate_list_to_dict(select_related, default={})\n        self.prefetch_dict = translate_list_to_dict(prefetch_related, default={})\n        self.orders_by = orders_by\n        self.load_tasks: List[Node] = []\n\n    async def prefetch_related(self, models: Sequence[\"Model\"]) -&gt; Sequence[\"Model\"]:\n        \"\"\"\n        Main entry point for prefetch_query.\n\n        Receives list of already initialized parent models with all children from\n        select_related already populated. Receives also list of row sql result rows\n        as it's quicker to extract ids that way instead of calling each model.\n\n        Returns list with related models already prefetched and set.\n\n        :param models: list of already instantiated models from main query\n        :type models: Sequence[Model]\n        :param rows: row sql result of the main query before the prefetch\n        :type rows: List[sqlalchemy.engine.result.RowProxy]\n        :return: list of models with children prefetched\n        :rtype: List[Model]\n        \"\"\"\n        parent_task = RootNode(models=cast(List[\"Model\"], models))\n        self._build_load_tree(\n            prefetch_dict=self.prefetch_dict,\n            select_dict=self.select_dict,\n            parent=parent_task,\n            model=self.model,\n        )\n        await parent_task.load_data()\n        parent_task.reload_tree()\n        return parent_task.models\n\n    def _build_load_tree(\n        self,\n        select_dict: Dict,\n        prefetch_dict: Dict,\n        parent: Node,\n        model: Type[\"Model\"],\n    ) -&gt; None:\n        \"\"\"\n        Build a tree of already loaded nodes and nodes that need\n        to be loaded through the prefetch query.\n\n        :param select_dict: dictionary wth select query structure\n        :type select_dict: Dict\n        :param prefetch_dict: dictionary with prefetch query structure\n        :type prefetch_dict: Dict\n        :param parent: parent Node\n        :type parent: Node\n        :param model: currently processed model\n        :type model: Model\n        \"\"\"\n        for related in prefetch_dict.keys():\n            relation_field = cast(\n                \"ForeignKeyField\", model.ormar_config.model_fields[related]\n            )\n            if related in select_dict:\n                task: Node = AlreadyLoadedNode(\n                    relation_field=relation_field, parent=parent\n                )\n            else:\n                task = LoadNode(\n                    relation_field=relation_field,\n                    excludable=self.excludable,\n                    orders_by=self.orders_by,\n                    parent=parent,\n                    source_model=self.model,\n                )\n            if prefetch_dict:\n                self._build_load_tree(\n                    select_dict=select_dict.get(related, {}),\n                    prefetch_dict=prefetch_dict.get(related, {}),\n                    parent=task,\n                    model=model.ormar_config.model_fields[related].to,\n                )\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.PrefetchQuery.prefetch_related","title":"<code>prefetch_related(models)</code>  <code>async</code>","text":"<p>Main entry point for prefetch_query.</p> <p>Receives list of already initialized parent models with all children from select_related already populated. Receives also list of row sql result rows as it's quicker to extract ids that way instead of calling each model.</p> <p>Returns list with related models already prefetched and set.</p> <p>:param models: list of already instantiated models from main query :type models: Sequence[Model] :param rows: row sql result of the main query before the prefetch :type rows: List[sqlalchemy.engine.result.RowProxy] :return: list of models with children prefetched :rtype: List[Model]</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>async def prefetch_related(self, models: Sequence[\"Model\"]) -&gt; Sequence[\"Model\"]:\n    \"\"\"\n    Main entry point for prefetch_query.\n\n    Receives list of already initialized parent models with all children from\n    select_related already populated. Receives also list of row sql result rows\n    as it's quicker to extract ids that way instead of calling each model.\n\n    Returns list with related models already prefetched and set.\n\n    :param models: list of already instantiated models from main query\n    :type models: Sequence[Model]\n    :param rows: row sql result of the main query before the prefetch\n    :type rows: List[sqlalchemy.engine.result.RowProxy]\n    :return: list of models with children prefetched\n    :rtype: List[Model]\n    \"\"\"\n    parent_task = RootNode(models=cast(List[\"Model\"], models))\n    self._build_load_tree(\n        prefetch_dict=self.prefetch_dict,\n        select_dict=self.select_dict,\n        parent=parent_task,\n        model=self.model,\n    )\n    await parent_task.load_data()\n    parent_task.reload_tree()\n    return parent_task.models\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.RootNode","title":"<code>RootNode</code>","text":"<p>               Bases: <code>AlreadyLoadedNode</code></p> <p>Root model Node from which both main and prefetch query originated</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class RootNode(AlreadyLoadedNode):\n    \"\"\"\n    Root model Node from which both main and prefetch query originated\n    \"\"\"\n\n    def __init__(self, models: List[\"Model\"]) -&gt; None:\n        self.models = models\n        self.use_alias = False\n        self.children = []\n\n    def reload_tree(self) -&gt; None:\n        for child in self.children:\n            child.reload_tree()\n</code></pre>"},{"location":"api/queryset/queries/prefetch_query/#ormar.queryset.queries.prefetch_query.UniqueList","title":"<code>UniqueList</code>","text":"<p>               Bases: <code>list</code></p> <p>Simple subclass of list that prevents the duplicates Cannot use set as the order is important</p> Source code in <code>ormar/queryset/queries/prefetch_query.py</code> <pre><code>class UniqueList(list):\n    \"\"\"\n    Simple subclass of list that prevents the duplicates\n    Cannot use set as the order is important\n    \"\"\"\n\n    def append(self, item: Any) -&gt; None:\n        if item not in self:\n            super().append(item)\n</code></pre>"},{"location":"api/queryset/queries/query/","title":"query","text":""},{"location":"api/queryset/queries/query/#ormar.queryset.queries.query.Query","title":"<code>Query</code>","text":"Source code in <code>ormar/queryset/queries/query.py</code> <pre><code>class Query:\n    def __init__(  # noqa CFQ002\n        self,\n        model_cls: Type[\"Model\"],\n        filter_clauses: List[FilterAction],\n        exclude_clauses: List[FilterAction],\n        select_related: List,\n        limit_count: Optional[int],\n        offset: Optional[int],\n        excludable: \"ExcludableItems\",\n        order_bys: Optional[List[\"OrderAction\"]],\n        limit_raw_sql: bool,\n    ) -&gt; None:\n        self.query_offset = offset\n        self.limit_count = limit_count\n        self._select_related = select_related[:]\n        self.filter_clauses = filter_clauses[:]\n        self.exclude_clauses = exclude_clauses[:]\n        self.excludable = excludable\n\n        self.model_cls = model_cls\n        self.table = self.model_cls.ormar_config.table\n\n        self.used_aliases: List[str] = []\n\n        self.select_from: Union[Join, Table, List[str]] = []\n        self.columns = [sqlalchemy.Column]\n        self.order_columns = order_bys\n        self.sorted_orders: Dict[OrderAction, text] = {}\n        self._init_sorted_orders()\n\n        self.limit_raw_sql = limit_raw_sql\n\n    def _init_sorted_orders(self) -&gt; None:\n        \"\"\"\n        Initialize empty order_by dict to be populated later during the query call\n        \"\"\"\n        if self.order_columns:\n            for clause in self.order_columns:\n                self.sorted_orders[clause] = None\n\n    def apply_order_bys_for_primary_model(self) -&gt; None:  # noqa: CCR001\n        \"\"\"\n        Applies order_by queries on main model when it's used as a subquery.\n        That way the subquery with limit and offset only on main model has proper\n        sorting applied and correct models are fetched.\n        \"\"\"\n        current_table_sorted = False\n        if self.order_columns:\n            for clause in self.order_columns:\n                if clause.is_source_model_order:\n                    current_table_sorted = True\n                    self.sorted_orders[clause] = clause.get_text_clause()\n\n        if not current_table_sorted:\n            self._apply_default_model_sorting()\n\n    def _apply_default_model_sorting(self) -&gt; None:\n        \"\"\"\n        Applies orders_by from model OrmarConfig (if provided), if it was not provided\n        it was filled by metaclass, so it's always there and falls back to pk column\n        \"\"\"\n        for order_by in self.model_cls.ormar_config.orders_by:\n            clause = ormar.OrderAction(order_str=order_by, model_cls=self.model_cls)\n            self.sorted_orders[clause] = clause.get_text_clause()\n\n    def _pagination_query_required(self) -&gt; bool:\n        \"\"\"\n        Checks if limit or offset are set, the flag limit_sql_raw is not set\n        and query has select_related applied. Otherwise we can limit/offset normally\n        at the end of whole query.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return bool(\n            (self.limit_count or self.query_offset)\n            and not self.limit_raw_sql\n            and self._select_related\n        )\n\n    def build_select_expression(self) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Main entry point from outside (after proper initialization).\n\n        Extracts columns list to fetch,\n        construct all required joins for select related,\n        then applies all conditional and sort clauses.\n\n        Returns ready to run query with all joins and clauses.\n\n        :return: ready to run query with all joins and clauses.\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        self_related_fields = self.model_cls.own_table_columns(\n            model=self.model_cls, excludable=self.excludable, use_alias=True\n        )\n        self.columns = self.model_cls.ormar_config.alias_manager.prefixed_columns(\n            \"\", self.table, self_related_fields\n        )\n        self.apply_order_bys_for_primary_model()\n        self.select_from = self.table\n\n        related_models = group_related_list(self._select_related)\n\n        for related in related_models:\n            remainder = None\n            if isinstance(related_models, dict) and related_models[related]:\n                remainder = related_models[related]\n            sql_join = SqlJoin(\n                used_aliases=self.used_aliases,\n                select_from=self.select_from,\n                columns=self.columns,\n                excludable=self.excludable,\n                order_columns=self.order_columns,\n                sorted_orders=self.sorted_orders,\n                main_model=self.model_cls,\n                relation_name=related,\n                relation_str=related,\n                related_models=remainder,\n            )\n\n            (\n                self.used_aliases,\n                self.select_from,\n                self.columns,\n                self.sorted_orders,\n            ) = sql_join.build_join()\n\n        if self._pagination_query_required():\n            limit_qry, on_clause = self._build_pagination_condition()\n            self.select_from = sqlalchemy.sql.join(\n                self.select_from, limit_qry, on_clause\n            )\n\n        expr = sqlalchemy.sql.select(self.columns)\n        expr = expr.select_from(self.select_from)\n\n        expr = self._apply_expression_modifiers(expr)\n\n        # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n        self._reset_query_parameters()\n\n        return expr\n\n    def _build_pagination_condition(\n        self,\n    ) -&gt; Tuple[\n        sqlalchemy.sql.expression.TextClause, sqlalchemy.sql.expression.TextClause\n    ]:\n        \"\"\"\n        In order to apply limit and offset on main table in join only\n        (otherwise you can get only partially constructed main model\n        if number of children exceeds the applied limit and select_related is used)\n\n        Used also to change first and get() without argument behaviour.\n        Needed only if limit or offset are set, the flag limit_sql_raw is not set\n        and query has select_related applied. Otherwise we can limit/offset normally\n        at the end of whole query.\n\n        The condition is added to filters to filter out desired number of main model\n        primary key values. Whole query is used to determine the values.\n        \"\"\"\n        pk_alias = self.model_cls.get_column_alias(self.model_cls.ormar_config.pkname)\n        pk_aliased_name = f\"{self.table.name}.{pk_alias}\"\n        qry_text = sqlalchemy.text(f\"{pk_aliased_name}\")\n        maxes = {}\n        for order in list(self.sorted_orders.keys()):\n            if order is not None and order.get_field_name_text() != pk_aliased_name:\n                aliased_col = order.get_field_name_text()\n                # maxes[aliased_col] = order.get_text_clause()\n                maxes[aliased_col] = order.get_min_or_max()\n            elif order.get_field_name_text() == pk_aliased_name:\n                maxes[pk_aliased_name] = order.get_text_clause()\n\n        limit_qry = sqlalchemy.sql.select([qry_text])\n        limit_qry = limit_qry.select_from(self.select_from)\n        limit_qry = FilterQuery(filter_clauses=self.filter_clauses).apply(limit_qry)\n        limit_qry = FilterQuery(\n            filter_clauses=self.exclude_clauses, exclude=True\n        ).apply(limit_qry)\n        limit_qry = limit_qry.group_by(qry_text)\n        for order_by in maxes.values():\n            limit_qry = limit_qry.order_by(order_by)\n        limit_qry = LimitQuery(limit_count=self.limit_count).apply(limit_qry)\n        limit_qry = OffsetQuery(query_offset=self.query_offset).apply(limit_qry)\n        limit_qry = limit_qry.alias(\"limit_query\")\n        on_clause = sqlalchemy.text(\n            f\"limit_query.{pk_alias}={self.table.name}.{pk_alias}\"\n        )\n        return limit_qry, on_clause\n\n    def _apply_expression_modifiers(\n        self, expr: sqlalchemy.sql.select\n    ) -&gt; sqlalchemy.sql.select:\n        \"\"\"\n        Receives the select query (might be join) and applies:\n        * Filter clauses\n        * Exclude filter clauses\n        * Limit clauses\n        * Offset clauses\n        * Order by clauses\n\n        Returns complete ready to run query.\n\n        :param expr: select expression before clauses\n        :type expr: sqlalchemy.sql.selectable.Select\n        :return: expression with all present clauses applied\n        :rtype: sqlalchemy.sql.selectable.Select\n        \"\"\"\n        expr = FilterQuery(filter_clauses=self.filter_clauses).apply(expr)\n        expr = FilterQuery(filter_clauses=self.exclude_clauses, exclude=True).apply(\n            expr\n        )\n        if not self._pagination_query_required():\n            expr = LimitQuery(limit_count=self.limit_count).apply(expr)\n            expr = OffsetQuery(query_offset=self.query_offset).apply(expr)\n        expr = OrderQuery(sorted_orders=self.sorted_orders).apply(expr)\n        return expr\n\n    def _reset_query_parameters(self) -&gt; None:\n        \"\"\"\n        Although it should be created each time before the call we reset the key params\n        anyway.\n        \"\"\"\n        self.select_from = []\n        self.columns = []\n        self.used_aliases = []\n</code></pre>"},{"location":"api/queryset/queries/query/#ormar.queryset.queries.query.Query.apply_order_bys_for_primary_model","title":"<code>apply_order_bys_for_primary_model()</code>","text":"<p>Applies order_by queries on main model when it's used as a subquery. That way the subquery with limit and offset only on main model has proper sorting applied and correct models are fetched.</p> Source code in <code>ormar/queryset/queries/query.py</code> <pre><code>def apply_order_bys_for_primary_model(self) -&gt; None:  # noqa: CCR001\n    \"\"\"\n    Applies order_by queries on main model when it's used as a subquery.\n    That way the subquery with limit and offset only on main model has proper\n    sorting applied and correct models are fetched.\n    \"\"\"\n    current_table_sorted = False\n    if self.order_columns:\n        for clause in self.order_columns:\n            if clause.is_source_model_order:\n                current_table_sorted = True\n                self.sorted_orders[clause] = clause.get_text_clause()\n\n    if not current_table_sorted:\n        self._apply_default_model_sorting()\n</code></pre>"},{"location":"api/queryset/queries/query/#ormar.queryset.queries.query.Query.build_select_expression","title":"<code>build_select_expression()</code>","text":"<p>Main entry point from outside (after proper initialization).</p> <p>Extracts columns list to fetch, construct all required joins for select related, then applies all conditional and sort clauses.</p> <p>Returns ready to run query with all joins and clauses.</p> <p>:return: ready to run query with all joins and clauses. :rtype: sqlalchemy.sql.selectable.Select</p> Source code in <code>ormar/queryset/queries/query.py</code> <pre><code>def build_select_expression(self) -&gt; sqlalchemy.sql.select:\n    \"\"\"\n    Main entry point from outside (after proper initialization).\n\n    Extracts columns list to fetch,\n    construct all required joins for select related,\n    then applies all conditional and sort clauses.\n\n    Returns ready to run query with all joins and clauses.\n\n    :return: ready to run query with all joins and clauses.\n    :rtype: sqlalchemy.sql.selectable.Select\n    \"\"\"\n    self_related_fields = self.model_cls.own_table_columns(\n        model=self.model_cls, excludable=self.excludable, use_alias=True\n    )\n    self.columns = self.model_cls.ormar_config.alias_manager.prefixed_columns(\n        \"\", self.table, self_related_fields\n    )\n    self.apply_order_bys_for_primary_model()\n    self.select_from = self.table\n\n    related_models = group_related_list(self._select_related)\n\n    for related in related_models:\n        remainder = None\n        if isinstance(related_models, dict) and related_models[related]:\n            remainder = related_models[related]\n        sql_join = SqlJoin(\n            used_aliases=self.used_aliases,\n            select_from=self.select_from,\n            columns=self.columns,\n            excludable=self.excludable,\n            order_columns=self.order_columns,\n            sorted_orders=self.sorted_orders,\n            main_model=self.model_cls,\n            relation_name=related,\n            relation_str=related,\n            related_models=remainder,\n        )\n\n        (\n            self.used_aliases,\n            self.select_from,\n            self.columns,\n            self.sorted_orders,\n        ) = sql_join.build_join()\n\n    if self._pagination_query_required():\n        limit_qry, on_clause = self._build_pagination_condition()\n        self.select_from = sqlalchemy.sql.join(\n            self.select_from, limit_qry, on_clause\n        )\n\n    expr = sqlalchemy.sql.select(self.columns)\n    expr = expr.select_from(self.select_from)\n\n    expr = self._apply_expression_modifiers(expr)\n\n    # print(\"\\n\", expr.compile(compile_kwargs={\"literal_binds\": True}))\n    self._reset_query_parameters()\n\n    return expr\n</code></pre>"},{"location":"api/relations/","title":"relations","text":"<p>Package handles relations on models, returning related models on calls and exposing QuerySetProxy for m2m and reverse relations.</p>"},{"location":"api/relations/#ormar.relations.AliasManager","title":"<code>AliasManager</code>","text":"<p>Keep all aliases of relations between different tables. One global instance is shared between all models.</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>class AliasManager:\n    \"\"\"\n    Keep all aliases of relations between different tables.\n    One global instance is shared between all models.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._aliases_new: Dict[str, str] = dict()\n        self._reversed_aliases: Dict[str, str] = dict()\n        self._prefixed_tables: Dict[str, text] = dict()\n\n    def __contains__(self, item: str) -&gt; bool:\n        return self._aliases_new.__contains__(item)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self._aliases_new.__getitem__(key)\n\n    @property\n    def reversed_aliases(self) -&gt; Dict:\n        \"\"\"\n        Returns swapped key-value pairs from aliases where alias is the key.\n\n        :return: dictionary of prefix to relation\n        :rtype: Dict\n        \"\"\"\n        if self._reversed_aliases:\n            return self._reversed_aliases\n        reversed_aliases = {v: k for k, v in self._aliases_new.items()}\n        self._reversed_aliases = reversed_aliases\n        return self._reversed_aliases\n\n    @staticmethod\n    def prefixed_columns(\n        alias: str, table: sqlalchemy.Table, fields: Optional[List] = None\n    ) -&gt; List[text]:\n        \"\"\"\n        Creates a list of aliases sqlalchemy text clauses from\n        string alias and sqlalchemy.Table.\n\n        Optional list of fields to include can be passed to extract only those columns.\n        List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones.\n\n        :param alias: alias of given table\n        :type alias: str\n        :param table: table from which fields should be aliased\n        :type table: sqlalchemy.Table\n        :param fields: fields to include\n        :type fields: Optional[List[str]]\n        :return: list of sqlalchemy text clauses with \"column name as aliased name\"\n        :rtype: List[text]\n        \"\"\"\n        alias = f\"{alias}_\" if alias else \"\"\n        aliased_fields = [f\"{alias}{x}\" for x in fields] if fields else []\n        all_columns = (\n            table.columns\n            if not fields\n            else [\n                col\n                for col in table.columns\n                if col.name in fields or col.name in aliased_fields\n            ]\n        )\n        return [column.label(f\"{alias}{column.name}\") for column in all_columns]\n\n    def prefixed_table_name(self, alias: str, table: sqlalchemy.Table) -&gt; text:\n        \"\"\"\n        Creates text clause with table name with aliased name.\n\n        :param alias: alias of given table\n        :type alias: str\n        :param table: table\n        :type table: sqlalchemy.Table\n        :return: sqlalchemy text clause as \"table_name aliased_name\"\n        :rtype: sqlalchemy text clause\n        \"\"\"\n        full_alias = f\"{alias}_{table.name}\"\n        key = f\"{full_alias}_{id(table)}\"\n        return self._prefixed_tables.setdefault(key, table.alias(full_alias))\n\n    def add_relation_type(\n        self,\n        source_model: Type[\"Model\"],\n        relation_name: str,\n        reverse_name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Registers the relations defined in ormar models.\n        Given the relation it registers also the reverse side of this relation.\n\n        Used by both ForeignKey and ManyToMany relations.\n\n        Each relation is registered as Model name and relation name.\n        Each alias registered has to be unique.\n\n        Aliases are used to construct joins to assure proper links between tables.\n        That way you can link to the same target tables from multiple fields\n        on one model as well as from multiple different models in one join.\n\n        :param source_model: model with relation defined\n        :type source_model: source Model\n        :param relation_name: name of the relation to define\n        :type relation_name: str\n        :param reverse_name: name of related_name fo given relation for m2m relations\n        :type reverse_name: Optional[str]\n        :return: none\n        :rtype: None\n        \"\"\"\n        parent_key = f\"{source_model.get_name()}_{relation_name}\"\n        if parent_key not in self._aliases_new:\n            self.add_alias(parent_key)\n\n        to_field = source_model.ormar_config.model_fields[relation_name]\n        child_model = to_field.to\n        child_key = f\"{child_model.get_name()}_{reverse_name}\"\n        if child_key not in self._aliases_new:\n            self.add_alias(child_key)\n\n    def add_alias(self, alias_key: str) -&gt; str:\n        \"\"\"\n        Adds alias to the dictionary of aliases under given key.\n\n        :param alias_key: key of relation to generate alias for\n        :type alias_key: str\n        :return: generated alias\n        :rtype: str\n        \"\"\"\n        alias = get_table_alias()\n        self._aliases_new[alias_key] = alias\n        return alias\n\n    def resolve_relation_alias(\n        self, from_model: Union[Type[\"Model\"], Type[\"ModelRow\"]], relation_name: str\n    ) -&gt; str:\n        \"\"\"\n        Given model and relation name returns the alias for this relation.\n\n        :param from_model: model with relation defined\n        :type from_model: source Model\n        :param relation_name: name of the relation field\n        :type relation_name: str\n        :return: alias of the relation\n        :rtype: str\n        \"\"\"\n        alias = self._aliases_new.get(f\"{from_model.get_name()}_{relation_name}\", \"\")\n        return alias\n\n    def resolve_relation_alias_after_complex(\n        self,\n        source_model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n        relation_str: str,\n        relation_field: \"ForeignKeyField\",\n    ) -&gt; str:\n        \"\"\"\n        Given source model and relation string returns the alias for this complex\n        relation if it exists, otherwise fallback to normal relation from a relation\n        field definition.\n\n        :param relation_field: field with direct relation definition\n        :type relation_field: \"ForeignKeyField\"\n        :param source_model: model with query starts\n        :type source_model: source Model\n        :param relation_str: string with relation joins defined\n        :type relation_str: str\n        :return: alias of the relation\n        :rtype: str\n        \"\"\"\n        alias = \"\"\n        if relation_str and \"__\" in relation_str:\n            alias = self.resolve_relation_alias(\n                from_model=source_model, relation_name=relation_str\n            )\n        if not alias:\n            alias = self.resolve_relation_alias(\n                from_model=relation_field.get_source_model(),\n                relation_name=relation_field.get_relation_name(),\n            )\n        return alias\n</code></pre>"},{"location":"api/relations/#ormar.relations.AliasManager.reversed_aliases","title":"<code>reversed_aliases: Dict</code>  <code>property</code>","text":"<p>Returns swapped key-value pairs from aliases where alias is the key.</p> <p>:return: dictionary of prefix to relation :rtype: Dict</p>"},{"location":"api/relations/#ormar.relations.AliasManager.add_alias","title":"<code>add_alias(alias_key)</code>","text":"<p>Adds alias to the dictionary of aliases under given key.</p> <p>:param alias_key: key of relation to generate alias for :type alias_key: str :return: generated alias :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def add_alias(self, alias_key: str) -&gt; str:\n    \"\"\"\n    Adds alias to the dictionary of aliases under given key.\n\n    :param alias_key: key of relation to generate alias for\n    :type alias_key: str\n    :return: generated alias\n    :rtype: str\n    \"\"\"\n    alias = get_table_alias()\n    self._aliases_new[alias_key] = alias\n    return alias\n</code></pre>"},{"location":"api/relations/#ormar.relations.AliasManager.add_relation_type","title":"<code>add_relation_type(source_model, relation_name, reverse_name=None)</code>","text":"<p>Registers the relations defined in ormar models. Given the relation it registers also the reverse side of this relation.</p> <p>Used by both ForeignKey and ManyToMany relations.</p> <p>Each relation is registered as Model name and relation name. Each alias registered has to be unique.</p> <p>Aliases are used to construct joins to assure proper links between tables. That way you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join.</p> <p>:param source_model: model with relation defined :type source_model: source Model :param relation_name: name of the relation to define :type relation_name: str :param reverse_name: name of related_name fo given relation for m2m relations :type reverse_name: Optional[str] :return: none :rtype: None</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def add_relation_type(\n    self,\n    source_model: Type[\"Model\"],\n    relation_name: str,\n    reverse_name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Registers the relations defined in ormar models.\n    Given the relation it registers also the reverse side of this relation.\n\n    Used by both ForeignKey and ManyToMany relations.\n\n    Each relation is registered as Model name and relation name.\n    Each alias registered has to be unique.\n\n    Aliases are used to construct joins to assure proper links between tables.\n    That way you can link to the same target tables from multiple fields\n    on one model as well as from multiple different models in one join.\n\n    :param source_model: model with relation defined\n    :type source_model: source Model\n    :param relation_name: name of the relation to define\n    :type relation_name: str\n    :param reverse_name: name of related_name fo given relation for m2m relations\n    :type reverse_name: Optional[str]\n    :return: none\n    :rtype: None\n    \"\"\"\n    parent_key = f\"{source_model.get_name()}_{relation_name}\"\n    if parent_key not in self._aliases_new:\n        self.add_alias(parent_key)\n\n    to_field = source_model.ormar_config.model_fields[relation_name]\n    child_model = to_field.to\n    child_key = f\"{child_model.get_name()}_{reverse_name}\"\n    if child_key not in self._aliases_new:\n        self.add_alias(child_key)\n</code></pre>"},{"location":"api/relations/#ormar.relations.AliasManager.prefixed_columns","title":"<code>prefixed_columns(alias, table, fields=None)</code>  <code>staticmethod</code>","text":"<p>Creates a list of aliases sqlalchemy text clauses from string alias and sqlalchemy.Table.</p> <p>Optional list of fields to include can be passed to extract only those columns. List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones.</p> <p>:param alias: alias of given table :type alias: str :param table: table from which fields should be aliased :type table: sqlalchemy.Table :param fields: fields to include :type fields: Optional[List[str]] :return: list of sqlalchemy text clauses with \"column name as aliased name\" :rtype: List[text]</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>@staticmethod\ndef prefixed_columns(\n    alias: str, table: sqlalchemy.Table, fields: Optional[List] = None\n) -&gt; List[text]:\n    \"\"\"\n    Creates a list of aliases sqlalchemy text clauses from\n    string alias and sqlalchemy.Table.\n\n    Optional list of fields to include can be passed to extract only those columns.\n    List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones.\n\n    :param alias: alias of given table\n    :type alias: str\n    :param table: table from which fields should be aliased\n    :type table: sqlalchemy.Table\n    :param fields: fields to include\n    :type fields: Optional[List[str]]\n    :return: list of sqlalchemy text clauses with \"column name as aliased name\"\n    :rtype: List[text]\n    \"\"\"\n    alias = f\"{alias}_\" if alias else \"\"\n    aliased_fields = [f\"{alias}{x}\" for x in fields] if fields else []\n    all_columns = (\n        table.columns\n        if not fields\n        else [\n            col\n            for col in table.columns\n            if col.name in fields or col.name in aliased_fields\n        ]\n    )\n    return [column.label(f\"{alias}{column.name}\") for column in all_columns]\n</code></pre>"},{"location":"api/relations/#ormar.relations.AliasManager.prefixed_table_name","title":"<code>prefixed_table_name(alias, table)</code>","text":"<p>Creates text clause with table name with aliased name.</p> <p>:param alias: alias of given table :type alias: str :param table: table :type table: sqlalchemy.Table :return: sqlalchemy text clause as \"table_name aliased_name\" :rtype: sqlalchemy text clause</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def prefixed_table_name(self, alias: str, table: sqlalchemy.Table) -&gt; text:\n    \"\"\"\n    Creates text clause with table name with aliased name.\n\n    :param alias: alias of given table\n    :type alias: str\n    :param table: table\n    :type table: sqlalchemy.Table\n    :return: sqlalchemy text clause as \"table_name aliased_name\"\n    :rtype: sqlalchemy text clause\n    \"\"\"\n    full_alias = f\"{alias}_{table.name}\"\n    key = f\"{full_alias}_{id(table)}\"\n    return self._prefixed_tables.setdefault(key, table.alias(full_alias))\n</code></pre>"},{"location":"api/relations/#ormar.relations.AliasManager.resolve_relation_alias","title":"<code>resolve_relation_alias(from_model, relation_name)</code>","text":"<p>Given model and relation name returns the alias for this relation.</p> <p>:param from_model: model with relation defined :type from_model: source Model :param relation_name: name of the relation field :type relation_name: str :return: alias of the relation :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def resolve_relation_alias(\n    self, from_model: Union[Type[\"Model\"], Type[\"ModelRow\"]], relation_name: str\n) -&gt; str:\n    \"\"\"\n    Given model and relation name returns the alias for this relation.\n\n    :param from_model: model with relation defined\n    :type from_model: source Model\n    :param relation_name: name of the relation field\n    :type relation_name: str\n    :return: alias of the relation\n    :rtype: str\n    \"\"\"\n    alias = self._aliases_new.get(f\"{from_model.get_name()}_{relation_name}\", \"\")\n    return alias\n</code></pre>"},{"location":"api/relations/#ormar.relations.AliasManager.resolve_relation_alias_after_complex","title":"<code>resolve_relation_alias_after_complex(source_model, relation_str, relation_field)</code>","text":"<p>Given source model and relation string returns the alias for this complex relation if it exists, otherwise fallback to normal relation from a relation field definition.</p> <p>:param relation_field: field with direct relation definition :type relation_field: \"ForeignKeyField\" :param source_model: model with query starts :type source_model: source Model :param relation_str: string with relation joins defined :type relation_str: str :return: alias of the relation :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def resolve_relation_alias_after_complex(\n    self,\n    source_model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n    relation_str: str,\n    relation_field: \"ForeignKeyField\",\n) -&gt; str:\n    \"\"\"\n    Given source model and relation string returns the alias for this complex\n    relation if it exists, otherwise fallback to normal relation from a relation\n    field definition.\n\n    :param relation_field: field with direct relation definition\n    :type relation_field: \"ForeignKeyField\"\n    :param source_model: model with query starts\n    :type source_model: source Model\n    :param relation_str: string with relation joins defined\n    :type relation_str: str\n    :return: alias of the relation\n    :rtype: str\n    \"\"\"\n    alias = \"\"\n    if relation_str and \"__\" in relation_str:\n        alias = self.resolve_relation_alias(\n            from_model=source_model, relation_name=relation_str\n        )\n    if not alias:\n        alias = self.resolve_relation_alias(\n            from_model=relation_field.get_source_model(),\n            relation_name=relation_field.get_relation_name(),\n        )\n    return alias\n</code></pre>"},{"location":"api/relations/#ormar.relations.Relation","title":"<code>Relation</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Keeps related Models and handles adding/removing of the children.</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>class Relation(Generic[T]):\n    \"\"\"\n    Keeps related Models and handles adding/removing of the children.\n    \"\"\"\n\n    def __init__(\n        self,\n        manager: \"RelationsManager\",\n        type_: RelationType,\n        field_name: str,\n        to: Type[\"T\"],\n        through: Optional[Type[\"Model\"]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Relation and keep the related models either as instances of\n        passed Model, or as a RelationProxy which is basically a list of models with\n        some special behavior, as it exposes QuerySetProxy and allows querying the\n        related models already pre filtered by parent model.\n\n        :param manager: reference to relation manager\n        :type manager: RelationsManager\n        :param type_: type of the relation\n        :type type_: RelationType\n        :param field_name: name of the relation field\n        :type field_name: str\n        :param to: model to which relation leads to\n        :type to: Type[Model]\n        :param through: model through which relation goes for m2m relations\n        :type through: Type[Model]\n        \"\"\"\n        self.manager = manager\n        self._owner: \"Model\" = manager.owner\n        self._type: RelationType = type_\n        self._to_remove: Set = set()\n        self.to: Type[\"T\"] = to\n        self._through = through\n        self.field_name: str = field_name\n        self.related_models: Optional[Union[RelationProxy, \"Model\"]] = (\n            RelationProxy(relation=self, type_=type_, to=to, field_name=field_name)\n            if type_ in (RelationType.REVERSE, RelationType.MULTIPLE)\n            else None\n        )\n\n    def clear(self) -&gt; None:\n        if self._type in (RelationType.PRIMARY, RelationType.THROUGH):\n            self.related_models = None\n            self._owner.__dict__[self.field_name] = None\n        elif self.related_models is not None:\n            related_models = cast(\"RelationProxy\", self.related_models)\n            related_models._clear()\n            self._owner.__dict__[self.field_name] = None\n\n    @property\n    def through(self) -&gt; Type[\"Model\"]:\n        if not self._through:  # pragma: no cover\n            raise RelationshipInstanceError(\"Relation does not have through model!\")\n        return self._through\n\n    def _clean_related(self) -&gt; None:\n        \"\"\"\n        Removes dead weakrefs from RelationProxy.\n        \"\"\"\n        cleaned_data = [\n            x\n            for i, x in enumerate(self.related_models)  # type: ignore\n            if i not in self._to_remove\n        ]\n        self.related_models = RelationProxy(\n            relation=self,\n            type_=self._type,\n            to=self.to,\n            field_name=self.field_name,\n            data_=cleaned_data,\n        )\n        relation_name = self.field_name\n        self._owner.__dict__[relation_name] = cleaned_data\n        self._to_remove = set()\n\n    def _find_existing(\n        self, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]\n    ) -&gt; Optional[int]:\n        \"\"\"\n        Find child model in RelationProxy if exists.\n\n        :param child: child model to find\n        :type child: Model\n        :return: index of child in RelationProxy\n        :rtype: Optional[ind]\n        \"\"\"\n        if not isinstance(self.related_models, RelationProxy):  # pragma nocover\n            raise ValueError(\"Cannot find existing models in parent relation type\")\n\n        if child not in self.related_models:\n            return None\n        else:\n            # We need to clear the weakrefs that don't point to anything anymore\n            # There's an assumption here that if some of the related models\n            # went out of scope, then they all did, so we can just check the first one\n            try:\n                self.related_models[0].__repr__.__self__\n                return self.related_models.index(child)\n            except ReferenceError:\n                missing = self.related_models._get_list_of_missing_weakrefs()\n                self._to_remove.update(missing)\n            return self.related_models.index(child)\n\n    def add(self, child: \"Model\") -&gt; None:\n        \"\"\"\n        Adds child Model to relation, either sets child as related model or adds\n        it to the list in RelationProxy depending on relation type.\n\n        :param child: model to add to relation\n        :type child: Model\n        \"\"\"\n        relation_name = self.field_name\n        if self._type in (RelationType.PRIMARY, RelationType.THROUGH):\n            self.related_models = child\n            self._owner.__dict__[relation_name] = child\n        else:\n            if self._find_existing(child) is None:\n                self.related_models.append(child)  # type: ignore\n                rel = self._owner.__dict__.get(relation_name, [])\n                rel = rel or []\n                if not isinstance(rel, list):\n                    rel = [rel]\n                self._populate_owner_side_dict(rel=rel, child=child)\n                self._owner.__dict__[relation_name] = rel\n\n    def _populate_owner_side_dict(self, rel: List[\"Model\"], child: \"Model\") -&gt; None:\n        try:\n            if child not in rel:\n                rel.append(child)\n        except ReferenceError:\n            rel.clear()\n            rel.append(child)\n\n    def remove(self, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]) -&gt; None:\n        \"\"\"\n        Removes child Model from relation, either sets None as related model or removes\n        it from the list in RelationProxy depending on relation type.\n\n        :param child: model to remove from relation\n        :type child: Model\n        \"\"\"\n        relation_name = self.field_name\n        if self._type == RelationType.PRIMARY:\n            if self.related_models == child:\n                self.related_models = None\n                del self._owner.__dict__[relation_name]\n        else:\n            position = self._find_existing(child)\n            if position is not None:\n                self.related_models.pop(position)  # type: ignore\n                del self._owner.__dict__[relation_name][position]\n\n    def get(self) -&gt; Optional[Union[List[\"Model\"], \"Model\"]]:\n        \"\"\"\n        Return the related model or models from RelationProxy.\n\n        :return: related model/models if set\n        :rtype: Optional[Union[List[Model], Model]]\n        \"\"\"\n        if self._to_remove:\n            self._clean_related()\n        return self.related_models\n\n    def __repr__(self) -&gt; str:  # pragma no cover\n        if self._to_remove:\n            self._clean_related()\n        return str(self.related_models)\n</code></pre>"},{"location":"api/relations/#ormar.relations.Relation.__init__","title":"<code>__init__(manager, type_, field_name, to, through=None)</code>","text":"<p>Initialize the Relation and keep the related models either as instances of passed Model, or as a RelationProxy which is basically a list of models with some special behavior, as it exposes QuerySetProxy and allows querying the related models already pre filtered by parent model.</p> <p>:param manager: reference to relation manager :type manager: RelationsManager :param type_: type of the relation :type type_: RelationType :param field_name: name of the relation field :type field_name: str :param to: model to which relation leads to :type to: Type[Model] :param through: model through which relation goes for m2m relations :type through: Type[Model]</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def __init__(\n    self,\n    manager: \"RelationsManager\",\n    type_: RelationType,\n    field_name: str,\n    to: Type[\"T\"],\n    through: Optional[Type[\"Model\"]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Relation and keep the related models either as instances of\n    passed Model, or as a RelationProxy which is basically a list of models with\n    some special behavior, as it exposes QuerySetProxy and allows querying the\n    related models already pre filtered by parent model.\n\n    :param manager: reference to relation manager\n    :type manager: RelationsManager\n    :param type_: type of the relation\n    :type type_: RelationType\n    :param field_name: name of the relation field\n    :type field_name: str\n    :param to: model to which relation leads to\n    :type to: Type[Model]\n    :param through: model through which relation goes for m2m relations\n    :type through: Type[Model]\n    \"\"\"\n    self.manager = manager\n    self._owner: \"Model\" = manager.owner\n    self._type: RelationType = type_\n    self._to_remove: Set = set()\n    self.to: Type[\"T\"] = to\n    self._through = through\n    self.field_name: str = field_name\n    self.related_models: Optional[Union[RelationProxy, \"Model\"]] = (\n        RelationProxy(relation=self, type_=type_, to=to, field_name=field_name)\n        if type_ in (RelationType.REVERSE, RelationType.MULTIPLE)\n        else None\n    )\n</code></pre>"},{"location":"api/relations/#ormar.relations.Relation.add","title":"<code>add(child)</code>","text":"<p>Adds child Model to relation, either sets child as related model or adds it to the list in RelationProxy depending on relation type.</p> <p>:param child: model to add to relation :type child: Model</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def add(self, child: \"Model\") -&gt; None:\n    \"\"\"\n    Adds child Model to relation, either sets child as related model or adds\n    it to the list in RelationProxy depending on relation type.\n\n    :param child: model to add to relation\n    :type child: Model\n    \"\"\"\n    relation_name = self.field_name\n    if self._type in (RelationType.PRIMARY, RelationType.THROUGH):\n        self.related_models = child\n        self._owner.__dict__[relation_name] = child\n    else:\n        if self._find_existing(child) is None:\n            self.related_models.append(child)  # type: ignore\n            rel = self._owner.__dict__.get(relation_name, [])\n            rel = rel or []\n            if not isinstance(rel, list):\n                rel = [rel]\n            self._populate_owner_side_dict(rel=rel, child=child)\n            self._owner.__dict__[relation_name] = rel\n</code></pre>"},{"location":"api/relations/#ormar.relations.Relation.get","title":"<code>get()</code>","text":"<p>Return the related model or models from RelationProxy.</p> <p>:return: related model/models if set :rtype: Optional[Union[List[Model], Model]]</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def get(self) -&gt; Optional[Union[List[\"Model\"], \"Model\"]]:\n    \"\"\"\n    Return the related model or models from RelationProxy.\n\n    :return: related model/models if set\n    :rtype: Optional[Union[List[Model], Model]]\n    \"\"\"\n    if self._to_remove:\n        self._clean_related()\n    return self.related_models\n</code></pre>"},{"location":"api/relations/#ormar.relations.Relation.remove","title":"<code>remove(child)</code>","text":"<p>Removes child Model from relation, either sets None as related model or removes it from the list in RelationProxy depending on relation type.</p> <p>:param child: model to remove from relation :type child: Model</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def remove(self, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]) -&gt; None:\n    \"\"\"\n    Removes child Model from relation, either sets None as related model or removes\n    it from the list in RelationProxy depending on relation type.\n\n    :param child: model to remove from relation\n    :type child: Model\n    \"\"\"\n    relation_name = self.field_name\n    if self._type == RelationType.PRIMARY:\n        if self.related_models == child:\n            self.related_models = None\n            del self._owner.__dict__[relation_name]\n    else:\n        position = self._find_existing(child)\n        if position is not None:\n            self.related_models.pop(position)  # type: ignore\n            del self._owner.__dict__[relation_name][position]\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationType","title":"<code>RelationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of relations supported by ormar:</p> <ul> <li>ForeignKey = PRIMARY</li> <li>reverse ForeignKey = REVERSE</li> <li>ManyToMany = MULTIPLE</li> </ul> Source code in <code>ormar/relations/relation.py</code> <pre><code>class RelationType(Enum):\n    \"\"\"\n    Different types of relations supported by ormar:\n\n    *  ForeignKey = PRIMARY\n    *  reverse ForeignKey = REVERSE\n    *  ManyToMany = MULTIPLE\n    \"\"\"\n\n    PRIMARY = 1\n    REVERSE = 2\n    MULTIPLE = 3\n    THROUGH = 4\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationsManager","title":"<code>RelationsManager</code>","text":"<p>Manages relations on a Model, each Model has it's own instance.</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>class RelationsManager:\n    \"\"\"\n    Manages relations on a Model, each Model has it's own instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        related_fields: Optional[List[\"ForeignKeyField\"]] = None,\n        owner: Optional[\"Model\"] = None,\n    ) -&gt; None:\n        self.owner = proxy(owner)\n        self._related_fields = related_fields or []\n        self._related_names = [field.name for field in self._related_fields]\n        self._relations: Dict[str, Relation] = dict()\n        for field in self._related_fields:\n            self._add_relation(field)\n\n    def __contains__(self, item: str) -&gt; bool:\n        \"\"\"\n        Checks if relation with given name is already registered.\n\n        :param item: name of attribute\n        :type item: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return item in self._related_names\n\n    def clear(self) -&gt; None:\n        for relation in self._relations.values():\n            relation.clear()\n\n    def get(self, name: str) -&gt; Optional[Union[\"Model\", Sequence[\"Model\"]]]:\n        \"\"\"\n        Returns the related model/models if relation is set.\n        Actual call is delegated to Relation instance registered under relation name.\n\n        :param name: name of the relation\n        :type name: str\n        :return: related model or list of related models if set\n        :rtype: Optional[Union[Model, List[Model]]\n        \"\"\"\n        relation = self._relations.get(name, None)\n        if relation is not None:\n            return relation.get()\n        return None  # pragma nocover\n\n    @staticmethod\n    def add(parent: \"Model\", child: \"Model\", field: \"ForeignKeyField\") -&gt; None:\n        \"\"\"\n        Adds relation on both sides -&gt; meaning on both child and parent models.\n        One side of the relation is always weakref proxy to avoid circular refs.\n\n        Based on the side from which relation is added and relation name actual names\n        of parent and child relations are established. The related models are registered\n        on both ends.\n\n        :param parent: parent model on which relation should be registered\n        :type parent: Model\n        :param child: child model to register\n        :type child: Model\n        :param field: field with relation definition\n        :type field: ForeignKeyField\n        \"\"\"\n        (parent, child, child_name, to_name) = get_relations_sides_and_names(\n            field, parent, child\n        )\n\n        # print('adding parent', parent.get_name(), child.get_name(), child_name)\n        parent_relation = parent._orm._get(child_name)\n        if parent_relation:\n            parent_relation.add(child)  # type: ignore\n\n        # print('adding child', child.get_name(), parent.get_name(), to_name)\n        child_relation = child._orm._get(to_name)\n        if child_relation:\n            child_relation.add(parent)\n\n    def remove(\n        self, name: str, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]\n    ) -&gt; None:\n        \"\"\"\n        Removes given child from relation with given name.\n        Since you can have many relations between two models you need to pass a name\n        of relation from which you want to remove the child.\n\n        :param name: name of the relation\n        :type name: str\n        :param child: child to remove from relation\n        :type child: Union[Model, Type[Model]]\n        \"\"\"\n        relation = self._get(name)\n        if relation:\n            relation.remove(child)\n\n    @staticmethod\n    def remove_parent(\n        item: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]], parent: \"Model\", name: str\n    ) -&gt; None:\n        \"\"\"\n        Removes given parent from relation with given name.\n        Since you can have many relations between two models you need to pass a name\n        of relation from which you want to remove the parent.\n\n        :param item: model with parent registered\n        :type item: Union[Model, Type[Model]]\n        :param parent: parent Model\n        :type parent: Model\n        :param name: name of the relation\n        :type name: str\n        \"\"\"\n        relation_name = item.ormar_config.model_fields[name].get_related_name()\n        item._orm.remove(name, parent)\n        parent._orm.remove(relation_name, item)\n\n    def _get(self, name: str) -&gt; Optional[Relation]:\n        \"\"\"\n        Returns the actual relation and not the related model(s).\n\n        :param name: name of the relation\n        :type name: str\n        :return: Relation instance\n        :rtype: ormar.relations.relation.Relation\n        \"\"\"\n        relation = self._relations.get(name, None)\n        if relation is not None:\n            return relation\n        return None\n\n    def _get_relation_type(self, field: \"BaseField\") -&gt; RelationType:\n        \"\"\"\n        Returns type of the relation declared on a field.\n\n        :param field: field with relation declaration\n        :type field: BaseField\n        :return: type of the relation defined on field\n        :rtype: RelationType\n        \"\"\"\n        if field.is_multi:\n            return RelationType.MULTIPLE\n        if field.is_through:\n            return RelationType.THROUGH\n        return RelationType.PRIMARY if not field.virtual else RelationType.REVERSE\n\n    def _add_relation(self, field: \"BaseField\") -&gt; None:\n        \"\"\"\n        Registers relation in the manager.\n        Adds Relation instance under field.name.\n\n        :param field: field with relation declaration\n        :type field: BaseField\n        \"\"\"\n        self._relations[field.name] = Relation(\n            manager=self,\n            type_=self._get_relation_type(field),\n            field_name=field.name,\n            to=field.to,\n            through=getattr(field, \"through\", None),\n        )\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationsManager.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Checks if relation with given name is already registered.</p> <p>:param item: name of attribute :type item: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>def __contains__(self, item: str) -&gt; bool:\n    \"\"\"\n    Checks if relation with given name is already registered.\n\n    :param item: name of attribute\n    :type item: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return item in self._related_names\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationsManager.add","title":"<code>add(parent, child, field)</code>  <code>staticmethod</code>","text":"<p>Adds relation on both sides -&gt; meaning on both child and parent models. One side of the relation is always weakref proxy to avoid circular refs.</p> <p>Based on the side from which relation is added and relation name actual names of parent and child relations are established. The related models are registered on both ends.</p> <p>:param parent: parent model on which relation should be registered :type parent: Model :param child: child model to register :type child: Model :param field: field with relation definition :type field: ForeignKeyField</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>@staticmethod\ndef add(parent: \"Model\", child: \"Model\", field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    Adds relation on both sides -&gt; meaning on both child and parent models.\n    One side of the relation is always weakref proxy to avoid circular refs.\n\n    Based on the side from which relation is added and relation name actual names\n    of parent and child relations are established. The related models are registered\n    on both ends.\n\n    :param parent: parent model on which relation should be registered\n    :type parent: Model\n    :param child: child model to register\n    :type child: Model\n    :param field: field with relation definition\n    :type field: ForeignKeyField\n    \"\"\"\n    (parent, child, child_name, to_name) = get_relations_sides_and_names(\n        field, parent, child\n    )\n\n    # print('adding parent', parent.get_name(), child.get_name(), child_name)\n    parent_relation = parent._orm._get(child_name)\n    if parent_relation:\n        parent_relation.add(child)  # type: ignore\n\n    # print('adding child', child.get_name(), parent.get_name(), to_name)\n    child_relation = child._orm._get(to_name)\n    if child_relation:\n        child_relation.add(parent)\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationsManager.get","title":"<code>get(name)</code>","text":"<p>Returns the related model/models if relation is set. Actual call is delegated to Relation instance registered under relation name.</p> <p>:param name: name of the relation :type name: str :return: related model or list of related models if set :rtype: Optional[Union[Model, List[Model]]</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>def get(self, name: str) -&gt; Optional[Union[\"Model\", Sequence[\"Model\"]]]:\n    \"\"\"\n    Returns the related model/models if relation is set.\n    Actual call is delegated to Relation instance registered under relation name.\n\n    :param name: name of the relation\n    :type name: str\n    :return: related model or list of related models if set\n    :rtype: Optional[Union[Model, List[Model]]\n    \"\"\"\n    relation = self._relations.get(name, None)\n    if relation is not None:\n        return relation.get()\n    return None  # pragma nocover\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationsManager.remove","title":"<code>remove(name, child)</code>","text":"<p>Removes given child from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the child.</p> <p>:param name: name of the relation :type name: str :param child: child to remove from relation :type child: Union[Model, Type[Model]]</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>def remove(\n    self, name: str, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]\n) -&gt; None:\n    \"\"\"\n    Removes given child from relation with given name.\n    Since you can have many relations between two models you need to pass a name\n    of relation from which you want to remove the child.\n\n    :param name: name of the relation\n    :type name: str\n    :param child: child to remove from relation\n    :type child: Union[Model, Type[Model]]\n    \"\"\"\n    relation = self._get(name)\n    if relation:\n        relation.remove(child)\n</code></pre>"},{"location":"api/relations/#ormar.relations.RelationsManager.remove_parent","title":"<code>remove_parent(item, parent, name)</code>  <code>staticmethod</code>","text":"<p>Removes given parent from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the parent.</p> <p>:param item: model with parent registered :type item: Union[Model, Type[Model]] :param parent: parent Model :type parent: Model :param name: name of the relation :type name: str</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>@staticmethod\ndef remove_parent(\n    item: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]], parent: \"Model\", name: str\n) -&gt; None:\n    \"\"\"\n    Removes given parent from relation with given name.\n    Since you can have many relations between two models you need to pass a name\n    of relation from which you want to remove the parent.\n\n    :param item: model with parent registered\n    :type item: Union[Model, Type[Model]]\n    :param parent: parent Model\n    :type parent: Model\n    :param name: name of the relation\n    :type name: str\n    \"\"\"\n    relation_name = item.ormar_config.model_fields[name].get_related_name()\n    item._orm.remove(name, parent)\n    parent._orm.remove(relation_name, item)\n</code></pre>"},{"location":"api/relations/#ormar.relations.get_relations_sides_and_names","title":"<code>get_relations_sides_and_names(to_field, parent, child)</code>","text":"<p>Determines the names of child and parent relations names, as well as changes one of the sides of the relation into weakref.proxy to model.</p> <p>:param to_field: field with relation definition :type to_field: ForeignKeyField :param parent: parent model :type parent: Model :param child: child model :type child: Model :return: parent, child, child_name, to_name :rtype: Tuple[\"Model\", \"Model\", str, str]</p> Source code in <code>ormar/relations/utils.py</code> <pre><code>def get_relations_sides_and_names(\n    to_field: ForeignKeyField, parent: \"Model\", child: \"Model\"\n) -&gt; Tuple[\"Model\", \"Model\", str, str]:\n    \"\"\"\n    Determines the names of child and parent relations names, as well as\n    changes one of the sides of the relation into weakref.proxy to model.\n\n    :param to_field: field with relation definition\n    :type to_field: ForeignKeyField\n    :param parent: parent model\n    :type parent: Model\n    :param child: child model\n    :type child: Model\n    :return: parent, child, child_name, to_name\n    :rtype: Tuple[\"Model\", \"Model\", str, str]\n    \"\"\"\n    to_name = to_field.name\n    child_name = to_field.get_related_name()\n    if to_field.virtual:\n        child_name, to_name = to_name, child_name\n        child, parent = parent, proxy(child)\n    else:\n        child = proxy(child)\n    return parent, child, child_name, to_name\n</code></pre>"},{"location":"api/relations/alias_manager/","title":"alias_manager","text":""},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager","title":"<code>AliasManager</code>","text":"<p>Keep all aliases of relations between different tables. One global instance is shared between all models.</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>class AliasManager:\n    \"\"\"\n    Keep all aliases of relations between different tables.\n    One global instance is shared between all models.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._aliases_new: Dict[str, str] = dict()\n        self._reversed_aliases: Dict[str, str] = dict()\n        self._prefixed_tables: Dict[str, text] = dict()\n\n    def __contains__(self, item: str) -&gt; bool:\n        return self._aliases_new.__contains__(item)\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self._aliases_new.__getitem__(key)\n\n    @property\n    def reversed_aliases(self) -&gt; Dict:\n        \"\"\"\n        Returns swapped key-value pairs from aliases where alias is the key.\n\n        :return: dictionary of prefix to relation\n        :rtype: Dict\n        \"\"\"\n        if self._reversed_aliases:\n            return self._reversed_aliases\n        reversed_aliases = {v: k for k, v in self._aliases_new.items()}\n        self._reversed_aliases = reversed_aliases\n        return self._reversed_aliases\n\n    @staticmethod\n    def prefixed_columns(\n        alias: str, table: sqlalchemy.Table, fields: Optional[List] = None\n    ) -&gt; List[text]:\n        \"\"\"\n        Creates a list of aliases sqlalchemy text clauses from\n        string alias and sqlalchemy.Table.\n\n        Optional list of fields to include can be passed to extract only those columns.\n        List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones.\n\n        :param alias: alias of given table\n        :type alias: str\n        :param table: table from which fields should be aliased\n        :type table: sqlalchemy.Table\n        :param fields: fields to include\n        :type fields: Optional[List[str]]\n        :return: list of sqlalchemy text clauses with \"column name as aliased name\"\n        :rtype: List[text]\n        \"\"\"\n        alias = f\"{alias}_\" if alias else \"\"\n        aliased_fields = [f\"{alias}{x}\" for x in fields] if fields else []\n        all_columns = (\n            table.columns\n            if not fields\n            else [\n                col\n                for col in table.columns\n                if col.name in fields or col.name in aliased_fields\n            ]\n        )\n        return [column.label(f\"{alias}{column.name}\") for column in all_columns]\n\n    def prefixed_table_name(self, alias: str, table: sqlalchemy.Table) -&gt; text:\n        \"\"\"\n        Creates text clause with table name with aliased name.\n\n        :param alias: alias of given table\n        :type alias: str\n        :param table: table\n        :type table: sqlalchemy.Table\n        :return: sqlalchemy text clause as \"table_name aliased_name\"\n        :rtype: sqlalchemy text clause\n        \"\"\"\n        full_alias = f\"{alias}_{table.name}\"\n        key = f\"{full_alias}_{id(table)}\"\n        return self._prefixed_tables.setdefault(key, table.alias(full_alias))\n\n    def add_relation_type(\n        self,\n        source_model: Type[\"Model\"],\n        relation_name: str,\n        reverse_name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Registers the relations defined in ormar models.\n        Given the relation it registers also the reverse side of this relation.\n\n        Used by both ForeignKey and ManyToMany relations.\n\n        Each relation is registered as Model name and relation name.\n        Each alias registered has to be unique.\n\n        Aliases are used to construct joins to assure proper links between tables.\n        That way you can link to the same target tables from multiple fields\n        on one model as well as from multiple different models in one join.\n\n        :param source_model: model with relation defined\n        :type source_model: source Model\n        :param relation_name: name of the relation to define\n        :type relation_name: str\n        :param reverse_name: name of related_name fo given relation for m2m relations\n        :type reverse_name: Optional[str]\n        :return: none\n        :rtype: None\n        \"\"\"\n        parent_key = f\"{source_model.get_name()}_{relation_name}\"\n        if parent_key not in self._aliases_new:\n            self.add_alias(parent_key)\n\n        to_field = source_model.ormar_config.model_fields[relation_name]\n        child_model = to_field.to\n        child_key = f\"{child_model.get_name()}_{reverse_name}\"\n        if child_key not in self._aliases_new:\n            self.add_alias(child_key)\n\n    def add_alias(self, alias_key: str) -&gt; str:\n        \"\"\"\n        Adds alias to the dictionary of aliases under given key.\n\n        :param alias_key: key of relation to generate alias for\n        :type alias_key: str\n        :return: generated alias\n        :rtype: str\n        \"\"\"\n        alias = get_table_alias()\n        self._aliases_new[alias_key] = alias\n        return alias\n\n    def resolve_relation_alias(\n        self, from_model: Union[Type[\"Model\"], Type[\"ModelRow\"]], relation_name: str\n    ) -&gt; str:\n        \"\"\"\n        Given model and relation name returns the alias for this relation.\n\n        :param from_model: model with relation defined\n        :type from_model: source Model\n        :param relation_name: name of the relation field\n        :type relation_name: str\n        :return: alias of the relation\n        :rtype: str\n        \"\"\"\n        alias = self._aliases_new.get(f\"{from_model.get_name()}_{relation_name}\", \"\")\n        return alias\n\n    def resolve_relation_alias_after_complex(\n        self,\n        source_model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n        relation_str: str,\n        relation_field: \"ForeignKeyField\",\n    ) -&gt; str:\n        \"\"\"\n        Given source model and relation string returns the alias for this complex\n        relation if it exists, otherwise fallback to normal relation from a relation\n        field definition.\n\n        :param relation_field: field with direct relation definition\n        :type relation_field: \"ForeignKeyField\"\n        :param source_model: model with query starts\n        :type source_model: source Model\n        :param relation_str: string with relation joins defined\n        :type relation_str: str\n        :return: alias of the relation\n        :rtype: str\n        \"\"\"\n        alias = \"\"\n        if relation_str and \"__\" in relation_str:\n            alias = self.resolve_relation_alias(\n                from_model=source_model, relation_name=relation_str\n            )\n        if not alias:\n            alias = self.resolve_relation_alias(\n                from_model=relation_field.get_source_model(),\n                relation_name=relation_field.get_relation_name(),\n            )\n        return alias\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.reversed_aliases","title":"<code>reversed_aliases: Dict</code>  <code>property</code>","text":"<p>Returns swapped key-value pairs from aliases where alias is the key.</p> <p>:return: dictionary of prefix to relation :rtype: Dict</p>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.add_alias","title":"<code>add_alias(alias_key)</code>","text":"<p>Adds alias to the dictionary of aliases under given key.</p> <p>:param alias_key: key of relation to generate alias for :type alias_key: str :return: generated alias :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def add_alias(self, alias_key: str) -&gt; str:\n    \"\"\"\n    Adds alias to the dictionary of aliases under given key.\n\n    :param alias_key: key of relation to generate alias for\n    :type alias_key: str\n    :return: generated alias\n    :rtype: str\n    \"\"\"\n    alias = get_table_alias()\n    self._aliases_new[alias_key] = alias\n    return alias\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.add_relation_type","title":"<code>add_relation_type(source_model, relation_name, reverse_name=None)</code>","text":"<p>Registers the relations defined in ormar models. Given the relation it registers also the reverse side of this relation.</p> <p>Used by both ForeignKey and ManyToMany relations.</p> <p>Each relation is registered as Model name and relation name. Each alias registered has to be unique.</p> <p>Aliases are used to construct joins to assure proper links between tables. That way you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join.</p> <p>:param source_model: model with relation defined :type source_model: source Model :param relation_name: name of the relation to define :type relation_name: str :param reverse_name: name of related_name fo given relation for m2m relations :type reverse_name: Optional[str] :return: none :rtype: None</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def add_relation_type(\n    self,\n    source_model: Type[\"Model\"],\n    relation_name: str,\n    reverse_name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Registers the relations defined in ormar models.\n    Given the relation it registers also the reverse side of this relation.\n\n    Used by both ForeignKey and ManyToMany relations.\n\n    Each relation is registered as Model name and relation name.\n    Each alias registered has to be unique.\n\n    Aliases are used to construct joins to assure proper links between tables.\n    That way you can link to the same target tables from multiple fields\n    on one model as well as from multiple different models in one join.\n\n    :param source_model: model with relation defined\n    :type source_model: source Model\n    :param relation_name: name of the relation to define\n    :type relation_name: str\n    :param reverse_name: name of related_name fo given relation for m2m relations\n    :type reverse_name: Optional[str]\n    :return: none\n    :rtype: None\n    \"\"\"\n    parent_key = f\"{source_model.get_name()}_{relation_name}\"\n    if parent_key not in self._aliases_new:\n        self.add_alias(parent_key)\n\n    to_field = source_model.ormar_config.model_fields[relation_name]\n    child_model = to_field.to\n    child_key = f\"{child_model.get_name()}_{reverse_name}\"\n    if child_key not in self._aliases_new:\n        self.add_alias(child_key)\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.prefixed_columns","title":"<code>prefixed_columns(alias, table, fields=None)</code>  <code>staticmethod</code>","text":"<p>Creates a list of aliases sqlalchemy text clauses from string alias and sqlalchemy.Table.</p> <p>Optional list of fields to include can be passed to extract only those columns. List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones.</p> <p>:param alias: alias of given table :type alias: str :param table: table from which fields should be aliased :type table: sqlalchemy.Table :param fields: fields to include :type fields: Optional[List[str]] :return: list of sqlalchemy text clauses with \"column name as aliased name\" :rtype: List[text]</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>@staticmethod\ndef prefixed_columns(\n    alias: str, table: sqlalchemy.Table, fields: Optional[List] = None\n) -&gt; List[text]:\n    \"\"\"\n    Creates a list of aliases sqlalchemy text clauses from\n    string alias and sqlalchemy.Table.\n\n    Optional list of fields to include can be passed to extract only those columns.\n    List has to have sqlalchemy names of columns (ormar aliases) not the ormar ones.\n\n    :param alias: alias of given table\n    :type alias: str\n    :param table: table from which fields should be aliased\n    :type table: sqlalchemy.Table\n    :param fields: fields to include\n    :type fields: Optional[List[str]]\n    :return: list of sqlalchemy text clauses with \"column name as aliased name\"\n    :rtype: List[text]\n    \"\"\"\n    alias = f\"{alias}_\" if alias else \"\"\n    aliased_fields = [f\"{alias}{x}\" for x in fields] if fields else []\n    all_columns = (\n        table.columns\n        if not fields\n        else [\n            col\n            for col in table.columns\n            if col.name in fields or col.name in aliased_fields\n        ]\n    )\n    return [column.label(f\"{alias}{column.name}\") for column in all_columns]\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.prefixed_table_name","title":"<code>prefixed_table_name(alias, table)</code>","text":"<p>Creates text clause with table name with aliased name.</p> <p>:param alias: alias of given table :type alias: str :param table: table :type table: sqlalchemy.Table :return: sqlalchemy text clause as \"table_name aliased_name\" :rtype: sqlalchemy text clause</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def prefixed_table_name(self, alias: str, table: sqlalchemy.Table) -&gt; text:\n    \"\"\"\n    Creates text clause with table name with aliased name.\n\n    :param alias: alias of given table\n    :type alias: str\n    :param table: table\n    :type table: sqlalchemy.Table\n    :return: sqlalchemy text clause as \"table_name aliased_name\"\n    :rtype: sqlalchemy text clause\n    \"\"\"\n    full_alias = f\"{alias}_{table.name}\"\n    key = f\"{full_alias}_{id(table)}\"\n    return self._prefixed_tables.setdefault(key, table.alias(full_alias))\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.resolve_relation_alias","title":"<code>resolve_relation_alias(from_model, relation_name)</code>","text":"<p>Given model and relation name returns the alias for this relation.</p> <p>:param from_model: model with relation defined :type from_model: source Model :param relation_name: name of the relation field :type relation_name: str :return: alias of the relation :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def resolve_relation_alias(\n    self, from_model: Union[Type[\"Model\"], Type[\"ModelRow\"]], relation_name: str\n) -&gt; str:\n    \"\"\"\n    Given model and relation name returns the alias for this relation.\n\n    :param from_model: model with relation defined\n    :type from_model: source Model\n    :param relation_name: name of the relation field\n    :type relation_name: str\n    :return: alias of the relation\n    :rtype: str\n    \"\"\"\n    alias = self._aliases_new.get(f\"{from_model.get_name()}_{relation_name}\", \"\")\n    return alias\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.AliasManager.resolve_relation_alias_after_complex","title":"<code>resolve_relation_alias_after_complex(source_model, relation_str, relation_field)</code>","text":"<p>Given source model and relation string returns the alias for this complex relation if it exists, otherwise fallback to normal relation from a relation field definition.</p> <p>:param relation_field: field with direct relation definition :type relation_field: \"ForeignKeyField\" :param source_model: model with query starts :type source_model: source Model :param relation_str: string with relation joins defined :type relation_str: str :return: alias of the relation :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def resolve_relation_alias_after_complex(\n    self,\n    source_model: Union[Type[\"Model\"], Type[\"ModelRow\"]],\n    relation_str: str,\n    relation_field: \"ForeignKeyField\",\n) -&gt; str:\n    \"\"\"\n    Given source model and relation string returns the alias for this complex\n    relation if it exists, otherwise fallback to normal relation from a relation\n    field definition.\n\n    :param relation_field: field with direct relation definition\n    :type relation_field: \"ForeignKeyField\"\n    :param source_model: model with query starts\n    :type source_model: source Model\n    :param relation_str: string with relation joins defined\n    :type relation_str: str\n    :return: alias of the relation\n    :rtype: str\n    \"\"\"\n    alias = \"\"\n    if relation_str and \"__\" in relation_str:\n        alias = self.resolve_relation_alias(\n            from_model=source_model, relation_name=relation_str\n        )\n    if not alias:\n        alias = self.resolve_relation_alias(\n            from_model=relation_field.get_source_model(),\n            relation_name=relation_field.get_relation_name(),\n        )\n    return alias\n</code></pre>"},{"location":"api/relations/alias_manager/#ormar.relations.alias_manager.get_table_alias","title":"<code>get_table_alias()</code>","text":"<p>Creates a random string that is used to alias tables in joins. It's necessary that each relation has it's own aliases cause you can link to the same target tables from multiple fields on one model as well as from multiple different models in one join.</p> <p>:return: randomly generated alias :rtype: str</p> Source code in <code>ormar/relations/alias_manager.py</code> <pre><code>def get_table_alias() -&gt; str:\n    \"\"\"\n    Creates a random string that is used to alias tables in joins.\n    It's necessary that each relation has it's own aliases cause you can link\n    to the same target tables from multiple fields on one model as well as from\n    multiple different models in one join.\n\n    :return: randomly generated alias\n    :rtype: str\n    \"\"\"\n    alias = \"\".join(choices(string.ascii_uppercase, k=2)) + uuid.uuid4().hex[:4]\n    return alias.lower()\n</code></pre>"},{"location":"api/relations/querysetproxy/","title":"querysetproxy","text":""},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy","title":"<code>QuerysetProxy</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Exposes QuerySet methods on relations, but also handles creating and removing of through Models for m2m relations.</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>class QuerysetProxy(Generic[T]):\n    \"\"\"\n    Exposes QuerySet methods on relations, but also handles creating and removing\n    of through Models for m2m relations.\n    \"\"\"\n\n    if TYPE_CHECKING:  # pragma no cover\n        relation: \"Relation\"\n\n    def __init__(\n        self,\n        relation: \"Relation\",\n        to: Type[\"T\"],\n        type_: \"RelationType\",\n        qryset: Optional[\"QuerySet[T]\"] = None,\n    ) -&gt; None:\n        self.relation: \"Relation\" = relation\n        self._queryset: Optional[\"QuerySet[T]\"] = qryset\n        self.type_: \"RelationType\" = type_\n        self._owner: Union[CallableProxyType, \"Model\"] = self.relation.manager.owner\n        self.related_field_name = self._owner.ormar_config.model_fields[\n            self.relation.field_name\n        ].get_related_name()\n        self.to: Type[T] = to\n        self.related_field = to.ormar_config.model_fields[self.related_field_name]\n        self.owner_pk_value = self._owner.pk\n        self.through_model_name = (\n            self.related_field.through.get_name()\n            if self.type_ == ormar.RelationType.MULTIPLE\n            else \"\"\n        )\n\n    @property\n    def queryset(self) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Returns queryset if it's set, AttributeError otherwise.\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        if not self._queryset:\n            raise AttributeError\n        return self._queryset\n\n    @queryset.setter\n    def queryset(self, value: \"QuerySet\") -&gt; None:\n        \"\"\"\n        Set's the queryset. Initialized in RelationProxy.\n        :param value: QuerySet\n        :type value: QuerySet\n        \"\"\"\n        self._queryset = value\n\n    def _assign_child_to_parent(self, child: Optional[\"T\"]) -&gt; None:\n        \"\"\"\n        Registers child in parents RelationManager.\n\n        :param child: child to register on parent side.\n        :type child: Model\n        \"\"\"\n        if child:\n            owner = self._owner\n            rel_name = self.relation.field_name\n            setattr(owner, rel_name, child)\n\n    def _register_related(self, child: Union[\"T\", Sequence[Optional[\"T\"]]]) -&gt; None:\n        \"\"\"\n        Registers child/ children in parents RelationManager.\n\n        :param child: child or list of children models to register.\n        :type child: Union[Model,List[Model]]\n        \"\"\"\n        if isinstance(child, list):\n            for subchild in child:\n                self._assign_child_to_parent(subchild)\n        else:\n            assert isinstance(child, ormar.Model)\n            child = cast(\"T\", child)\n            self._assign_child_to_parent(child)\n\n    def _clean_items_on_load(self) -&gt; None:\n        \"\"\"\n        Cleans the current list of the related models.\n        \"\"\"\n        if isinstance(self.relation.related_models, MutableSequence):\n            for item in self.relation.related_models[:]:\n                self.relation.remove(item)\n\n    async def create_through_instance(self, child: \"T\", **kwargs: Any) -&gt; None:\n        \"\"\"\n        Crete a through model instance in the database for m2m relations.\n\n        :param kwargs: dict of additional keyword arguments for through instance\n        :type kwargs: Any\n        :param child: child model instance\n        :type child: Model\n        \"\"\"\n        model_cls = self.relation.through\n        owner_column = self.related_field.default_target_field_name()  # type: ignore\n        child_column = self.related_field.default_source_field_name()  # type: ignore\n        rel_kwargs = {owner_column: self._owner.pk, child_column: child.pk}\n        final_kwargs = {**rel_kwargs, **kwargs}\n        if child.pk is None:\n            raise ModelPersistenceError(\n                f\"You cannot save {child.get_name()} \"\n                f\"model without primary key set! \\n\"\n                f\"Save the child model first.\"\n            )\n        await model_cls(**final_kwargs).save()\n\n    async def update_through_instance(self, child: \"T\", **kwargs: Any) -&gt; None:\n        \"\"\"\n        Updates a through model instance in the database for m2m relations.\n\n        :param kwargs: dict of additional keyword arguments for through instance\n        :type kwargs: Any\n        :param child: child model instance\n        :type child: Model\n        \"\"\"\n        model_cls = self.relation.through\n        owner_column = self.related_field.default_target_field_name()  # type: ignore\n        child_column = self.related_field.default_source_field_name()  # type: ignore\n        rel_kwargs = {owner_column: self._owner.pk, child_column: child.pk}\n        through_model = await model_cls.objects.get(**rel_kwargs)\n        await through_model.update(**kwargs)\n\n    async def upsert_through_instance(self, child: \"T\", **kwargs: Any) -&gt; None:\n        \"\"\"\n        Updates a through model instance in the database for m2m relations if\n        it already exists, else creates one.\n\n        :param kwargs: dict of additional keyword arguments for through instance\n        :type kwargs: Any\n        :param child: child model instance\n        :type child: Model\n        \"\"\"\n        try:\n            await self.update_through_instance(child=child, **kwargs)\n        except NoMatch:\n            await self.create_through_instance(child=child, **kwargs)\n\n    async def delete_through_instance(self, child: \"T\") -&gt; None:\n        \"\"\"\n        Removes through model instance from the database for m2m relations.\n\n        :param child: child model instance\n        :type child: Model\n        \"\"\"\n        queryset = ormar.QuerySet(model_cls=self.relation.through)  # type: ignore\n        owner_column = self.related_field.default_target_field_name()  # type: ignore\n        child_column = self.related_field.default_source_field_name()  # type: ignore\n        kwargs = {owner_column: self._owner, child_column: child}\n        link_instance = await queryset.filter(**kwargs).get()  # type: ignore\n        await link_instance.delete()\n\n    async def exists(self) -&gt; bool:\n        \"\"\"\n        Returns a bool value to confirm if there are rows matching the given criteria\n        (applied with `filter` and `exclude` if set).\n\n        Actual call delegated to QuerySet.\n\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return await self.queryset.exists()\n\n    async def count(self, distinct: bool = True) -&gt; int:\n        \"\"\"\n        Returns number of rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n        If `distinct` is `True` (the default), this will return\n        the number of primary rows selected. If `False`,\n        the count will be the total number of rows returned\n        (including extra rows for `one-to-many` or `many-to-many`\n        left `select_related` table joins).\n        `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n        Actual call delegated to QuerySet.\n\n        :param distinct: flag if the primary table rows should be distinct or not\n        :return: number of rows\n        :rtype: int\n        \"\"\"\n        return await self.queryset.count(distinct=distinct)\n\n    async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns max value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: max value of column(s)\n        :rtype: Any\n        \"\"\"\n        return await self.queryset.max(columns=columns)\n\n    async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns min value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: min value of column(s)\n        :rtype: Any\n        \"\"\"\n        return await self.queryset.min(columns=columns)\n\n    async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n        \"\"\"\n        Returns sum value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: sum value of columns\n        :rtype: int\n        \"\"\"\n        return await self.queryset.sum(columns=columns)\n\n    async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n        \"\"\"\n        Returns avg value of columns for rows matching the given criteria\n        (applied with `filter` and `exclude` if set before).\n\n        :return: avg value of columns\n        :rtype: Union[int, float, List]\n        \"\"\"\n        return await self.queryset.avg(columns=columns)\n\n    async def clear(self, keep_reversed: bool = True) -&gt; int:\n        \"\"\"\n        Removes all related models from given relation.\n\n        Removes all through models for m2m relation.\n\n        For reverse FK relations keep_reversed flag marks if the reversed models\n        should be kept or deleted from the database too (False means that models\n        will be deleted, and not only removed from relation).\n\n        :param keep_reversed: flag if reverse models in reverse FK should be deleted\n        or not, keep_reversed=False deletes them from database.\n        :type keep_reversed: bool\n        :return: number of deleted models\n        :rtype: int\n        \"\"\"\n        if self.type_ == ormar.RelationType.MULTIPLE:\n            queryset = ormar.QuerySet(model_cls=self.relation.through)  # type: ignore\n            owner_column = self._owner.get_name()\n        else:\n            queryset = ormar.QuerySet(model_cls=self.relation.to)  # type: ignore\n            owner_column = self.related_field_name\n        kwargs = {owner_column: self._owner}\n        self._clean_items_on_load()\n        if keep_reversed and self.type_ == ormar.RelationType.REVERSE:\n            update_kwrgs = {f\"{owner_column}\": None}\n            return await queryset.filter(_exclude=False, **kwargs).update(\n                each=False, **update_kwrgs\n            )\n        return await queryset.delete(**kwargs)  # type: ignore\n\n    async def values(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        exclude_through: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of dictionaries with column values in order of the fields\n        passed or all fields from queried models.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields:  Union[List, str, Set, Dict]\n        \"\"\"\n        return await self.queryset.values(\n            fields=fields, exclude_through=exclude_through\n        )\n\n    async def values_list(\n        self,\n        fields: Union[List, str, Set, Dict, None] = None,\n        flatten: bool = False,\n        exclude_through: bool = False,\n    ) -&gt; List:\n        \"\"\"\n        Return a list of tuples with column values in order of the fields passed or\n        all fields from queried models.\n\n        When one field is passed you can flatten the list of tuples into list of values\n        of that single field.\n\n        To filter for given row use filter/exclude methods before values,\n        to limit number of rows use limit/offset or paginate before values.\n\n        Note that it always return a list even for one row from database.\n\n        :param exclude_through: flag if through models should be excluded\n        :type exclude_through: bool\n        :param fields: field name or list of field names to extract from db\n        :type fields: Union[str, List[str]]\n        :param flatten: when one field is passed you can flatten the list of tuples\n        :type flatten: bool\n        \"\"\"\n        return await self.queryset.values(\n            fields=fields,\n            exclude_through=exclude_through,\n            _as_dict=False,\n            _flatten=flatten,\n        )\n\n    async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Gets the first row from the db ordered by primary key column ascending.\n\n        Actual call delegated to QuerySet.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).first()`.\n\n        List of related models is cleared before the call.\n\n        :param kwargs:\n        :type kwargs:\n        :return:\n        :rtype: _asyncio.Future\n        \"\"\"\n        first = await self.queryset.first(*args, **kwargs)\n        self._clean_items_on_load()\n        self._register_related(first)\n        return first\n\n    async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).get_or_none()`.\n\n        If not match is found None will be returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        try:\n            get = await self.queryset.get(*args, **kwargs)\n        except ormar.NoMatch:\n            return None\n\n        self._clean_items_on_load()\n        self._register_related(get)\n        return get\n\n    async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Gets the first row from the db meeting the criteria set by kwargs.\n\n        If no criteria set it will return the last row in db sorted by pk.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).get()`.\n\n        Actual call delegated to QuerySet.\n\n        List of related models is cleared before the call.\n\n        :raises NoMatch: if no rows are returned\n        :raises MultipleMatches: if more than 1 row is returned.\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: returned model\n        :rtype: Model\n        \"\"\"\n        get = await self.queryset.get(*args, **kwargs)\n        self._clean_items_on_load()\n        self._register_related(get)\n        return get\n\n    async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n        \"\"\"\n        Returns all rows from a database for given model for set filter options.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).all()`.\n\n        If there are no rows meeting the criteria an empty list is returned.\n\n        Actual call delegated to QuerySet.\n\n        List of related models is cleared before the call.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: list of returned models\n        :rtype: List[Model]\n        \"\"\"\n        all_items = await self.queryset.all(*args, **kwargs)\n        self._clean_items_on_load()\n        self._register_related(all_items)\n        return all_items\n\n    async def iterate(  # noqa: A003\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; AsyncGenerator[\"T\", None]:\n        \"\"\"\n        Return async iterable generator for all rows from a database for given model.\n\n        Passing args and/or kwargs is a shortcut and equals to calling\n        `filter(*args, **kwargs).iterate()`.\n\n        If there are no rows meeting the criteria an empty async generator is returned.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: asynchronous iterable generator of returned models\n        :rtype: AsyncGenerator[Model]\n        \"\"\"\n\n        async for item in self.queryset.iterate(*args, **kwargs):\n            yield item\n\n    async def create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Creates the model instance, saves it in a database and returns the updates model\n        (with pk populated if not passed and autoincrement is set).\n\n        The allowed kwargs are `Model` fields names and proper value types.\n\n        For m2m relation the through model is created automatically.\n\n        Actual call delegated to QuerySet.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: created model\n        :rtype: Model\n        \"\"\"\n        through_kwargs = kwargs.pop(self.through_model_name, {})\n        if self.type_ == ormar.RelationType.REVERSE:\n            kwargs[self.related_field_name] = self._owner\n        created = await self.queryset.create(**kwargs)\n        self._register_related(created)\n        if self.type_ == ormar.RelationType.MULTIPLE:\n            await self.create_through_instance(created, **through_kwargs)\n        return created\n\n    async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n        \"\"\"\n        Updates the model table after applying the filters from kwargs.\n\n        You have to either pass a filter to narrow down a query or explicitly pass\n        each=True flag to affect whole table.\n\n        :param each: flag if whole table should be affected if no filter is passed\n        :type each: bool\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: number of updated rows\n        :rtype: int\n        \"\"\"\n        # queryset proxy always have one filter for pk of parent model\n        if (\n            not each\n            and (len(self.queryset.filter_clauses) + len(self.queryset.exclude_clauses))\n            == 1\n        ):\n            raise QueryDefinitionError(\n                \"You cannot update without filtering the queryset first. \"\n                \"If you want to update all rows use update(each=True, **kwargs)\"\n            )\n\n        through_kwargs = kwargs.pop(self.through_model_name, {})\n        children = await self.queryset.all()\n        for child in children:\n            await child.update(**kwargs)  # type: ignore\n            if self.type_ == ormar.RelationType.MULTIPLE and through_kwargs:\n                await self.update_through_instance(\n                    child=child, **through_kwargs  # type: ignore\n                )\n        return len(children)\n\n    async def get_or_create(\n        self,\n        _defaults: Optional[Dict[str, Any]] = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Tuple[\"T\", bool]:\n        \"\"\"\n        Combination of create and get methods.\n\n        Tries to get a row meeting the criteria for kwargs\n        and if `NoMatch` exception is raised\n        it creates a new one with given kwargs and _defaults.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :param _defaults: default values for creating object\n        :type _defaults: Optional[Dict[str, Any]]\n        :return: model instance and a boolean\n        :rtype: Tuple(\"T\", bool)\n        \"\"\"\n        try:\n            return await self.get(*args, **kwargs), False\n        except NoMatch:\n            _defaults = _defaults or {}\n            return await self.create(**{**kwargs, **_defaults}), True\n\n    async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n        \"\"\"\n        Updates the model, or in case there is no match in database creates a new one.\n\n        Actual call delegated to QuerySet.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: updated or created model\n        :rtype: Model\n        \"\"\"\n        pk_name = self.queryset.model_config.pkname\n        if \"pk\" in kwargs:\n            kwargs[pk_name] = kwargs.pop(\"pk\")\n        if pk_name not in kwargs or kwargs.get(pk_name) is None:\n            return await self.create(**kwargs)\n        model = await self.queryset.get(pk=kwargs[pk_name])\n        return await model.update(**kwargs)\n\n    def filter(  # noqa: A003, A001\n        self, *args: Any, **kwargs: Any\n    ) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        Allows you to filter by any `Model` attribute/field\n        as well as to fetch instances, with a filter across an FK relationship.\n\n        You can use special filter suffix to change the filter operands:\n\n        *  exact - like `album__name__exact='Malibu'` (exact match)\n        *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n        *  contains - like `album__name__contains='Mal'` (sql like)\n        *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n        *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n        *  isnull - like `album__name__isnull=True` (sql is null)\n           (isnotnull `album__name__isnull=False` (sql is not null))\n        *  gt - like `position__gt=3` (sql &gt;)\n        *  gte - like `position__gte=3` (sql &gt;=)\n        *  lt - like `position__lt=3` (sql &lt;)\n        *  lte - like `position__lte=3` (sql &lt;=)\n        *  startswith - like `album__name__startswith='Mal'` (exact start match)\n        *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n        *  endswith - like `album__name__endswith='ibu'` (exact end match)\n        *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n        Actual call delegated to QuerySet.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.filter(*args, **kwargs)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def exclude(\n        self, *args: Any, **kwargs: Any\n    ) -&gt; \"QuerysetProxy[T]\":  # noqa: A003, A001\n        \"\"\"\n        Works exactly the same as filter and all modifiers (suffixes) are the same,\n        but returns a *not* condition.\n\n        So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n        the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n        Note that all conditions are joined so if you pass multiple values it\n        becomes a union of conditions.\n\n        `exclude(name='John', age&gt;=35)` will become\n        `where not (name='John' and age&gt;=35)`\n\n        Actual call delegated to QuerySet.\n\n        :param kwargs: fields names and proper value types\n        :type kwargs: Any\n        :return: filtered QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.exclude(*args, **kwargs)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def select_all(self, follow: bool = False) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        By default adds only directly related models.\n\n        If follow=True is set it adds also related models of related models.\n\n        To not get stuck in an infinite loop as related models also keep a relation\n        to parent model visited models set is kept.\n\n        That way already visited models that are nested are loaded, but the load do not\n        follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n        will load second Model A but will never follow into Model X.\n        Nested relations of those kind need to be loaded manually.\n\n        :param follow: flag to trigger deep save -\n        by default only directly related models are saved\n        with follow=True also related models of related models are saved\n        :type follow: bool\n        :return: reloaded Model\n        :rtype: Model\n        \"\"\"\n        queryset = self.queryset.select_all(follow=follow)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def select_related(self, related: Union[List, str]) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        Allows to prefetch related models during the same query.\n\n        **With `select_related` always only one query is run against the database**,\n        meaning that one (sometimes complicated) join is generated and later nested\n        models are processed in python.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        Actual call delegated to QuerySet.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.select_related(related)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def prefetch_related(self, related: Union[List, str]) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        Allows to prefetch related models during query - but opposite to\n        `select_related` each subsequent model is fetched in a separate database query.\n\n        **With `prefetch_related` always one query per Model is run against the\n        database**, meaning that you will have multiple queries executed one\n        after another.\n\n        To fetch related model use `ForeignKey` names.\n\n        To chain related `Models` relation use double underscores between names.\n\n        Actual call delegated to QuerySet.\n\n        :param related: list of relation field names, can be linked by '__' to nest\n        :type related: Union[List, str]\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.prefetch_related(related)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        You can paginate the result which is a combination of offset and limit clauses.\n        Limit is set to page size and offset is set to (page-1) * page_size.\n\n        Actual call delegated to QuerySet.\n\n        :param page_size: numbers of items per page\n        :type page_size: int\n        :param page: page number\n        :type page: int\n        :return: QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        queryset = self.queryset.paginate(page=page, page_size=page_size)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def limit(self, limit_count: int) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        You can limit the results to desired number of parent models.\n\n        Actual call delegated to QuerySet.\n\n        :param limit_count: number of models to limit\n        :type limit_count: int\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.limit(limit_count)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def offset(self, offset: int) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        You can also offset the results by desired number of main models.\n\n        Actual call delegated to QuerySet.\n\n        :param offset: numbers of models to offset\n        :type offset: int\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.offset(offset)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        With `fields()` you can select subset of model columns to limit the data load.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related`\n        models (with nested notation).\n\n        You can select specified fields by passing a `str, List[str], Set[str] or\n        dict` with nested definition.\n\n        To include related models use notation\n        `{related_name}__{column}[__{optional_next} etc.]`.\n\n        `fields()` can be called several times, building up the columns to select.\n\n        If you include related models into `select_related()` call but you won't specify\n        columns for those models in fields - implies a list of all fields for\n        those nested models.\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n         to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even if\n        not explicitly included.\n\n        You can also pass fields to include as dictionary or set.\n\n        To mark a field as included in a dictionary use it's name as key\n        and ellipsis as value.\n\n        To traverse nested models use nested dictionaries.\n\n        To include fields at last level instead of nested dictionary a set can be used.\n\n        To include whole nested model specify model related field name and ellipsis.\n\n        Actual call delegated to QuerySet.\n\n        :param columns: columns to include\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.fields(columns)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def exclude_fields(\n        self, columns: Union[List, str, Set, Dict]\n    ) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        With `exclude_fields()` you can select subset of model columns that will\n        be excluded to limit the data load.\n\n        It's the opposite of `fields()` method so check documentation above\n        to see what options are available.\n\n        Especially check above how you can pass also nested dictionaries\n        and sets as a mask to exclude fields from whole hierarchy.\n\n        Note that `fields()` and `exclude_fields()` works both for main models\n        (on normal queries like `get`, `all` etc.)\n        as well as `select_related` and `prefetch_related` models\n        (with nested notation).\n\n        Mandatory fields cannot be excluded as it will raise `ValidationError`,\n        to exclude a field it has to be nullable.\n\n        Pk column cannot be excluded - it's always auto added even\n        if explicitly excluded.\n\n        Actual call delegated to QuerySet.\n\n        :param columns: columns to exclude\n        :type columns: Union[List, str, Set, Dict]\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.exclude_fields(columns=columns)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n\n    def order_by(self, columns: Union[List, str, \"OrderAction\"]) -&gt; \"QuerysetProxy[T]\":\n        \"\"\"\n        With `order_by()` you can order the results from database based on your\n        choice of fields.\n\n        You can provide a string with field name or list of strings with fields names.\n\n        Ordering in sql will be applied in order of names you provide in order_by.\n\n        By default if you do not provide ordering `ormar` explicitly orders by\n        all primary keys\n\n        If you are sorting by nested models that causes that the result rows are\n        unsorted by the main model `ormar` will combine those children rows into\n        one main model.\n\n        The main model will never duplicate in the result\n\n        To order by main model field just provide a field name\n\n        To sort on nested models separate field names with dunder '__'.\n\n        You can sort this way across all relation types -&gt; `ForeignKey`,\n        reverse virtual FK and `ManyToMany` fields.\n\n        To sort in descending order provide a hyphen in front of the field name\n\n        Actual call delegated to QuerySet.\n\n        :param columns: columns by which models should be sorted\n        :type columns: Union[List, str]\n        :return: QuerysetProxy\n        :rtype: QuerysetProxy\n        \"\"\"\n        queryset = self.queryset.order_by(columns)\n        return self.__class__(\n            relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n        )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.queryset","title":"<code>queryset: QuerySet[T]</code>  <code>property</code> <code>writable</code>","text":"<p>Returns queryset if it's set, AttributeError otherwise. :return: QuerySet :rtype: QuerySet</p>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.all","title":"<code>all(*args, **kwargs)</code>  <code>async</code>","text":"<p>Returns all rows from a database for given model for set filter options.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).all()</code>.</p> <p>If there are no rows meeting the criteria an empty list is returned.</p> <p>Actual call delegated to QuerySet.</p> <p>List of related models is cleared before the call.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: list of returned models :rtype: List[Model]</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def all(self, *args: Any, **kwargs: Any) -&gt; List[\"T\"]:  # noqa: A003\n    \"\"\"\n    Returns all rows from a database for given model for set filter options.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).all()`.\n\n    If there are no rows meeting the criteria an empty list is returned.\n\n    Actual call delegated to QuerySet.\n\n    List of related models is cleared before the call.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: list of returned models\n    :rtype: List[Model]\n    \"\"\"\n    all_items = await self.queryset.all(*args, **kwargs)\n    self._clean_items_on_load()\n    self._register_related(all_items)\n    return all_items\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.avg","title":"<code>avg(columns)</code>  <code>async</code>","text":"<p>Returns avg value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: avg value of columns :rtype: Union[int, float, List]</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def avg(self, columns: Union[str, List[str]]) -&gt; Any:\n    \"\"\"\n    Returns avg value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: avg value of columns\n    :rtype: Union[int, float, List]\n    \"\"\"\n    return await self.queryset.avg(columns=columns)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.clear","title":"<code>clear(keep_reversed=True)</code>  <code>async</code>","text":"<p>Removes all related models from given relation.</p> <p>Removes all through models for m2m relation.</p> <p>For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation).</p> <p>:param keep_reversed: flag if reverse models in reverse FK should be deleted or not, keep_reversed=False deletes them from database. :type keep_reversed: bool :return: number of deleted models :rtype: int</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def clear(self, keep_reversed: bool = True) -&gt; int:\n    \"\"\"\n    Removes all related models from given relation.\n\n    Removes all through models for m2m relation.\n\n    For reverse FK relations keep_reversed flag marks if the reversed models\n    should be kept or deleted from the database too (False means that models\n    will be deleted, and not only removed from relation).\n\n    :param keep_reversed: flag if reverse models in reverse FK should be deleted\n    or not, keep_reversed=False deletes them from database.\n    :type keep_reversed: bool\n    :return: number of deleted models\n    :rtype: int\n    \"\"\"\n    if self.type_ == ormar.RelationType.MULTIPLE:\n        queryset = ormar.QuerySet(model_cls=self.relation.through)  # type: ignore\n        owner_column = self._owner.get_name()\n    else:\n        queryset = ormar.QuerySet(model_cls=self.relation.to)  # type: ignore\n        owner_column = self.related_field_name\n    kwargs = {owner_column: self._owner}\n    self._clean_items_on_load()\n    if keep_reversed and self.type_ == ormar.RelationType.REVERSE:\n        update_kwrgs = {f\"{owner_column}\": None}\n        return await queryset.filter(_exclude=False, **kwargs).update(\n            each=False, **update_kwrgs\n        )\n    return await queryset.delete(**kwargs)  # type: ignore\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.count","title":"<code>count(distinct=True)</code>  <code>async</code>","text":"<p>Returns number of rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before). If <code>distinct</code> is <code>True</code> (the default), this will return the number of primary rows selected. If <code>False</code>, the count will be the total number of rows returned (including extra rows for <code>one-to-many</code> or <code>many-to-many</code> left <code>select_related</code> table joins). <code>False</code> is the legacy (buggy) behavior for workflows that depend on it.</p> <p>Actual call delegated to QuerySet.</p> <p>:param distinct: flag if the primary table rows should be distinct or not :return: number of rows :rtype: int</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def count(self, distinct: bool = True) -&gt; int:\n    \"\"\"\n    Returns number of rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n    If `distinct` is `True` (the default), this will return\n    the number of primary rows selected. If `False`,\n    the count will be the total number of rows returned\n    (including extra rows for `one-to-many` or `many-to-many`\n    left `select_related` table joins).\n    `False` is the legacy (buggy) behavior for workflows that depend on it.\n\n    Actual call delegated to QuerySet.\n\n    :param distinct: flag if the primary table rows should be distinct or not\n    :return: number of rows\n    :rtype: int\n    \"\"\"\n    return await self.queryset.count(distinct=distinct)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.create","title":"<code>create(**kwargs)</code>  <code>async</code>","text":"<p>Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set).</p> <p>The allowed kwargs are <code>Model</code> fields names and proper value types.</p> <p>For m2m relation the through model is created automatically.</p> <p>Actual call delegated to QuerySet.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: created model :rtype: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Creates the model instance, saves it in a database and returns the updates model\n    (with pk populated if not passed and autoincrement is set).\n\n    The allowed kwargs are `Model` fields names and proper value types.\n\n    For m2m relation the through model is created automatically.\n\n    Actual call delegated to QuerySet.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: created model\n    :rtype: Model\n    \"\"\"\n    through_kwargs = kwargs.pop(self.through_model_name, {})\n    if self.type_ == ormar.RelationType.REVERSE:\n        kwargs[self.related_field_name] = self._owner\n    created = await self.queryset.create(**kwargs)\n    self._register_related(created)\n    if self.type_ == ormar.RelationType.MULTIPLE:\n        await self.create_through_instance(created, **through_kwargs)\n    return created\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.create_through_instance","title":"<code>create_through_instance(child, **kwargs)</code>  <code>async</code>","text":"<p>Crete a through model instance in the database for m2m relations.</p> <p>:param kwargs: dict of additional keyword arguments for through instance :type kwargs: Any :param child: child model instance :type child: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def create_through_instance(self, child: \"T\", **kwargs: Any) -&gt; None:\n    \"\"\"\n    Crete a through model instance in the database for m2m relations.\n\n    :param kwargs: dict of additional keyword arguments for through instance\n    :type kwargs: Any\n    :param child: child model instance\n    :type child: Model\n    \"\"\"\n    model_cls = self.relation.through\n    owner_column = self.related_field.default_target_field_name()  # type: ignore\n    child_column = self.related_field.default_source_field_name()  # type: ignore\n    rel_kwargs = {owner_column: self._owner.pk, child_column: child.pk}\n    final_kwargs = {**rel_kwargs, **kwargs}\n    if child.pk is None:\n        raise ModelPersistenceError(\n            f\"You cannot save {child.get_name()} \"\n            f\"model without primary key set! \\n\"\n            f\"Save the child model first.\"\n        )\n    await model_cls(**final_kwargs).save()\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.delete_through_instance","title":"<code>delete_through_instance(child)</code>  <code>async</code>","text":"<p>Removes through model instance from the database for m2m relations.</p> <p>:param child: child model instance :type child: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def delete_through_instance(self, child: \"T\") -&gt; None:\n    \"\"\"\n    Removes through model instance from the database for m2m relations.\n\n    :param child: child model instance\n    :type child: Model\n    \"\"\"\n    queryset = ormar.QuerySet(model_cls=self.relation.through)  # type: ignore\n    owner_column = self.related_field.default_target_field_name()  # type: ignore\n    child_column = self.related_field.default_source_field_name()  # type: ignore\n    kwargs = {owner_column: self._owner, child_column: child}\n    link_instance = await queryset.filter(**kwargs).get()  # type: ignore\n    await link_instance.delete()\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.exclude","title":"<code>exclude(*args, **kwargs)</code>","text":"<p>Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition.</p> <p>So if you use <code>filter(name='John')</code> which is <code>where name = 'John'</code> in SQL, the <code>exclude(name='John')</code> equals to <code>where name &lt;&gt; 'John'</code></p> <p>Note that all conditions are joined so if you pass multiple values it becomes a union of conditions.</p> <p><code>exclude(name='John', age&gt;=35)</code> will become <code>where not (name='John' and age&gt;=35)</code></p> <p>Actual call delegated to QuerySet.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def exclude(\n    self, *args: Any, **kwargs: Any\n) -&gt; \"QuerysetProxy[T]\":  # noqa: A003, A001\n    \"\"\"\n    Works exactly the same as filter and all modifiers (suffixes) are the same,\n    but returns a *not* condition.\n\n    So if you use `filter(name='John')` which is `where name = 'John'` in SQL,\n    the `exclude(name='John')` equals to `where name &lt;&gt; 'John'`\n\n    Note that all conditions are joined so if you pass multiple values it\n    becomes a union of conditions.\n\n    `exclude(name='John', age&gt;=35)` will become\n    `where not (name='John' and age&gt;=35)`\n\n    Actual call delegated to QuerySet.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.exclude(*args, **kwargs)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.exclude_fields","title":"<code>exclude_fields(columns)</code>","text":"<p>With <code>exclude_fields()</code> you can select subset of model columns that will be excluded to limit the data load.</p> <p>It's the opposite of <code>fields()</code> method so check documentation above to see what options are available.</p> <p>Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if explicitly excluded.</p> <p>Actual call delegated to QuerySet.</p> <p>:param columns: columns to exclude :type columns: Union[List, str, Set, Dict] :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def exclude_fields(\n    self, columns: Union[List, str, Set, Dict]\n) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    With `exclude_fields()` you can select subset of model columns that will\n    be excluded to limit the data load.\n\n    It's the opposite of `fields()` method so check documentation above\n    to see what options are available.\n\n    Especially check above how you can pass also nested dictionaries\n    and sets as a mask to exclude fields from whole hierarchy.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related` models\n    (with nested notation).\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n    to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even\n    if explicitly excluded.\n\n    Actual call delegated to QuerySet.\n\n    :param columns: columns to exclude\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.exclude_fields(columns=columns)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.exists","title":"<code>exists()</code>  <code>async</code>","text":"<p>Returns a bool value to confirm if there are rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set).</p> <p>Actual call delegated to QuerySet.</p> <p>:return: result of the check :rtype: bool</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def exists(self) -&gt; bool:\n    \"\"\"\n    Returns a bool value to confirm if there are rows matching the given criteria\n    (applied with `filter` and `exclude` if set).\n\n    Actual call delegated to QuerySet.\n\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return await self.queryset.exists()\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.fields","title":"<code>fields(columns)</code>","text":"<p>With <code>fields()</code> you can select subset of model columns to limit the data load.</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>You can select specified fields by passing a <code>str, List[str], Set[str] or dict</code> with nested definition.</p> <p>To include related models use notation <code>{related_name}__{column}[__{optional_next} etc.]</code>.</p> <p><code>fields()</code> can be called several times, building up the columns to select.</p> <p>If you include related models into <code>select_related()</code> call but you won't specify columns for those models in fields - implies a list of all fields for those nested models.</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>,  to exclude a field it has to be nullable.</p> <p>Pk column cannot be excluded - it's always auto added even if not explicitly included.</p> <p>You can also pass fields to include as dictionary or set.</p> <p>To mark a field as included in a dictionary use it's name as key and ellipsis as value.</p> <p>To traverse nested models use nested dictionaries.</p> <p>To include fields at last level instead of nested dictionary a set can be used.</p> <p>To include whole nested model specify model related field name and ellipsis.</p> <p>Actual call delegated to QuerySet.</p> <p>:param columns: columns to include :type columns: Union[List, str, Set, Dict] :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def fields(self, columns: Union[List, str, Set, Dict]) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    With `fields()` you can select subset of model columns to limit the data load.\n\n    Note that `fields()` and `exclude_fields()` works both for main models\n    (on normal queries like `get`, `all` etc.)\n    as well as `select_related` and `prefetch_related`\n    models (with nested notation).\n\n    You can select specified fields by passing a `str, List[str], Set[str] or\n    dict` with nested definition.\n\n    To include related models use notation\n    `{related_name}__{column}[__{optional_next} etc.]`.\n\n    `fields()` can be called several times, building up the columns to select.\n\n    If you include related models into `select_related()` call but you won't specify\n    columns for those models in fields - implies a list of all fields for\n    those nested models.\n\n    Mandatory fields cannot be excluded as it will raise `ValidationError`,\n     to exclude a field it has to be nullable.\n\n    Pk column cannot be excluded - it's always auto added even if\n    not explicitly included.\n\n    You can also pass fields to include as dictionary or set.\n\n    To mark a field as included in a dictionary use it's name as key\n    and ellipsis as value.\n\n    To traverse nested models use nested dictionaries.\n\n    To include fields at last level instead of nested dictionary a set can be used.\n\n    To include whole nested model specify model related field name and ellipsis.\n\n    Actual call delegated to QuerySet.\n\n    :param columns: columns to include\n    :type columns: Union[List, str, Set, Dict]\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.fields(columns)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.filter","title":"<code>filter(*args, **kwargs)</code>","text":"<p>Allows you to filter by any <code>Model</code> attribute/field as well as to fetch instances, with a filter across an FK relationship.</p> <p>You can use special filter suffix to change the filter operands:</p> <ul> <li>exact - like <code>album__name__exact='Malibu'</code> (exact match)</li> <li>iexact - like <code>album__name__iexact='malibu'</code> (exact match case insensitive)</li> <li>contains - like <code>album__name__contains='Mal'</code> (sql like)</li> <li>icontains - like <code>album__name__icontains='mal'</code> (sql like case insensitive)</li> <li>in - like <code>album__name__in=['Malibu', 'Barclay']</code> (sql in)</li> <li>isnull - like <code>album__name__isnull=True</code> (sql is null)    (isnotnull <code>album__name__isnull=False</code> (sql is not null))</li> <li>gt - like <code>position__gt=3</code> (sql &gt;)</li> <li>gte - like <code>position__gte=3</code> (sql &gt;=)</li> <li>lt - like <code>position__lt=3</code> (sql &lt;)</li> <li>lte - like <code>position__lte=3</code> (sql &lt;=)</li> <li>startswith - like <code>album__name__startswith='Mal'</code> (exact start match)</li> <li>istartswith - like <code>album__name__istartswith='mal'</code> (case insensitive)</li> <li>endswith - like <code>album__name__endswith='ibu'</code> (exact end match)</li> <li>iendswith - like <code>album__name__iendswith='IBU'</code> (case insensitive)</li> </ul> <p>Actual call delegated to QuerySet.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: filtered QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def filter(  # noqa: A003, A001\n    self, *args: Any, **kwargs: Any\n) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    Allows you to filter by any `Model` attribute/field\n    as well as to fetch instances, with a filter across an FK relationship.\n\n    You can use special filter suffix to change the filter operands:\n\n    *  exact - like `album__name__exact='Malibu'` (exact match)\n    *  iexact - like `album__name__iexact='malibu'` (exact match case insensitive)\n    *  contains - like `album__name__contains='Mal'` (sql like)\n    *  icontains - like `album__name__icontains='mal'` (sql like case insensitive)\n    *  in - like `album__name__in=['Malibu', 'Barclay']` (sql in)\n    *  isnull - like `album__name__isnull=True` (sql is null)\n       (isnotnull `album__name__isnull=False` (sql is not null))\n    *  gt - like `position__gt=3` (sql &gt;)\n    *  gte - like `position__gte=3` (sql &gt;=)\n    *  lt - like `position__lt=3` (sql &lt;)\n    *  lte - like `position__lte=3` (sql &lt;=)\n    *  startswith - like `album__name__startswith='Mal'` (exact start match)\n    *  istartswith - like `album__name__istartswith='mal'` (case insensitive)\n    *  endswith - like `album__name__endswith='ibu'` (exact end match)\n    *  iendswith - like `album__name__iendswith='IBU'` (case insensitive)\n\n    Actual call delegated to QuerySet.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: filtered QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.filter(*args, **kwargs)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.first","title":"<code>first(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db ordered by primary key column ascending.</p> <p>Actual call delegated to QuerySet.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).first()</code>.</p> <p>List of related models is cleared before the call.</p> <p>:param kwargs: :type kwargs: :return: :rtype: _asyncio.Future</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def first(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Gets the first row from the db ordered by primary key column ascending.\n\n    Actual call delegated to QuerySet.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).first()`.\n\n    List of related models is cleared before the call.\n\n    :param kwargs:\n    :type kwargs:\n    :return:\n    :rtype: _asyncio.Future\n    \"\"\"\n    first = await self.queryset.first(*args, **kwargs)\n    self._clean_items_on_load()\n    self._register_related(first)\n    return first\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.get","title":"<code>get(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).get()</code>.</p> <p>Actual call delegated to QuerySet.</p> <p>List of related models is cleared before the call.</p> <p>:raises NoMatch: if no rows are returned :raises MultipleMatches: if more than 1 row is returned. :param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def get(self, *args: Any, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).get()`.\n\n    Actual call delegated to QuerySet.\n\n    List of related models is cleared before the call.\n\n    :raises NoMatch: if no rows are returned\n    :raises MultipleMatches: if more than 1 row is returned.\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    get = await self.queryset.get(*args, **kwargs)\n    self._clean_items_on_load()\n    self._register_related(get)\n    return get\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.get_or_create","title":"<code>get_or_create(_defaults=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Combination of create and get methods.</p> <p>Tries to get a row meeting the criteria for kwargs and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :param _defaults: default values for creating object :type _defaults: Optional[Dict[str, Any]] :return: model instance and a boolean :rtype: Tuple(\"T\", bool)</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def get_or_create(\n    self,\n    _defaults: Optional[Dict[str, Any]] = None,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Tuple[\"T\", bool]:\n    \"\"\"\n    Combination of create and get methods.\n\n    Tries to get a row meeting the criteria for kwargs\n    and if `NoMatch` exception is raised\n    it creates a new one with given kwargs and _defaults.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :param _defaults: default values for creating object\n    :type _defaults: Optional[Dict[str, Any]]\n    :return: model instance and a boolean\n    :rtype: Tuple(\"T\", bool)\n    \"\"\"\n    try:\n        return await self.get(*args, **kwargs), False\n    except NoMatch:\n        _defaults = _defaults or {}\n        return await self.create(**{**kwargs, **_defaults}), True\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.get_or_none","title":"<code>get_or_none(*args, **kwargs)</code>  <code>async</code>","text":"<p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).get_or_none()</code>.</p> <p>If not match is found None will be returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: returned model :rtype: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def get_or_none(self, *args: Any, **kwargs: Any) -&gt; Optional[\"T\"]:\n    \"\"\"\n    Gets the first row from the db meeting the criteria set by kwargs.\n\n    If no criteria set it will return the last row in db sorted by pk.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).get_or_none()`.\n\n    If not match is found None will be returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: returned model\n    :rtype: Model\n    \"\"\"\n    try:\n        get = await self.queryset.get(*args, **kwargs)\n    except ormar.NoMatch:\n        return None\n\n    self._clean_items_on_load()\n    self._register_related(get)\n    return get\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.iterate","title":"<code>iterate(*args, **kwargs)</code>  <code>async</code>","text":"<p>Return async iterable generator for all rows from a database for given model.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).iterate()</code>.</p> <p>If there are no rows meeting the criteria an empty async generator is returned.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: asynchronous iterable generator of returned models :rtype: AsyncGenerator[Model]</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def iterate(  # noqa: A003\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; AsyncGenerator[\"T\", None]:\n    \"\"\"\n    Return async iterable generator for all rows from a database for given model.\n\n    Passing args and/or kwargs is a shortcut and equals to calling\n    `filter(*args, **kwargs).iterate()`.\n\n    If there are no rows meeting the criteria an empty async generator is returned.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: asynchronous iterable generator of returned models\n    :rtype: AsyncGenerator[Model]\n    \"\"\"\n\n    async for item in self.queryset.iterate(*args, **kwargs):\n        yield item\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.limit","title":"<code>limit(limit_count)</code>","text":"<p>You can limit the results to desired number of parent models.</p> <p>Actual call delegated to QuerySet.</p> <p>:param limit_count: number of models to limit :type limit_count: int :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def limit(self, limit_count: int) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    You can limit the results to desired number of parent models.\n\n    Actual call delegated to QuerySet.\n\n    :param limit_count: number of models to limit\n    :type limit_count: int\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.limit(limit_count)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.max","title":"<code>max(columns)</code>  <code>async</code>","text":"<p>Returns max value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: max value of column(s) :rtype: Any</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def max(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns max value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: max value of column(s)\n    :rtype: Any\n    \"\"\"\n    return await self.queryset.max(columns=columns)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.min","title":"<code>min(columns)</code>  <code>async</code>","text":"<p>Returns min value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: min value of column(s) :rtype: Any</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def min(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns min value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: min value of column(s)\n    :rtype: Any\n    \"\"\"\n    return await self.queryset.min(columns=columns)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.offset","title":"<code>offset(offset)</code>","text":"<p>You can also offset the results by desired number of main models.</p> <p>Actual call delegated to QuerySet.</p> <p>:param offset: numbers of models to offset :type offset: int :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def offset(self, offset: int) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    You can also offset the results by desired number of main models.\n\n    Actual call delegated to QuerySet.\n\n    :param offset: numbers of models to offset\n    :type offset: int\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.offset(offset)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.order_by","title":"<code>order_by(columns)</code>","text":"<p>With <code>order_by()</code> you can order the results from database based on your choice of fields.</p> <p>You can provide a string with field name or list of strings with fields names.</p> <p>Ordering in sql will be applied in order of names you provide in order_by.</p> <p>By default if you do not provide ordering <code>ormar</code> explicitly orders by all primary keys</p> <p>If you are sorting by nested models that causes that the result rows are unsorted by the main model <code>ormar</code> will combine those children rows into one main model.</p> <p>The main model will never duplicate in the result</p> <p>To order by main model field just provide a field name</p> <p>To sort on nested models separate field names with dunder '__'.</p> <p>You can sort this way across all relation types -&gt; <code>ForeignKey</code>, reverse virtual FK and <code>ManyToMany</code> fields.</p> <p>To sort in descending order provide a hyphen in front of the field name</p> <p>Actual call delegated to QuerySet.</p> <p>:param columns: columns by which models should be sorted :type columns: Union[List, str] :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def order_by(self, columns: Union[List, str, \"OrderAction\"]) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    With `order_by()` you can order the results from database based on your\n    choice of fields.\n\n    You can provide a string with field name or list of strings with fields names.\n\n    Ordering in sql will be applied in order of names you provide in order_by.\n\n    By default if you do not provide ordering `ormar` explicitly orders by\n    all primary keys\n\n    If you are sorting by nested models that causes that the result rows are\n    unsorted by the main model `ormar` will combine those children rows into\n    one main model.\n\n    The main model will never duplicate in the result\n\n    To order by main model field just provide a field name\n\n    To sort on nested models separate field names with dunder '__'.\n\n    You can sort this way across all relation types -&gt; `ForeignKey`,\n    reverse virtual FK and `ManyToMany` fields.\n\n    To sort in descending order provide a hyphen in front of the field name\n\n    Actual call delegated to QuerySet.\n\n    :param columns: columns by which models should be sorted\n    :type columns: Union[List, str]\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.order_by(columns)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.paginate","title":"<code>paginate(page, page_size=20)</code>","text":"<p>You can paginate the result which is a combination of offset and limit clauses. Limit is set to page size and offset is set to (page-1) * page_size.</p> <p>Actual call delegated to QuerySet.</p> <p>:param page_size: numbers of items per page :type page_size: int :param page: page number :type page: int :return: QuerySet :rtype: QuerySet</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def paginate(self, page: int, page_size: int = 20) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    You can paginate the result which is a combination of offset and limit clauses.\n    Limit is set to page size and offset is set to (page-1) * page_size.\n\n    Actual call delegated to QuerySet.\n\n    :param page_size: numbers of items per page\n    :type page_size: int\n    :param page: page number\n    :type page: int\n    :return: QuerySet\n    :rtype: QuerySet\n    \"\"\"\n    queryset = self.queryset.paginate(page=page, page_size=page_size)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.prefetch_related","title":"<code>prefetch_related(related)</code>","text":"<p>Allows to prefetch related models during query - but opposite to <code>select_related</code> each subsequent model is fetched in a separate database query.</p> <p>With <code>prefetch_related</code> always one query per Model is run against the database, meaning that you will have multiple queries executed one after another.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>Actual call delegated to QuerySet.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def prefetch_related(self, related: Union[List, str]) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    Allows to prefetch related models during query - but opposite to\n    `select_related` each subsequent model is fetched in a separate database query.\n\n    **With `prefetch_related` always one query per Model is run against the\n    database**, meaning that you will have multiple queries executed one\n    after another.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    Actual call delegated to QuerySet.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.prefetch_related(related)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.select_all","title":"<code>select_all(follow=False)</code>","text":"<p>By default adds only directly related models.</p> <p>If follow=True is set it adds also related models of related models.</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>:param follow: flag to trigger deep save - by default only directly related models are saved with follow=True also related models of related models are saved :type follow: bool :return: reloaded Model :rtype: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def select_all(self, follow: bool = False) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    By default adds only directly related models.\n\n    If follow=True is set it adds also related models of related models.\n\n    To not get stuck in an infinite loop as related models also keep a relation\n    to parent model visited models set is kept.\n\n    That way already visited models that are nested are loaded, but the load do not\n    follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X\n    will load second Model A but will never follow into Model X.\n    Nested relations of those kind need to be loaded manually.\n\n    :param follow: flag to trigger deep save -\n    by default only directly related models are saved\n    with follow=True also related models of related models are saved\n    :type follow: bool\n    :return: reloaded Model\n    :rtype: Model\n    \"\"\"\n    queryset = self.queryset.select_all(follow=follow)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.select_related","title":"<code>select_related(related)</code>","text":"<p>Allows to prefetch related models during the same query.</p> <p>With <code>select_related</code> always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>Actual call delegated to QuerySet.</p> <p>:param related: list of relation field names, can be linked by '__' to nest :type related: Union[List, str] :return: QuerysetProxy :rtype: QuerysetProxy</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>def select_related(self, related: Union[List, str]) -&gt; \"QuerysetProxy[T]\":\n    \"\"\"\n    Allows to prefetch related models during the same query.\n\n    **With `select_related` always only one query is run against the database**,\n    meaning that one (sometimes complicated) join is generated and later nested\n    models are processed in python.\n\n    To fetch related model use `ForeignKey` names.\n\n    To chain related `Models` relation use double underscores between names.\n\n    Actual call delegated to QuerySet.\n\n    :param related: list of relation field names, can be linked by '__' to nest\n    :type related: Union[List, str]\n    :return: QuerysetProxy\n    :rtype: QuerysetProxy\n    \"\"\"\n    queryset = self.queryset.select_related(related)\n    return self.__class__(\n        relation=self.relation, type_=self.type_, to=self.to, qryset=queryset\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.sum","title":"<code>sum(columns)</code>  <code>async</code>","text":"<p>Returns sum value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>:return: sum value of columns :rtype: int</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def sum(self, columns: Union[str, List[str]]) -&gt; Any:  # noqa: A003\n    \"\"\"\n    Returns sum value of columns for rows matching the given criteria\n    (applied with `filter` and `exclude` if set before).\n\n    :return: sum value of columns\n    :rtype: int\n    \"\"\"\n    return await self.queryset.sum(columns=columns)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.update","title":"<code>update(each=False, **kwargs)</code>  <code>async</code>","text":"<p>Updates the model table after applying the filters from kwargs.</p> <p>You have to either pass a filter to narrow down a query or explicitly pass each=True flag to affect whole table.</p> <p>:param each: flag if whole table should be affected if no filter is passed :type each: bool :param kwargs: fields names and proper value types :type kwargs: Any :return: number of updated rows :rtype: int</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def update(self, each: bool = False, **kwargs: Any) -&gt; int:\n    \"\"\"\n    Updates the model table after applying the filters from kwargs.\n\n    You have to either pass a filter to narrow down a query or explicitly pass\n    each=True flag to affect whole table.\n\n    :param each: flag if whole table should be affected if no filter is passed\n    :type each: bool\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: number of updated rows\n    :rtype: int\n    \"\"\"\n    # queryset proxy always have one filter for pk of parent model\n    if (\n        not each\n        and (len(self.queryset.filter_clauses) + len(self.queryset.exclude_clauses))\n        == 1\n    ):\n        raise QueryDefinitionError(\n            \"You cannot update without filtering the queryset first. \"\n            \"If you want to update all rows use update(each=True, **kwargs)\"\n        )\n\n    through_kwargs = kwargs.pop(self.through_model_name, {})\n    children = await self.queryset.all()\n    for child in children:\n        await child.update(**kwargs)  # type: ignore\n        if self.type_ == ormar.RelationType.MULTIPLE and through_kwargs:\n            await self.update_through_instance(\n                child=child, **through_kwargs  # type: ignore\n            )\n    return len(children)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.update_or_create","title":"<code>update_or_create(**kwargs)</code>  <code>async</code>","text":"<p>Updates the model, or in case there is no match in database creates a new one.</p> <p>Actual call delegated to QuerySet.</p> <p>:param kwargs: fields names and proper value types :type kwargs: Any :return: updated or created model :rtype: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def update_or_create(self, **kwargs: Any) -&gt; \"T\":\n    \"\"\"\n    Updates the model, or in case there is no match in database creates a new one.\n\n    Actual call delegated to QuerySet.\n\n    :param kwargs: fields names and proper value types\n    :type kwargs: Any\n    :return: updated or created model\n    :rtype: Model\n    \"\"\"\n    pk_name = self.queryset.model_config.pkname\n    if \"pk\" in kwargs:\n        kwargs[pk_name] = kwargs.pop(\"pk\")\n    if pk_name not in kwargs or kwargs.get(pk_name) is None:\n        return await self.create(**kwargs)\n    model = await self.queryset.get(pk=kwargs[pk_name])\n    return await model.update(**kwargs)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.update_through_instance","title":"<code>update_through_instance(child, **kwargs)</code>  <code>async</code>","text":"<p>Updates a through model instance in the database for m2m relations.</p> <p>:param kwargs: dict of additional keyword arguments for through instance :type kwargs: Any :param child: child model instance :type child: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def update_through_instance(self, child: \"T\", **kwargs: Any) -&gt; None:\n    \"\"\"\n    Updates a through model instance in the database for m2m relations.\n\n    :param kwargs: dict of additional keyword arguments for through instance\n    :type kwargs: Any\n    :param child: child model instance\n    :type child: Model\n    \"\"\"\n    model_cls = self.relation.through\n    owner_column = self.related_field.default_target_field_name()  # type: ignore\n    child_column = self.related_field.default_source_field_name()  # type: ignore\n    rel_kwargs = {owner_column: self._owner.pk, child_column: child.pk}\n    through_model = await model_cls.objects.get(**rel_kwargs)\n    await through_model.update(**kwargs)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.upsert_through_instance","title":"<code>upsert_through_instance(child, **kwargs)</code>  <code>async</code>","text":"<p>Updates a through model instance in the database for m2m relations if it already exists, else creates one.</p> <p>:param kwargs: dict of additional keyword arguments for through instance :type kwargs: Any :param child: child model instance :type child: Model</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def upsert_through_instance(self, child: \"T\", **kwargs: Any) -&gt; None:\n    \"\"\"\n    Updates a through model instance in the database for m2m relations if\n    it already exists, else creates one.\n\n    :param kwargs: dict of additional keyword arguments for through instance\n    :type kwargs: Any\n    :param child: child model instance\n    :type child: Model\n    \"\"\"\n    try:\n        await self.update_through_instance(child=child, **kwargs)\n    except NoMatch:\n        await self.create_through_instance(child=child, **kwargs)\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.values","title":"<code>values(fields=None, exclude_through=False)</code>  <code>async</code>","text":"<p>Return a list of dictionaries with column values in order of the fields passed or all fields from queried models.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param fields: field name or list of field names to extract from db :type fields:  Union[List, str, Set, Dict]</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def values(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    exclude_through: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of dictionaries with column values in order of the fields\n    passed or all fields from queried models.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields:  Union[List, str, Set, Dict]\n    \"\"\"\n    return await self.queryset.values(\n        fields=fields, exclude_through=exclude_through\n    )\n</code></pre>"},{"location":"api/relations/querysetproxy/#ormar.relations.querysetproxy.QuerysetProxy.values_list","title":"<code>values_list(fields=None, flatten=False, exclude_through=False)</code>  <code>async</code>","text":"<p>Return a list of tuples with column values in order of the fields passed or all fields from queried models.</p> <p>When one field is passed you can flatten the list of tuples into list of values of that single field.</p> <p>To filter for given row use filter/exclude methods before values, to limit number of rows use limit/offset or paginate before values.</p> <p>Note that it always return a list even for one row from database.</p> <p>:param exclude_through: flag if through models should be excluded :type exclude_through: bool :param fields: field name or list of field names to extract from db :type fields: Union[str, List[str]] :param flatten: when one field is passed you can flatten the list of tuples :type flatten: bool</p> Source code in <code>ormar/relations/querysetproxy.py</code> <pre><code>async def values_list(\n    self,\n    fields: Union[List, str, Set, Dict, None] = None,\n    flatten: bool = False,\n    exclude_through: bool = False,\n) -&gt; List:\n    \"\"\"\n    Return a list of tuples with column values in order of the fields passed or\n    all fields from queried models.\n\n    When one field is passed you can flatten the list of tuples into list of values\n    of that single field.\n\n    To filter for given row use filter/exclude methods before values,\n    to limit number of rows use limit/offset or paginate before values.\n\n    Note that it always return a list even for one row from database.\n\n    :param exclude_through: flag if through models should be excluded\n    :type exclude_through: bool\n    :param fields: field name or list of field names to extract from db\n    :type fields: Union[str, List[str]]\n    :param flatten: when one field is passed you can flatten the list of tuples\n    :type flatten: bool\n    \"\"\"\n    return await self.queryset.values(\n        fields=fields,\n        exclude_through=exclude_through,\n        _as_dict=False,\n        _flatten=flatten,\n    )\n</code></pre>"},{"location":"api/relations/relation/","title":"relation","text":""},{"location":"api/relations/relation/#ormar.relations.relation.Relation","title":"<code>Relation</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Keeps related Models and handles adding/removing of the children.</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>class Relation(Generic[T]):\n    \"\"\"\n    Keeps related Models and handles adding/removing of the children.\n    \"\"\"\n\n    def __init__(\n        self,\n        manager: \"RelationsManager\",\n        type_: RelationType,\n        field_name: str,\n        to: Type[\"T\"],\n        through: Optional[Type[\"Model\"]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Relation and keep the related models either as instances of\n        passed Model, or as a RelationProxy which is basically a list of models with\n        some special behavior, as it exposes QuerySetProxy and allows querying the\n        related models already pre filtered by parent model.\n\n        :param manager: reference to relation manager\n        :type manager: RelationsManager\n        :param type_: type of the relation\n        :type type_: RelationType\n        :param field_name: name of the relation field\n        :type field_name: str\n        :param to: model to which relation leads to\n        :type to: Type[Model]\n        :param through: model through which relation goes for m2m relations\n        :type through: Type[Model]\n        \"\"\"\n        self.manager = manager\n        self._owner: \"Model\" = manager.owner\n        self._type: RelationType = type_\n        self._to_remove: Set = set()\n        self.to: Type[\"T\"] = to\n        self._through = through\n        self.field_name: str = field_name\n        self.related_models: Optional[Union[RelationProxy, \"Model\"]] = (\n            RelationProxy(relation=self, type_=type_, to=to, field_name=field_name)\n            if type_ in (RelationType.REVERSE, RelationType.MULTIPLE)\n            else None\n        )\n\n    def clear(self) -&gt; None:\n        if self._type in (RelationType.PRIMARY, RelationType.THROUGH):\n            self.related_models = None\n            self._owner.__dict__[self.field_name] = None\n        elif self.related_models is not None:\n            related_models = cast(\"RelationProxy\", self.related_models)\n            related_models._clear()\n            self._owner.__dict__[self.field_name] = None\n\n    @property\n    def through(self) -&gt; Type[\"Model\"]:\n        if not self._through:  # pragma: no cover\n            raise RelationshipInstanceError(\"Relation does not have through model!\")\n        return self._through\n\n    def _clean_related(self) -&gt; None:\n        \"\"\"\n        Removes dead weakrefs from RelationProxy.\n        \"\"\"\n        cleaned_data = [\n            x\n            for i, x in enumerate(self.related_models)  # type: ignore\n            if i not in self._to_remove\n        ]\n        self.related_models = RelationProxy(\n            relation=self,\n            type_=self._type,\n            to=self.to,\n            field_name=self.field_name,\n            data_=cleaned_data,\n        )\n        relation_name = self.field_name\n        self._owner.__dict__[relation_name] = cleaned_data\n        self._to_remove = set()\n\n    def _find_existing(\n        self, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]\n    ) -&gt; Optional[int]:\n        \"\"\"\n        Find child model in RelationProxy if exists.\n\n        :param child: child model to find\n        :type child: Model\n        :return: index of child in RelationProxy\n        :rtype: Optional[ind]\n        \"\"\"\n        if not isinstance(self.related_models, RelationProxy):  # pragma nocover\n            raise ValueError(\"Cannot find existing models in parent relation type\")\n\n        if child not in self.related_models:\n            return None\n        else:\n            # We need to clear the weakrefs that don't point to anything anymore\n            # There's an assumption here that if some of the related models\n            # went out of scope, then they all did, so we can just check the first one\n            try:\n                self.related_models[0].__repr__.__self__\n                return self.related_models.index(child)\n            except ReferenceError:\n                missing = self.related_models._get_list_of_missing_weakrefs()\n                self._to_remove.update(missing)\n            return self.related_models.index(child)\n\n    def add(self, child: \"Model\") -&gt; None:\n        \"\"\"\n        Adds child Model to relation, either sets child as related model or adds\n        it to the list in RelationProxy depending on relation type.\n\n        :param child: model to add to relation\n        :type child: Model\n        \"\"\"\n        relation_name = self.field_name\n        if self._type in (RelationType.PRIMARY, RelationType.THROUGH):\n            self.related_models = child\n            self._owner.__dict__[relation_name] = child\n        else:\n            if self._find_existing(child) is None:\n                self.related_models.append(child)  # type: ignore\n                rel = self._owner.__dict__.get(relation_name, [])\n                rel = rel or []\n                if not isinstance(rel, list):\n                    rel = [rel]\n                self._populate_owner_side_dict(rel=rel, child=child)\n                self._owner.__dict__[relation_name] = rel\n\n    def _populate_owner_side_dict(self, rel: List[\"Model\"], child: \"Model\") -&gt; None:\n        try:\n            if child not in rel:\n                rel.append(child)\n        except ReferenceError:\n            rel.clear()\n            rel.append(child)\n\n    def remove(self, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]) -&gt; None:\n        \"\"\"\n        Removes child Model from relation, either sets None as related model or removes\n        it from the list in RelationProxy depending on relation type.\n\n        :param child: model to remove from relation\n        :type child: Model\n        \"\"\"\n        relation_name = self.field_name\n        if self._type == RelationType.PRIMARY:\n            if self.related_models == child:\n                self.related_models = None\n                del self._owner.__dict__[relation_name]\n        else:\n            position = self._find_existing(child)\n            if position is not None:\n                self.related_models.pop(position)  # type: ignore\n                del self._owner.__dict__[relation_name][position]\n\n    def get(self) -&gt; Optional[Union[List[\"Model\"], \"Model\"]]:\n        \"\"\"\n        Return the related model or models from RelationProxy.\n\n        :return: related model/models if set\n        :rtype: Optional[Union[List[Model], Model]]\n        \"\"\"\n        if self._to_remove:\n            self._clean_related()\n        return self.related_models\n\n    def __repr__(self) -&gt; str:  # pragma no cover\n        if self._to_remove:\n            self._clean_related()\n        return str(self.related_models)\n</code></pre>"},{"location":"api/relations/relation/#ormar.relations.relation.Relation.__init__","title":"<code>__init__(manager, type_, field_name, to, through=None)</code>","text":"<p>Initialize the Relation and keep the related models either as instances of passed Model, or as a RelationProxy which is basically a list of models with some special behavior, as it exposes QuerySetProxy and allows querying the related models already pre filtered by parent model.</p> <p>:param manager: reference to relation manager :type manager: RelationsManager :param type_: type of the relation :type type_: RelationType :param field_name: name of the relation field :type field_name: str :param to: model to which relation leads to :type to: Type[Model] :param through: model through which relation goes for m2m relations :type through: Type[Model]</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def __init__(\n    self,\n    manager: \"RelationsManager\",\n    type_: RelationType,\n    field_name: str,\n    to: Type[\"T\"],\n    through: Optional[Type[\"Model\"]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Relation and keep the related models either as instances of\n    passed Model, or as a RelationProxy which is basically a list of models with\n    some special behavior, as it exposes QuerySetProxy and allows querying the\n    related models already pre filtered by parent model.\n\n    :param manager: reference to relation manager\n    :type manager: RelationsManager\n    :param type_: type of the relation\n    :type type_: RelationType\n    :param field_name: name of the relation field\n    :type field_name: str\n    :param to: model to which relation leads to\n    :type to: Type[Model]\n    :param through: model through which relation goes for m2m relations\n    :type through: Type[Model]\n    \"\"\"\n    self.manager = manager\n    self._owner: \"Model\" = manager.owner\n    self._type: RelationType = type_\n    self._to_remove: Set = set()\n    self.to: Type[\"T\"] = to\n    self._through = through\n    self.field_name: str = field_name\n    self.related_models: Optional[Union[RelationProxy, \"Model\"]] = (\n        RelationProxy(relation=self, type_=type_, to=to, field_name=field_name)\n        if type_ in (RelationType.REVERSE, RelationType.MULTIPLE)\n        else None\n    )\n</code></pre>"},{"location":"api/relations/relation/#ormar.relations.relation.Relation.add","title":"<code>add(child)</code>","text":"<p>Adds child Model to relation, either sets child as related model or adds it to the list in RelationProxy depending on relation type.</p> <p>:param child: model to add to relation :type child: Model</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def add(self, child: \"Model\") -&gt; None:\n    \"\"\"\n    Adds child Model to relation, either sets child as related model or adds\n    it to the list in RelationProxy depending on relation type.\n\n    :param child: model to add to relation\n    :type child: Model\n    \"\"\"\n    relation_name = self.field_name\n    if self._type in (RelationType.PRIMARY, RelationType.THROUGH):\n        self.related_models = child\n        self._owner.__dict__[relation_name] = child\n    else:\n        if self._find_existing(child) is None:\n            self.related_models.append(child)  # type: ignore\n            rel = self._owner.__dict__.get(relation_name, [])\n            rel = rel or []\n            if not isinstance(rel, list):\n                rel = [rel]\n            self._populate_owner_side_dict(rel=rel, child=child)\n            self._owner.__dict__[relation_name] = rel\n</code></pre>"},{"location":"api/relations/relation/#ormar.relations.relation.Relation.get","title":"<code>get()</code>","text":"<p>Return the related model or models from RelationProxy.</p> <p>:return: related model/models if set :rtype: Optional[Union[List[Model], Model]]</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def get(self) -&gt; Optional[Union[List[\"Model\"], \"Model\"]]:\n    \"\"\"\n    Return the related model or models from RelationProxy.\n\n    :return: related model/models if set\n    :rtype: Optional[Union[List[Model], Model]]\n    \"\"\"\n    if self._to_remove:\n        self._clean_related()\n    return self.related_models\n</code></pre>"},{"location":"api/relations/relation/#ormar.relations.relation.Relation.remove","title":"<code>remove(child)</code>","text":"<p>Removes child Model from relation, either sets None as related model or removes it from the list in RelationProxy depending on relation type.</p> <p>:param child: model to remove from relation :type child: Model</p> Source code in <code>ormar/relations/relation.py</code> <pre><code>def remove(self, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]) -&gt; None:\n    \"\"\"\n    Removes child Model from relation, either sets None as related model or removes\n    it from the list in RelationProxy depending on relation type.\n\n    :param child: model to remove from relation\n    :type child: Model\n    \"\"\"\n    relation_name = self.field_name\n    if self._type == RelationType.PRIMARY:\n        if self.related_models == child:\n            self.related_models = None\n            del self._owner.__dict__[relation_name]\n    else:\n        position = self._find_existing(child)\n        if position is not None:\n            self.related_models.pop(position)  # type: ignore\n            del self._owner.__dict__[relation_name][position]\n</code></pre>"},{"location":"api/relations/relation/#ormar.relations.relation.RelationType","title":"<code>RelationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of relations supported by ormar:</p> <ul> <li>ForeignKey = PRIMARY</li> <li>reverse ForeignKey = REVERSE</li> <li>ManyToMany = MULTIPLE</li> </ul> Source code in <code>ormar/relations/relation.py</code> <pre><code>class RelationType(Enum):\n    \"\"\"\n    Different types of relations supported by ormar:\n\n    *  ForeignKey = PRIMARY\n    *  reverse ForeignKey = REVERSE\n    *  ManyToMany = MULTIPLE\n    \"\"\"\n\n    PRIMARY = 1\n    REVERSE = 2\n    MULTIPLE = 3\n    THROUGH = 4\n</code></pre>"},{"location":"api/relations/relation_manager/","title":"relation_manager","text":""},{"location":"api/relations/relation_manager/#ormar.relations.relation_manager.RelationsManager","title":"<code>RelationsManager</code>","text":"<p>Manages relations on a Model, each Model has it's own instance.</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>class RelationsManager:\n    \"\"\"\n    Manages relations on a Model, each Model has it's own instance.\n    \"\"\"\n\n    def __init__(\n        self,\n        related_fields: Optional[List[\"ForeignKeyField\"]] = None,\n        owner: Optional[\"Model\"] = None,\n    ) -&gt; None:\n        self.owner = proxy(owner)\n        self._related_fields = related_fields or []\n        self._related_names = [field.name for field in self._related_fields]\n        self._relations: Dict[str, Relation] = dict()\n        for field in self._related_fields:\n            self._add_relation(field)\n\n    def __contains__(self, item: str) -&gt; bool:\n        \"\"\"\n        Checks if relation with given name is already registered.\n\n        :param item: name of attribute\n        :type item: str\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return item in self._related_names\n\n    def clear(self) -&gt; None:\n        for relation in self._relations.values():\n            relation.clear()\n\n    def get(self, name: str) -&gt; Optional[Union[\"Model\", Sequence[\"Model\"]]]:\n        \"\"\"\n        Returns the related model/models if relation is set.\n        Actual call is delegated to Relation instance registered under relation name.\n\n        :param name: name of the relation\n        :type name: str\n        :return: related model or list of related models if set\n        :rtype: Optional[Union[Model, List[Model]]\n        \"\"\"\n        relation = self._relations.get(name, None)\n        if relation is not None:\n            return relation.get()\n        return None  # pragma nocover\n\n    @staticmethod\n    def add(parent: \"Model\", child: \"Model\", field: \"ForeignKeyField\") -&gt; None:\n        \"\"\"\n        Adds relation on both sides -&gt; meaning on both child and parent models.\n        One side of the relation is always weakref proxy to avoid circular refs.\n\n        Based on the side from which relation is added and relation name actual names\n        of parent and child relations are established. The related models are registered\n        on both ends.\n\n        :param parent: parent model on which relation should be registered\n        :type parent: Model\n        :param child: child model to register\n        :type child: Model\n        :param field: field with relation definition\n        :type field: ForeignKeyField\n        \"\"\"\n        (parent, child, child_name, to_name) = get_relations_sides_and_names(\n            field, parent, child\n        )\n\n        # print('adding parent', parent.get_name(), child.get_name(), child_name)\n        parent_relation = parent._orm._get(child_name)\n        if parent_relation:\n            parent_relation.add(child)  # type: ignore\n\n        # print('adding child', child.get_name(), parent.get_name(), to_name)\n        child_relation = child._orm._get(to_name)\n        if child_relation:\n            child_relation.add(parent)\n\n    def remove(\n        self, name: str, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]\n    ) -&gt; None:\n        \"\"\"\n        Removes given child from relation with given name.\n        Since you can have many relations between two models you need to pass a name\n        of relation from which you want to remove the child.\n\n        :param name: name of the relation\n        :type name: str\n        :param child: child to remove from relation\n        :type child: Union[Model, Type[Model]]\n        \"\"\"\n        relation = self._get(name)\n        if relation:\n            relation.remove(child)\n\n    @staticmethod\n    def remove_parent(\n        item: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]], parent: \"Model\", name: str\n    ) -&gt; None:\n        \"\"\"\n        Removes given parent from relation with given name.\n        Since you can have many relations between two models you need to pass a name\n        of relation from which you want to remove the parent.\n\n        :param item: model with parent registered\n        :type item: Union[Model, Type[Model]]\n        :param parent: parent Model\n        :type parent: Model\n        :param name: name of the relation\n        :type name: str\n        \"\"\"\n        relation_name = item.ormar_config.model_fields[name].get_related_name()\n        item._orm.remove(name, parent)\n        parent._orm.remove(relation_name, item)\n\n    def _get(self, name: str) -&gt; Optional[Relation]:\n        \"\"\"\n        Returns the actual relation and not the related model(s).\n\n        :param name: name of the relation\n        :type name: str\n        :return: Relation instance\n        :rtype: ormar.relations.relation.Relation\n        \"\"\"\n        relation = self._relations.get(name, None)\n        if relation is not None:\n            return relation\n        return None\n\n    def _get_relation_type(self, field: \"BaseField\") -&gt; RelationType:\n        \"\"\"\n        Returns type of the relation declared on a field.\n\n        :param field: field with relation declaration\n        :type field: BaseField\n        :return: type of the relation defined on field\n        :rtype: RelationType\n        \"\"\"\n        if field.is_multi:\n            return RelationType.MULTIPLE\n        if field.is_through:\n            return RelationType.THROUGH\n        return RelationType.PRIMARY if not field.virtual else RelationType.REVERSE\n\n    def _add_relation(self, field: \"BaseField\") -&gt; None:\n        \"\"\"\n        Registers relation in the manager.\n        Adds Relation instance under field.name.\n\n        :param field: field with relation declaration\n        :type field: BaseField\n        \"\"\"\n        self._relations[field.name] = Relation(\n            manager=self,\n            type_=self._get_relation_type(field),\n            field_name=field.name,\n            to=field.to,\n            through=getattr(field, \"through\", None),\n        )\n</code></pre>"},{"location":"api/relations/relation_manager/#ormar.relations.relation_manager.RelationsManager.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Checks if relation with given name is already registered.</p> <p>:param item: name of attribute :type item: str :return: result of the check :rtype: bool</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>def __contains__(self, item: str) -&gt; bool:\n    \"\"\"\n    Checks if relation with given name is already registered.\n\n    :param item: name of attribute\n    :type item: str\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return item in self._related_names\n</code></pre>"},{"location":"api/relations/relation_manager/#ormar.relations.relation_manager.RelationsManager.add","title":"<code>add(parent, child, field)</code>  <code>staticmethod</code>","text":"<p>Adds relation on both sides -&gt; meaning on both child and parent models. One side of the relation is always weakref proxy to avoid circular refs.</p> <p>Based on the side from which relation is added and relation name actual names of parent and child relations are established. The related models are registered on both ends.</p> <p>:param parent: parent model on which relation should be registered :type parent: Model :param child: child model to register :type child: Model :param field: field with relation definition :type field: ForeignKeyField</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>@staticmethod\ndef add(parent: \"Model\", child: \"Model\", field: \"ForeignKeyField\") -&gt; None:\n    \"\"\"\n    Adds relation on both sides -&gt; meaning on both child and parent models.\n    One side of the relation is always weakref proxy to avoid circular refs.\n\n    Based on the side from which relation is added and relation name actual names\n    of parent and child relations are established. The related models are registered\n    on both ends.\n\n    :param parent: parent model on which relation should be registered\n    :type parent: Model\n    :param child: child model to register\n    :type child: Model\n    :param field: field with relation definition\n    :type field: ForeignKeyField\n    \"\"\"\n    (parent, child, child_name, to_name) = get_relations_sides_and_names(\n        field, parent, child\n    )\n\n    # print('adding parent', parent.get_name(), child.get_name(), child_name)\n    parent_relation = parent._orm._get(child_name)\n    if parent_relation:\n        parent_relation.add(child)  # type: ignore\n\n    # print('adding child', child.get_name(), parent.get_name(), to_name)\n    child_relation = child._orm._get(to_name)\n    if child_relation:\n        child_relation.add(parent)\n</code></pre>"},{"location":"api/relations/relation_manager/#ormar.relations.relation_manager.RelationsManager.get","title":"<code>get(name)</code>","text":"<p>Returns the related model/models if relation is set. Actual call is delegated to Relation instance registered under relation name.</p> <p>:param name: name of the relation :type name: str :return: related model or list of related models if set :rtype: Optional[Union[Model, List[Model]]</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>def get(self, name: str) -&gt; Optional[Union[\"Model\", Sequence[\"Model\"]]]:\n    \"\"\"\n    Returns the related model/models if relation is set.\n    Actual call is delegated to Relation instance registered under relation name.\n\n    :param name: name of the relation\n    :type name: str\n    :return: related model or list of related models if set\n    :rtype: Optional[Union[Model, List[Model]]\n    \"\"\"\n    relation = self._relations.get(name, None)\n    if relation is not None:\n        return relation.get()\n    return None  # pragma nocover\n</code></pre>"},{"location":"api/relations/relation_manager/#ormar.relations.relation_manager.RelationsManager.remove","title":"<code>remove(name, child)</code>","text":"<p>Removes given child from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the child.</p> <p>:param name: name of the relation :type name: str :param child: child to remove from relation :type child: Union[Model, Type[Model]]</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>def remove(\n    self, name: str, child: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]]\n) -&gt; None:\n    \"\"\"\n    Removes given child from relation with given name.\n    Since you can have many relations between two models you need to pass a name\n    of relation from which you want to remove the child.\n\n    :param name: name of the relation\n    :type name: str\n    :param child: child to remove from relation\n    :type child: Union[Model, Type[Model]]\n    \"\"\"\n    relation = self._get(name)\n    if relation:\n        relation.remove(child)\n</code></pre>"},{"location":"api/relations/relation_manager/#ormar.relations.relation_manager.RelationsManager.remove_parent","title":"<code>remove_parent(item, parent, name)</code>  <code>staticmethod</code>","text":"<p>Removes given parent from relation with given name. Since you can have many relations between two models you need to pass a name of relation from which you want to remove the parent.</p> <p>:param item: model with parent registered :type item: Union[Model, Type[Model]] :param parent: parent Model :type parent: Model :param name: name of the relation :type name: str</p> Source code in <code>ormar/relations/relation_manager.py</code> <pre><code>@staticmethod\ndef remove_parent(\n    item: Union[\"NewBaseModel\", Type[\"NewBaseModel\"]], parent: \"Model\", name: str\n) -&gt; None:\n    \"\"\"\n    Removes given parent from relation with given name.\n    Since you can have many relations between two models you need to pass a name\n    of relation from which you want to remove the parent.\n\n    :param item: model with parent registered\n    :type item: Union[Model, Type[Model]]\n    :param parent: parent Model\n    :type parent: Model\n    :param name: name of the relation\n    :type name: str\n    \"\"\"\n    relation_name = item.ormar_config.model_fields[name].get_related_name()\n    item._orm.remove(name, parent)\n    parent._orm.remove(relation_name, item)\n</code></pre>"},{"location":"api/relations/relation_proxy/","title":"relation_proxy","text":""},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy","title":"<code>RelationProxy</code>","text":"<p>               Bases: <code>Generic[T]</code>, <code>List[T]</code></p> <p>Proxy of the Relation that is a list with special methods.</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>class RelationProxy(Generic[T], List[T]):\n    \"\"\"\n    Proxy of the Relation that is a list with special methods.\n    \"\"\"\n\n    def __init__(\n        self,\n        relation: \"Relation\",\n        type_: \"RelationType\",\n        to: Type[\"T\"],\n        field_name: str,\n        data_: Any = None,\n    ) -&gt; None:\n        self.relation: \"Relation[T]\" = relation\n        self.type_: \"RelationType\" = type_\n        self.field_name = field_name\n        self._owner: \"Model\" = self.relation.manager.owner\n        self.queryset_proxy: QuerysetProxy[T] = QuerysetProxy[T](\n            relation=self.relation, to=to, type_=type_\n        )\n        self._related_field_name: Optional[str] = None\n\n        self._relation_cache: Dict[int, int] = {}\n\n        validated_data = []\n        if data_ is not None:\n            idx = 0\n            for d in data_:\n                try:\n                    self._relation_cache[d.__hash__()] = idx\n                    validated_data.append(d)\n                    idx += 1\n                except ReferenceError:\n                    pass\n        super().__init__(validated_data or ())\n\n    @property\n    def related_field_name(self) -&gt; str:\n        \"\"\"\n        On first access calculates the name of the related field, later stored in\n        _related_field_name property.\n\n        :return: name of the related field\n        :rtype: str\n        \"\"\"\n        if self._related_field_name:\n            return self._related_field_name\n        owner_field = self._owner.ormar_config.model_fields[self.field_name]\n        self._related_field_name = owner_field.get_related_name()\n\n        return self._related_field_name\n\n    def __getitem__(self, item: Any) -&gt; \"T\":  # type: ignore\n        return super().__getitem__(item)\n\n    def append(self, item: \"T\") -&gt; None:\n        \"\"\"\n        Appends an item to the list in place\n\n        :param item: The generic item of the list\n        :type item: T\n        \"\"\"\n        idx = len(self)\n        self._relation_cache[item.__hash__()] = idx\n        super().append(item)\n\n    def update_cache(self, prev_hash: int, new_hash: int) -&gt; None:\n        \"\"\"\n        Updates the cache from the old hash to the new one.\n        This maintains the index cache, which allows O(1) indexing and\n        existence checks\n\n        :param prev_hash: The hash to update\n        :type prev_hash: int\n        :param prev_hash: The new hash to update to\n        :type new_hash: int\n        \"\"\"\n        try:\n            idx = self._relation_cache.pop(prev_hash)\n            self._relation_cache[new_hash] = idx\n        except KeyError:\n            pass\n\n    def index(self, item: T, *args: Any) -&gt; int:\n        \"\"\"\n        Gets the index of the item in the list\n\n        :param item: The item to get the index of\n        :type item: \"T\"\n        \"\"\"\n        return self._relation_cache[item.__hash__()]\n\n    def _get_list_of_missing_weakrefs(self) -&gt; Set[int]:\n        \"\"\"\n        Iterates through the list and checks for weakrefs.\n\n        :return: The set of missing weakref indices\n        :rtype: Set[int]\n        \"\"\"\n        to_remove = set()\n        for ind, relation_child in enumerate(self[:]):\n            try:\n                relation_child.__repr__.__self__  # type: ignore\n            except ReferenceError:  # pragma no cover\n                to_remove.add(ind)\n\n        return to_remove\n\n    def pop(self, index: SupportsIndex = 0) -&gt; T:\n        \"\"\"\n        Pops the index off the list and returns it. By default,\n        it pops off the element at index 0.\n        This also clears the value from the relation cache.\n\n        :param index: The index to pop\n        :type index: SupportsIndex\n        :return: The item at the provided index\n        :rtype: \"T\"\n        \"\"\"\n        item = self[index]\n\n        # Try to delete it, but do it a long way\n        # if weakly-referenced thing doesn't exist\n        try:\n            self._relation_cache.pop(item.__hash__())\n        except ReferenceError:\n            for hash_, idx in self._relation_cache.items():\n                if idx == index:\n                    self._relation_cache.pop(hash_)\n                    break\n\n        index_int = int(index)\n        for idx in range(index_int + 1, len(self)):\n            self._relation_cache[self[idx].__hash__()] -= 1\n\n        return super().pop(index)\n\n    def __contains__(self, item: object) -&gt; bool:\n        \"\"\"\n        Checks whether the item exists in self. This relies\n        on the relation cache, which is a hashmap of values\n        in the list. It runs in O(1) time.\n\n        :param item: The item to check if the list contains\n        :type item: object\n        \"\"\"\n        try:\n            return item.__hash__() in self._relation_cache\n        except ReferenceError:\n            return False\n\n    def __getattribute__(self, item: str) -&gt; Any:\n        \"\"\"\n        Since some QuerySetProxy methods overwrite builtin list methods we\n        catch calls to them and delegate it to QuerySetProxy instead.\n\n        :param item: name of attribute\n        :type item: str\n        :return: value of attribute\n        :rtype: Any\n        \"\"\"\n        if item in [\"count\", \"clear\"]:\n            self._initialize_queryset()\n            return getattr(self.queryset_proxy, item)\n        return super().__getattribute__(item)\n\n    def __getattr__(self, item: str) -&gt; Any:\n        \"\"\"\n        Delegates calls for non existing attributes to QuerySetProxy.\n\n        :param item: name of attribute/method\n        :type item: str\n        :return: method from QuerySetProxy if exists\n        :rtype: method\n        \"\"\"\n        self._initialize_queryset()\n        return getattr(self.queryset_proxy, item)\n\n    def _clear(self) -&gt; None:\n        self._relation_cache.clear()\n        super().clear()\n\n    def _initialize_queryset(self) -&gt; None:\n        \"\"\"\n        Initializes the QuerySetProxy if not yet initialized.\n        \"\"\"\n        if not self._check_if_queryset_is_initialized():\n            self.queryset_proxy.queryset = self._set_queryset()\n\n    def _check_if_queryset_is_initialized(self) -&gt; bool:\n        \"\"\"\n        Checks if the QuerySetProxy is already set and ready.\n        :return: result of the check\n        :rtype: bool\n        \"\"\"\n        return (\n            hasattr(self.queryset_proxy, \"queryset\")\n            and self.queryset_proxy.queryset is not None\n        )\n\n    def _check_if_model_saved(self) -&gt; None:\n        \"\"\"\n        Verifies if the parent model of the relation has been already saved.\n        Otherwise QuerySetProxy cannot filter by parent primary key.\n        \"\"\"\n        pk_value = self._owner.pk\n        if not pk_value:\n            raise RelationshipInstanceError(\n                \"You cannot query relationships from unsaved model.\"\n            )\n\n    def _set_queryset(self) -&gt; \"QuerySet[T]\":\n        \"\"\"\n        Creates new QuerySet with relation model and pre filters it with currents\n        parent model primary key, so all queries by definition are already related\n        to the parent model only, without need for user to filter them.\n\n        :return: initialized QuerySet\n        :rtype: QuerySet\n        \"\"\"\n        related_field_name = self.related_field_name\n        pkname = self._owner.get_column_alias(self._owner.ormar_config.pkname)\n        self._check_if_model_saved()\n        kwargs = {f\"{related_field_name}__{pkname}\": self._owner.pk}\n        queryset = (\n            ormar.QuerySet(\n                model_cls=self.relation.to, proxy_source_model=self._owner.__class__\n            )\n            .select_related(related_field_name)\n            .filter(**kwargs)\n        )\n        return queryset\n\n    async def remove(  # type: ignore\n        self, item: \"T\", keep_reversed: bool = True\n    ) -&gt; None:\n        \"\"\"\n        Removes the related from relation with parent.\n\n        Through models are automatically deleted for m2m relations.\n\n        For reverse FK relations keep_reversed flag marks if the reversed models\n        should be kept or deleted from the database too (False means that models\n        will be deleted, and not only removed from relation).\n\n        :param item: child to remove from relation\n        :type item: Model\n        :param keep_reversed: flag if the reversed model should be kept or deleted too\n        :type keep_reversed: bool\n        \"\"\"\n        if item not in self:\n            raise NoMatch(\n                f\"Object {self._owner.get_name()} has no \"\n                f\"{item.get_name()} with given primary key!\"\n            )\n        await self._owner.signals.pre_relation_remove.send(\n            sender=self._owner.__class__,\n            instance=self._owner,\n            child=item,\n            relation_name=self.field_name,\n        )\n\n        index_to_remove = self._relation_cache[item.__hash__()]\n        self.pop(index_to_remove)\n\n        relation_name = self.related_field_name\n        relation = item._orm._get(relation_name)\n        # if relation is None:  # pragma nocover\n        #     raise ValueError(\n        #         f\"{self._owner.get_name()} does not have relation {relation_name}\"\n        #     )\n        if relation:\n            relation.remove(self._owner)\n        self.relation.remove(item)\n        if self.type_ == ormar.RelationType.MULTIPLE:\n            await self.queryset_proxy.delete_through_instance(item)\n        else:\n            if keep_reversed:\n                setattr(item, relation_name, None)\n                await item.update()\n            else:\n                await item.delete()\n        await self._owner.signals.post_relation_remove.send(\n            sender=self._owner.__class__,\n            instance=self._owner,\n            child=item,\n            relation_name=self.field_name,\n        )\n\n    async def add(self, item: \"T\", **kwargs: Any) -&gt; None:\n        \"\"\"\n        Adds child model to relation.\n\n        For ManyToMany relations through instance is automatically created.\n\n        :param kwargs: dict of additional keyword arguments for through instance\n        :type kwargs: Any\n        :param item: child to add to relation\n        :type item: Model\n        \"\"\"\n        new_idx = len(self) if item not in self else self.index(item)\n        relation_name = self.related_field_name\n        await self._owner.signals.pre_relation_add.send(\n            sender=self._owner.__class__,\n            instance=self._owner,\n            child=item,\n            relation_name=self.field_name,\n            passed_kwargs=kwargs,\n        )\n        self._check_if_model_saved()\n        if self.type_ == ormar.RelationType.MULTIPLE:\n            await self.queryset_proxy.create_through_instance(item, **kwargs)\n            setattr(self._owner, self.field_name, item)\n        else:\n            setattr(item, relation_name, self._owner)\n            await item.upsert()\n        self._relation_cache[item.__hash__()] = new_idx\n        await self._owner.signals.post_relation_add.send(\n            sender=self._owner.__class__,\n            instance=self._owner,\n            child=item,\n            relation_name=self.field_name,\n            passed_kwargs=kwargs,\n        )\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.related_field_name","title":"<code>related_field_name: str</code>  <code>property</code>","text":"<p>On first access calculates the name of the related field, later stored in _related_field_name property.</p> <p>:return: name of the related field :rtype: str</p>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Checks whether the item exists in self. This relies on the relation cache, which is a hashmap of values in the list. It runs in O(1) time.</p> <p>:param item: The item to check if the list contains :type item: object</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def __contains__(self, item: object) -&gt; bool:\n    \"\"\"\n    Checks whether the item exists in self. This relies\n    on the relation cache, which is a hashmap of values\n    in the list. It runs in O(1) time.\n\n    :param item: The item to check if the list contains\n    :type item: object\n    \"\"\"\n    try:\n        return item.__hash__() in self._relation_cache\n    except ReferenceError:\n        return False\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Delegates calls for non existing attributes to QuerySetProxy.</p> <p>:param item: name of attribute/method :type item: str :return: method from QuerySetProxy if exists :rtype: method</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def __getattr__(self, item: str) -&gt; Any:\n    \"\"\"\n    Delegates calls for non existing attributes to QuerySetProxy.\n\n    :param item: name of attribute/method\n    :type item: str\n    :return: method from QuerySetProxy if exists\n    :rtype: method\n    \"\"\"\n    self._initialize_queryset()\n    return getattr(self.queryset_proxy, item)\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.__getattribute__","title":"<code>__getattribute__(item)</code>","text":"<p>Since some QuerySetProxy methods overwrite builtin list methods we catch calls to them and delegate it to QuerySetProxy instead.</p> <p>:param item: name of attribute :type item: str :return: value of attribute :rtype: Any</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def __getattribute__(self, item: str) -&gt; Any:\n    \"\"\"\n    Since some QuerySetProxy methods overwrite builtin list methods we\n    catch calls to them and delegate it to QuerySetProxy instead.\n\n    :param item: name of attribute\n    :type item: str\n    :return: value of attribute\n    :rtype: Any\n    \"\"\"\n    if item in [\"count\", \"clear\"]:\n        self._initialize_queryset()\n        return getattr(self.queryset_proxy, item)\n    return super().__getattribute__(item)\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.add","title":"<code>add(item, **kwargs)</code>  <code>async</code>","text":"<p>Adds child model to relation.</p> <p>For ManyToMany relations through instance is automatically created.</p> <p>:param kwargs: dict of additional keyword arguments for through instance :type kwargs: Any :param item: child to add to relation :type item: Model</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>async def add(self, item: \"T\", **kwargs: Any) -&gt; None:\n    \"\"\"\n    Adds child model to relation.\n\n    For ManyToMany relations through instance is automatically created.\n\n    :param kwargs: dict of additional keyword arguments for through instance\n    :type kwargs: Any\n    :param item: child to add to relation\n    :type item: Model\n    \"\"\"\n    new_idx = len(self) if item not in self else self.index(item)\n    relation_name = self.related_field_name\n    await self._owner.signals.pre_relation_add.send(\n        sender=self._owner.__class__,\n        instance=self._owner,\n        child=item,\n        relation_name=self.field_name,\n        passed_kwargs=kwargs,\n    )\n    self._check_if_model_saved()\n    if self.type_ == ormar.RelationType.MULTIPLE:\n        await self.queryset_proxy.create_through_instance(item, **kwargs)\n        setattr(self._owner, self.field_name, item)\n    else:\n        setattr(item, relation_name, self._owner)\n        await item.upsert()\n    self._relation_cache[item.__hash__()] = new_idx\n    await self._owner.signals.post_relation_add.send(\n        sender=self._owner.__class__,\n        instance=self._owner,\n        child=item,\n        relation_name=self.field_name,\n        passed_kwargs=kwargs,\n    )\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.append","title":"<code>append(item)</code>","text":"<p>Appends an item to the list in place</p> <p>:param item: The generic item of the list :type item: T</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def append(self, item: \"T\") -&gt; None:\n    \"\"\"\n    Appends an item to the list in place\n\n    :param item: The generic item of the list\n    :type item: T\n    \"\"\"\n    idx = len(self)\n    self._relation_cache[item.__hash__()] = idx\n    super().append(item)\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.index","title":"<code>index(item, *args)</code>","text":"<p>Gets the index of the item in the list</p> <p>:param item: The item to get the index of :type item: \"T\"</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def index(self, item: T, *args: Any) -&gt; int:\n    \"\"\"\n    Gets the index of the item in the list\n\n    :param item: The item to get the index of\n    :type item: \"T\"\n    \"\"\"\n    return self._relation_cache[item.__hash__()]\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.pop","title":"<code>pop(index=0)</code>","text":"<p>Pops the index off the list and returns it. By default, it pops off the element at index 0. This also clears the value from the relation cache.</p> <p>:param index: The index to pop :type index: SupportsIndex :return: The item at the provided index :rtype: \"T\"</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def pop(self, index: SupportsIndex = 0) -&gt; T:\n    \"\"\"\n    Pops the index off the list and returns it. By default,\n    it pops off the element at index 0.\n    This also clears the value from the relation cache.\n\n    :param index: The index to pop\n    :type index: SupportsIndex\n    :return: The item at the provided index\n    :rtype: \"T\"\n    \"\"\"\n    item = self[index]\n\n    # Try to delete it, but do it a long way\n    # if weakly-referenced thing doesn't exist\n    try:\n        self._relation_cache.pop(item.__hash__())\n    except ReferenceError:\n        for hash_, idx in self._relation_cache.items():\n            if idx == index:\n                self._relation_cache.pop(hash_)\n                break\n\n    index_int = int(index)\n    for idx in range(index_int + 1, len(self)):\n        self._relation_cache[self[idx].__hash__()] -= 1\n\n    return super().pop(index)\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.remove","title":"<code>remove(item, keep_reversed=True)</code>  <code>async</code>","text":"<p>Removes the related from relation with parent.</p> <p>Through models are automatically deleted for m2m relations.</p> <p>For reverse FK relations keep_reversed flag marks if the reversed models should be kept or deleted from the database too (False means that models will be deleted, and not only removed from relation).</p> <p>:param item: child to remove from relation :type item: Model :param keep_reversed: flag if the reversed model should be kept or deleted too :type keep_reversed: bool</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>async def remove(  # type: ignore\n    self, item: \"T\", keep_reversed: bool = True\n) -&gt; None:\n    \"\"\"\n    Removes the related from relation with parent.\n\n    Through models are automatically deleted for m2m relations.\n\n    For reverse FK relations keep_reversed flag marks if the reversed models\n    should be kept or deleted from the database too (False means that models\n    will be deleted, and not only removed from relation).\n\n    :param item: child to remove from relation\n    :type item: Model\n    :param keep_reversed: flag if the reversed model should be kept or deleted too\n    :type keep_reversed: bool\n    \"\"\"\n    if item not in self:\n        raise NoMatch(\n            f\"Object {self._owner.get_name()} has no \"\n            f\"{item.get_name()} with given primary key!\"\n        )\n    await self._owner.signals.pre_relation_remove.send(\n        sender=self._owner.__class__,\n        instance=self._owner,\n        child=item,\n        relation_name=self.field_name,\n    )\n\n    index_to_remove = self._relation_cache[item.__hash__()]\n    self.pop(index_to_remove)\n\n    relation_name = self.related_field_name\n    relation = item._orm._get(relation_name)\n    # if relation is None:  # pragma nocover\n    #     raise ValueError(\n    #         f\"{self._owner.get_name()} does not have relation {relation_name}\"\n    #     )\n    if relation:\n        relation.remove(self._owner)\n    self.relation.remove(item)\n    if self.type_ == ormar.RelationType.MULTIPLE:\n        await self.queryset_proxy.delete_through_instance(item)\n    else:\n        if keep_reversed:\n            setattr(item, relation_name, None)\n            await item.update()\n        else:\n            await item.delete()\n    await self._owner.signals.post_relation_remove.send(\n        sender=self._owner.__class__,\n        instance=self._owner,\n        child=item,\n        relation_name=self.field_name,\n    )\n</code></pre>"},{"location":"api/relations/relation_proxy/#ormar.relations.relation_proxy.RelationProxy.update_cache","title":"<code>update_cache(prev_hash, new_hash)</code>","text":"<p>Updates the cache from the old hash to the new one. This maintains the index cache, which allows O(1) indexing and existence checks</p> <p>:param prev_hash: The hash to update :type prev_hash: int :param prev_hash: The new hash to update to :type new_hash: int</p> Source code in <code>ormar/relations/relation_proxy.py</code> <pre><code>def update_cache(self, prev_hash: int, new_hash: int) -&gt; None:\n    \"\"\"\n    Updates the cache from the old hash to the new one.\n    This maintains the index cache, which allows O(1) indexing and\n    existence checks\n\n    :param prev_hash: The hash to update\n    :type prev_hash: int\n    :param prev_hash: The new hash to update to\n    :type new_hash: int\n    \"\"\"\n    try:\n        idx = self._relation_cache.pop(prev_hash)\n        self._relation_cache[new_hash] = idx\n    except KeyError:\n        pass\n</code></pre>"},{"location":"api/relations/utils/","title":"utils","text":""},{"location":"api/relations/utils/#ormar.relations.utils.get_relations_sides_and_names","title":"<code>get_relations_sides_and_names(to_field, parent, child)</code>","text":"<p>Determines the names of child and parent relations names, as well as changes one of the sides of the relation into weakref.proxy to model.</p> <p>:param to_field: field with relation definition :type to_field: ForeignKeyField :param parent: parent model :type parent: Model :param child: child model :type child: Model :return: parent, child, child_name, to_name :rtype: Tuple[\"Model\", \"Model\", str, str]</p> Source code in <code>ormar/relations/utils.py</code> <pre><code>def get_relations_sides_and_names(\n    to_field: ForeignKeyField, parent: \"Model\", child: \"Model\"\n) -&gt; Tuple[\"Model\", \"Model\", str, str]:\n    \"\"\"\n    Determines the names of child and parent relations names, as well as\n    changes one of the sides of the relation into weakref.proxy to model.\n\n    :param to_field: field with relation definition\n    :type to_field: ForeignKeyField\n    :param parent: parent model\n    :type parent: Model\n    :param child: child model\n    :type child: Model\n    :return: parent, child, child_name, to_name\n    :rtype: Tuple[\"Model\", \"Model\", str, str]\n    \"\"\"\n    to_name = to_field.name\n    child_name = to_field.get_related_name()\n    if to_field.virtual:\n        child_name, to_name = to_name, child_name\n        child, parent = parent, proxy(child)\n    else:\n        child = proxy(child)\n    return parent, child, child_name, to_name\n</code></pre>"},{"location":"api/signals/","title":"signals","text":"<p>Signals and SignalEmitter that gathers the signals on models OrmarConfig. Used to signal receivers functions about events, i.e. post_save, pre_delete etc.</p>"},{"location":"api/signals/#ormar.signals.Signal","title":"<code>Signal</code>","text":"<p>Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals.</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>class Signal:\n    \"\"\"\n    Signal that notifies all receiver functions.\n    In ormar used by models to send pre_save, post_save etc. signals.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._receivers: Dict[Union[int, Tuple[int, int]], Callable] = {}\n\n    def connect(self, receiver: Callable) -&gt; None:\n        \"\"\"\n        Connects given receiver function to the signal.\n\n        :raises SignalDefinitionError: if receiver is not callable\n        or not accept **kwargs\n        :param receiver: receiver function\n        :type receiver: Callable\n        \"\"\"\n        if not callable(receiver):\n            raise SignalDefinitionError(\"Signal receivers must be callable.\")\n        if not callable_accepts_kwargs(receiver):\n            raise SignalDefinitionError(\n                \"Signal receivers must accept **kwargs argument.\"\n            )\n        new_receiver_key = make_id(receiver)\n        if new_receiver_key not in self._receivers:\n            self._receivers[new_receiver_key] = receiver\n\n    def disconnect(self, receiver: Callable) -&gt; bool:\n        \"\"\"\n        Removes the receiver function from the signal.\n\n        :param receiver: receiver function\n        :type receiver: Callable\n        :return: flag if receiver was removed\n        :rtype: bool\n        \"\"\"\n        new_receiver_key = make_id(receiver)\n        receiver_func: Union[Callable, None] = self._receivers.pop(\n            new_receiver_key, None\n        )\n        return True if receiver_func is not None else False\n\n    async def send(self, sender: Type[\"Model\"], **kwargs: Any) -&gt; None:\n        \"\"\"\n        Notifies all receiver functions with given kwargs\n        :param sender: model that sends the signal\n        :type sender: Type[\"Model\"]\n        :param kwargs: arguments passed to receivers\n        :type kwargs: Any\n        \"\"\"\n        receivers = [\n            receiver_func(sender=sender, **kwargs)\n            for receiver_func in self._receivers.values()\n        ]\n        await asyncio.gather(*receivers)\n</code></pre>"},{"location":"api/signals/#ormar.signals.Signal.connect","title":"<code>connect(receiver)</code>","text":"<p>Connects given receiver function to the signal.</p> <p>:raises SignalDefinitionError: if receiver is not callable or not accept **kwargs :param receiver: receiver function :type receiver: Callable</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def connect(self, receiver: Callable) -&gt; None:\n    \"\"\"\n    Connects given receiver function to the signal.\n\n    :raises SignalDefinitionError: if receiver is not callable\n    or not accept **kwargs\n    :param receiver: receiver function\n    :type receiver: Callable\n    \"\"\"\n    if not callable(receiver):\n        raise SignalDefinitionError(\"Signal receivers must be callable.\")\n    if not callable_accepts_kwargs(receiver):\n        raise SignalDefinitionError(\n            \"Signal receivers must accept **kwargs argument.\"\n        )\n    new_receiver_key = make_id(receiver)\n    if new_receiver_key not in self._receivers:\n        self._receivers[new_receiver_key] = receiver\n</code></pre>"},{"location":"api/signals/#ormar.signals.Signal.disconnect","title":"<code>disconnect(receiver)</code>","text":"<p>Removes the receiver function from the signal.</p> <p>:param receiver: receiver function :type receiver: Callable :return: flag if receiver was removed :rtype: bool</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def disconnect(self, receiver: Callable) -&gt; bool:\n    \"\"\"\n    Removes the receiver function from the signal.\n\n    :param receiver: receiver function\n    :type receiver: Callable\n    :return: flag if receiver was removed\n    :rtype: bool\n    \"\"\"\n    new_receiver_key = make_id(receiver)\n    receiver_func: Union[Callable, None] = self._receivers.pop(\n        new_receiver_key, None\n    )\n    return True if receiver_func is not None else False\n</code></pre>"},{"location":"api/signals/#ormar.signals.Signal.send","title":"<code>send(sender, **kwargs)</code>  <code>async</code>","text":"<p>Notifies all receiver functions with given kwargs :param sender: model that sends the signal :type sender: Type[\"Model\"] :param kwargs: arguments passed to receivers :type kwargs: Any</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>async def send(self, sender: Type[\"Model\"], **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notifies all receiver functions with given kwargs\n    :param sender: model that sends the signal\n    :type sender: Type[\"Model\"]\n    :param kwargs: arguments passed to receivers\n    :type kwargs: Any\n    \"\"\"\n    receivers = [\n        receiver_func(sender=sender, **kwargs)\n        for receiver_func in self._receivers.values()\n    ]\n    await asyncio.gather(*receivers)\n</code></pre>"},{"location":"api/signals/#ormar.signals.SignalEmitter","title":"<code>SignalEmitter</code>","text":"<p>               Bases: <code>dict</code></p> <p>Emitter that registers the signals in internal dictionary. If signal with given name does not exist it's auto added on access.</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>class SignalEmitter(dict):\n    \"\"\"\n    Emitter that registers the signals in internal dictionary.\n    If signal with given name does not exist it's auto added on access.\n    \"\"\"\n\n    def __getattr__(self, item: str) -&gt; Signal:\n        return self.setdefault(item, Signal())\n\n    def __setattr__(self, key: str, value: Signal) -&gt; None:\n        if not isinstance(value, Signal):\n            raise SignalDefinitionError(f\"{value} is not valid signal\")\n        self[key] = value\n</code></pre>"},{"location":"api/signals/signal/","title":"signal","text":""},{"location":"api/signals/signal/#ormar.signals.signal.Signal","title":"<code>Signal</code>","text":"<p>Signal that notifies all receiver functions. In ormar used by models to send pre_save, post_save etc. signals.</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>class Signal:\n    \"\"\"\n    Signal that notifies all receiver functions.\n    In ormar used by models to send pre_save, post_save etc. signals.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._receivers: Dict[Union[int, Tuple[int, int]], Callable] = {}\n\n    def connect(self, receiver: Callable) -&gt; None:\n        \"\"\"\n        Connects given receiver function to the signal.\n\n        :raises SignalDefinitionError: if receiver is not callable\n        or not accept **kwargs\n        :param receiver: receiver function\n        :type receiver: Callable\n        \"\"\"\n        if not callable(receiver):\n            raise SignalDefinitionError(\"Signal receivers must be callable.\")\n        if not callable_accepts_kwargs(receiver):\n            raise SignalDefinitionError(\n                \"Signal receivers must accept **kwargs argument.\"\n            )\n        new_receiver_key = make_id(receiver)\n        if new_receiver_key not in self._receivers:\n            self._receivers[new_receiver_key] = receiver\n\n    def disconnect(self, receiver: Callable) -&gt; bool:\n        \"\"\"\n        Removes the receiver function from the signal.\n\n        :param receiver: receiver function\n        :type receiver: Callable\n        :return: flag if receiver was removed\n        :rtype: bool\n        \"\"\"\n        new_receiver_key = make_id(receiver)\n        receiver_func: Union[Callable, None] = self._receivers.pop(\n            new_receiver_key, None\n        )\n        return True if receiver_func is not None else False\n\n    async def send(self, sender: Type[\"Model\"], **kwargs: Any) -&gt; None:\n        \"\"\"\n        Notifies all receiver functions with given kwargs\n        :param sender: model that sends the signal\n        :type sender: Type[\"Model\"]\n        :param kwargs: arguments passed to receivers\n        :type kwargs: Any\n        \"\"\"\n        receivers = [\n            receiver_func(sender=sender, **kwargs)\n            for receiver_func in self._receivers.values()\n        ]\n        await asyncio.gather(*receivers)\n</code></pre>"},{"location":"api/signals/signal/#ormar.signals.signal.Signal.connect","title":"<code>connect(receiver)</code>","text":"<p>Connects given receiver function to the signal.</p> <p>:raises SignalDefinitionError: if receiver is not callable or not accept **kwargs :param receiver: receiver function :type receiver: Callable</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def connect(self, receiver: Callable) -&gt; None:\n    \"\"\"\n    Connects given receiver function to the signal.\n\n    :raises SignalDefinitionError: if receiver is not callable\n    or not accept **kwargs\n    :param receiver: receiver function\n    :type receiver: Callable\n    \"\"\"\n    if not callable(receiver):\n        raise SignalDefinitionError(\"Signal receivers must be callable.\")\n    if not callable_accepts_kwargs(receiver):\n        raise SignalDefinitionError(\n            \"Signal receivers must accept **kwargs argument.\"\n        )\n    new_receiver_key = make_id(receiver)\n    if new_receiver_key not in self._receivers:\n        self._receivers[new_receiver_key] = receiver\n</code></pre>"},{"location":"api/signals/signal/#ormar.signals.signal.Signal.disconnect","title":"<code>disconnect(receiver)</code>","text":"<p>Removes the receiver function from the signal.</p> <p>:param receiver: receiver function :type receiver: Callable :return: flag if receiver was removed :rtype: bool</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def disconnect(self, receiver: Callable) -&gt; bool:\n    \"\"\"\n    Removes the receiver function from the signal.\n\n    :param receiver: receiver function\n    :type receiver: Callable\n    :return: flag if receiver was removed\n    :rtype: bool\n    \"\"\"\n    new_receiver_key = make_id(receiver)\n    receiver_func: Union[Callable, None] = self._receivers.pop(\n        new_receiver_key, None\n    )\n    return True if receiver_func is not None else False\n</code></pre>"},{"location":"api/signals/signal/#ormar.signals.signal.Signal.send","title":"<code>send(sender, **kwargs)</code>  <code>async</code>","text":"<p>Notifies all receiver functions with given kwargs :param sender: model that sends the signal :type sender: Type[\"Model\"] :param kwargs: arguments passed to receivers :type kwargs: Any</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>async def send(self, sender: Type[\"Model\"], **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notifies all receiver functions with given kwargs\n    :param sender: model that sends the signal\n    :type sender: Type[\"Model\"]\n    :param kwargs: arguments passed to receivers\n    :type kwargs: Any\n    \"\"\"\n    receivers = [\n        receiver_func(sender=sender, **kwargs)\n        for receiver_func in self._receivers.values()\n    ]\n    await asyncio.gather(*receivers)\n</code></pre>"},{"location":"api/signals/signal/#ormar.signals.signal.SignalEmitter","title":"<code>SignalEmitter</code>","text":"<p>               Bases: <code>dict</code></p> <p>Emitter that registers the signals in internal dictionary. If signal with given name does not exist it's auto added on access.</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>class SignalEmitter(dict):\n    \"\"\"\n    Emitter that registers the signals in internal dictionary.\n    If signal with given name does not exist it's auto added on access.\n    \"\"\"\n\n    def __getattr__(self, item: str) -&gt; Signal:\n        return self.setdefault(item, Signal())\n\n    def __setattr__(self, key: str, value: Signal) -&gt; None:\n        if not isinstance(value, Signal):\n            raise SignalDefinitionError(f\"{value} is not valid signal\")\n        self[key] = value\n</code></pre>"},{"location":"api/signals/signal/#ormar.signals.signal.callable_accepts_kwargs","title":"<code>callable_accepts_kwargs(func)</code>","text":"<p>Checks if function accepts **kwargs.</p> <p>:param func: function which signature needs to be checked :type func: function :return: result of the check :rtype: bool</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def callable_accepts_kwargs(func: Callable) -&gt; bool:\n    \"\"\"\n    Checks if function accepts **kwargs.\n\n    :param func: function which signature needs to be checked\n    :type func: function\n    :return: result of the check\n    :rtype: bool\n    \"\"\"\n    return any(\n        p\n        for p in inspect.signature(func).parameters.values()\n        if p.kind == p.VAR_KEYWORD\n    )\n</code></pre>"},{"location":"api/signals/signal/#ormar.signals.signal.make_id","title":"<code>make_id(target)</code>","text":"<p>Creates id of a function or method to be used as key to store signal</p> <p>:param target: target which id we want :type target: Any :return: id of the target :rtype: int</p> Source code in <code>ormar/signals/signal.py</code> <pre><code>def make_id(target: Any) -&gt; Union[int, Tuple[int, int]]:\n    \"\"\"\n    Creates id of a function or method to be used as key to store signal\n\n    :param target: target which id we want\n    :type target: Any\n    :return: id of the target\n    :rtype: int\n    \"\"\"\n    if hasattr(target, \"__func__\"):\n        return id(target.__self__), id(target.__func__)\n    return id(target)\n</code></pre>"},{"location":"fastapi/","title":"Fastapi","text":"<p>The use of ormar with fastapi is quite simple.</p> <p>Apart from connecting to databases at startup everything else  you need to do is substitute pydantic models with ormar models.</p> <p>Here you can find a very simple sample application code.</p> <p>Warning</p> <p>This example assumes that you already have a database created. If that is not the case please visit database initialization section.</p> <p>Tip</p> <p>The following example (all sections) should be put in one file.</p> <p>It's divided into subsections for clarity.</p> <p>Note</p> <p>If you want to read more on how you can use ormar models in fastapi requests and  responses check the responses and requests documentation.</p>"},{"location":"fastapi/#quick-start","title":"Quick Start","text":"<p>Note</p> <p>Note that you can find the full quick start script in the github repo under examples.</p>"},{"location":"fastapi/#imports-and-initialization","title":"Imports and initialization","text":"<p>Define startup and shutdown procedures using FastAPI lifespan and use is in the application. <pre><code>from typing import List, Optional, AsyncIterator\n\nimport databases\nimport sqlalchemy\nfrom fastapi import FastAPI\n\nimport ormar\n\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI\n\n\ndef get_lifespan(config):\n    @asynccontextmanager\n    async def lifespan(_: FastAPI) -&gt; AsyncIterator[None]:\n        if not config.database.is_connected:\n            await config.database.connect()\n\n        yield\n\n        if config.database.is_connected:\n            await config.database.disconnect()\n    return lifespan\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(\"sqlite:///test.db\"),\n)\n\napp = FastAPI(lifespan=get_lifespan(base_ormar_config))\n</code></pre></p> <p>Info</p> <p>You can read more on connecting to databases in fastapi documentation</p>"},{"location":"fastapi/#models-definition","title":"Models definition","text":"<p>Define ormar models with appropriate fields. </p> <p>Those models will be used instead of pydantic ones.</p> <pre><code>base_ormar_config = OrmarConfig(\n    metadata = metadata\n    database = database\n)\n\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n</code></pre> <p>Tip</p> <p>You can read more on defining <code>Models</code> in models section.</p>"},{"location":"fastapi/#fastapi-endpoints-definition","title":"Fastapi endpoints definition","text":"<p>Define your desired endpoints, note how <code>ormar</code> models are used both  as <code>response_model</code> and as a requests parameters.</p> <pre><code>@app.get(\"/items/\", response_model=List[Item])\nasync def get_items():\n    items = await Item.objects.select_related(\"category\").all()\n    return items\n\n\n@app.post(\"/items/\", response_model=Item)\nasync def create_item(item: Item):\n    await item.save()\n    return item\n\n\n@app.post(\"/categories/\", response_model=Category)\nasync def create_category(category: Category):\n    await category.save()\n    return category\n\n\n@app.put(\"/items/{item_id}\")\nasync def get_item(item_id: int, item: Item):\n    item_db = await Item.objects.get(pk=item_id)\n    return await item_db.update(**item.model_dump())\n\n\n@app.delete(\"/items/{item_id}\")\nasync def delete_item(item_id: int, item: Item = None):\n    if item:\n        return {\"deleted_rows\": await item.delete()}\n    item_db = await Item.objects.get(pk=item_id)\n    return {\"deleted_rows\": await item_db.delete()}\n</code></pre> <p>Note</p> <p>Note how ormar <code>Model</code> methods like save() are available straight out of the box after fastapi initializes it for you.</p> <p>Note</p> <p>Note that you can return a <code>Model</code> (or list of <code>Models</code>) directly - fastapi will jsonize it for you</p>"},{"location":"fastapi/#test-the-application","title":"Test the application","text":""},{"location":"fastapi/#run-fastapi","title":"Run fastapi","text":"<p>If you want to run this script and play with fastapi swagger install uvicorn first</p> <p><code>pip install uvicorn</code></p> <p>And launch the fastapi.</p> <p><code>uvicorn &lt;filename_without_extension&gt;:app --reload</code></p> <p>Now you can navigate to your browser (by default fastapi address is <code>127.0.0.1:8000/docs</code>) and play with the api.</p> <p>Info</p> <p>You can read more about running fastapi in fastapi docs. </p>"},{"location":"fastapi/#test-with-pytest","title":"Test with pytest","text":"<p>Here you have a sample test that will prove that everything works as intended.</p> <p>Be sure to create the tables first. If you are using pytest you can use a fixture.</p> <pre><code>@pytest.fixture(autouse=True, scope=\"module\")\ndef create_test_database():\n    engine = sqlalchemy.create_engine(DATABASE_URL)\n    metadata.create_all(engine)\n    yield\n    metadata.drop_all(engine)\n</code></pre> <pre><code># here is a sample test to check the working of the ormar with fastapi\n\nfrom starlette.testclient import TestClient\n\ndef test_all_endpoints():\n    # note that TestClient is only sync, don't use asyns here\n    client = TestClient(app)\n    # note that you need to connect to database manually\n    # or use client as contextmanager during tests\n    with client as client:\n        response = client.post(\"/categories/\", json={\"name\": \"test cat\"})\n        category = response.json()\n        response = client.post(\n            \"/items/\", json={\"name\": \"test\", \"id\": 1, \"category\": category}\n        )\n        item = Item(**response.json())\n        assert item.pk is not None\n\n        response = client.get(\"/items/\")\n        items = [Item(**item) for item in response.json()]\n        assert items[0] == item\n\n        item.name = \"New name\"\n        response = client.put(f\"/items/{item.pk}\", json=item.model_dump())\n        assert response.json() == item.model_dump()\n\n        response = client.get(\"/items/\")\n        items = [Item(**item) for item in response.json()]\n        assert items[0].name == \"New name\"\n\n        response = client.delete(f\"/items/{item.pk}\", json=item.model_dump())\n        assert response.json().get(\"deleted_rows\", \"__UNDEFINED__\") != \"__UNDEFINED__\"\n        response = client.get(\"/items/\")\n        items = response.json()\n        assert len(items) == 0\n</code></pre> <p>Tip</p> <p>If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo</p> <p>Info</p> <p>You can read more on testing fastapi in fastapi docs. </p>"},{"location":"fastapi/requests/","title":"Request","text":"<p>You can use ormar Models in <code>fastapi</code> request <code>Body</code> parameters instead of pydantic models.</p> <p>You can of course also mix <code>ormar.Model</code>s with <code>pydantic</code> ones if you need to.</p> <p>One of the most common tasks in requests is excluding certain fields that you do not want to include in the payload you send to API.</p> <p>This can be achieved in several ways in <code>ormar</code> so below you can review your options and select the one most suitable for your situation.</p>"},{"location":"fastapi/requests/#excluding-fields-in-request","title":"Excluding fields in request","text":""},{"location":"fastapi/requests/#optional-fields","title":"Optional fields","text":"<p>Note that each field that is optional is not required, that means that Optional fields can be skipped both in response and in requests.</p> <p>Field is not required if (any/many/all) of following:</p> <ul> <li>Field is marked with <code>nullable=True</code></li> <li>Field has <code>default</code> value or function provided, i.e. <code>default=\"Test\"</code></li> <li>Field has a <code>server_default</code> value set</li> <li>Field is an <code>autoincrement=True</code> <code>primary_key</code> field (note that <code>ormar.Integer</code> <code>primary_key</code> is <code>autoincrement</code> by default)</li> </ul> <p>Example: <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=metadata\n    database=database\n)\n\nclass User(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    email: str = ormar.String(max_length=255)\n    password: str = ormar.String(max_length=255)\n    first_name: str = ormar.String(max_length=255, nullable=True)\n    last_name: str = ormar.String(max_length=255)\n    category: str = ormar.String(max_length=255, default=\"User\")\n</code></pre></p> <p>In above example fields <code>id</code> (is an <code>autoincrement</code> <code>Integer</code>), <code>first_name</code> ( has <code>nullable=True</code>) and <code>category</code> (has <code>default</code>) are optional and can be skipped in response and model will still validate.</p> <p>If the field is nullable you don't have to include it in payload during creation as well as in response, so given example above you can:</p> <p>Warning</p> <p>Note that although you do not have to pass the optional field, you still can do it. And if someone will pass a value it will be used later unless you take measures to prevent it.</p> <pre><code># note that app is an FastApi app\n@app.post(\"/users/\", response_model=User) # here we use ormar.Model in response\nasync def create_user(user: User):  # here we use ormar.Model in request parameter\n    return await user.save()\n</code></pre> <p>That means that if you do not pass i.e. <code>first_name</code> in request it will validate correctly (as field is optional), <code>None</code> will be saved in the database.</p>"},{"location":"fastapi/requests/#generate-pydantic-model-from-ormarmodel","title":"Generate <code>pydantic</code> model from <code>ormar.Model</code>","text":"<p>Since task of excluding fields is so common <code>ormar</code> has a special way to generate <code>pydantic</code> models from existing <code>ormar.Models</code> without you needing to retype all the fields. </p> <p>That method is <code>get_pydantic()</code> method available on all models classes.</p> <pre><code># generate a tree of models without password on User and without priority on nested Category\nRequestUser = User.get_pydantic(exclude={\"password\": ..., \"category\": {\"priority\"}})\n@app.post(\"/users3/\", response_model=User) # here you can also use both ormar/pydantic\nasync def create_user3(user: RequestUser):  # use the generated model here\n    # note how now user is pydantic and not ormar Model so you need to convert\n    return await User(**user.model_dump()).save()\n</code></pre> <p>Note</p> <p>To see more examples and read more visit get_pydantic part of the documentation.</p> <p>Warning</p> <p>The <code>get_pydantic</code> method generates all models in a tree of nested models according to an algorithm that allows to avoid loops in models (same algorithm that is used in <code>model_dump()</code>, <code>select_all()</code> etc.)</p> <p>That means that nested models won't have reference to parent model (by default ormar relation is bidirectional).</p> <p>Note also that if given model exists in a tree more than once it will be doubled in pydantic models (each occurrence will have separate own model). That way you can exclude/include different fields on different leafs of the tree.</p>"},{"location":"fastapi/requests/#mypy-and-type-checking","title":"Mypy and type checking","text":"<p>Note that assigning a function as a python type passes at runtime (as it's not checked) the static type checkers like mypy will complain.</p> <p>Although result of the function call will always be the same for given model using a dynamically created type is not allowed.</p> <p>Therefore you have two options:</p> <p>First one is to simply add <code># type: ignore</code> to skip the type checking</p> <pre><code>RequestUser = User.get_pydantic(exclude={\"password\": ..., \"category\": {\"priority\"}})\n@app.post(\"/users3/\", response_model=User)\nasync def create_user3(user: RequestUser):  # type: ignore\n    # note how now user is not ormar Model so you need to convert\n    return await User(**user.model_dump()).save()\n</code></pre> <p>The second one is a little bit more hacky and utilizes a way in which fastapi extract function parameters.</p> <p>You can overwrite the <code>__annotations__</code> entry for given param.</p> <pre><code>RequestUser = User.get_pydantic(exclude={\"password\": ..., \"category\": {\"priority\"}})\n# do not use the app decorator\nasync def create_user3(user: User):  # use ormar model here\n    return await User(**user.model_dump()).save()\n# overwrite the function annotations entry for user param with generated model \ncreate_user3.__annotations__[\"user\"] = RequestUser\n# manually call app functions (app.get, app.post etc.) and pass your function reference\napp.post(\"/categories/\", response_model=User)(create_user3)\n</code></pre> <p>Note that this will cause mypy to \"think\" that user is an ormar model but since in request it doesn't matter that much (you pass jsonized dict anyway and you need to convert before saving).</p> <p>That still should work fine as generated model will be a subset of fields, so all needed fields will validate, and all not used fields will fail at runtime.</p>"},{"location":"fastapi/requests/#separate-pydantic-model","title":"Separate <code>pydantic</code> model","text":"<p>The final solution is to just create separate pydantic model manually.  That works exactly the same as with normal fastapi application, so you can have different models for response and requests etc.</p> <p>Sample: <pre><code>import pydantic\n\nclass UserCreate(pydantic.BaseModel):\n    model_config = pydantic.ConfigDict(from_attributes=True)\n\n    email: str\n    first_name: str\n    last_name: str\n    password: str\n\n\n@app.post(\"/users3/\", response_model=User) # use ormar model here (but of course you CAN use pydantic also here)\nasync def create_user3(user: UserCreate):  # use pydantic model here\n    # note how now request param is a pydantic model and not the ormar one\n    # so you need to parse/convert it to ormar before you can use database\n    return await User(**user.model_dump()).save()\n</code></pre></p>"},{"location":"fastapi/response/","title":"Response","text":"<p>You can use ormar Models in <code>fastapi</code> response_model instead of pydantic models.</p> <p>You can of course also mix <code>ormar.Model</code>s with <code>pydantic</code> ones if you need to.</p> <p>One of the most common tasks in responses is excluding certain fields that you do not want to include in response data.</p> <p>This can be achieved in several ways in <code>ormar</code> so below you can review your options and select the one most suitable for your situation.</p>"},{"location":"fastapi/response/#excluding-fields-in-response","title":"Excluding fields in response","text":""},{"location":"fastapi/response/#optional-fields","title":"Optional fields","text":"<p>Note that each field that is optional is not required, that means that Optional fields can be skipped both in response and in requests.</p> <p>Field is not required if (any/many/all) of following:</p> <ul> <li>Field is marked with <code>nullable=True</code></li> <li>Field has <code>default</code> value or function provided, i.e. <code>default=\"Test\"</code></li> <li>Field has a <code>server_default</code> value set</li> <li>Field is an <code>autoincrement=True</code> <code>primary_key</code> field (note that <code>ormar.Integer</code> <code>primary_key</code> is <code>autoincrement</code> by default)</li> </ul> <p>Example: <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=metadata\n    database=database\n)\n\nclass User(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    email: str = ormar.String(max_length=255)\n    password: str = ormar.String(max_length=255)\n    first_name: str = ormar.String(max_length=255, nullable=True)\n    last_name: str = ormar.String(max_length=255)\n    category: str = ormar.String(max_length=255, default=\"User\")\n</code></pre></p> <p>In above example fields <code>id</code> (is an <code>autoincrement</code> <code>Integer</code>), <code>first_name</code> ( has <code>nullable=True</code>) and <code>category</code> (has <code>default</code>) are optional and can be skipped in response and model will still validate.</p> <p>If the field is nullable you don't have to include it in payload during creation as well as in response, so given example above you can:</p> <pre><code># note that app is an FastApi app\n@app.post(\"/users/\", response_model=User) # here we use ormar.Model in response\nasync def create_user(user: User):  # here we use ormar.Model in request parameter\n    return await user.save()\n</code></pre> <p>That means that if you do not pass i.e. <code>first_name</code> in request it will validate correctly (as field is optional), save in the database and return the saved record without this field (which will also pass validation).</p> <p>Note</p> <p>Note that although you do not pass the field value, the field itself is still present in the <code>response_model</code> that means it will be present in response data and set to <code>None</code>.</p> <p>If you want to fully exclude the field from the result read on.</p>"},{"location":"fastapi/response/#fastapi-response_model_exclude","title":"FastApi <code>response_model_exclude</code>","text":"<p>Fastapi has <code>response_model_exclude</code> that accepts a set (or a list) of field names.</p> <p>That has it's limitation as <code>ormar</code> and <code>pydantic</code> accepts also dictionaries in which you can set exclude/include columns also on nested models (more on this below)</p> <p>Warning</p> <p>Note that you cannot exclude required fields when using <code>response_model</code> as it will fail during validation.</p> <pre><code>@app.post(\"/users/\", response_model=User, response_model_exclude={\"password\"})\nasync def create_user(user: User):\n    return await user.save()\n</code></pre> <p>Above endpoint can be queried like this:</p> <pre><code>from starlette.testclient import TestClient\n\nclient = TestClient(app)\n\nwith client as client:\n        # note there is no pk\n        user = {\n            \"email\": \"test@domain.com\",\n            \"password\": \"^*^%A*DA*IAAA\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\",\n        }\n        response = client.post(\"/users/\", json=user)\n        # note that the excluded field is fully gone from response\n        assert \"password\" not in response.json()\n        # read the response and initialize model out of it\n        created_user = User(**response.json())\n        # note pk is populated by autoincrement\n        assert created_user.pk is not None\n        # note that password is missing in initialized model too\n        assert created_user.password is None\n</code></pre> <p>Note</p> <p>Note how in above example <code>password</code> field is fully gone from the response data. </p> <p>Note that you can use this method only for non-required fields.</p>"},{"location":"fastapi/response/#nested-models-excludes","title":"Nested models excludes","text":"<p>Despite the fact that <code>fastapi</code> allows passing only set of field names, so simple excludes, when using <code>response_model_exclude</code>, ormar is smarter.</p> <p>In <code>ormar</code> you can exclude nested models using two types of notations.</p> <p>One is a dictionary with nested fields that represents the model tree structure, and the second one is double underscore separated path of field names.</p> <p>Assume for a second that our user's category is a separate model:</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=metadata\n    database=database\n)\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=255)    \n    priority: int = ormar.Integer(nullable=True)\n\n\nclass User(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    email: str = ormar.String(max_length=255)\n    password: str = ormar.String(max_length=255)\n    first_name: str = ormar.String(max_length=255, nullable=True)\n    last_name: str = ormar.String(max_length=255)\n    category: Optional[Category] = ormar.ForeignKey(Category, related_name=\"categories\")\n</code></pre> <p>If you want to exclude <code>priority</code> from category in your response, you can still use fastapi parameter. <pre><code>@app.post(\"/users/\", response_model=User, response_model_exclude={\"category__priority\"})\nasync def create_user(user: User):\n    return await user.save()\n</code></pre></p> <p>Note that you can go in deeper models with double underscore, and if you want to exclude multiple fields from nested model you need to prefix them with full path. In example <code>response_model_exclude={\"category__priority\", \"category__other_field\", category__nested_model__nested_model_field}</code> etc.</p> <p>Note</p> <p>To read more about possible excludes and how to structure your exclude dictionary or set visit fields section of documentation</p> <p>Note</p> <p>Note that apart from <code>response_model_exclude</code> parameter <code>fastapi</code> supports also other parameters inherited from <code>pydantic</code>. All of them works also with ormar, but can have some nuances so best to read dict part of the documentation.</p>"},{"location":"fastapi/response/#exclude-in-modelmodel_dump","title":"Exclude in <code>Model.model_dump()</code>","text":"<p>Alternatively you can just return a dict from <code>ormar.Model</code> and use . </p> <p>Like this you can also set exclude/include as dict and exclude fields on nested models too.</p> <p>Warning</p> <p>Not using a <code>response_model</code> will cause api documentation having no response example and schema since in theory response can have any format.</p> <pre><code>@app.post(\"/users2/\", response_model=User)\nasync def create_user2(user: User):\n    user = await user.save()\n    return user.model_dump(exclude={'password'})\n    # could be also something like return user.model_dump(exclude={'category': {'priority'}}) to exclude category priority\n</code></pre> <p>Note</p> <p>Note that above example will nullify the password field even if you pass it in request, but the field will be still there as it's part of the response schema, the value will be set to <code>None</code>.</p> <p>If you want to fully exclude the field with this approach simply don't use <code>response_model</code> and exclude in Model's model_dump()</p> <p>Alternatively you can just return a dict from ormar model.  Like this you can also set exclude/include as dict and exclude fields on nested models.</p> <p>Note</p> <p>In theory you loose validation of response here but since you operate on <code>ormar.Models</code> the response data have already been validated after db query (as ormar model is pydantic model).</p> <p>So if you skip <code>response_model</code> altogether you can do something like this:</p> <pre><code>@app.post(\"/users4/\") # note no response_model\nasync def create_user4(user: User):\n    user = await user.save()\n    return user.model_dump(exclude={'last_name'})\n</code></pre> <p>Note</p> <p>Note that when you skip the response_model you can now exclude also required fields as the response is no longer validated after being returned.</p> <p>The cost of this solution is that you loose also api documentation as response schema in unknown from fastapi perspective. </p>"},{"location":"fastapi/response/#generate-pydantic-model-from-ormarmodel","title":"Generate <code>pydantic</code> model from <code>ormar.Model</code>","text":"<p>Since task of excluding fields is so common <code>ormar</code> has a special way to generate <code>pydantic</code> models from existing <code>ormar.Models</code> without you needing to retype all the fields. </p> <p>That method is <code>get_pydantic()</code> method available on all models classes.</p> <pre><code># generate a tree of models without password on User and without priority on nested Category\nResponseUser = User.get_pydantic(exclude={\"password\": ..., \"category\": {\"priority\"}})\n@app.post(\"/users3/\", response_model=ResponseUser) # use the generated model here\nasync def create_user3(user: User):\n    return await user.save()\n</code></pre> <p>Note</p> <p>To see more examples and read more visit get_pydantic part of the documentation.</p> <p>Warning</p> <p>The <code>get_pydantic</code> method generates all models in a tree of nested models according to an algorithm that allows to avoid loops in models (same algorithm that is used in <code>model_dump()</code>, <code>select_all()</code> etc.)</p> <p>That means that nested models won't have reference to parent model (by default ormar relation is bidirectional).</p> <p>Note also that if given model exists in a tree more than once it will be doubled in pydantic models (each occurrence will have separate own model). That way you can exclude/include different fields on different leafs of the tree.</p>"},{"location":"fastapi/response/#separate-pydantic-model","title":"Separate <code>pydantic</code> model","text":"<p>The final solution is to just create separate pydantic model manually.  That works exactly the same as with normal fastapi application so you can have different models for response and requests etc.</p> <p>Sample: <pre><code>import pydantic\n\nclass UserBase(pydantic.BaseModel):\n    model_config = pydantic.ConfigDict(from_attributes=True)\n\n    email: str\n    first_name: str\n    last_name: str\n\n\n@app.post(\"/users3/\", response_model=UserBase) # use pydantic model here\nasync def create_user3(user: User): #use ormar model here (but of course you CAN use pydantic also here)\n    return await user.save()\n</code></pre></p>"},{"location":"fields/common-parameters/","title":"Common Parameters","text":"<p>All <code>Field</code> types have a set of common parameters.</p>"},{"location":"fields/common-parameters/#primary_key","title":"primary_key","text":"<p><code>primary_key</code>: <code>bool</code> = <code>False</code> -&gt; by default False.</p> <p>Sets the primary key column on a table, foreign keys always refer to the pk of the <code>Model</code>.</p> <p>Used in sql only.</p>"},{"location":"fields/common-parameters/#autoincrement","title":"autoincrement","text":"<p><code>autoincrement</code>: <code>bool</code> = <code>primary_key and type == int</code> -&gt; defaults to True if column is a primary key and of type Integer, otherwise False.</p> <p>Can be only used with int/bigint fields.</p> <p>If a field has autoincrement it becomes optional.</p> <p>Used both in sql and pydantic (changes pk field to optional for autoincrement).</p>"},{"location":"fields/common-parameters/#nullable","title":"nullable","text":"<p><code>nullable</code>: <code>bool</code> = <code>False</code> -&gt; defaults to False for all fields except relation fields.</p> <p>Automatically changed to True if user provide one of the following:</p> <ul> <li><code>default</code> value or function is provided</li> <li><code>server_default</code> value or function is provided</li> <li><code>autoincrement</code> is set on <code>Integer</code> <code>primary_key</code> field</li> </ul> <p>Specifies if field is optional or required, used both with sql and pydantic.</p> <p>By default, used for both <code>pydantic</code> and <code>sqlalchemy</code> as those are the most common settings:</p> <ul> <li><code>nullable=False</code> - means database column is not null and field is required in pydantic</li> <li><code>nullable=True</code> - means database column is null and field is optional in pydantic</li> </ul> <p>If you want to set different setting for pydantic and the database see <code>sql_nullable</code> below.</p> <p>Note</p> <p>By default all <code>ForeignKeys</code> are also nullable, meaning the related <code>Model</code> is not required.</p> <p>If you change the <code>ForeignKey</code> column to <code>nullable=False</code>, it becomes required.</p>"},{"location":"fields/common-parameters/#sql_nullable","title":"sql_nullable","text":"<p><code>sql_nullable</code>: <code>bool</code> = <code>nullable</code> -&gt; defaults to the value of nullable (described above). </p> <p>Specifies if field is not null or allows nulls in the database only. </p> <p>Use this setting in combination with <code>nullable</code> only if you want to set different options on pydantic model and in the database. </p> <p>A sample usage might be i.e. making field not null in the database, but allow this field to be nullable in pydantic (i.e. with <code>server_default</code> value). That will prevent the updates of the field to null (as with <code>server_default</code> set you cannot insert null values already as the default value would be used)</p>"},{"location":"fields/common-parameters/#default","title":"default","text":"<p><code>default</code>: <code>Any</code> = <code>None</code> -&gt; defaults to None. </p> <p>A default value used if no other value is passed.</p> <p>In sql invoked on an insert, used during pydantic model definition.</p> <p>If the field has a default value it becomes optional.</p> <p>You can pass a static value or a Callable (function etc.)</p> <p>Used both in sql and pydantic.</p> <p>Sample usage:</p> <pre><code># note the distinction between passing a value and Callable pointer\n\n# value\nname: str = ormar.String(max_length=200, default=\"Name\")\n\n# note that when you call a function it's not a pointer to Callable\n# a definition like this will call the function at startup and assign\n# the result of the function to the default, so it will be constant value for all instances\ncreated_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now())\n\n# if you want to pass Callable reference (note that it cannot have arguments)\n# note lack of the parenthesis -&gt; ormar will call this function for you on each model\ncreated_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n\n# Callable can be a function, builtin, class etc.\n</code></pre>"},{"location":"fields/common-parameters/#server-default","title":"server default","text":"<p><code>server_default</code>: <code>Any</code> = <code>None</code>  -&gt; defaults to None. </p> <p>A default value used if no other value is passed.</p> <p>In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause).</p> <p>If the field has a server_default value it becomes optional.</p> <p>You can pass a static value or a Callable (function etc.)</p> <p>Used in sql only.</p> <p>Sample usage:</p> <pre><code>from datetime import datetime\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom sqlalchemy import func, text\n\ndatabase = databases.Database(\"sqlite:///test.db\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Product(ormar.Model):\n\n    ormar_config = ormar.OrmarConfig(\n        database=database, metadata=metadata, tablename=\"product\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    company: str = ormar.String(max_length=200, server_default=\"Acme\")\n    sort_order: int = ormar.Integer(server_default=text(\"10\"))\n    created: datetime = ormar.DateTime(server_default=func.now())\n</code></pre> <p>Warning</p> <p><code>server_default</code> accepts <code>str</code>, <code>sqlalchemy.sql.elements.ClauseElement</code> or <code>sqlalchemy.sql.elements.TextClause</code> so if you want to set i.e. Integer value you need to wrap it in <code>sqlalchemy.text()</code> function like above</p> <p>Tip</p> <p>You can pass also valid sql (dialect specific) wrapped in <code>sqlalchemy.text()</code></p> <p>For example <code>func.now()</code> above could be exchanged for <code>text('(CURRENT_TIMESTAMP)')</code> for sqlite backend</p> <p>Info</p> <p><code>server_default</code> is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation</p>"},{"location":"fields/common-parameters/#name","title":"name","text":"<p><code>name</code>: <code>str</code> = <code>None</code> -&gt; defaults to None</p> <p>Allows you to specify a column name alias to be used. </p> <p>Useful for existing database structures that use a reserved keyword, or if you would like to use database name that is different from <code>ormar</code> field name. </p> <p>Take for example the snippet below. </p> <p><code>from</code>, being a reserved word in python, will prevent you from creating a model with that column name. </p> <p>Changing the model name to <code>from_</code> and adding the parameter <code>name='from'</code> will cause ormar to use <code>from</code> for the database column name. </p> <pre><code> #... rest of Model cut for brevity\n from_: str = ormar.String(max_length=15, name='from')\n</code></pre> <p>Similarly, you can change the foreign key column names in database, while keeping the desired relation name in ormar:</p> <pre><code> # ... rest of Model cut for brevity\nalbum: Optional[Album] = ormar.ForeignKey(Album, name=\"album_id\")\n</code></pre>"},{"location":"fields/common-parameters/#index","title":"index","text":"<p><code>index</code>: <code>bool</code> = <code>False</code> -&gt; by default False, </p> <p>Sets the index on a table's column.</p> <p>Used in sql only.</p>"},{"location":"fields/common-parameters/#unique","title":"unique","text":"<p><code>unique</code>: <code>bool</code> = <code>False</code> </p> <p>Sets the unique constraint on a table's column.</p> <p>Used in sql only.</p>"},{"location":"fields/common-parameters/#overwrite_pydantic_type","title":"overwrite_pydantic_type","text":"<p>By default, ormar uses predefined pydantic field types that it applies on model creation (hence the type hints are optional).</p> <p>If you want to, you can apply your own type, that will be completely replacing the build in one. So it's on you as a user to provide a type that is valid in the context of given ormar field type.</p> <p>Warning</p> <p>Note that by default you should use build in arguments that are passed to underlying pydantic field. </p> <p>You can check what arguments are supported in field types section or in pydantic docs.</p> <p>Danger</p> <p>Setting a wrong type of pydantic field can break your model, so overwrite it only when you know what you are doing.</p> <p>As it's easy to break functionality of ormar the <code>overwrite_pydantic_type</code> argument is not available on relation fields!</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=metadata\n    database=database\n)\n\n\n# sample overwrites\nclass OverwriteTest(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"overwrites\")\n\n    id: int = ormar.Integer(primary_key=True)\n    my_int: str = ormar.Integer(overwrite_pydantic_type=PositiveInt)\n    constraint_dict: Json = ormar.JSON(\n        overwrite_pydantic_type=Optional[Json[Dict[str, int]]])\n</code></pre>"},{"location":"fields/encryption/","title":"Encryption","text":"<p><code>ormar</code> provides you with a way to encrypt a field in the database only. Provided encryption backends allow for both one-way encryption (<code>HASH</code> backend) as well as both-way encryption/decryption (<code>FERNET</code> backend).</p> <p>Warning</p> <p>Note that in order for encryption to work you need to install optional <code>cryptography</code> package.</p> <p>You can do it manually <code>pip install cryptography</code> or with ormar by <code>pip install ormar[crypto]</code></p> <p>Warning</p> <p>Note that adding <code>encrypt_backend</code> changes the database column type to <code>TEXT</code>,  which needs to be reflected in db either by migration (<code>alembic</code>) or manual change</p>"},{"location":"fields/encryption/#defining-a-field-encryption","title":"Defining a field encryption","text":"<p>To encrypt a field you need to pass at minimum <code>encrypt_secret</code> and <code>encrypt_backend</code> parameters.</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=metadata\n    database=database\n)\n\nclass Filter(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, \n                             encrypt_secret=\"secret123\", \n                             encrypt_backend=ormar.EncryptBackends.FERNET)\n</code></pre> <p>Warning</p> <p>You can encrypt all <code>Field</code> types apart from <code>primary_key</code> column and relation  columns (<code>ForeignKey</code> and <code>ManyToMany</code>). Check backends details for more information.</p>"},{"location":"fields/encryption/#available-backends","title":"Available backends","text":""},{"location":"fields/encryption/#hash","title":"HASH","text":"<p>HASH is a one-way hash (like for password), never decrypted on retrieval</p> <p>To set it up pass appropriate backend value.</p> <pre><code>... # rest of model definition\npassword: str = ormar.String(max_length=128,\n                         encrypt_secret=\"secret123\", \n                         encrypt_backend=ormar.EncryptBackends.HASH)\n</code></pre> <p>Note that since this backend never decrypt the stored value it's only applicable for <code>String</code> fields. Used hash is a <code>sha512</code> hash, so the field length has to be &gt;=128.</p> <p>Warning</p> <p>Note that in <code>HASH</code> backend you can filter by full value but filters like <code>contain</code> will not work as comparison is make on encrypted values</p> <p>Note</p> <p>Note that provided <code>encrypt_secret</code> is first hashed itself and used as salt, so in order to compare to stored string you need to recreate this steps. The <code>order_by</code> will not work as encrypted strings are compared so you cannot reliably order by.</p> <pre><code>class Hash(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"hashes\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=128,\n                             encrypt_secret=\"udxc32\",\n                             encrypt_backend=ormar.EncryptBackends.HASH)\n\n\nawait Hash(name='test1').save()\n\n# note the steps to recreate the stored value\n# you can use also cryptography package instead of hashlib\nsecret = hashlib.sha256(\"udxc32\".encode()).digest()\nsecret = base64.urlsafe_b64encode(secret)\nhashed_test1 = hashlib.sha512(secret + 'test1'.encode()).hexdigest()\n\n# full value comparison works\nhash1 = await Hash.objects.get(name='test1')\nassert hash1.name == hashed_test1\n\n# but partial comparison does not (hashed strings are compared)\nwith pytest.raises(NoMatch):\n    await Filter.objects.get(name__icontains='test')\n</code></pre>"},{"location":"fields/encryption/#fernet","title":"FERNET","text":"<p>FERNET is a two-way encrypt/decrypt backend</p> <p>To set it up pass appropriate backend value.</p> <pre><code>... # rest of model definition\nyear: int = ormar.Integer(encrypt_secret=\"secret123\", \n                          encrypt_backend=ormar.EncryptBackends.FERNET)\n</code></pre> <p>Value is encrypted on way to database end decrypted on way out. Can be used on all types, as the returned value is parsed to corresponding python type.</p> <p>Warning</p> <p>Note that in <code>FERNET</code> backend you loose <code>filter</code>ing possibility altogether as part of the encrypted value is a timestamp. The same goes for <code>order_by</code> as encrypted strings are compared so you cannot reliably order by. </p> <pre><code>class Filter(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, \n                             encrypt_secret=\"asd123\", \n                             encrypt_backend=ormar.EncryptBackends.FERNET)\n\nawait Filter(name='test1').save()\nawait Filter(name='test1').save()\n\n# values are properly encrypted and later decrypted\nfilters = await Filter.objects.all()\nassert filters[0].name == filters[1].name == 'test1'\n\n# but you cannot filter at all since part of the fernet hash is a timestamp\n# which means that even if you encrypt the same string 2 times it will be different\nwith pytest.raises(NoMatch):\n    await Filter.objects.get(name='test1')\n</code></pre>"},{"location":"fields/encryption/#custom-backends","title":"Custom Backends","text":"<p>If you wish to support other type of encryption (i.e. AES) you can provide your own <code>EncryptionBackend</code>.</p> <p>To setup a backend all you need to do is subclass <code>ormar.fields.EncryptBackend</code> class and provide required backend.</p> <p>Sample dummy backend (that does nothing) can look like following:</p> <pre><code>class DummyBackend(ormar.fields.EncryptBackend):\n    def _initialize_backend(self, secret_key: bytes) -&gt; None:\n        pass\n\n    def encrypt(self, value: Any) -&gt; str:\n        return value\n\n    def decrypt(self, value: Any) -&gt; str:\n        return value\n</code></pre> <p>To use this backend set <code>encrypt_backend</code> to <code>CUSTOM</code> and provide your backend as argument by <code>encrypt_custom_backend</code>.</p> <pre><code>class Filter(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, \n                             encrypt_secret=\"secret123\", \n                             encrypt_backend=ormar.EncryptBackends.CUSTOM,\n                             encrypt_custom_backend=DummyBackend\n                             )\n</code></pre>"},{"location":"fields/field-types/","title":"Fields","text":"<p>There are 12 basic model field types and a special <code>ForeignKey</code> and <code>ManyToMany</code> fields to establish relationships between models.</p> <p>Tip</p> <p>For explanation of <code>ForeignKey</code> and <code>ManyToMany</code> fields check relations.</p> <p>Each of the <code>Fields</code> has assigned both <code>sqlalchemy</code> column class and python type that is used to create <code>pydantic</code> model.</p>"},{"location":"fields/field-types/#fields-types","title":"Fields Types","text":""},{"location":"fields/field-types/#string","title":"String","text":"<p><code>String(max_length: int,          min_length: int = None,         regex: str = None,)</code> has a required <code>max_length</code> parameter.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.String</code> </li> <li>Type (used for pydantic): <code>str</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#text","title":"Text","text":"<p><code>Text()</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Text</code> </li> <li>Type (used for pydantic): <code>str</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#boolean","title":"Boolean","text":"<p><code>Boolean()</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Boolean</code> </li> <li>Type (used for pydantic): <code>bool</code> </li> </ul>"},{"location":"fields/field-types/#integer","title":"Integer","text":"<p><code>Integer(minimum: int = None,         maximum: int = None,         multiple_of: int = None)</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Integer</code> </li> <li>Type (used for pydantic): <code>int</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#biginteger","title":"BigInteger","text":"<p><code>BigInteger(minimum: int = None,         maximum: int = None,         multiple_of: int = None)</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.BigInteger</code> </li> <li>Type (used for pydantic): <code>int</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#smallinteger","title":"SmallInteger","text":"<p><code>SmallInteger(minimum: int = None,         maximum: int = None,         multiple_of: int = None)</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.SmallInteger</code> </li> <li>Type (used for pydantic): <code>int</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#float","title":"Float","text":"<p><code>Float(minimum: float = None,         maximum: float = None,         multiple_of: int = None)</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Float</code> </li> <li>Type (used for pydantic): <code>float</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#decimal","title":"Decimal","text":"<p><code>Decimal(minimum: float = None,         maximum: float = None,         multiple_of: int = None,         precision: int = None,         scale: int = None,         max_digits: int = None,         decimal_places: int = None)</code> has no required parameters</p> <p>You can use either <code>length</code> and <code>precision</code> parameters or <code>max_digits</code> and <code>decimal_places</code>.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.DECIMAL</code> </li> <li>Type (used for pydantic): <code>decimal.Decimal</code> </li> </ul> <p>Tip</p> <p>For explanation of other parameters check pydantic documentation.</p>"},{"location":"fields/field-types/#date","title":"Date","text":"<p><code>Date()</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Date</code> </li> <li>Type (used for pydantic): <code>datetime.date</code> </li> </ul>"},{"location":"fields/field-types/#time","title":"Time","text":"<p><code>Time(timezone: bool = False)</code> has no required parameters.  </p> <p>You can pass <code>timezone=True</code> for timezone aware database column.</p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Time</code> </li> <li>Type (used for pydantic): <code>datetime.time</code> </li> </ul>"},{"location":"fields/field-types/#datetime","title":"DateTime","text":"<p><code>DateTime(timezone: bool = False)</code> has no required parameters.  </p> <p>You can pass <code>timezone=True</code> for timezone aware database column.</p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.DateTime</code> </li> <li>Type (used for pydantic): <code>datetime.datetime</code> </li> </ul>"},{"location":"fields/field-types/#json","title":"JSON","text":"<p><code>JSON()</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.JSON</code> </li> <li>Type (used for pydantic): <code>pydantic.Json</code> </li> </ul>"},{"location":"fields/field-types/#largebinary","title":"LargeBinary","text":"<p><code>LargeBinary(max_length)</code> has a required <code>max_length</code> parameter.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.LargeBinary</code> </li> <li>Type (used for pydantic): <code>bytes</code></li> </ul> <p>LargeBinary length is used in some backend (i.e. mysql) to determine the size of the field, in other backends it's simply ignored yet in ormar it's always required. It should be max size of the file/bytes in bytes.</p> <p><code>LargeBinary</code> has also optional <code>represent_as_base64_str: bool = False</code> flag.  When set to <code>True</code> <code>ormar</code> will auto-convert bytes value to base64 decoded string,  you can also set value by passing a base64 encoded string. </p> <p>That way you can i.e. set the value by API, even if value is not <code>utf-8</code> compatible and would otherwise fail during json conversion.</p> <pre><code>import base64\n... # other imports skipped for brevity \n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=metadata\n    database=database\n)\n\n\nclass LargeBinaryStr(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"my_str_blobs\")\n\n    id: int = ormar.Integer(primary_key=True)\n    test_binary: str = ormar.LargeBinary(\n        max_length=100000, represent_as_base64_str=True\n    )\n\n# set non utf-8 compliant value - note this can be passed by api (i.e. fastapi) in json\nitem = LargeBinaryStr(test_binary=base64.b64encode(b\"\\xc3\\x28\").decode())\n\nassert item.test_binary == base64.b64encode(b\"\\xc3\\x28\").decode()\n\n# technical note that underlying value is still bytes and will be saved as so\nassert item.__dict__[\"test_binary\"] == b\"\\xc3\\x28\"\n</code></pre>"},{"location":"fields/field-types/#uuid","title":"UUID","text":"<p><code>UUID(uuid_format: str = 'hex')</code> has no required parameters.  </p> <ul> <li>Sqlalchemy column: <code>ormar.UUID</code> based on <code>sqlalchemy.CHAR(36)</code> or <code>sqlalchemy.CHAR(32)</code> field (for string or hex format respectively)  </li> <li>Type (used for pydantic): <code>uuid.UUID</code> </li> </ul> <p><code>uuid_format</code> parameters allow 'hex'(default) or 'string' values.</p> <p>Depending on the format either 32 or 36 char is used in the database.</p> <p>Sample:</p> <ul> <li>'hex' format value = <code>c616ab438cce49dbbf4380d109251dce</code> (CHAR(32))</li> <li>'string' value = <code>c616ab43-8cce-49db-bf43-80d109251dce</code> (CHAR(36))  </li> </ul> <p>When loaded it's always python UUID so you can compare it and compare two formats values between each other.</p>"},{"location":"fields/field-types/#enum","title":"Enum","text":"<p>There are two ways to use enums in ormar -&gt; one is a dedicated <code>Enum</code> field that uses <code>sqlalchemy.Enum</code> column type, while the other is setting <code>choices</code> on any field in ormar.</p> <p>The Enum field uses the database dialect specific Enum column type if it's available, but fallback to varchar if this field type is not available.</p> <p>The <code>choices</code> option always respect the database field type selected.</p> <p>So which one to use depends on the backend you use and on the column/ data type you want in your Enum field.</p>"},{"location":"fields/field-types/#enum-field","title":"Enum - Field","text":"<p><code>Enum(enum_class=Type[Enum])</code> has a required <code>enum_class</code> parameter.  </p> <ul> <li>Sqlalchemy column: <code>sqlalchemy.Enum</code> </li> <li>Type (used for pydantic): <code>Type[Enum]</code></li> </ul>"},{"location":"fields/pydantic-fields/","title":"Pydantic only fields","text":"<p>Ormar allows you to declare normal <code>pydantic</code> fields in its model, so you have access to all basic and custom pydantic fields like <code>str</code>, <code>int</code>, <code>HttpUrl</code>, <code>PaymentCardNumber</code> etc.</p> <p>You can even declare fields leading to nested pydantic only Models, not only single fields.</p> <p>Since those fields are not stored in database (that's the whole point of those fields), you have to provide a meaningful value for them, either by setting a default one or  providing one during model initialization.</p> <p>If <code>ormar</code> cannot resolve the value for pydantic field it will fail during loading data from the database, with missing required value for declared pydantic field.</p> <p>Options to provide a value are described below.</p> <p>Of course you can combine few or all of them in one model.</p>"},{"location":"fields/pydantic-fields/#optional-field","title":"Optional field","text":"<p>If you set a field as <code>Optional</code>, it defaults to <code>None</code> if not provided and that's  exactly what's going to happen during loading from database.</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL),\n)\n\n\nclass ModelTest(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=200)\n    number: Optional[PaymentCardNumber]\n\ntest = ModelTest(name=\"Test\")\nassert test.name == \"Test\"\nassert test.number is None\ntest.number = \"123456789015\"\n\nawait test.save()\ntest_check = await ModelTest.objects.get()\n\nassert test_check.name == \"Test\"\n# after load it's back to None\nassert test_check.number is None\n</code></pre>"},{"location":"fields/pydantic-fields/#field-with-default-value","title":"Field with default value","text":"<p>By setting a default value, this value will be set on initialization and database load.  Note that setting a default to <code>None</code> is the same as setting the field to <code>Optional</code>.</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL),\n)\n\n\nclass ModelTest(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=200)\n    url: HttpUrl = \"https://www.example.com\"\n\ntest = ModelTest(name=\"Test\")\nassert test.name == \"Test\"\nassert test.url == \"https://www.example.com\"\n\ntest.url = \"https://www.sdta.ada.pt\"\nassert test.url == \"https://www.sdta.ada.pt\"\n\nawait test.save()\ntest_check = await ModelTest.objects.get()\n\nassert test_check.name == \"Test\"\n# after load it's back to default\nassert test_check.url == \"https://www.example.com\"\n</code></pre>"},{"location":"fields/pydantic-fields/#default-factory-function","title":"Default factory function","text":"<p>By setting a <code>default_factory</code> function, this result of the function call will be set  on initialization and each database load.</p> <pre><code>from pydantic import Field, PaymentCardNumber\n# ...\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL),\n)\n\n\nCARD_NUMBERS = [\n    \"123456789007\",\n    \"123456789015\",\n    \"123456789023\",\n    \"123456789031\",\n    \"123456789049\",\n]\n\n\ndef get_number():\n    return random.choice(CARD_NUMBERS)\n\n\nclass ModelTest2(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=200)\n    # note that you do not call the function, just pass reference\n    number: PaymentCardNumber = Field(default_factory=get_number)\n\n# note that you still CAN provide a value \ntest = ModelTest2(name=\"Test2\", number=\"4000000000000002\")\nassert test.name == \"Test2\"\nassert test.number == \"4000000000000002\"\n\nawait test.save()\ntest_check = await ModelTest2.objects.get()\n\nassert test_check.name == \"Test2\"\n# after load value is set to be one of the CARD_NUMBERS\nassert test_check.number in CARD_NUMBERS\nassert test_check.number != test.number\n</code></pre>"},{"location":"fields/pydantic-fields/#custom-setup-in-__init__","title":"Custom setup in <code>__init__</code>","text":"<p>You can provide a value for the field in your <code>__init__()</code> method before calling a <code>super()</code> init method.</p> <pre><code>from pydantic import BaseModel\n# ...\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL),\n)\n\n\nclass PydanticTest(BaseModel):\n    aa: str\n    bb: int\n\n\nclass ModelTest3(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    # provide your custom init function\n    def __init__(self, **kwargs):\n        # add value for required field without default value\n        kwargs[\"pydantic_test\"] = PydanticTest(aa=\"random\", bb=42)\n        # remember to call ormar.Model init!\n        super().__init__(**kwargs)\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=200)\n    pydantic_test: PydanticTest\n\ntest = ModelTest3(name=\"Test3\")\nassert test.name == \"Test3\"\nassert test.pydantic_test.bb == 42\ntest.pydantic.aa = \"new value\"\nassert test.pydantic.aa == \"new value\"\n\nawait test.save()\ntest_check = await ModelTest3.objects.get()\n\nassert test_check.name == \"Test3\"\n# after load it's back to value provided in init\nassert test_check.pydantic_test.aa == \"random\"\n</code></pre> <p>Warning</p> <p>If you do not provide a value in one of the above ways <code>ValidationError</code> will be raised on load from database.</p>"},{"location":"models/","title":"Models","text":""},{"location":"models/#defining-models","title":"Defining models","text":"<p>By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own.</p>"},{"location":"models/#model-class","title":"Model Class","text":"<p>To build an ormar model you simply need to inherit a <code>ormar.Model</code> class.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre>"},{"location":"models/#defining-fields","title":"Defining Fields","text":"<p>Next assign one or more of the Fields as a class level variables.</p>"},{"location":"models/#basic-field-types","title":"Basic Field Types","text":"<p>Each table has to have a primary key column, which you specify by setting <code>primary_key=True</code> on selected field.</p> <p>Only one primary key column is allowed.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre> <p>Warning</p> <p>Not assigning <code>primary_key</code> column or assigning more than one column per <code>Model</code> will raise <code>ModelDefinitionError</code> exception.</p> <p>By default if you assign primary key to <code>Integer</code> field, the <code>autoincrement</code> option is set to true.</p> <p>You can disable by passing <code>autoincrement=False</code>.</p> <pre><code>id: int = ormar.Integer(primary_key=True, autoincrement=False)\n</code></pre>"},{"location":"models/#non-database-fields","title":"Non Database Fields","text":"<p>Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a  field like usual in pydantic.</p> <p>Fields created like this are added to the <code>pydantic</code> model fields -&gt; so are subject to validation according to <code>Field</code> type,  also appear in <code>model_dump()</code> and <code>model_dump_json()</code> result. </p> <p>The difference is that those fields are not saved in the database. So they won't be included in underlying sqlalchemy <code>columns</code>,  or <code>table</code> variables (check Internals section below to see how you can access those if you need).</p> <p>Subsequently, pydantic fields won't be included in migrations or any database operation (like <code>save</code>, <code>update</code> etc.)</p> <p>Fields like those can be passed around into payload in <code>fastapi</code> request and will be returned in <code>fastapi</code> response  (of course only if you set their value somewhere in your code as the value is not fetched from the db.  If you pass a value in <code>fastapi</code> <code>request</code> and return the same instance that <code>fastapi</code> constructs for you in <code>request_model</code> you should get back exactly same value in <code>response</code>.).</p> <p>Warning</p> <p>pydantic fields have to be always Optional and it cannot be changed (otherwise db load validation would fail)</p> <pre><code>import databases\nimport ormar\nimport pydantic\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    non_db_field: str = pydantic.Field(max_length=100)\n</code></pre> <p>If you set pydantic field with <code>default</code> parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set <code>default=datetime.datetime.now</code> and get current timestamp each time you call an endpoint etc.</p>"},{"location":"models/#non-database-fields-in-fastapi","title":"Non Database Fields in Fastapi","text":"<p>Note</p> <p>Note, that both pydantic and calculated_fields decorated field can be included/excluded in both <code>model_dump()</code> and <code>fastapi</code> response with <code>include</code>/<code>exclude</code> and <code>response_model_include</code>/<code>response_model_exclude</code> accordingly.</p> <pre><code># &lt;==part of related code removed for clarity==&gt;\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n    engine=sqlalchemy.create_engine(DATABASE_URL),\n)\n\n\nclass User(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"users2\")\n\n    id: int = ormar.Integer(primary_key=True)\n    email: str = ormar.String(max_length=255, nullable=False)\n    password: str = ormar.String(max_length=255)\n    first_name: str = ormar.String(max_length=255)\n    last_name: str = ormar.String(max_length=255)\n    category: str = ormar.String(max_length=255, nullable=True)\n    timestamp: datetime.datetime = pydantic.Field(\n        default=datetime.datetime.now\n    )\n\n# &lt;==part of related code removed for clarity==&gt;\napp = FastAPI()\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return await user.save()\n\n# &lt;==part of related code removed for clarity==&gt;\n\ndef test_excluding_fields_in_endpoints():\n    client = TestClient(app)\n    with client as client:\n        timestamp = datetime.datetime.now()\n\n        user = {\n            \"email\": \"test@domain.com\",\n            \"password\": \"^*^%A*DA*IAAA\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\",\n            \"timestamp\": str(timestamp),\n        }\n        response = client.post(\"/users/\", json=user)\n        assert list(response.json().keys()) == [\n            \"id\",\n            \"email\",\n            \"first_name\",\n            \"last_name\",\n            \"category\",\n            \"timestamp\",\n        ]\n        # returned is the same timestamp\n        assert response.json().get(\"timestamp\") == str(timestamp).replace(\" \", \"T\")\n\n\n# &lt;==part of related code removed for clarity==&gt;\n</code></pre>"},{"location":"models/#fields-names-vs-column-names","title":"Fields names vs Column names","text":"<p>By default names of the fields will be used for both the underlying <code>pydantic</code> model and <code>sqlalchemy</code> table.</p> <p>If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this  with specifying <code>name</code> parameter during Field declaration</p> <p>Here you have a sample model with changed names <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URl = \"sqlite:///test.db\"\n\ndatabase = databases.Database(DATABASE_URl, force_rollback=True)\nmetadata = sqlalchemy.MetaData()\n\n\nclass Child(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"children\",\n    )\n\n    id: int = ormar.Integer(name=\"child_id\", primary_key=True)\n    first_name: str = ormar.String(name=\"fname\", max_length=100)\n    last_name: str = ormar.String(name=\"lname\", max_length=100)\n    born_year: int = ormar.Integer(name=\"year_born\", nullable=True)\n</code></pre></p> <p>Note that you can also change the ForeignKey column name <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///test.db\", force_rollback=True)\nmetadata = sqlalchemy.MetaData()\n\n\nclass Artist(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"artists\",\n    )\n\n    id: int = ormar.Integer(name=\"artist_id\", primary_key=True)\n    first_name: str = ormar.String(name=\"fname\", max_length=100)\n    last_name: str = ormar.String(name=\"lname\", max_length=100)\n    born_year: int = ormar.Integer(name=\"year\")\n\n\nclass Album(ormar.Model):\n\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"music_albums\",\n    )\n\n    id: int = ormar.Integer(name=\"album_id\", primary_key=True)\n    name: str = ormar.String(name=\"album_name\", max_length=100)\n    artist: Optional[Artist] = ormar.ForeignKey(Artist, name=\"artist_id\")\n</code></pre></p> <p>But for now you cannot change the ManyToMany column names as they go through other Model anyway. <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URl = \"sqlite:///test.db\"\n\ndatabase = databases.Database(DATABASE_URl, force_rollback=True)\nmetadata = sqlalchemy.MetaData()\n\n\nclass Child(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"children\",\n    )\n\n    id: int = ormar.Integer(name=\"child_id\", primary_key=True)\n    first_name: str = ormar.String(name=\"fname\", max_length=100)\n    last_name: str = ormar.String(name=\"lname\", max_length=100)\n    born_year: int = ormar.Integer(name=\"year_born\", nullable=True)\n\n\nclass ArtistChildren(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"children_x_artists\",\n    )\n\n\nclass Artist(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"artists\",\n    )\n\n    id: int = ormar.Integer(name=\"artist_id\", primary_key=True)\n    first_name: str = ormar.String(name=\"fname\", max_length=100)\n    last_name: str = ormar.String(name=\"lname\", max_length=100)\n    born_year: int = ormar.Integer(name=\"year\")\n    children = ormar.ManyToMany(Child, through=ArtistChildren)\n</code></pre></p>"},{"location":"models/#overwriting-the-default-queryset","title":"Overwriting the default QuerySet","text":"<p>If you want to customize the queries run by ormar you can define your own queryset class (that extends the ormar <code>QuerySet</code>) in your model class, default one is simply the <code>QuerySet</code></p> <p>You can provide a new class in <code>ormar_config</code> of your class as <code>queryset_class</code> parameter.</p> <pre><code>import ormar\nfrom ormar.queryset.queryset import QuerySet\nfrom fastapi import HTTPException\n\n\nclass MyQuerySetClass(QuerySet):\n\n    async def first_or_404(self, *args, **kwargs):\n        entity = await self.get_or_none(*args, **kwargs) \n        if entity is None:\n            # in fastapi or starlette\n            raise HTTPException(404)\n\n\nclass Book(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        queryset_class=MyQuerySetClass,\n        tablename=\"book\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=32)\n\n\n# when book not found, raise `404` in your view.\nbook = await Book.objects.first_or_404(name=\"123\")\n</code></pre>"},{"location":"models/#type-hints","title":"Type Hints","text":"<p>Note that for better IDE support and mypy checks you can provide type hints.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre> <p>Note that type hints are optional so perfectly valid <code>ormar</code> code can look like this:</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=100)\n    completed = ormar.Boolean(default=False)\n</code></pre> <p>Warning</p> <p>Even if you use type hints <code>ormar</code> does not use them to construct <code>pydantic</code> fields!</p> <p>Type hints are there only to support static checkers and linting,  <code>ormar</code> construct annotations used by <code>pydantic</code> from own fields.</p>"},{"location":"models/#dependencies","title":"Dependencies","text":"<p>Since ormar depends on <code>databases</code> and <code>sqlalchemy-core</code> for database connection  and table creation you need to assign each <code>Model</code> with two special parameters.</p>"},{"location":"models/#databases","title":"Databases","text":"<p>One is <code>Database</code> instance created with your database url in sqlalchemy connection string format.</p> <p>Created instance needs to be passed to every <code>Model</code> with <code>ormar_config</code> object <code>database</code> parameter.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre> <p>Tip</p> <p>You need to create the <code>Database</code> instance only once and use it for all models.  You can create several ones if you want to use multiple databases.</p>"},{"location":"models/#sqlalchemy","title":"Sqlalchemy","text":"<p>Second dependency is sqlalchemy <code>MetaData</code> instance.</p> <p>Created instance needs to be passed to every <code>Model</code> with <code>ormar_config</code> object <code>metadata</code> parameter.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre> <p>Tip</p> <p>You need to create the <code>MetaData</code> instance only once and use it for all models.  You can create several ones if you want to use multiple databases.</p>"},{"location":"models/#best-practice","title":"Best practice","text":"<p>Note that <code>ormar</code> expects the field with name <code>ormar_config</code> that is an instance of <code>OrmarConfig</code> class. To ease the config management, the <code>OrmarConfig</code> class provide <code>copy</code> method. So instead of providing the same parameters over and over again for all models you should create a base object and use its copy in all models.</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Artist(ormar.Model):\n    # note that tablename is optional\n    # if not provided ormar will user class.__name__.lower()+'s'\n    # -&gt; artists in this example\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=100)\n    last_name: str = ormar.String(max_length=100)\n    born_year: int = ormar.Integer(name=\"year\")\n\n\nclass Album(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    artist: Optional[Artist] = ormar.ForeignKey(Artist)\n</code></pre>"},{"location":"models/#table-names","title":"Table Names","text":"<p>By default table name is created from Model class name as lowercase name plus 's'.</p> <p>You can overwrite this parameter by providing <code>ormar_config</code> object's <code>tablename</code> argument.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        # if you omit this parameter it will be created automatically\n        # as class.__name__.lower()+'s' -&gt; \"courses\" in this example\n        tablename=\"my_courses\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre>"},{"location":"models/#constraints","title":"Constraints","text":"<p>On a model level you can also set model-wise constraints on sql columns.</p> <p>Right now only <code>IndexColumns</code>, <code>UniqueColumns</code> and <code>CheckColumns</code> constraints are supported. </p> <p>Note</p> <p>Note that both constraints should be used only if you want to set a name on constraint or want to set the index on multiple columns, otherwise <code>index</code> and <code>unique</code> properties on ormar fields are preferred.</p> <p>Tip</p> <p>To read more about columns constraints like <code>primary_key</code>, <code>unique</code>, <code>ForeignKey</code> etc. visit fields.</p>"},{"location":"models/#uniquecolumns","title":"UniqueColumns","text":"<p>You can set this parameter by providing <code>ormar_config</code> object <code>constraints</code> argument.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        # define your constraints in OrmarConfig of the model\n        # it's a list that can contain multiple constraints\n        # hera a combination of name and column will have to be unique in db\n        constraints=[ormar.UniqueColumns(\"name\", \"completed\")],\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre> <p>Note</p> <p>Note that constraints are meant for combination of columns that should be unique.  To set one column as unique use <code>unique</code> common parameter.  Of course you can set many columns as unique with this param but each of them will be checked separately.</p>"},{"location":"models/#indexcolumns","title":"IndexColumns","text":"<p>You can set this parameter by providing <code>ormar_config</code> object <code>constraints</code> argument.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        # define your constraints in OrmarConfig of the model\n        # it's a list that can contain multiple constraints\n        # hera a combination of name and column will have a compound index in the db\n        constraints=[ormar.IndexColumns(\"name\", \"completed\")],\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre> <p>Note</p> <p>Note that constraints are meant for combination of columns that should be in the index.  To set one column index use <code>unique</code> common parameter.  Of course, you can set many columns as indexes with this param but each of them will be a separate index.</p>"},{"location":"models/#checkcolumns","title":"CheckColumns","text":"<p>You can set this parameter by providing <code>ormar_config</code> object <code>constraints</code> argument.</p> <pre><code>import datetime\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        # define your constraints in OrmarConfig of the model\n        # it's a list that can contain multiple constraints\n        # hera a combination of name and column will have a level check in the db\n        constraints=[\n            ormar.CheckColumns(\"start_time &lt; end_time\", name=\"date_check\"),\n        ],\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    start_date: datetime.date = ormar.Date()\n    end_date: datetime.date = ormar.Date()\n</code></pre> <p>Note</p> <p>Note that some databases do not actively support check constraints (such as MySQL).</p>"},{"location":"models/#pydantic-configuration","title":"Pydantic configuration","text":"<p>As each <code>ormar.Model</code> is also a <code>pydantic</code> model, you might want to tweak the settings of the pydantic configuration.</p> <p>The way to do this in pydantic is to adjust the settings on the <code>model_config</code> dictionary provided to your model, and it works exactly the same for ormar models.</p> <p>So in order to set your own preferences you need to provide not only the <code>ormar_config</code> class but also the <code>model_config = ConfigDict()</code> class to your model.</p> <p>Note</p> <p>To read more about available settings visit the pydantic config page.</p> <p>Note that if you do not provide your own configuration, ormar will do it for you. The default config provided is as follows:</p> <pre><code>model_config = ConfigDict(validate_assignment=True, ser_json_bytes=\"base64\")\n</code></pre> <p>So to overwrite setting or provide your own a sample model can look like following: <pre><code>import databases\nimport ormar\nimport pydantic\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    model_config = pydantic.ConfigDict(frozen=True)\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n</code></pre></p>"},{"location":"models/#extra-fields-in-models","title":"Extra fields in models","text":"<p>By default <code>ormar</code> forbids you to pass extra fields to Model.</p> <p>If you try to do so the <code>ModelError</code> will be raised.</p> <p>Since the extra fields cannot be saved in the database the default to disallow such fields seems a feasible option.</p> <p>On the contrary in <code>pydantic</code> the default option is to ignore such extra fields, therefore <code>ormar</code> provides an <code>ormar_config.extra</code> setting to behave in the same way.</p> <p>To ignore extra fields passed to <code>ormar</code> set this setting to <code>Extra.ignore</code> instead of default <code>Extra.forbid</code>.</p> <p>Note that <code>ormar</code> does not allow accepting extra fields, you can only ignore them or forbid them (raise exception if present)</p> <pre><code>from ormar import Extra, OrmarConfig\n\nclass Child(ormar.Model):\n    ormar_config = OrmarConfig(\n        tablename=\"children\",\n        extra=Extra.ignore  # set extra setting to prevent exceptions on extra fields presence\n    )\n\n    id: int = ormar.Integer(name=\"child_id\", primary_key=True)\n    first_name: str = ormar.String(name=\"fname\", max_length=100)\n    last_name: str = ormar.String(name=\"lname\", max_length=100)\n</code></pre> <p>To set the same setting on all model check the best practices and <code>base_ormar_config</code> concept.</p>"},{"location":"models/#model-sort-order","title":"Model sort order","text":"<p>When querying the database with given model by default the Model is ordered by the <code>primary_key</code> column ascending. If you wish to change the default behaviour you can do it by providing <code>orders_by</code> parameter to model <code>ormar_config</code> object.</p> <p>Sample default ordering (not specified - so by primary key): <pre><code>base_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\n# default sort by column id ascending\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        tablename=\"authors\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre> Modified <pre><code>base_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n# now default sort by name descending\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        orders_by = [\"-name\"],\n        tablename=\"authors\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre></p>"},{"location":"models/#model-initialization","title":"Model Initialization","text":"<p>There are two ways to create and persist the <code>Model</code> instance in the database.</p> <p>If you plan to modify the instance in the later execution of your program you can initiate your <code>Model</code> as a normal class and later await a <code>save()</code> call.  </p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"courses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    course = Course(name=\"Painting for dummies\", completed=False)\n    await course.save()\n\n    await Course.objects.create(name=\"Painting for dummies\", completed=False)\n\n\nasyncio.run(run_query())\n</code></pre> <p>If you want to initiate your <code>Model</code> and at the same time save in in the database use a QuerySet's method <code>create()</code>.</p> <p>For creating multiple objects at once a <code>bulk_create()</code> QuerySet's method is available.</p> <p>Each model has a <code>QuerySet</code> initialised as <code>objects</code> parameter </p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"courses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    course = Course(name=\"Painting for dummies\", completed=False)\n    await course.save()\n\n    await Course.objects.create(name=\"Painting for dummies\", completed=False)\n\n\nasyncio.run(run_query())\n</code></pre> <p>Info</p> <p>To read more about <code>QuerySets</code> (including bulk operations) and available methods visit queries</p>"},{"location":"models/#model-save-status","title":"<code>Model</code> save status","text":"<p>Each model instance is a separate python object and they do not know anything about each other.</p> <pre><code>track1 = await Track.objects.get(name='The Bird')\ntrack2 = await Track.objects.get(name='The Bird')\nassert track1 == track2 # True\n\ntrack1.name = 'The Bird2'\nawait track1.save()\nassert track1.name == track2.name # False\n# track2 does not update and knows nothing about track1\n</code></pre> <p>The objects itself have a saved status, which is set as following:</p> <ul> <li>Model is saved after <code>save/update/load/upsert</code> method on model</li> <li>Model is saved after <code>create/get/first/all/get_or_create/update_or_create</code> method</li> <li>Model is saved when passed to <code>bulk_update</code> and <code>bulk_create</code></li> <li>Model is saved after <code>adding/removing</code> <code>ManyToMany</code> related objects (through model instance auto saved/deleted)</li> <li>Model is not saved after change of any own field (including <code>pk</code> as <code>Model.pk</code> alias)</li> <li>Model is not saved after adding/removing <code>ForeignKey</code> related object (fk column not saved)</li> <li>Model is not saved after instantiation with <code>__init__</code> (w/o <code>QuerySet.create</code> or before calling <code>save</code>)</li> </ul> <p>You can check if model is saved with <code>ModelInstance.saved</code> property</p>"},{"location":"models/inheritance/","title":"Inheritance","text":"<p>Out of various types of ORM models inheritance <code>ormar</code> currently supports two of them:</p> <ul> <li>Mixins</li> <li>Concrete table inheritance (with parents set to <code>abstract=True</code>)</li> </ul>"},{"location":"models/inheritance/#types-of-inheritance","title":"Types of inheritance","text":"<p>The short summary of different types of inheritance:</p> <ul> <li>Mixins [SUPPORTED] - don't subclass <code>ormar.Model</code>, just define fields that are   later used on different models (like <code>created_date</code> and <code>updated_date</code> on each model),   only actual models create tables, but those fields from mixins are added</li> <li>Concrete table inheritance [SUPPORTED] - means that parent is marked as abstract   and each child has its own table with columns from a parent and own child columns, kind   of similar to Mixins but parent also is a Model</li> <li>Single table inheritance [NOT SUPPORTED] - means that only one table is created   with fields that are combination/sum of the parent and all children models but child   models use only subset of column in db (all parent and own ones, skipping the other   children ones)</li> <li>Multi/ Joined table inheritance [NOT SUPPORTED] - means that part of the columns   is saved on parent model and part is saved on child model that are connected to each   other by kind of one to one relation and under the hood you operate on two models at   once</li> <li>Proxy models [NOT SUPPORTED] - means that only parent has an actual table,   children just add methods, modify settings etc.</li> </ul>"},{"location":"models/inheritance/#mixins","title":"Mixins","text":"<p>To use Mixins just define a class that is not inheriting from an <code>ormar.Model</code> but is defining <code>ormar.Fields</code> as class variables.</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n    engine=sqlalchemy.create_engine(DATABASE_URL),\n)\n\n\n# a mixin defines the fields but is a normal python class \nclass AuditMixin:\n    created_by: str = ormar.String(max_length=100)\n    updated_by: str = ormar.String(max_length=100, default=\"Sam\")\n\n\nclass DateFieldsMixins:\n    created_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n    updated_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n\n\n# a models can inherit from one or more mixins\nclass Category(ormar.Model, DateFieldsMixins, AuditMixin):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=50, unique=True, index=True)\n    code: int = ormar.Integer()\n</code></pre> <p>Tip</p> <p>Note that Mixins are not models, so you still need to inherit from <code>ormar.Model</code> as well as define <code>ormar_config</code> field in the final model.</p> <p>A Category class above will have four additional fields: <code>created_date</code>, <code>updated_date</code>, <code>created_by</code> and <code>updated_by</code>.</p> <p>There will be only one table created for model <code>Category</code> (<code>categories</code>), with <code>Category</code> class fields combined with all <code>Mixins</code> fields.</p> <p>Note that <code>Mixin</code> in class name is optional but is a good python practice.</p>"},{"location":"models/inheritance/#concrete-table-inheritance","title":"Concrete table inheritance","text":"<p>In concept concrete table inheritance is very similar to Mixins, but uses actual <code>ormar.Models</code> as base classes.</p> <p>Warning</p> <p>Note that base classes have <code>abstract=True</code> set in <code>ormar_config</code> object, if you try to inherit from non abstract marked class <code>ModelDefinitionError</code> will be raised.</p> <p>Since this abstract Model will never be initialized you can skip <code>metadata</code> and <code>database</code> in it's <code>ormar_config</code> definition.</p> <p>But if you provide it - it will be inherited, that way you do not have to provide <code>metadata</code> and <code>databases</code> in the final/concrete class</p> <p>Note that you can always overwrite it in child/concrete class if you need to.</p> <p>More over at least one of the classes in inheritance chain have to provide both <code>database</code> and <code>metadata</code> - otherwise an error will be raised.</p> <pre><code># note that base classes have abstract=True\n# since this model will never be initialized you can skip metadata and database\nclass AuditModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    created_by: str = ormar.String(max_length=100)\n    updated_by: str = ormar.String(max_length=100, default=\"Sam\")\n\n\n# but if you provide it it will be inherited - DRY (Don't Repeat Yourself) in action\nclass DateFieldsModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(\n        abstract=True,\n        metadata=metadata,\n        database=db,\n    )\n\n    created_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n    updated_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n\n\n# that way you do not have to provide metadata and databases in concrete class\nclass Category(DateFieldsModel, AuditModel):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=50, unique=True, index=True)\n    code: int = ormar.Integer()\n</code></pre> <p>The list of inherited options/settings is as follows: <code>metadata</code>, <code>database</code> and <code>constraints</code>.</p> <p>Of course apart from that all fields from base classes are combined and created in the concrete table of the final Model.</p> <p>Tip</p> <p>Note how you don't have to provide <code>abstarct=False</code> in the final class - it's the default setting that is not inherited.</p>"},{"location":"models/inheritance/#redefining-fields-in-subclasses","title":"Redefining fields in subclasses","text":"<p>Note that you can redefine previously created fields like in normal python class inheritance.</p> <p>Whenever you define a field with same name and new definition it will completely replace the previously defined one.</p> <pre><code># base class\nclass DateFieldsModel(ormar.Model):\n    ormar_config = OrmarConfig(\n        abstract=True,\n        metadata=metadata,\n        database=db,\n        # note that UniqueColumns need sqlalchemy db columns names not the ormar ones\n        constraints=[ormar.UniqueColumns(\"creation_date\", \"modification_date\")]\n    )\n\n    created_date: datetime.datetime = ormar.DateTime(\n        default=datetime.datetime.now, name=\"creation_date\"\n    )\n    updated_date: datetime.datetime = ormar.DateTime(\n        default=datetime.datetime.now, name=\"modification_date\"\n    )\n\n\nclass RedefinedField(DateFieldsModel):\n    ormar_config = OrmarConfig(\n        tablename=\"redefines\",\n        metadata=metadata,\n        database=db,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    # here the created_date is replaced by the String field\n    created_date: str = ormar.String(max_length=200, name=\"creation_date\")\n\n\n# you can verify that the final field is correctly declared and created\nchanged_field = RedefinedField.ormar_config.model_fields[\"created_date\"]\nassert changed_field.default is None\nassert changed_field.alias == \"creation_date\"\nassert any(x.name == \"creation_date\" for x in RedefinedField.ormar_config.table.columns)\nassert isinstance(\n    RedefinedField.ormar_config.table.columns[\"creation_date\"].type,\n    sqlalchemy.sql.sqltypes.String,\n)\n</code></pre> <p>Warning</p> <p>If you declare <code>UniqueColumns</code> constraint with column names, the final model has to have a column with the same name declared. Otherwise, the <code>ModelDefinitionError</code> will be raised.</p> <p>So in example above if you do not provide <code>name</code> for <code>created_date</code> in <code>RedefinedField</code> model ormar will complain.</p> <p><code>created_date: str = ormar.String(max_length=200) # exception</code></p> <p><code>created_date: str = ormar.String(max_length=200, name=\"creation_date2\") # exception</code></p>"},{"location":"models/inheritance/#relations-in-inheritance","title":"Relations in inheritance","text":"<p>You can declare relations in every step of inheritance, so both in parent and child classes. </p> <p>When you define a relation on a child model level it's either overwriting the relation  defined in parent model (if the same field name is used), or is accessible only to this  child if you define a new relation.</p> <p>When inheriting relations, you always need to be aware of <code>related_name</code> parameter, that has to be unique across a related model, when you define multiple child classes that inherit the same relation.</p> <p>If you do not provide <code>related_name</code> parameter ormar calculates it for you. This works with inheritance as all child models have to have different class names, which are used to calculate the default <code>related_name</code> (class.name.lower()+'s').</p> <p>But, if you provide a <code>related_name</code> this name cannot be reused in all child models as they would overwrite each other on the related model side.</p> <p>Therefore, you have two options:</p> <ul> <li>redefine relation field in child models and manually provide different <code>related_name</code>   parameters</li> <li>let this for <code>ormar</code> to handle -&gt; auto adjusted related_name are: original   related_name + \"_\" + child model table name</li> </ul> <p>That might sound complicated but let's look at the following example:</p>"},{"location":"models/inheritance/#foreignkey-relations","title":"ForeignKey relations","text":"<pre><code># normal model used in relation\nclass Person(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\n# parent model - needs to be abstract\nclass Car(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=50)\n    owner: Person = ormar.ForeignKey(Person)\n    # note that we refer to the Person model again so we **have to** provide related_name\n    co_owner: Person = ormar.ForeignKey(Person, related_name=\"coowned\")\n    created_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n\n\nclass Truck(Car):\n    ormar_config = base_ormar_config.copy()\n\n    max_capacity: int = ormar.Integer()\n\n\nclass Bus(Car):\n    ormar_config = base_ormar_config.copy(tablename=\"buses\")\n\n    max_persons: int = ormar.Integer()\n</code></pre> <p>Now when you will inspect the fields on Person model you will get:</p> <pre><code>Person.ormar_config.model_fields\n\"\"\"\n{'id': &lt;class 'ormar.fields.model_fields.Integer'&gt;, \n'name': &lt;class 'ormar.fields.model_fields.String'&gt;, \n'trucks': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_trucks': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'buss': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_buses': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;}\n\"\"\"\n</code></pre> <p>Note how you have <code>trucks</code> and <code>buss</code> fields that leads to Truck and Bus class that this Person owns. There were no <code>related_name</code> parameter so default names were used.</p> <p>At the same time the co-owned cars need to be referenced by <code>coowned_trucks</code> and <code>coowned_buses</code>. Ormar appended <code>_trucks</code> and <code>_buses</code> suffixes taken from child model table names.</p> <p>Seems fine, but the default name for owned trucks is ok (<code>trucks</code>) but the <code>buss</code> is ugly, so how can we change it?</p> <p>The solution is pretty simple - just redefine the field in Bus class and provide different <code>related_name</code> parameter.</p> <pre><code># rest of the above example remains the same\nclass Bus(Car):\n    ormar_config = base_ormar_config.copy(tablename=\"buses\")\n\n    # new field that changes the related_name\n    owner: Person = ormar.ForeignKey(Person, related_name=\"buses\")\n    max_persons: int = ormar.Integer()\n</code></pre> <p>Now the columns looks much better.</p> <pre><code>Person.ormar_config.model_fields\n\"\"\"\n{'id': &lt;class 'ormar.fields.model_fields.Integer'&gt;, \n'name': &lt;class 'ormar.fields.model_fields.String'&gt;, \n'trucks': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_trucks': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'buses': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_buses': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;}\n\"\"\"\n</code></pre> <p>Note</p> <p>You could also provide <code>related_name</code> for the <code>owner</code> field, that way the proper suffixes would be added.</p> <p><code>owner: Person = ormar.ForeignKey(Person, related_name=\"owned\")</code> </p> <p>and model fields for Person owned cars would become <code>owned_trucks</code> and <code>owned_buses</code>.</p>"},{"location":"models/inheritance/#manytomany-relations","title":"ManyToMany relations","text":"<p>Similarly, you can inherit from Models that have ManyToMany relations declared but there is one, but substantial difference - the Through model. </p> <p>Since the Through model will be able to hold additional fields, and now it links only two Tables  (<code>from</code> and <code>to</code> ones), each child that inherits the m2m relation field has to have separate Through model. </p> <p>Of course, you can overwrite the relation in each Child model, but that requires additional code and undermines the point of the whole inheritance. <code>Ormar</code> will handle this for you if you agree with default naming convention, which you can always manually overwrite in  children if needed.</p> <p>Again, let's look at the example to easier grasp the concepts. </p> <p>We will modify the previous example described above to use m2m relation for co_owners.</p> <pre><code># person remain the same as above\nclass Person(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n# new through model between Person and Car2\nclass PersonsCar(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"cars_x_persons\")\n\n# note how co_owners is now ManyToMany relation\nclass Car2(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=50)\n    # note the related_name - needs to be unique across Person\n    # model, regardless of how many different models leads to Person\n    owner: Person = ormar.ForeignKey(Person, related_name=\"owned\")\n    co_owners: List[Person] = ormar.ManyToMany(\n        Person, through=PersonsCar, related_name=\"coowned\"\n    )\n    created_date: datetime.datetime = ormar.DateTime(default=datetime.datetime.now)\n\n\n# child models define only additional Fields\nclass Truck2(Car2):\n    ormar_config = base_ormar_config.copy(tablename=\"trucks2\")\n\n    max_capacity: int = ormar.Integer()\n\n\nclass Bus2(Car2):\n    ormar_config = base_ormar_config.copy(tablename=\"buses2\")\n\n    max_persons: int = ormar.Integer()\n</code></pre> <p><code>Ormar</code> automatically modifies related_name of the fields to include the table name  of the children models. The default name is original related_name + '_' + child table name.</p> <p>That way for class Truck2 the relation defined in  <code>owner: Person = ormar.ForeignKey(Person, related_name=\"owned\")</code> becomes <code>owned_trucks2</code></p> <p>You can verify the names by inspecting the list of fields present on <code>Person</code> model.</p> <pre><code>Person.ormar_config.model_fields\n{\n# note how all relation fields need to be unique on Person\n# regardless if autogenerated or manually overwritten\n'id': &lt;class 'ormar.fields.model_fields.Integer'&gt;, \n'name': &lt;class 'ormar.fields.model_fields.String'&gt;, \n# note that we expanded on previous example so all 'old' fields are here\n'trucks': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_trucks': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'buses': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_buses': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n# newly defined related fields\n'owned_trucks2': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_trucks2': &lt;class 'abc.ManyToMany'&gt;, \n'owned_buses2': &lt;class 'ormar.fields.foreign_key.ForeignKey'&gt;, \n'coowned_buses2': &lt;class 'abc.ManyToMany'&gt;\n}\n</code></pre> <p>But that's not all. It's kind of internal to <code>ormar</code> but affects the data structure in the database, so let's examine the through models for both <code>Bus2</code> and <code>Truck2</code> models.</p> <pre><code>Bus2.ormar_config.model_fields['co_owners'].through\n&lt;class 'abc.PersonsCarBus2'&gt;\nBus2.ormar_config.model_fields['co_owners'].through.ormar_config.tablename\n'cars_x_persons_buses2'\n\nTruck2.ormar_config.model_fields['co_owners'].through\n&lt;class 'abc.PersonsCarTruck2'&gt;\nTruck2.ormar_config.model_fields['co_owners'].through.ormar_config.tablename\n'cars_x_persons_trucks2'\n</code></pre> <p>As you can see above <code>ormar</code> cloned the Through model for each of the Child classes and added Child class name at the end, while changing the table names of the cloned fields the name of the table from the child is used.</p> <p>Note that original model is not only not used, the table for this model is removed from metadata:</p> <pre><code>Bus2.ormar_config.metadata.tables.keys()\ndict_keys(['test_date_models', 'categories', 'subjects', 'persons', 'trucks', 'buses', \n           'cars_x_persons_trucks2', 'trucks2', 'cars_x_persons_buses2', 'buses2'])\n</code></pre> <p>So be aware that if you introduce inheritance along the way and convert a model into  abstract parent model you may lose your data on through table if not careful.</p> <p>Note</p> <p>Note that original table name and model name of the Through model is never used. Only the cloned models tables are created and used.</p> <p>Warning</p> <p>Note that each subclass of the Model that has <code>ManyToMany</code> relation defined generates a new <code>Through</code> model, meaning also new database table.</p> <p>That means that each time you define a Child model you need to either manually create the table in the database, or run a migration (with alembic).</p>"},{"location":"models/inheritance/#exclude_parent_fields","title":"exclude_parent_fields","text":"<p>Ormar allows you to skip certain fields in inherited model that are coming from a parent model.</p> <p>Note</p> <p>Note that the same behaviour can be achieved by splitting the model into more abstract models and mixins - which is a preferred way in normal circumstances.</p> <p>To skip certain fields from a child model, list all fields that you want to skip in <code>model.ormar_config.exclude_parent_fields</code> parameter like follows:</p> <pre><code>base_ormar_config = OrmarConfig(\n    metadata=sa.MetaData(),\n    database=databases.Database(DATABASE_URL),\n)\n\n\nclass AuditModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    created_by: str = ormar.String(max_length=100)\n    updated_by: str = ormar.String(max_length=100, default=\"Sam\")\n\n\nclass DateFieldsModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    created_date: datetime.datetime = ormar.DateTime(\n        default=datetime.datetime.now, name=\"creation_date\"\n    )\n    updated_date: datetime.datetime = ormar.DateTime(\n        default=datetime.datetime.now, name=\"modification_date\"\n    )\n\n\nclass Category(DateFieldsModel, AuditModel):\n    ormar_config = base_ormar_config.copy(\n        tablename=\"categories\",\n        # set fields that should be skipped\n        exclude_parent_fields=[\"updated_by\", \"updated_date\"],\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=50, unique=True, index=True)\n    code: int = ormar.Integer()\n\n# Note that now the update fields in Category are gone in all places -&gt; ormar fields, pydantic fields and sqlachemy table columns\n# so full list of available fields in Category is: [\"created_by\", \"created_date\", \"id\", \"name\", \"code\"]\n</code></pre> <p>Note how you simply need to provide field names and it will exclude the parent field regardless of from which parent model the field is coming from.</p> <p>Note</p> <p>Note that if you want to overwrite a field in child model you do not have to exclude it, simply overwrite the field declaration in child model with same field name.</p> <p>Warning</p> <p>Note that this kind of behavior can confuse mypy and static type checkers, yet accessing the non existing fields will fail at runtime. That's why splitting the base classes is preferred.</p> <p>The same effect can be achieved by splitting base classes like:</p> <pre><code>base_ormar_config = OrmarConfig(\n    metadata=sa.MetaData(),\n    database=databases.Database(DATABASE_URL),\n)\n\n\nclass AuditCreateModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    created_by: str = ormar.String(max_length=100)\n\n\nclass AuditUpdateModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    updated_by: str = ormar.String(max_length=100, default=\"Sam\")\n\nclass CreateDateFieldsModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    created_date: datetime.datetime = ormar.DateTime(\n        default=datetime.datetime.now, name=\"creation_date\"\n    )\n\nclass UpdateDateFieldsModel(ormar.Model):\n    ormar_config = base_ormar_config.copy(abstract=True)\n\n    updated_date: datetime.datetime = ormar.DateTime(\n        default=datetime.datetime.now, name=\"modification_date\"\n    )\n\n\nclass Category(CreateDateFieldsModel, AuditCreateModel):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=50, unique=True, index=True)\n    code: int = ormar.Integer()\n</code></pre> <p>That way you can inherit from both create and update classes if needed, and only one of them otherwise.</p>"},{"location":"models/internals/","title":"Internals","text":"<p>Apart from special parameters defined in the <code>Model</code> during definition (tablename, metadata etc.) the <code>Model</code> provides you with useful internals.</p>"},{"location":"models/internals/#pydantic-model","title":"Pydantic Model","text":"<p>All <code>Model</code> classes inherit from <code>pydantic.BaseModel</code> so you can access all normal attributes of pydantic models.</p> <p>For example to list pydantic model fields you can:</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n\n\nprint(Course.model_fields)\n\"\"\"\nWill produce:\n{'id':        Field(name='id', \n                         type=Optional[int], \n                         required=False, \n                         default=None),\n 'name':      Field(name='name', \n                         type=Optional[str], \n                         required=False, \n                         default=None),\n'completed':  Field(name='completed', \n                         type=bool, \n                         required=False, \n                         default=False)}\n\"\"\"\n</code></pre> <p>Tip</p> <p>Note how the primary key <code>id</code> field is optional as <code>Integer</code> primary key by default has <code>autoincrement</code> set to <code>True</code>.</p> <p>Info</p> <p>For more options visit official pydantic documentation.</p>"},{"location":"models/internals/#sqlalchemy-table","title":"Sqlalchemy Table","text":"<p>To access auto created sqlalchemy table you can use <code>Model.ormar_config.table</code> parameter</p> <p>For example to list table columns you can:</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        tablename=\"courses\",\n        database=databases.Database(DATABASE_URL),\n        metadata=sqlalchemy.MetaData(),\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n\n\nprint(Course.ormar_config.table.columns)\n\"\"\"\nWill produce:\nImmutableColumnCollection(courses.id, courses.name, courses.completed)\n\"\"\"\n</code></pre> <p>Tip</p> <p>You can access table primary key name by <code>Course.ormar_config.pkname</code></p> <p>Info</p> <p>For more options visit official sqlalchemy-metadata documentation.</p>"},{"location":"models/internals/#fields-definition","title":"Fields Definition","text":"<p>To access ormar <code>Fields</code> you can use <code>Model.ormar_config.model_fields</code> parameter</p> <p>For example to list table model fields you can:</p> <pre><code>import pprint\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n\n\npprint.pp({x: v.__dict__ for x, v in Course.ormar_config.model_fields.items()})\n\"\"\"\nWill produce:\n{'id': {'__type__': &lt;class 'int'&gt;,\n        '__pydantic_type__': &lt;class 'int'&gt;,\n        '__sample__': 0,\n        'related_name': None,\n        'column_type': Integer(),\n        'constraints': [],\n        'name': 'id',\n        'db_alias': None,\n        'primary_key': True,\n        'autoincrement': True,\n        'nullable': True,\n        'sql_nullable': False,\n        'index': False,\n        'unique': False,\n        'virtual': None,\n        'is_multi': None,\n        'is_relation': None,\n        'is_through': False,\n        'through_relation_name': None,\n        'through_reverse_relation_name': None,\n        'skip_reverse': False,\n        'skip_field': False,\n        'owner': &lt;class '__main__.Course'&gt;,\n        'to': None,\n        'to_pk_only': None,\n        'through': None,\n        'self_reference': False,\n        'self_reference_primary': None,\n        'orders_by': None,\n        'related_orders_by': None,\n        'encrypt_secret': None,\n        'encrypt_backend': &lt;EncryptBackends.NONE: 0&gt;,\n        'encrypt_custom_backend': None,\n        'ormar_default': None,\n        'server_default': None,\n        'comment': None,\n        'represent_as_base64_str': False,\n        'minimum': None,\n        'maximum': None,\n        'multiple_of': None,\n        'ge': None,\n        'le': None},\n 'name': {'__type__': &lt;class 'str'&gt;,\n          '__pydantic_type__': &lt;class 'str'&gt;,\n          '__sample__': 'string',\n          'related_name': None,\n          'column_type': String(length=100),\n          'constraints': [],\n          'name': 'name',\n          'db_alias': None,\n          'primary_key': False,\n          'autoincrement': False,\n          'nullable': False,\n          'sql_nullable': False,\n          'index': False,\n          'unique': False,\n          'virtual': None,\n          'is_multi': None,\n          'is_relation': None,\n          'is_through': False,\n          'through_relation_name': None,\n          'through_reverse_relation_name': None,\n          'skip_reverse': False,\n          'skip_field': False,\n          'owner': &lt;class '__main__.Course'&gt;,\n          'to': None,\n          'to_pk_only': None,\n          'through': None,\n          'self_reference': False,\n          'self_reference_primary': None,\n          'orders_by': None,\n          'related_orders_by': None,\n          'encrypt_secret': None,\n          'encrypt_backend': &lt;EncryptBackends.NONE: 0&gt;,\n          'encrypt_custom_backend': None,\n          'ormar_default': None,\n          'server_default': None,\n          'comment': None,\n          'represent_as_base64_str': False,\n          'max_length': 100,\n          'min_length': None,\n          'regex': None},\n 'completed': {'__type__': &lt;class 'bool'&gt;,\n               '__pydantic_type__': &lt;class 'bool'&gt;,\n               '__sample__': True,\n               'related_name': None,\n               'column_type': Boolean(),\n               'constraints': [],\n               'name': 'completed',\n               'db_alias': None,\n               'primary_key': False,\n               'autoincrement': False,\n               'nullable': True,\n               'sql_nullable': True,\n               'index': False,\n               'unique': False,\n               'virtual': None,\n               'is_multi': None,\n               'is_relation': None,\n               'is_through': False,\n               'through_relation_name': None,\n               'through_reverse_relation_name': None,\n               'skip_reverse': False,\n               'skip_field': False,\n               'owner': &lt;class '__main__.Course'&gt;,\n               'to': None,\n               'to_pk_only': None,\n               'through': None,\n               'self_reference': False,\n               'self_reference_primary': None,\n               'orders_by': None,\n               'related_orders_by': None,\n               'encrypt_secret': None,\n               'encrypt_backend': &lt;EncryptBackends.NONE: 0&gt;,\n               'encrypt_custom_backend': None,\n               'ormar_default': False,\n               'server_default': None,\n               'comment': None,\n               'represent_as_base64_str': False}}\n\"\"\"\n</code></pre> <p>Info</p> <p>Note that fields stored on a model are <code>classes</code> not <code>instances</code>.</p> <p>So if you print just model fields you will get:</p> <p><code>{'id': &lt;class 'ormar.fields.model_fields.Integer'&gt;,</code></p> <p><code>'name': &lt;class 'ormar.fields.model_fields.String'&gt;,</code></p> <p><code>'completed': &lt;class 'ormar.fields.model_fields.Boolean'&gt;}</code></p>"},{"location":"models/methods/","title":"Model methods","text":"<p>Tip</p> <p>Main interaction with the databases is exposed through a <code>QuerySet</code> object exposed on  each model as <code>Model.objects</code> similar to the django orm.</p> <p>To read more about quering, joining tables, excluding fields etc. visit queries section.</p> <p>Each model instance have a set of methods to <code>save</code>, <code>update</code> or <code>load</code> itself.</p> <p>Available methods are described below.</p>"},{"location":"models/methods/#pydantic-methods","title":"<code>pydantic</code> methods","text":"<p>Note that each <code>ormar.Model</code> is also a <code>pydantic.BaseModel</code>, so all <code>pydantic</code> methods are also available on a model, especially <code>model_dump()</code> and <code>model_dump_json()</code> methods that can also accept <code>exclude</code>, <code>include</code> and other parameters.</p> <p>To read more check pydantic documentation</p>"},{"location":"models/methods/#model_construct","title":"model_construct()","text":"<p><code>model_construct</code> is a raw equivalent of <code>__init__</code> method used for construction of new instances.</p> <p>The difference is that <code>model_construct</code> skips validations, so it should be used when you know that data is correct and can be trusted. The benefit of using construct is the speed of execution due to skipped validation.</p> <p>Note</p> <p>Note that in contrast to <code>pydantic.model_construct</code> method - the <code>ormar</code> equivalent will also process the nested related models.</p> <p>Warning</p> <p>Bear in mind that due to skipped validation the <code>construct</code> method does not perform any conversions, checks etc.  So it's your responsibility to provide that data that is valid and can be consumed by the database.</p> <p>The only two things that construct still performs are:</p> <ul> <li>Providing a <code>default</code> value for not set fields</li> <li>Initialize nested ormar models if you pass a dictionary or a primary key value</li> </ul>"},{"location":"models/methods/#model_dump","title":"model_dump()","text":"<p><code>model_dump</code> is a method inherited from <code>pydantic</code>, yet <code>ormar</code> adds its own parameters and has some nuances when working with default values, therefore it's listed here for clarity.</p> <p><code>model_dump</code> as the name suggests export data from model tree to dictionary.</p> <p>Explanation of model_dump parameters:</p>"},{"location":"models/methods/#include-ormar-modified","title":"include (<code>ormar</code> modified)","text":"<p><code>include: Union[Set, Dict] = None</code></p> <p>Set or dictionary of field names to include in returned dictionary.</p> <p>Note that <code>pydantic</code> has an uncommon pattern of including/ excluding fields in lists (so also nested models) by an index. And if you want to exclude the field in all children you need to pass a <code>__all__</code> key to dictionary. </p> <p>You cannot exclude nested models in <code>Set</code>s in <code>pydantic</code> but you can in <code>ormar</code>  (by adding double underscore on relation name i.e. to exclude name of category for a book you can use <code>exclude={\"book__category__name\"}</code>)</p> <p><code>ormar</code> does not support by index exclusion/ inclusions and accepts a simplified and more user-friendly notation.</p> <p>To check how you can include/exclude fields, including nested fields check out fields section that has an explanation and a lot of samples.</p> <p>Note</p> <p>The fact that in <code>ormar</code> you can exclude nested models in sets, you can exclude from a whole model tree in <code>response_model_exclude</code> and <code>response_model_include</code> in fastapi!</p>"},{"location":"models/methods/#exclude-ormar-modified","title":"exclude (<code>ormar</code> modified)","text":"<p><code>exclude: Union[Set, Dict] = None</code></p> <p>Set or dictionary of field names to exclude in returned dictionary.</p> <p>Note that <code>pydantic</code> has an uncommon pattern of including/ excluding fields in lists (so also nested models) by an index. And if you want to exclude the field in all children you need to pass a <code>__all__</code> key to dictionary. </p> <p>You cannot exclude nested models in <code>Set</code>s in <code>pydantic</code> but you can in <code>ormar</code>  (by adding double underscore on relation name i.e. to exclude name of category for a book you cen use <code>exclude={\"book__category__name\"}</code>)</p> <p><code>ormar</code> does not support by index exclusion/ inclusions and accepts a simplified and more user-friendly notation.</p> <p>To check how you can include/exclude fields, including nested fields check out fields section that has an explanation and a lot of samples.</p> <p>Note</p> <p>The fact that in <code>ormar</code> you can exclude nested models in sets, you can exclude from a whole model tree in <code>response_model_exclude</code> and <code>response_model_include</code> in fastapi!</p>"},{"location":"models/methods/#exclude_unset","title":"exclude_unset","text":"<p><code>exclude_unset: bool = False</code></p> <p>Flag indicates whether fields which were not explicitly set when creating the model should be excluded from the returned dictionary.</p> <p>Warning</p> <p>Note that after you save data into database each field has its own value -&gt; either provided by you, default, or <code>None</code>.</p> <p>That means that when you load the data from database, all fields are set, and this flag basically stop working! </p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, default=\"Test\")\n    visibility: bool = ormar.Boolean(default=True)\n\n\nclass Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    price: float = ormar.Float(default=9.99)\n    categories: List[Category] = ormar.ManyToMany(Category)\n\ncategory = Category(name=\"Test 2\")\nassert category.model_dump() == {'id': None, 'items': [], 'name': 'Test 2',\n                           'visibility': True}\nassert category.model_dump(exclude_unset=True) == {'items': [], 'name': 'Test 2'}\n\nawait category.save()\ncategory2 = await Category.objects.get()\nassert category2.model_dump() == {'id': 1, 'items': [], 'name': 'Test 2',\n                            'visibility': True}\n# NOTE how after loading from db all fields are set explicitly\n# as this is what happens when you populate a model from db\nassert category2.model_dump(exclude_unset=True) == {'id': 1, 'items': [],\n                                              'name': 'Test 2', 'visibility': True}\n</code></pre>"},{"location":"models/methods/#exclude_defaults","title":"exclude_defaults","text":"<p><code>exclude_defaults: bool = False</code></p> <p>Flag indicates are equal to their default values (whether set or otherwise) should be excluded from the returned dictionary</p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, default=\"Test\")\n    visibility: bool = ormar.Boolean(default=True)\n\nclass Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    price: float = ormar.Float(default=9.99)\n    categories: List[Category] = ormar.ManyToMany(Category)\n\ncategory = Category()\n# note that Integer pk is by default autoincrement so optional\nassert category.model_dump() == {'id': None, 'items': [], 'name': 'Test', 'visibility': True}\nassert category.model_dump(exclude_defaults=True) == {'items': []}\n\n# save and reload the data\nawait category.save()\ncategory2 = await Category.objects.get()\n\nassert category2.model_dump() == {'id': 1, 'items': [], 'name': 'Test', 'visibility': True}\nassert category2.model_dump(exclude_defaults=True) == {'id': 1, 'items': []}\n</code></pre>"},{"location":"models/methods/#exclude_none","title":"exclude_none","text":"<p><code>exclude_none: bool = False</code></p> <p>Flag indicates whether fields which are equal to <code>None</code> should be excluded from the returned dictionary.</p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, default=\"Test\", nullable=True)\n    visibility: bool = ormar.Boolean(default=True)\n\n\nclass Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    price: float = ormar.Float(default=9.99)\n    categories: List[Category] = ormar.ManyToMany(Category)\n\n\ncategory = Category(name=None)\nassert category.model_dump() == {'id': None, 'items': [], 'name': None,\n                           'visibility': True}\n# note the id is not set yet so None and excluded\nassert category.model_dump(exclude_none=True) == {'items': [], 'visibility': True}\n\nawait category.save()\ncategory2 = await Category.objects.get()\nassert category2.model_dump() == {'id': 1, 'items': [], 'name': None,\n                            'visibility': True}\nassert category2.model_dump(exclude_none=True) == {'id': 1, 'items': [],\n                                             'visibility': True}\n</code></pre>"},{"location":"models/methods/#exclude_primary_keys-ormar-only","title":"exclude_primary_keys (<code>ormar</code> only)","text":"<p><code>exclude_primary_keys: bool = False</code></p> <p>Setting flag to <code>True</code> will exclude all primary key columns in a tree, including nested models.</p> <pre><code>class Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\nitem1 = Item(id=1, name=\"Test Item\")\nassert item1.model_dump() == {\"id\": 1, \"name\": \"Test Item\"}\nassert item1.model_dump(exclude_primary_keys=True) == {\"name\": \"Test Item\"}\n</code></pre>"},{"location":"models/methods/#exclude_through_models-ormar-only","title":"exclude_through_models (<code>ormar</code> only)","text":"<p><code>exclude_through_models: bool = False</code></p> <p><code>Through</code> models are auto added for every <code>ManyToMany</code> relation, and they hold additional parameters on linking model/table.</p> <p>Setting the <code>exclude_through_models=True</code> will exclude all through models, including Through models of submodels.</p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    categories: List[Category] = ormar.ManyToMany(Category)\n\n# tree defining the models\nitem_dict = {\n            \"name\": \"test\",\n            \"categories\": [{\"name\": \"test cat\"}, {\"name\": \"test cat2\"}],\n        }\n# save whole tree\nawait Item(**item_dict).save_related(follow=True, save_all=True)\n\n# get the saved values\nitem = await Item.objects.select_related(\"categories\").get()\n\n# by default you can see the through models (itemcategory)\nassert item.model_dump() == {'id': 1, 'name': 'test', \n                       'categories': [\n                           {'id': 1, 'name': 'test cat', \n                            'itemcategory': {'id': 1, 'category': None, 'item': None}}, \n                           {'id': 2, 'name': 'test cat2', \n                            'itemcategory': {'id': 2, 'category': None, 'item': None}}\n                       ]}\n\n# you can exclude those fields/ models\nassert item.model_dump(exclude_through_models=True) == {\n                       'id': 1, 'name': 'test', \n                       'categories': [\n                           {'id': 1, 'name': 'test cat'}, \n                           {'id': 2, 'name': 'test cat2'}\n                       ]}\n</code></pre>"},{"location":"models/methods/#model_dump_json","title":"model_dump_json()","text":"<p><code>model_dump_json()</code> has exactly the same parameters as <code>model_dump()</code> so check above.</p> <p>Of course the end result is a string with json representation and not a dictionary.</p>"},{"location":"models/methods/#get_pydantic","title":"get_pydantic()","text":"<p><code>get_pydantic(include: Union[Set, Dict] = None, exclude: Union[Set, Dict] = None)</code></p> <p>This method allows you to generate <code>pydantic</code> models from your ormar models without you needing to retype all the fields.</p> <p>Note that if you have nested models, it will generate whole tree of pydantic models for you! but in a way that prevents cyclic references issues.</p> <p>Moreover, you can pass <code>exclude</code> and/or <code>include</code> parameters to keep only the fields that you want to, including in nested models.</p> <p>That means that this way you can effortlessly create pydantic models for requests and responses in <code>fastapi</code>.</p> <p>Note</p> <p>To read more about possible excludes/includes and how to structure your exclude dictionary or set visit fields section of documentation</p> <p>Given sample ormar models like follows:</p> <pre><code>base_ormar_config = ormar.OrmarConfig(\n    metadata=sqlalchemy.MetaData(),\n    database=databases.Database(DATABASE_URL, force_rollback=True),\n)\n\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Item(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, default=\"test\")\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n</code></pre> <p>You can generate pydantic models out of it with a one simple call.</p> <pre><code>PydanticCategory = Category.get_pydantic(include={\"id\", \"name\"})\n</code></pre> <p>Which will generate model equivalent of:</p> <pre><code>class Category(BaseModel):\n    id: Optional[int]\n    name: Optional[str] = \"test\"\n</code></pre> <p>Warning</p> <p>Note that it's not a good practice to have several classes with same name in one module, as well as it would break <code>fastapi</code> docs. Thats's why ormar adds random 3 uppercase letters to the class name. In example above it means that in reality class would be named i.e. <code>Category_XIP(BaseModel)</code>.</p> <p>To exclude or include nested fields you can use dict or double underscores.</p> <pre><code># both calls are equivalent\nPydanticCategory = Category.get_pydantic(include={\"id\", \"items__id\"})\nPydanticCategory = Category.get_pydantic(include={\"id\": ..., \"items\": {\"id\"}})\n</code></pre> <p>and results in a generated structure as follows: <pre><code>class Item(BaseModel):\n    id: Optional[int]\n\nclass Category(BaseModel):\n    id: Optional[int]\n    items: Optional[List[Item]]\n</code></pre></p> <p>Of course, you can use also deeply nested structures and ormar will generate it's pydantic equivalent for you (in a way that exclude loops).</p> <p>Note how <code>Item</code> model above does not have a reference to <code>Category</code> although in ormar the relation is bidirectional (and <code>ormar.Item</code> has <code>categories</code> field).</p> <p>Warning</p> <p>Note that the generated pydantic model will inherit all field validators from the original <code>ormar</code> model, that includes the ormar choices validator as well as validators defined with <code>pydantic.validator</code> decorator.</p> <p>But, at the same time all root validators present on <code>ormar</code> models will NOT be copied to the generated pydantic model. Since root validator can operate on all fields and a user can exclude some fields during generation of pydantic model it's not safe to copy those validators. If required, you need to redefine/ manually copy them to generated pydantic model.</p>"},{"location":"models/methods/#load","title":"load()","text":"<p>By default, when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling <code>load()</code> method.</p> <p><code>load()</code> can also be used to refresh the model from the database (if it was changed by some other process). </p> <pre><code>track = await Track.objects.get(name='The Bird')\ntrack.album.pk # will return malibu album pk (1)\ntrack.album.name # will return None\n\n# you need to actually load the data first\nawait track.album.load()\ntrack.album.name # will return 'Malibu'\n</code></pre>"},{"location":"models/methods/#load_all","title":"load_all()","text":"<p><code>load_all(follow: bool = False, exclude: Union[List, str, Set, Dict] = None) -&gt; Model</code></p> <p>Method works like <code>load()</code> but also goes through all relations of the <code>Model</code> on which the method is called,  and reloads them from database.</p> <p>By default, the <code>load_all</code> method loads only models that are directly related (one step away) to the model on which the method is called.</p> <p>But you can specify the <code>follow=True</code> parameter to traverse through nested models and load all of them in the relation tree.</p> <p>Warning</p> <p>To avoid circular updates with <code>follow=True</code> set, <code>load_all</code> keeps a set of already visited Models,  and won't perform nested <code>loads</code> on Models that were already visited.</p> <p>So if you have a diamond or circular relations types you need to perform the loads in a manual way.</p> <pre><code># in example like this the second Street (coming from City) won't be load_all, so ZipCode won't be reloaded\nStreet -&gt; District -&gt; City -&gt; Street -&gt; ZipCode\n</code></pre> <p>Method accepts also optional exclude parameter that works exactly the same as exclude_fields method in <code>QuerySet</code>. That way you can remove fields from related models being refreshed or skip whole related models.</p> <p>Method performs one database query so it's more efficient than nested calls to <code>load()</code> and <code>all()</code> on related models.</p> <p>Tip</p> <p>To read more about <code>exclude</code> read exclude_fields</p> <p>Warning</p> <p>All relations are cleared on <code>load_all()</code>, so if you exclude some nested models they will be empty after call.</p>"},{"location":"models/methods/#save","title":"save()","text":"<p><code>save() -&gt; self</code></p> <p>You can create new models by using <code>QuerySet.create()</code> method or by initializing your model as a normal pydantic model  and later calling <code>save()</code> method.</p> <p><code>save()</code> can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database.</p> <p>The <code>save()</code> method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. </p> <pre><code>track = Track(name='The Bird')\nawait track.save() # will persist the model in database\n\ntrack = await Track.objects.get(name='The Bird')\nawait track.save() # will raise integrity error as pk is populated\n</code></pre>"},{"location":"models/methods/#update","title":"update()","text":"<p><code>update(_columns: List[str] = None, **kwargs) -&gt; self</code></p> <p>You can update models by using <code>QuerySet.update()</code> method or by updating your model attributes (fields) and calling <code>update()</code> method.</p> <p>If you try to update a model without a primary key set a <code>ModelPersistenceError</code> exception will be thrown.</p> <p>To persist a newly created model use <code>save()</code> or <code>upsert(**kwargs)</code> methods.</p> <pre><code>track = await Track.objects.get(name='The Bird')\nawait track.update(name='The Bird Strikes Again')\n</code></pre> <p>To update only selected columns from model into the database provide a list of columns that should be updated to <code>_columns</code> argument.</p> <p>In example:</p> <pre><code>class Movie(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, nullable=False, name=\"title\")\n    year: int = ormar.Integer()\n    profit: float = ormar.Float()\n\nterminator = await Movie(name='Terminator', year=1984, profit=0.078).save()\n\nterminator.name = \"Terminator 2\"\nterminator.year = 1991\nterminator.profit = 0.520\n\n# update only name\nawait terminator.update(_columns=[\"name\"])\n\n# note that terminator instance was not reloaded so\nassert terminator.year == 1991\n\n# but once you load the data from db you see it was not updated\nawait terminator.load()\nassert terminator.year == 1984\n</code></pre> <p>Warning</p> <p>Note that <code>update()</code> does not refresh the instance of the Model, so if you change more columns than you pass in <code>_columns</code> list your Model instance will have different values than the database!</p>"},{"location":"models/methods/#upsert","title":"upsert()","text":"<p><code>upsert(**kwargs) -&gt; self</code></p> <p>It's a proxy to either <code>save()</code> or <code>update(**kwargs)</code> methods described above.</p> <p>If the primary key is set -&gt; the <code>update</code> method will be called.</p> <p>If the pk is not set the <code>save()</code> method will be called.</p> <pre><code>track = Track(name='The Bird')\nawait track.upsert() # will call save as the pk is empty\n\ntrack = await Track.objects.get(name='The Bird')\nawait track.upsert(name='The Bird Strikes Again') # will call update as pk is already populated\n</code></pre>"},{"location":"models/methods/#delete","title":"delete()","text":"<p>You can delete models by using <code>QuerySet.delete()</code> method or by using your model and calling <code>delete()</code> method.</p> <pre><code>track = await Track.objects.get(name='The Bird')\nawait track.delete() # will delete the model from database\n</code></pre> <p>Tip</p> <p>Note that that <code>track</code> object stays the same, only record in the database is removed.</p>"},{"location":"models/methods/#save_related","title":"save_related()","text":"<p><code>save_related(follow: bool = False, save_all: bool = False, exclude=Optional[Union[Set, Dict]]) -&gt; None</code></p> <p>Method goes through all relations of the <code>Model</code> on which the method is called,  and calls <code>upsert()</code> method on each model that is not saved. </p> <p>To understand when a model is saved check save status section above.</p> <p>By default the <code>save_related</code> method saved only models that are directly related (one step away) to the model on which the method is called.</p> <p>But you can specify the <code>follow=True</code> parameter to traverse through nested models and save all of them in the relation tree.</p> <p>By default save_related saves only model that has not <code>saved</code> status, meaning that they were modified in current scope.</p> <p>If you want to force saving all of the related methods use <code>save_all=True</code> flag, which will upsert all related models, regardless of their save status.</p> <p>If you want to skip saving some of the relations you can pass <code>exclude</code> parameter. </p> <p><code>Exclude</code> can be a set of own model relations, or it can be a dictionary that can also contain nested items. </p> <p>Note</p> <p>Note that <code>exclude</code> parameter in <code>save_related</code> accepts only relation fields names, so if you pass any other fields they will be saved anyway</p> <p>Note</p> <p>To read more about the structure of possible values passed to <code>exclude</code> check <code>Queryset.fields</code> method documentation.</p> <p>Warning</p> <p>To avoid circular updates with <code>follow=True</code> set, <code>save_related</code> keeps a set of already visited Models on each branch of relation tree,  and won't perform nested <code>save_related</code> on Models that were already visited.</p> <p>So if you have circular relations types you need to perform the updates in a manual way.</p> <p>Note that with <code>save_all=True</code> and <code>follow=True</code> you can use <code>save_related()</code> to save whole relation tree at once.</p> <p>Example:</p> <pre><code>class Department(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    department_name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    course_name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean()\n    department: Optional[Department] = ormar.ForeignKey(Department)\n\n\nclass Student(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    courses = ormar.ManyToMany(Course)\n\nto_save = {\n            \"department_name\": \"Ormar\",\n            \"courses\": [\n                {\"course_name\": \"basic1\",\n                 \"completed\": True,\n                 \"students\": [\n                     {\"name\": \"Jack\"},\n                     {\"name\": \"Abi\"}\n                 ]},\n                {\"course_name\": \"basic2\",\n                 \"completed\": True,\n                 \"students\": [\n                     {\"name\": \"Kate\"},\n                     {\"name\": \"Miranda\"}\n                 ]\n                 },\n            ],\n        }\n# initialize whole tree\ndepartment = Department(**to_save)\n\n# save all at once (one after another)\nawait department.save_related(follow=True, save_all=True)\n\ndepartment_check = await Department.objects.select_all(follow=True).get()\n\nto_exclude = {\n    \"id\": ...,\n    \"courses\": {\n        \"id\": ...,\n        \"students\": {\"id\", \"studentcourse\"}\n    }\n}\n# after excluding ids and through models you get exact same payload used to\n# construct whole tree\nassert department_check.model_dump(exclude=to_exclude) == to_save\n</code></pre> <p>Warning</p> <p><code>save_related()</code> iterates all relations and all models and upserts() them one by one, so it will save all models but might not be optimal in regard of number of database queries.</p>"},{"location":"models/migrations/","title":"Migrations","text":""},{"location":"models/migrations/#database-initialization","title":"Database Initialization","text":"<p>Note that all examples assume that you already have a database.</p> <p>If that is not the case and you need to create your tables, that's super easy as <code>ormar</code> is using sqlalchemy for underlying table construction.</p> <p>All you have to do is call <code>create_all()</code> like in the example below.</p> <pre><code>import sqlalchemy\n# get your database url in sqlalchemy format - same as used with databases instance used in Model definition\nengine = sqlalchemy.create_engine(\"sqlite:///test.db\")\n# note that this has to be the same metadata that is used in ormar Models definition\nmetadata.create_all(engine)\n</code></pre> <p>You can also create single tables, sqlalchemy tables are exposed in <code>ormar.ormar_config</code> object.</p> <pre><code>import sqlalchemy\n# get your database url in sqlalchemy format - same as used with databases instance used in Model definition\nengine = sqlalchemy.create_engine(\"sqlite:///test.db\")\n# Artist is an ormar model from previous examples\nArtist.ormar_config.table.create(engine)\n</code></pre> <p>Warning</p> <p>You need to create the tables only once, so use a python console for that or remove the script from your production code after first use.</p>"},{"location":"models/migrations/#alembic-usage","title":"Alembic usage","text":"<p>Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic.</p>"},{"location":"models/migrations/#initialization","title":"Initialization","text":"<p>Use command line to reproduce this minimalistic example.</p> <pre><code>alembic init alembic\nalembic revision --autogenerate -m \"made some changes\"\nalembic upgrade head\n</code></pre>"},{"location":"models/migrations/#sample-envpy-file","title":"Sample env.py file","text":"<p>A quick example of alembic migrations should be something similar to:</p> <p>When you have application structure like:</p> <pre><code>-&gt; app\n    -&gt; alembic (initialized folder - so run alembic init alembic inside app folder)\n    -&gt; models (here are the models)\n      -&gt; __init__.py\n      -&gt; my_models.py\n</code></pre> <p>Your <code>env.py</code> file (in alembic folder) can look something like:</p> <pre><code>from logging.config import fileConfig\nfrom sqlalchemy import create_engine\n\nfrom alembic import context\nimport sys, os\n\n# add app folder to system path (alternative is running it from parent folder with python -m ...)\nmyPath = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, myPath + '/../../')\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here (the one used in ormar)\n# for 'autogenerate' support\nfrom app.models.my_models import metadata\ntarget_metadata = metadata\n\n\n# set your url here or import from settings\n# note that by default url is in saved sqlachemy.url variable in alembic.ini file\nURL = \"sqlite:///test.db\"\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    context.configure(\n        url=URL,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n        # if you use UUID field set also this param\n        # the prefix has to match sqlalchemy import name in alembic\n        # that can be set by sqlalchemy_module_prefix option (default 'sa.')\n        user_module_prefix='sa.'\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = create_engine(URL)\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=target_metadata,\n            # if you use UUID field set also this param\n            # the prefix has to match sqlalchemy import name in alembic\n            # that can be set by sqlalchemy_module_prefix option (default 'sa.')\n            user_module_prefix='sa.'\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n</code></pre>"},{"location":"models/migrations/#excluding-tables","title":"Excluding tables","text":"<p>You can also include/exclude specific tables with <code>include_object</code> parameter passed to <code>context.configure</code>. That should be a function returning <code>True/False</code> for given objects.</p> <p>A sample function excluding tables starting with <code>data_</code> in name unless it's 'data_jobs': <pre><code>def include_object(object, name, type_, reflected, compare_to):\n    if name and name.startswith('data_') and name not in ['data_jobs']:\n        return False\n\n    return True\n</code></pre></p> <p>Note</p> <p>Function parameters for <code>include_objects</code> (you can change the name) are required and defined in alembic to check what they do check the alembic documentation</p> <p>And you pass it into context like (both in online and offline): <pre><code>context.configure(\n        url=URL,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n        user_module_prefix='sa.',\n        include_object=include_object\n    )\n</code></pre></p> <p>Info</p> <p>You can read more about table creation, altering and migrations in sqlalchemy table creation documentation.</p>"},{"location":"queries/","title":"Querying database with ormar","text":""},{"location":"queries/#queryset","title":"QuerySet","text":"<p>Each Model is auto registered with a <code>QuerySet</code> that represents the underlying query, and it's options.</p> <p>Most of the methods are also available through many to many relations and on reverse foreign key relations through <code>QuerysetProxy</code> interface.</p> <p>Info</p> <p>To see which relations are supported and how to construct relations visit relations.</p> <p>For simplicity available methods to fetch and save the data into the database are divided into categories according to the function they fulfill.</p> <p>Note that some functions/methods are in multiple categories.</p> <p>For completeness, Model and relation methods are listed.</p> <p>To read more about any specific section or function please refer to the details subpage.</p>"},{"location":"queries/#insert-data-into-database","title":"Insert data into database","text":"<ul> <li><code>create(**kwargs) -&gt; Model</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li><code>update_or_create(**kwargs) -&gt; Model</code></li> <li> <p><code>bulk_create(objects: List[Model]) -&gt; None</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.save()</code> method</li> <li><code>Model.upsert()</code> method</li> <li><code>Model.save_related()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.create(**kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs)</code> method</li> <li><code>QuerysetProxy.update_or_create(**kwargs)</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit create section.</p>"},{"location":"queries/#read-data-from-database","title":"Read data from database","text":"<ul> <li><code>get(**kwargs) -&gt; Model</code></li> <li><code>get_or_none(**kwargs) -&gt; Optional[Model]</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li><code>first() -&gt; Model</code></li> <li> <p><code>all(**kwargs) -&gt; List[Optional[Model]]</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.load()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.get(**kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_none(**kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs)</code> method</li> <li><code>QuerysetProxy.first()</code> method</li> <li><code>QuerysetProxy.all(**kwargs)</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit read section.</p>"},{"location":"queries/#read-raw-data-from-database","title":"Read raw data from database","text":"<p>Instead of ormar models return raw data in form list of dictionaries or tuples.</p> <ul> <li><code>values(fields = None, exclude_through = False) -&gt; List[Dict]</code></li> <li> <p><code>values_list(fields = None, exclude_through = False, flatten = False) -&gt; List</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.values(fields = None, exclude_through = False)</code> method</li> <li><code>QuerysetProxy.values_list(fields = None, exclude_through= False, flatten = False)</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit raw data section.</p>"},{"location":"queries/#update-data-in-database","title":"Update data in database","text":"<ul> <li><code>update(each: bool = False, **kwargs) -&gt; int</code></li> <li><code>update_or_create(**kwargs) -&gt; Model</code></li> <li> <p><code>bulk_update(objects: List[Model], columns: List[str] = None) -&gt; None</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.update()</code> method</li> <li><code>Model.upsert()</code> method</li> <li><code>Model.save_related()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.update_or_create(**kwargs)</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit update section.</p>"},{"location":"queries/#delete-data-from-database","title":"Delete data from database","text":"<ul> <li> <p><code>delete(each: bool = False, **kwargs) -&gt; int</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.delete()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.remove()</code> method</li> <li><code>QuerysetProxy.clear()</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit delete section.</p>"},{"location":"queries/#joins-and-subqueries","title":"Joins and subqueries","text":"<ul> <li><code>select_related(related: Union[List, str]) -&gt; QuerySet</code></li> <li> <p><code>prefetch_related(related: Union[List, str]) -&gt; QuerySet</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.load()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.select_related(related: Union[List, str])</code> method</li> <li><code>QuerysetProxy.prefetch_related(related: Union[List, str])</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit joins and subqueries section.</p>"},{"location":"queries/#filtering-and-sorting","title":"Filtering and sorting","text":"<ul> <li><code>filter(**kwargs) -&gt; QuerySet</code></li> <li><code>exclude(**kwargs) -&gt; QuerySet</code></li> <li><code>order_by(columns:Union[List, str]) -&gt; QuerySet</code></li> <li><code>get(**kwargs) -&gt; Model</code></li> <li><code>get_or_none(**kwargs) -&gt; Optional[Model]</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li> <p><code>all(**kwargs) -&gt; List[Optional[Model]]</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.filter(**kwargs)</code> method</li> <li><code>QuerysetProxy.exclude(**kwargs)</code> method</li> <li><code>QuerysetProxy.order_by(columns:Union[List, str])</code> method</li> <li><code>QuerysetProxy.get(**kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_none(**kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs)</code> method</li> <li><code>QuerysetProxy.all(**kwargs)</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit filtering and sorting section.</p>"},{"location":"queries/#selecting-columns","title":"Selecting columns","text":"<ul> <li><code>fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></li> <li> <p><code>exclude_fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.fields(columns: Union[List, str, set, dict])</code> method</li> <li><code>QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict])</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit selecting columns section.</p>"},{"location":"queries/#pagination-and-rows-number","title":"Pagination and rows number","text":"<ul> <li><code>paginate(page: int) -&gt; QuerySet</code></li> <li><code>limit(limit_count: int) -&gt; QuerySet</code></li> <li><code>offset(offset: int) -&gt; QuerySet</code></li> <li><code>get() -&gt; Model</code></li> <li> <p><code>first() -&gt; Model</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.paginate(page: int)</code> method</li> <li><code>QuerysetProxy.limit(limit_count: int)</code> method</li> <li><code>QuerysetProxy.offset(offset: int)</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit pagination section.</p>"},{"location":"queries/#aggregated-functions","title":"Aggregated functions","text":"<ul> <li><code>count(distinct: bool = True) -&gt; int</code></li> <li> <p><code>exists() -&gt; bool</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.count(distinct=True)</code> method</li> <li><code>QuerysetProxy.exists()</code> method</li> </ul> </li> </ul> <p>Tip</p> <p>To read more about any or all of those functions visit aggregations section.</p>"},{"location":"queries/aggregations/","title":"Aggregation functions","text":"<p>Currently 6 aggregation functions are supported.</p> <ul> <li><code>count(distinct: bool = True) -&gt; int</code></li> <li><code>exists() -&gt; bool</code></li> <li><code>sum(columns) -&gt; Any</code></li> <li><code>avg(columns) -&gt; Any</code></li> <li><code>min(columns) -&gt; Any</code></li> <li> <p><code>max(columns) -&gt; Any</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.count(distinct=True)</code> method</li> <li><code>QuerysetProxy.exists()</code> method</li> <li><code>QuerysetProxy.sum(columns)</code> method</li> <li><code>QuerysetProxy.avg(columns)</code> method</li> <li><code>QuerysetProxy.min(column)</code> method</li> <li><code>QuerysetProxy.max(columns)</code> method</li> </ul> </li> </ul>"},{"location":"queries/aggregations/#count","title":"count","text":"<p><code>count(distinct: bool = True) -&gt; int</code></p> <p>Returns number of rows matching the given criteria (i.e. applied with <code>filter</code> and <code>exclude</code>). If <code>distinct</code> is <code>True</code> (the default), this will return the number of primary rows selected. If <code>False</code>, the count will be the total number of rows returned (including extra rows for <code>one-to-many</code> or <code>many-to-many</code> left <code>select_related</code> table joins). <code>False</code> is the legacy (buggy) behavior for workflows that depend on it.</p> <pre><code>class Book(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=databases.Database(DATABASE_URL),\n        metadata=sqlalchemy.MetaData(),\n        tablename=\"book\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: str = ormar.String(max_length=100)\n    genre: str = ormar.String(\n        max_length=100,\n        default=\"Fiction\",\n        choices=[\"Fiction\", \"Adventure\", \"Historic\", \"Fantasy\"],\n    )\n</code></pre> <pre><code># returns count of rows in db for Books model\nno_of_books = await Book.objects.count()\n</code></pre>"},{"location":"queries/aggregations/#exists","title":"exists","text":"<p><code>exists() -&gt; bool</code></p> <p>Returns a bool value to confirm if there are rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code>)</p> <pre><code>class Book(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=databases.Database(DATABASE_URL),\n        metadata=sqlalchemy.MetaData(),\n        tablename=\"book\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: str = ormar.String(max_length=100)\n    genre: str = ormar.String(\n        max_length=100,\n        default=\"Fiction\",\n        choices=[\"Fiction\", \"Adventure\", \"Historic\", \"Fantasy\"],\n    )\n</code></pre> <pre><code># returns a boolean value if given row exists\nhas_sample = await Book.objects.filter(title='Sample').exists()\n</code></pre>"},{"location":"queries/aggregations/#sum","title":"sum","text":"<p><code>sum(columns) -&gt; Any</code></p> <p>Returns sum value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>You can pass one or many column names including related columns.</p> <p>As of now each column passed is aggregated separately (so <code>sum(col1+col2)</code> is not possible, you can have <code>sum(col1, col2)</code> and later add 2 returned sums in python)</p> <p>You cannot <code>sum</code> non numeric columns.</p> <p>If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned</p> <p>Given models like follows</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom tests.settings import DATABASE_URL\n\ndatabase = databases.Database(DATABASE_URL)\nmetadata = sqlalchemy.MetaData()\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=metadata,\n    database=database,\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"authors\", order_by=[\"-name\"])\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n\n    ormar_config = base_ormar_config.copy(\n        tablename=\"books\", order_by=[\"year\", \"-ranking\"]\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    ranking: int = ormar.Integer(nullable=True)\n</code></pre> <p>A sample usage might look like following</p> <pre><code>author = await Author(name=\"Author 1\").save()\nawait Book(title=\"Book 1\", year=1920, ranking=3, author=author).save()\nawait Book(title=\"Book 2\", year=1930, ranking=1, author=author).save()\nawait Book(title=\"Book 3\", year=1923, ranking=5, author=author).save()\n\nassert await Book.objects.sum(\"year\") == 5773\nresult = await Book.objects.sum([\"year\", \"ranking\"])\nassert result == dict(year=5773, ranking=9)\n\ntry:\n    # cannot sum string column\n    await Book.objects.sum(\"title\")\nexcept ormar.QueryDefinitionError:\n    pass\n\nassert await Author.objects.select_related(\"books\").sum(\"books__year\") == 5773\nresult = await Author.objects.select_related(\"books\").sum(\n    [\"books__year\", \"books__ranking\"]\n)\nassert result == dict(books__year=5773, books__ranking=9)\n\nassert (\n    await Author.objects.select_related(\"books\")\n    .filter(books__year__lt=1925)\n    .sum(\"books__year\")\n    == 3843\n)\n</code></pre>"},{"location":"queries/aggregations/#avg","title":"avg","text":"<p><code>avg(columns) -&gt; Any</code></p> <p>Returns avg value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>You can pass one or many column names including related columns.</p> <p>As of now each column passed is aggregated separately (so <code>sum(col1+col2)</code> is not possible, you can have <code>sum(col1, col2)</code> and later add 2 returned sums in python)</p> <p>You cannot <code>avg</code> non numeric columns.</p> <p>If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom tests.settings import DATABASE_URL\n\ndatabase = databases.Database(DATABASE_URL)\nmetadata = sqlalchemy.MetaData()\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=metadata,\n    database=database,\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"authors\", order_by=[\"-name\"])\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n\n    ormar_config = base_ormar_config.copy(\n        tablename=\"books\", order_by=[\"year\", \"-ranking\"]\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    ranking: int = ormar.Integer(nullable=True)\n</code></pre> <p>A sample usage might look like following</p> <pre><code>author = await Author(name=\"Author 1\").save()\nawait Book(title=\"Book 1\", year=1920, ranking=3, author=author).save()\nawait Book(title=\"Book 2\", year=1930, ranking=1, author=author).save()\nawait Book(title=\"Book 3\", year=1923, ranking=5, author=author).save()\n\nassert round(float(await Book.objects.avg(\"year\")), 2) == 1924.33\nresult = await Book.objects.avg([\"year\", \"ranking\"])\nassert round(float(result.get(\"year\")), 2) == 1924.33\nassert result.get(\"ranking\") == 3.0\n\ntry:\n    # cannot avg string column\n    await Book.objects.avg(\"title\")\nexcept ormar.QueryDefinitionError:\n    pass\n\nresult = await Author.objects.select_related(\"books\").avg(\"books__year\")\nassert round(float(result), 2) == 1924.33\nresult = await Author.objects.select_related(\"books\").avg(\n    [\"books__year\", \"books__ranking\"]\n)\nassert round(float(result.get(\"books__year\")), 2) == 1924.33\nassert result.get(\"books__ranking\") == 3.0\n\nassert (\n    await Author.objects.select_related(\"books\")\n    .filter(books__year__lt=1925)\n    .avg(\"books__year\")\n    == 1921.5\n)\n</code></pre>"},{"location":"queries/aggregations/#min","title":"min","text":"<p><code>min(columns) -&gt; Any</code></p> <p>Returns min value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>You can pass one or many column names including related columns.</p> <p>As of now each column passed is aggregated separately (so <code>sum(col1+col2)</code> is not possible, you can have <code>sum(col1, col2)</code> and later add 2 returned sums in python)</p> <p>If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom tests.settings import DATABASE_URL\n\ndatabase = databases.Database(DATABASE_URL)\nmetadata = sqlalchemy.MetaData()\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=metadata,\n    database=database,\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"authors\", order_by=[\"-name\"])\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n\n    ormar_config = base_ormar_config.copy(\n        tablename=\"books\", order_by=[\"year\", \"-ranking\"]\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    ranking: int = ormar.Integer(nullable=True)\n</code></pre> <p>A sample usage might look like following</p> <pre><code>author = await Author(name=\"Author 1\").save()\nawait Book(title=\"Book 1\", year=1920, ranking=3, author=author).save()\nawait Book(title=\"Book 2\", year=1930, ranking=1, author=author).save()\nawait Book(title=\"Book 3\", year=1923, ranking=5, author=author).save()\n\nassert await Book.objects.min(\"year\") == 1920\nresult = await Book.objects.min([\"year\", \"ranking\"])\nassert result == dict(year=1920, ranking=1)\n\nassert await Book.objects.min(\"title\") == \"Book 1\"\n\nassert await Author.objects.select_related(\"books\").min(\"books__year\") == 1920\nresult = await Author.objects.select_related(\"books\").min(\n    [\"books__year\", \"books__ranking\"]\n)\nassert result == dict(books__year=1920, books__ranking=1)\n\nassert (\n    await Author.objects.select_related(\"books\")\n    .filter(books__year__gt=1925)\n    .min(\"books__year\")\n    == 1930\n)\n</code></pre>"},{"location":"queries/aggregations/#max","title":"max","text":"<p><code>max(columns) -&gt; Any</code></p> <p>Returns max value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>Returns min value of columns for rows matching the given criteria (applied with <code>filter</code> and <code>exclude</code> if set before).</p> <p>You can pass one or many column names including related columns.</p> <p>As of now each column passed is aggregated separately (so <code>sum(col1+col2)</code> is not possible, you can have <code>sum(col1, col2)</code> and later add 2 returned sums in python)</p> <p>If you aggregate on one column, the single value is directly returned as a result If you aggregate on multiple columns a dictionary with column: result pairs is returned</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom tests.settings import DATABASE_URL\n\ndatabase = databases.Database(DATABASE_URL)\nmetadata = sqlalchemy.MetaData()\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    metadata=metadata,\n    database=database,\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"authors\", order_by=[\"-name\"])\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n\n    ormar_config = base_ormar_config.copy(\n        tablename=\"books\", order_by=[\"year\", \"-ranking\"]\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    ranking: int = ormar.Integer(nullable=True)\n</code></pre> <p>A sample usage might look like following</p> <pre><code>author = await Author(name=\"Author 1\").save()\nawait Book(title=\"Book 1\", year=1920, ranking=3, author=author).save()\nawait Book(title=\"Book 2\", year=1930, ranking=1, author=author).save()\nawait Book(title=\"Book 3\", year=1923, ranking=5, author=author).save()\n\nassert await Book.objects.max(\"year\") == 1930\nresult = await Book.objects.max([\"year\", \"ranking\"])\nassert result == dict(year=1930, ranking=5)\n\nassert await Book.objects.max(\"title\") == \"Book 3\"\n\nassert await Author.objects.select_related(\"books\").max(\"books__year\") == 1930\nresult = await Author.objects.select_related(\"books\").max(\n    [\"books__year\", \"books__ranking\"]\n)\nassert result == dict(books__year=1930, books__ranking=5)\n\nassert (\n    await Author.objects.select_related(\"books\")\n    .filter(books__year__lt=1925)\n    .max(\"books__year\")\n    == 1923\n)\n</code></pre>"},{"location":"queries/aggregations/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes a subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/aggregations/#count_1","title":"count","text":"<p>Works exactly the same as count function above but allows you to select columns from related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/aggregations/#exists_1","title":"exists","text":"<p>Works exactly the same as exists function above but allows you to select columns from related objects from other side of the relation.</p>"},{"location":"queries/aggregations/#sum_1","title":"sum","text":"<p>Works exactly the same as sum function above but allows you to sum columns from related objects from other side of the relation.</p>"},{"location":"queries/aggregations/#avg_1","title":"avg","text":"<p>Works exactly the same as avg function above but allows you to average columns from related objects from other side of the relation.</p>"},{"location":"queries/aggregations/#min_1","title":"min","text":"<p>Works exactly the same as min function above but allows you to select minimum of columns from related objects from other side of the relation.</p>"},{"location":"queries/aggregations/#max_1","title":"max","text":"<p>Works exactly the same as max function above but allows you to select maximum of columns from related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/create/","title":"Insert data into database","text":"<p>Following methods allow you to insert data into the database.</p> <ul> <li><code>create(**kwargs) -&gt; Model</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li><code>update_or_create(**kwargs) -&gt; Model</code></li> <li> <p><code>bulk_create(objects: List[Model]) -&gt; None</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.save()</code> method</li> <li><code>Model.upsert()</code> method</li> <li><code>Model.save_related()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.create(**kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs)</code> method</li> <li><code>QuerysetProxy.update_or_create(**kwargs)</code> method</li> </ul> </li> </ul>"},{"location":"queries/create/#create","title":"create","text":"<p><code>create(**kwargs): -&gt; Model</code></p> <p>Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set).</p> <p>The allowed kwargs are <code>Model</code> fields names and proper value types.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"album\"\n    )\n\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre> <pre><code>malibu = await Album.objects.create(name=\"Malibu\")\nawait Track.objects.create(album=malibu, title=\"The Bird\", position=1)\n</code></pre> <p>The alternative is a split creation and persistence of the <code>Model</code>.</p> <pre><code>malibu = Album(name=\"Malibu\")\nawait malibu.save()\n</code></pre> <p>Tip</p> <p>Check other <code>Model</code> methods in models</p>"},{"location":"queries/create/#get_or_create","title":"get_or_create","text":"<p><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></p> <p>Combination of create and get methods.</p> <p>Tries to get a row meeting the criteria and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <p>When <code>_defaults</code> dictionary is provided the values set in <code>_defaults</code> will always be set, including overwriting explicitly provided values.  i.e. <code>get_or_create(_defaults: {\"title\": \"I win\"}, title=\"never used\")</code> will always use \"I win\" as title whether you provide your own value in kwargs or not. </p> <pre><code>class Album(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"album\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    year: int = ormar.Integer()\n</code></pre> <pre><code>album, created = await Album.objects.get_or_create(name='The Cat', _defaults={\"year\": 1999})\nassert created is True\nassert album.name == \"The Cat\"\nassert album.year == 1999\n# object is created as it does not exist\nalbum2, created = await Album.objects.get_or_create(name='The Cat')\nassert created is False\nassert album == album2\n# return True as the same db row is returned\n</code></pre> <p>Warning</p> <p>Despite being a equivalent row from database the <code>album</code> and <code>album2</code> in example above are 2 different python objects! Updating one of them will not refresh the second one until you explicitly load() the fresh data from db.</p> <p>Note</p> <p>Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement</p>"},{"location":"queries/create/#update_or_create","title":"update_or_create","text":"<p><code>update_or_create(**kwargs) -&gt; Model</code></p> <p>Updates the model, or in case there is no match in database creates a new one.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Book(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: str = ormar.String(max_length=100)\n    genre: str = ormar.String(\n        max_length=100,\n        default=\"Fiction\",\n    )\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    await Book.objects.create(\n        title=\"Tom Sawyer\", author=\"Twain, Mark\", genre=\"Adventure\"\n    )\n    await Book.objects.create(\n        title=\"War and Peace\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n    await Book.objects.create(\n        title=\"Anna Karenina\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n\n    # if not exist the instance will be persisted in db\n    vol2 = await Book.objects.update_or_create(\n        title=\"Volume II\", author=\"Anonymous\", genre=\"Fiction\"\n    )\n    assert await Book.objects.count() == 4\n\n    # if pk or pkname passed in kwargs (like id here) the object will be updated\n    assert await Book.objects.update_or_create(id=vol2.id, genre=\"Historic\")\n    assert await Book.objects.count() == 4\n\n\nasyncio.run(run_query())\n</code></pre> <p>Note</p> <p>Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement</p>"},{"location":"queries/create/#bulk_create","title":"bulk_create","text":"<p><code>bulk_create(objects: List[\"Model\"]) -&gt; None</code></p> <p>Allows you to create multiple objects at once.</p> <p>A valid list of <code>Model</code> objects needs to be passed.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass ToDo(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"todos\")\n\n    id: int = ormar.Integer(primary_key=True)\n    text: str = ormar.String(max_length=500)\n    completed = ormar.Boolean(default=False)\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    # create multiple instances at once with bulk_create\n    await ToDo.objects.bulk_create(\n        [\n            ToDo(text=\"Buy the groceries.\"),\n            ToDo(text=\"Call Mum.\", completed=True),\n            ToDo(text=\"Send invoices.\", completed=True),\n        ]\n    )\n\n    todoes = await ToDo.objects.all()\n    assert len(todoes) == 3\n\n\nasyncio.run(run_query())\n</code></pre>"},{"location":"queries/create/#model-methods","title":"Model methods","text":"<p>Each model instance have a set of methods to <code>save</code>, <code>update</code> or <code>load</code> itself.</p>"},{"location":"queries/create/#save","title":"save","text":"<p>You can create new models by using <code>QuerySet.create()</code> method or by initializing your model as a normal pydantic model  and later calling <code>save()</code> method.</p> <p>Tip</p> <p>Read more about <code>save()</code> method in models-save</p>"},{"location":"queries/create/#upsert","title":"upsert","text":"<p>It's a proxy to either <code>save()</code> or <code>update(**kwargs)</code> methods of a Model. If the pk is not set the <code>save()</code> method will be called.</p> <p>Tip</p> <p>Read more about <code>upsert()</code> method in models-upsert</p>"},{"location":"queries/create/#save_related","title":"save_related","text":"<p>Method goes through all relations of the <code>Model</code> on which the method is called,  and calls <code>upsert()</code> method on each model that is not saved. </p> <p>Tip</p> <p>Read more about <code>save_related()</code> method in models-save-related</p>"},{"location":"queries/create/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/create/#create_1","title":"create","text":"<p>Works exactly the same as create function above but allows you to create related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/create/#get_or_create_1","title":"get_or_create","text":"<p>Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/create/#update_or_create_1","title":"update_or_create","text":"<p>Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/delete/","title":"Delete data from database","text":"<p>Following methods allow you to delete data from the database.</p> <ul> <li> <p><code>delete(each: bool = False, **kwargs) -&gt; int</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.delete()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.remove()</code> method</li> <li><code>QuerysetProxy.clear()</code> method</li> </ul> </li> </ul>"},{"location":"queries/delete/#delete","title":"delete","text":"<p><code>delete(each: bool = False, **kwargs) -&gt; int</code></p> <p>QuerySet level delete is used to delete multiple records at once.</p> <p>You either have to filter the QuerySet first or provide a <code>each=True</code> flag to delete whole table.</p> <p>If you do not provide this flag or a filter a <code>QueryDefinitionError</code> will be raised.</p> <p>Return number of rows deleted.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Book(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"books\")\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: str = ormar.String(max_length=100)\n    genre: str = ormar.String(\n        max_length=100,\n        default=\"Fiction\",\n    )\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    await Book.objects.create(\n        title=\"Tom Sawyer\", author=\"Twain, Mark\", genre=\"Adventure\"\n    )\n    await Book.objects.create(\n        title=\"War and Peace in Space\", author=\"Tolstoy, Leo\", genre=\"Fantasy\"\n    )\n    await Book.objects.create(\n        title=\"Anna Karenina\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n\n    # delete accepts kwargs that will be used in filter\n    # acting in same way as queryset.filter(**kwargs).delete()\n    await Book.objects.delete(genre=\"Fantasy\")  # delete all fantasy books\n    all_books = await Book.objects.all()\n    assert len(all_books) == 2\n\n\nasyncio.run(run_query())\n</code></pre>"},{"location":"queries/delete/#model-methods","title":"Model methods","text":"<p>Each model instance have a set of methods to <code>save</code>, <code>update</code> or <code>load</code> itself.</p>"},{"location":"queries/delete/#delete_1","title":"delete","text":"<p>You can delete model instance by calling <code>delete()</code> method on it.</p> <p>Tip</p> <p>Read more about <code>delete()</code> method in models methods</p>"},{"location":"queries/delete/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/delete/#remove","title":"remove","text":"<p>Removal of the related model one by one.</p> <p>Removes the relation in the database.</p> <p>If you specify the keep_reversed flag to <code>False</code> <code>ormar</code> will also delete the related model from the database.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    title: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n    play_count: int = ormar.Integer(nullable=True)\n</code></pre> <pre><code>album = await Album(name=\"Malibu\").save()\ntrack1 = await Track(\n    album=album, title=\"The Bird\", position=1, play_count=30, \n).save()\n# remove through proxy from reverse side of relation\nawait album.tracks.remove(track1, keep_reversed=False)\n\n# the track was also deleted\ntracks = await Track.objects.all()\nassert len(tracks) == 0\n</code></pre>"},{"location":"queries/delete/#clear","title":"clear","text":"<p>Removal of all related models in one call.</p> <p>Removes also the relation in the database.</p> <p>If you specify the keep_reversed flag to <code>False</code> <code>ormar</code> will also delete the related model from the database.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    title: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n    play_count: int = ormar.Integer(nullable=True)\n</code></pre> <pre><code>album = await Album(name=\"Malibu\").save()\ntrack1 = await Track(\n    album=album, \n    title=\"The Bird\", \n    position=1, \n    play_count=30, \n).save()\ntrack2 = await Track(\n    album=album,\n    title=\"Heart don't stand a chance\",\n    position=2,\n    play_count=20,\n).save()\n\n# removes the relation only -&gt; clears foreign keys on tracks\nawait album.tracks.clear()\n\n# removes also the tracks\nawait album.tracks.clear(keep_reversed=False)\n</code></pre>"},{"location":"queries/filter-and-sort/","title":"Filtering and sorting data","text":"<p>You can use following methods to filter the data (sql where clause).</p> <ul> <li><code>filter(*args, **kwargs) -&gt; QuerySet</code></li> <li><code>exclude(*args, **kwargs) -&gt; QuerySet</code></li> <li><code>get(*args, **kwargs) -&gt; Model</code></li> <li><code>get_or_none(*args, **kwargs) -&gt; Optional[Model]</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li> <p><code>all(*args, **kwargs) -&gt; List[Optional[Model]]</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.filter(*args, **kwargs)</code> method</li> <li><code>QuerysetProxy.exclude(*args, **kwargs)</code> method</li> <li><code>QuerysetProxy.get(*args, **kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_none(*args, **kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs)</code> method</li> <li><code>QuerysetProxy.all(*args, **kwargs)</code> method</li> </ul> </li> </ul> <p>And following methods to sort the data (sql order by clause).</p> <ul> <li><code>order_by(columns:Union[List, str, OrderAction]) -&gt; QuerySet</code></li> <li><code>QuerysetProxy</code><ul> <li><code>QuerysetProxy.order_by(columns:Union[List, str, OrderAction])</code> method</li> </ul> </li> </ul>"},{"location":"queries/filter-and-sort/#filtering","title":"Filtering","text":""},{"location":"queries/filter-and-sort/#filter","title":"filter","text":"<p><code>filter(*args, **kwargs) -&gt; QuerySet</code></p> <p>Allows you to filter by any <code>Model</code> attribute/field as well as to fetch instances, with a filter across an FK relationship.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    name: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n    play_count: int = ormar.Integer(nullable=True)\n</code></pre> <pre><code>track = Track.objects.filter(name=\"The Bird\").get()\n# will return a track with name equal to 'The Bird'\n\ntracks = Track.objects.filter(album__name=\"Fantasies\").all()\n# will return all tracks where the columns album name = 'Fantasies'\n</code></pre>"},{"location":"queries/filter-and-sort/#django-style-filters","title":"Django style filters","text":"<p>You can use special filter suffix to change the filter operands:</p> <ul> <li>exact - exact match to value, sql <code>column = &lt;VALUE&gt;</code> <ul> <li>can be written as<code>album__name__exact='Malibu'</code></li> </ul> </li> <li>iexact - exact match sql <code>column = &lt;VALUE&gt;</code> (case insensitive)<ul> <li>can be written as<code>album__name__iexact='malibu'</code></li> </ul> </li> <li>contains - sql <code>column LIKE '%&lt;VALUE&gt;%'</code><ul> <li>can be written as<code>album__name__contains='Mal'</code></li> </ul> </li> <li>icontains - sql <code>column LIKE '%&lt;VALUE&gt;%'</code> (case insensitive)<ul> <li>can be written as<code>album__name__icontains='mal'</code></li> </ul> </li> <li>in - sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;, ...)</code><ul> <li>can be written as<code>album__name__in=['Malibu', 'Barclay']</code></li> </ul> </li> <li>isnull - sql <code>column IS NULL</code> (and sql <code>column IS NOT NULL</code>) <ul> <li>can be written as<code>album__name__isnull=True</code> (isnotnull <code>album__name__isnull=False</code>)</li> </ul> </li> <li>gt - sql <code>column &gt; &lt;VALUE&gt;</code> (greater than)<ul> <li>can be written as<code>position__gt=3</code></li> </ul> </li> <li>gte - sql <code>column &gt;= &lt;VALUE&gt;</code> (greater or equal than)<ul> <li>can be written as<code>position__gte=3</code></li> </ul> </li> <li>lt - sql <code>column &lt; &lt;VALUE&gt;</code> (lower than)<ul> <li>can be written as<code>position__lt=3</code></li> </ul> </li> <li>lte - sql <code>column &lt;= &lt;VALUE&gt;</code> (lower equal than)<ul> <li>can be written as<code>position__lte=3</code> </li> </ul> </li> <li>startswith - sql <code>column LIKE '&lt;VALUE&gt;%'</code> (exact start match)<ul> <li>can be written as<code>album__name__startswith='Mal'</code></li> </ul> </li> <li>istartswith - sql <code>column LIKE '&lt;VALUE&gt;%'</code> (case insensitive)<ul> <li>can be written as<code>album__name__istartswith='mal'</code></li> </ul> </li> <li>endswith - sql <code>column LIKE '%&lt;VALUE&gt;'</code> (exact end match)<ul> <li>can be written as<code>album__name__endswith='ibu'</code></li> </ul> </li> <li>iendswith - sql <code>column LIKE '%&lt;VALUE&gt;'</code> (case insensitive)<ul> <li>can be written as<code>album__name__iendswith='IBU'</code> </li> </ul> </li> </ul> <p>Some samples:</p> <pre><code># sql: ( product.name = 'Test'  AND  product.rating &gt;= 3.0 ) \nProduct.objects.filter(name='Test', rating__gte=3.0).get()\n\n# sql: ( product.name = 'Test' AND product.rating &gt;= 3.0 ) \n#       OR (categories.name IN ('Toys', 'Books'))\nProduct.objects.filter(\n    ormar.or_(\n        ormar.and_(name='Test', rating__gte=3.0), \n        categories__name__in=['Toys', 'Books'])\n    ).get()\n# note: to read more about and_ and or_ read complex filters section below\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style-filters","title":"Python style filters","text":"<ul> <li>exact - exact match to value, sql <code>column = &lt;VALUE&gt;</code> <ul> <li>can be written as <code>Track.album.name == 'Malibu</code></li> </ul> </li> <li>iexact - exact match sql <code>column = &lt;VALUE&gt;</code> (case insensitive)<ul> <li>can be written as <code>Track.album.name.iexact('malibu')</code></li> </ul> </li> <li>contains - sql <code>column LIKE '%&lt;VALUE&gt;%'</code><ul> <li>can be written as <code>Track.album.name % 'Mal')</code></li> <li>can be written as <code>Track.album.name.contains('Mal')</code></li> </ul> </li> <li>icontains - sql <code>column LIKE '%&lt;VALUE&gt;%'</code> (case insensitive)<ul> <li>can be written as <code>Track.album.name.icontains('mal')</code></li> </ul> </li> <li>in - sql <code>column IN (&lt;VALUE1&gt;, &lt;VALUE2&gt;, ...)</code><ul> <li>can be written as <code>Track.album.name &lt;&lt; ['Malibu', 'Barclay']</code></li> <li>can be written as <code>Track.album.name.in_(['Malibu', 'Barclay'])</code></li> </ul> </li> <li>isnull - sql <code>column IS NULL</code> (and sql <code>column IS NOT NULL</code>) <ul> <li>can be written as <code>Track.album.name &gt;&gt; None</code></li> <li>can be written as <code>Track.album.name.isnull(True)</code></li> <li>not null can be written as <code>Track.album.name.isnull(False)</code></li> <li>not null can be written as <code>~(Track.album.name &gt;&gt; None)</code></li> <li>not null can be written as <code>~(Track.album.name.isnull(True))</code></li> </ul> </li> <li>gt - sql <code>column &gt; &lt;VALUE&gt;</code> (greater than)<ul> <li>can be written as <code>Track.album.name &gt; 3</code></li> </ul> </li> <li>gte - sql <code>column &gt;= &lt;VALUE&gt;</code> (greater or equal than)<ul> <li>can be written as <code>Track.album.name &gt;= 3</code></li> </ul> </li> <li>lt - sql <code>column &lt; &lt;VALUE&gt;</code> (lower than)<ul> <li>can be written as <code>Track.album.name &lt; 3</code></li> </ul> </li> <li>lte - sql <code>column &lt;= &lt;VALUE&gt;</code> (lower equal than)<ul> <li>can be written as <code>Track.album.name &lt;= 3</code></li> </ul> </li> <li>startswith - sql <code>column LIKE '&lt;VALUE&gt;%'</code> (exact start match)<ul> <li>can be written as <code>Track.album.name.startswith('Mal')</code></li> </ul> </li> <li>istartswith - sql <code>column LIKE '&lt;VALUE&gt;%'</code> (case insensitive)<ul> <li>can be written as <code>Track.album.name.istartswith('mal')</code></li> </ul> </li> <li>endswith - sql <code>column LIKE '%&lt;VALUE&gt;'</code> (exact end match)<ul> <li>can be written as <code>Track.album.name.endswith('ibu')</code></li> </ul> </li> <li>iendswith - sql <code>column LIKE '%&lt;VALUE&gt;'</code> (case insensitive)<ul> <li>can be written as <code>Track.album.name.iendswith('IBU')</code></li> </ul> </li> </ul> <p>Some samples:</p> <pre><code># sql: ( product.name = 'Test'  AND  product.rating &gt;= 3.0 ) \nProduct.objects.filter(\n    (Product.name == 'Test') &amp; (Product.rating &gt;= 3.0)\n).get()\n\n# sql: ( product.name = 'Test' AND product.rating &gt;= 3.0 ) \n#       OR (categories.name IN ('Toys', 'Books'))\nProduct.objects.filter(\n        ((Product.name == 'Test') &amp; (Product.rating &gt;= 3.0)) | \n        (Product.categories.name &lt;&lt; ['Toys', 'Books'])\n    ).get()\n</code></pre> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p> <p>Warning</p> <p>Note that you do not have to specify the <code>%</code> wildcard in contains and other filters, it's added for you. If you include <code>%</code> in your search value it will be escaped and treated as literal percentage sign inside the text.</p>"},{"location":"queries/filter-and-sort/#exclude","title":"exclude","text":"<p><code>exclude(*args, **kwargs) -&gt; QuerySet</code></p> <p>Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition.</p> <p>So if you use <code>filter(name='John')</code> which equals to <code>where name = 'John'</code> in SQL, the <code>exclude(name='John')</code> equals to <code>where name &lt;&gt; 'John'</code></p> <p>Note that all conditions are joined so if you pass multiple values it becomes a union of conditions.</p> <p><code>exclude(name='John', age&gt;=35)</code> will become <code>where not (name='John' and age&gt;=35)</code></p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    name: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n    play_count: int = ormar.Integer(nullable=True)\n</code></pre> <pre><code>notes = await Track.objects.exclude(position_gt=3).all()\n# returns all tracks with position &lt; 3\n</code></pre>"},{"location":"queries/filter-and-sort/#complex-filters-including-or","title":"Complex filters (including OR)","text":"<p>By default both <code>filter()</code> and <code>exclude()</code> methods combine provided filter options with <code>AND</code> condition so <code>filter(name=\"John\", age__gt=30)</code> translates into <code>WHERE name = 'John' AND age &gt; 30</code>.</p> <p>Sometimes it's useful to query the database with conditions that should not be applied  jointly like <code>WHERE name = 'John' OR age &gt; 30</code>, or build a complex where query that you would like to have bigger control over. After all <code>WHERE (name = 'John' OR age &gt; 30) and city='New York'</code> is completely different than <code>WHERE name = 'John' OR (age &gt; 30 and city='New York')</code>.</p> <p>In order to build <code>OR</code> and nested conditions ormar provides two functions that can be used in  <code>filter()</code> and <code>exclude()</code> in <code>QuerySet</code> and <code>QuerysetProxy</code>. </p> <p>Note</p> <p>Note that you can provide those methods in any other method like <code>get()</code> or <code>all()</code> that accepts <code>*args</code>. </p> <p>Call to <code>or_</code> and <code>and_</code> can be nested in each other, as well as combined with keyword arguments. Since it sounds more complicated than it is, let's look at some examples.</p> <p>Given a sample models like this: <pre><code>base_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n</code></pre></p> <p>Let's create some sample data:</p> <pre><code>tolkien = await Author(name=\"J.R.R. Tolkien\").save()\nawait Book(author=tolkien, title=\"The Hobbit\", year=1933).save()\nawait Book(author=tolkien, title=\"The Lord of the Rings\", year=1955).save()\nawait Book(author=tolkien, title=\"The Silmarillion\", year=1977).save()\nsapkowski = await Author(name=\"Andrzej Sapkowski\").save()\nawait Book(author=sapkowski, title=\"The Witcher\", year=1990).save()\nawait Book(author=sapkowski, title=\"The Tower of Fools\", year=2002).save()\n</code></pre> <p>We can construct some sample complex queries:</p> <p>Let's select books of Tolkien OR books written after 1970</p> <p>sql: <code>WHERE ( authors.name = 'J.R.R. Tolkien' OR books.year &gt; 1970 )</code></p>"},{"location":"queries/filter-and-sort/#django-style","title":"Django style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(ormar.or_(author__name=\"J.R.R. Tolkien\", year__gt=1970))\n    .all()\n)\nassert len(books) == 5\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style","title":"Python style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter((Book.author.name==\"J.R.R. Tolkien\") | (Book.year &gt; 1970))\n    .all()\n)\nassert len(books) == 5\n</code></pre> <p>Now let's select books written after 1960 or before 1940 which were written by Tolkien.</p> <p>sql: <code>WHERE ( books.year &gt; 1960 OR books.year &lt; 1940 ) AND authors.name = 'J.R.R. Tolkien'</code></p>"},{"location":"queries/filter-and-sort/#django-style_1","title":"Django style","text":"<pre><code># OPTION 1 - split and into separate call\nbooks = (\n    await Book.objects.select_related(\"author\")\n    .filter(ormar.or_(year__gt=1960, year__lt=1940))\n    .filter(author__name=\"J.R.R. Tolkien\")\n    .all()\n)\nassert len(books) == 2\n\n# OPTION 2 - all in one\nbooks = (\n    await Book.objects.select_related(\"author\")\n    .filter(\n        ormar.and_(\n            ormar.or_(year__gt=1960, year__lt=1940),\n            author__name=\"J.R.R. Tolkien\",\n        )\n    )\n    .all()\n)\n\nassert len(books) == 2\nassert books[0].title == \"The Hobbit\"\nassert books[1].title == \"The Silmarillion\"\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_1","title":"Python style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter((Book.year &gt; 1960) | (Book.year &lt; 1940))\n    .filter(Book.author.name == \"J.R.R. Tolkien\")\n    .all()\n)\nassert len(books) == 2\n\n# OPTION 2 - all in one\nbooks = (\n    await Book.objects.select_related(\"author\")\n    .filter(\n        (\n            (Book.year &gt; 1960) | (Book.year &lt; 1940)\n        ) &amp; (Book.author.name == \"J.R.R. Tolkien\")\n    )\n    .all()\n)\n\nassert len(books) == 2\nassert books[0].title == \"The Hobbit\"\nassert books[1].title == \"The Silmarillion\"\n</code></pre> <p>Books of Sapkowski from before 2000 or books of Tolkien written after 1960</p> <p>sql: <code>WHERE ( ( books.year &gt; 1960 AND authors.name = 'J.R.R. Tolkien' ) OR ( books.year &lt; 2000 AND authors.name = 'Andrzej Sapkowski' ) )</code></p>"},{"location":"queries/filter-and-sort/#django-style_2","title":"Django style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(\n        ormar.or_(\n            ormar.and_(year__gt=1960, author__name=\"J.R.R. Tolkien\"),\n            ormar.and_(year__lt=2000, author__name=\"Andrzej Sapkowski\"),\n        )\n    )\n    .all()\n)\nassert len(books) == 2\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_2","title":"Python style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(    \n        ((Book.year &gt; 1960) &amp; (Book.author.name == \"J.R.R. Tolkien\")) |\n        ((Book.year &lt; 2000) &amp; (Book.author.name == \"Andrzej Sapkowski\"))\n    )\n    .all()\n)\nassert len(books) == 2\n</code></pre> <p>Of course those functions can have more than 2 conditions, so if we for example want  books that contains 'hobbit':</p> <p>sql: <code>WHERE ( ( books.year &gt; 1960 AND authors.name = 'J.R.R. Tolkien' ) OR  ( books.year &lt; 2000 AND os0cec_authors.name = 'Andrzej Sapkowski' ) OR  books.title LIKE '%hobbit%' )</code></p>"},{"location":"queries/filter-and-sort/#django-style_3","title":"Django style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(\n        ormar.or_(\n            ormar.and_(year__gt=1960, author__name=\"J.R.R. Tolkien\"),\n            ormar.and_(year__lt=2000, author__name=\"Andrzej Sapkowski\"),\n            title__icontains=\"hobbit\",\n        )\n    )\n    .all()\n)\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_3","title":"Python style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(    \n        ((Book.year &gt; 1960) &amp; (Book.author.name == \"J.R.R. Tolkien\")) |\n        ((Book.year &lt; 2000) &amp; (Book.author.name == \"Andrzej Sapkowski\")) |\n        (Book.title.icontains(\"hobbit\"))\n    )\n    .all()\n)\n</code></pre> <p>If you want or need to you can nest deeper conditions as deep as you want, in example to achieve a query like this:</p> <p>sql: <pre><code>WHERE ( ( ( books.year &gt; 1960 OR books.year &lt; 1940 ) \nAND authors.name = 'J.R.R. Tolkien' ) OR \n( books.year &lt; 2000 AND authors.name = 'Andrzej Sapkowski' ) )\n</code></pre></p> <p>You can construct a query as follows:</p>"},{"location":"queries/filter-and-sort/#django-style_4","title":"Django style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(\n        ormar.or_(\n            ormar.and_(\n                ormar.or_(year__gt=1960, year__lt=1940),\n                author__name=\"J.R.R. Tolkien\",\n            ),\n            ormar.and_(year__lt=2000, author__name=\"Andrzej Sapkowski\"),\n        )\n    )\n    .all()\n)\nassert len(books) == 3\nassert books[0].title == \"The Hobbit\"\nassert books[1].title == \"The Silmarillion\"\nassert books[2].title == \"The Witcher\"\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_4","title":"Python style","text":"<pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(        \n        (\n            (\n            (Book.year &gt; 1960) |\n            (Book.year &lt; 1940)\n            ) &amp;\n            (Book.author.name == \"J.R.R. Tolkien\")\n        ) |\n        (\n            (Book.year &lt; 2000) &amp; \n            (Book.author.name == \"Andrzej Sapkowski\")\n        )\n    )\n    .all()\n)\nassert len(books) == 3\nassert books[0].title == \"The Hobbit\"\nassert books[1].title == \"The Silmarillion\"\nassert books[2].title == \"The Witcher\"\n</code></pre> <p>By now you should already have an idea how <code>ormar.or_</code> and <code>ormar.and_</code> works. Of course, you could chain them in any other methods of queryset, so in example a perfectly valid query can look like follows:</p> <pre><code>books = (\n    await Book.objects.select_related(\"author\")\n    .filter(ormar.or_(year__gt=1980, author__name=\"Andrzej Sapkowski\"))\n    .filter(title__startswith=\"The\")\n    .limit(1)\n    .offset(1)\n    .order_by(\"-id\")\n    .all()\n)\nassert len(books) == 1\nassert books[0].title == \"The Witcher\"\n</code></pre> <p>Same applies to python style chaining and nesting.</p>"},{"location":"queries/filter-and-sort/#django-style_5","title":"Django style","text":"<p>Note that with django style you cannot provide the same keyword argument several times so queries like <code>filter(ormar.or_(name='Jack', name='John'))</code> are not allowed. If you want to check the same column for several values simply use <code>in</code> operator: <code>filter(name__in=['Jack','John'])</code>.</p> <p>If you pass only one parameter to <code>or_</code> or <code>and_</code> functions it's simply wrapped in parenthesis and has no effect on actual query, so in the end all 3 queries are identical:</p> <pre><code>await Book.objects.filter(title='The Hobbit').get()\nawait Book.objects.filter(ormar.or_(title='The Hobbit')).get()\nawait Book.objects.filter(ormar.and_(title='The Hobbit')).get()\n</code></pre> <p>Note</p> <p>Note that <code>or_</code> and <code>and_</code> queries will have <code>WHERE (title='The Hobbit')</code> but the parenthesis is redundant and has no real effect.</p> <p>This feature can be used if you really need to use the same field name twice. Remember that you cannot pass the same keyword arguments twice to the function, so how you can query in example <code>WHERE (authors.name LIKE '%tolkien%') OR (authors.name LIKE '%sapkowski%'))</code>?</p> <p>You cannot do: <pre><code>books = (\n    await Book.objects.select_related(\"author\")\n        .filter(ormar.or_(\n        author__name__icontains=\"tolkien\",\n        author__name__icontains=\"sapkowski\" # you cannot use same keyword twice in or_!\n    ))                                      # python syntax error\n        .all()\n)\n</code></pre></p> <p>But you can do this:</p> <pre><code>books = (\n    await Book.objects.select_related(\"author\")\n        .filter(ormar.or_(\n        ormar.and_(author__name__icontains=\"tolkien\"), # one argument == just wrapped in ()\n        ormar.and_(author__name__icontains=\"sapkowski\")\n    ))\n        .all()\n)\nassert len(books) == 5\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_5","title":"Python style","text":"<p>Note that with python style you can perfectly use the same fields as many times as you want.</p> <pre><code>books = (\n    await Book.objects.select_related(\"author\")\n        .filter(\n        (Book.author.name.icontains(\"tolkien\")) |\n        (Book.author.name.icontains(\"sapkowski\"))\n    ))                                      \n        .all()\n)\n</code></pre>"},{"location":"queries/filter-and-sort/#get","title":"get","text":"<p><code>get(*args, **kwargs) -&gt; Model</code></p> <p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>When any args and/or kwargs are passed it's a shortcut equivalent to calling <code>filter(*args, **kwargs).get()</code></p> <p>Tip</p> <p>To read more about <code>filter</code> go to filter.</p> <p>To read more about <code>get</code> go to read/get</p>"},{"location":"queries/filter-and-sort/#get_or_none","title":"get_or_none","text":"<p>Exact equivalent of get described above but instead of raising the exception returns <code>None</code> if no db record matching the criteria is found.</p>"},{"location":"queries/filter-and-sort/#get_or_create","title":"get_or_create","text":"<p><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs) -&gt; Tuple[Model, bool]</code></p> <p>Combination of create and get methods.</p> <p>When any args and/or kwargs are passed it's a shortcut equivalent to calling <code>filter(*args, **kwargs).get_or_create()</code></p> <p>Tip</p> <p>To read more about <code>filter</code> go to filter.</p> <p>To read more about <code>get_or_create</code> go to read/get_or_create</p> <p>Warning</p> <p>When given item does not exist you need to pass kwargs for all required fields of the model, including but not limited to primary_key column (unless it's autoincrement).</p>"},{"location":"queries/filter-and-sort/#all","title":"all","text":"<p><code>all(*args, **kwargs) -&gt; List[Optional[\"Model\"]]</code></p> <p>Returns all rows from a database for given model for set filter options.</p> <p>When any kwargs are passed it's a shortcut equivalent to calling <code>filter(*args, **kwargs).all()</code></p> <p>Tip</p> <p>To read more about <code>filter</code> go to filter.</p> <p>To read more about <code>all</code> go to read/all</p>"},{"location":"queries/filter-and-sort/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/filter-and-sort/#filter_1","title":"filter","text":"<p>Works exactly the same as filter function above but allows you to filter related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/filter-and-sort/#exclude_1","title":"exclude","text":"<p>Works exactly the same as exclude function above but allows you to filter related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/filter-and-sort/#get_1","title":"get","text":"<p>Works exactly the same as get function above but allows you to filter related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/filter-and-sort/#get_or_none_1","title":"get_or_none","text":"<p>Exact equivalent of get described above but instead of raising the exception returns <code>None</code> if no db record matching the criteria is found.</p>"},{"location":"queries/filter-and-sort/#get_or_create_1","title":"get_or_create","text":"<p>Works exactly the same as get_or_create function above but allows you to filter related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/filter-and-sort/#all_1","title":"all","text":"<p>Works exactly the same as all function above but allows you to filter related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/filter-and-sort/#sorting","title":"Sorting","text":""},{"location":"queries/filter-and-sort/#order_by","title":"order_by","text":"<p><code>order_by(columns: Union[List, str, OrderAction]) -&gt; QuerySet</code></p> <p>With <code>order_by()</code> you can order the results from database based on your choice of fields.</p> <p>You can provide a string with field name or list of strings with different fields.</p> <p>Ordering in sql will be applied in order of names you provide in order_by.</p> <p>Tip</p> <p>By default if you do not provide ordering <code>ormar</code> explicitly orders by all primary keys</p> <p>Warning</p> <p>If you are sorting by nested models that causes that the result rows are unsorted by the main model <code>ormar</code> will combine those children rows into one main model.</p> <p>Sample raw database rows result (sort by child model desc): <pre><code>MODEL: 1 - Child Model - 3\nMODEL: 2 - Child Model - 2\nMODEL: 1 - Child Model - 1\n</code></pre></p> <p>will result in 2 rows of result: <pre><code>MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined\nMODEL: 2 - Child Models: [2]\n</code></pre></p> <p>The main model will never duplicate in the result</p> <p>Given sample Models like following:</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Owner(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"owners\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Toy(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"toys\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    owner: Owner = ormar.ForeignKey(Owner)\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    # build some sample data\n    aphrodite = await Owner.objects.create(name=\"Aphrodite\")\n    hermes = await Owner.objects.create(name=\"Hermes\")\n    zeus = await Owner.objects.create(name=\"Zeus\")\n\n    await Toy.objects.create(name=\"Toy 4\", owner=zeus)\n    await Toy.objects.create(name=\"Toy 5\", owner=hermes)\n    await Toy.objects.create(name=\"Toy 2\", owner=aphrodite)\n    await Toy.objects.create(name=\"Toy 1\", owner=zeus)\n    await Toy.objects.create(name=\"Toy 3\", owner=aphrodite)\n    await Toy.objects.create(name=\"Toy 6\", owner=hermes)\n\n\nasyncio.run(run_query())\n</code></pre> <p>To order by main model field just provide a field name</p>"},{"location":"queries/filter-and-sort/#django-style_6","title":"Django style","text":"<pre><code>toys = await Toy.objects.select_related(\"owner\").order_by(\"name\").all()\nassert [x.name.replace(\"Toy \", \"\") for x in toys] == [\n    str(x + 1) for x in range(6)\n]\nassert toys[0].owner == zeus\nassert toys[1].owner == aphrodite\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_6","title":"Python style","text":"<pre><code>toys = await Toy.objects.select_related(\"owner\").order_by(Toy.name.asc()).all()\nassert [x.name.replace(\"Toy \", \"\") for x in toys] == [\n    str(x + 1) for x in range(6)\n]\nassert toys[0].owner == zeus\nassert toys[1].owner == aphrodite\n</code></pre> <p>To sort on nested models separate field names with dunder '__'.</p> <p>You can sort this way across all relation types -&gt; <code>ForeignKey</code>, reverse virtual FK and <code>ManyToMany</code> fields.</p>"},{"location":"queries/filter-and-sort/#django-style_7","title":"Django style","text":"<pre><code>toys = await Toy.objects.select_related(\"owner\").order_by(\"owner__name\").all()\nassert toys[0].owner.name == toys[1].owner.name == \"Aphrodite\"\nassert toys[2].owner.name == toys[3].owner.name == \"Hermes\"\nassert toys[4].owner.name == toys[5].owner.name == \"Zeus\"\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_7","title":"Python style","text":"<pre><code>toys = await Toy.objects.select_related(\"owner\").order_by(Toy.owner.name.asc()).all()\nassert toys[0].owner.name == toys[1].owner.name == \"Aphrodite\"\nassert toys[2].owner.name == toys[3].owner.name == \"Hermes\"\nassert toys[4].owner.name == toys[5].owner.name == \"Zeus\"\n</code></pre> <p>To sort in descending order provide a hyphen in front of the field name</p>"},{"location":"queries/filter-and-sort/#django-style_8","title":"Django style","text":"<pre><code>owner = (\n    await Owner.objects.select_related(\"toys\")\n        .order_by(\"-toys__name\")\n        .filter(name=\"Zeus\")\n        .get()\n)\nassert owner.toys[0].name == \"Toy 4\"\nassert owner.toys[1].name == \"Toy 1\"\n</code></pre>"},{"location":"queries/filter-and-sort/#python-style_8","title":"Python style","text":"<pre><code>owner = (\n    await Owner.objects.select_related(\"toys\")\n        .order_by(Owner.toys.name.desc())\n        .filter(Owner.name == \"Zeus\")\n        .get()\n)\nassert owner.toys[0].name == \"Toy 4\"\nassert owner.toys[1].name == \"Toy 1\"\n</code></pre> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/filter-and-sort/#default-sorting-in-ormar","title":"Default sorting in ormar","text":"<p>Since order of rows in a database is not guaranteed, <code>ormar</code> always issues an <code>order by</code> sql clause to each (part of) query even if you do not provide order yourself. </p> <p>When querying the database with given model by default the <code>Model</code> is ordered by the <code>primary_key</code> column ascending. If you wish to change the default behaviour you can do it by providing <code>orders_by</code> parameter to <code>ormar_config</code>.</p> <p>Tip</p> <p>To read more about models sort order visit models section of documentation</p> <p>By default the relations follow the same ordering, but you can modify the order in which related models are loaded during query by providing <code>orders_by</code> and <code>related_orders_by</code> parameters to relations.</p> <p>Tip</p> <p>To read more about models sort order visit relations section of documentation</p> <p>Order in which order_by clauses are applied is as follows:</p> <ul> <li>Explicitly passed <code>order_by()</code> calls in query</li> <li>Relation passed <code>orders_by</code> and <code>related_orders_by</code> if exists</li> <li>Model's <code>ormar_config</code> object <code>orders_by</code></li> <li>Model's <code>primary_key</code> column ascending (fallback, used if none of above provided)</li> </ul> <p>Order from only one source is applied to each <code>Model</code> (so that you can always overwrite it in a single query).</p> <p>That means that if you provide explicit <code>order_by</code> for a model in a query, the <code>Relation</code> and <code>Model</code> sort orders are skipped.</p> <p>If you provide a <code>Relation</code> one, the <code>Model</code> sort is skipped.</p> <p>Finally, if you provide one for <code>Model</code> the default one by <code>primary_key</code> is skipped.</p>"},{"location":"queries/filter-and-sort/#querysetproxy-methods_1","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/filter-and-sort/#order_by_1","title":"order_by","text":"<p>Works exactly the same as order_by function above but allows you to sort related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/joins-and-subqueries/","title":"Joins and subqueries","text":"<p>To join one table to another, so load also related models you can use following methods.</p> <ul> <li><code>select_related(related: Union[List, str]) -&gt; QuerySet</code></li> <li><code>select_all(follow: bool = True) -&gt; QuerySet</code></li> <li> <p><code>prefetch_related(related: Union[List, str]) -&gt; QuerySet</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.load()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.select_related(related: Union[List, str])</code> method</li> <li><code>QuerysetProxy.select_all(follow: bool=True)</code> method</li> <li><code>QuerysetProxy.prefetch_related(related: Union[List, str])</code> method</li> </ul> </li> </ul>"},{"location":"queries/joins-and-subqueries/#select_related","title":"select_related","text":"<p><code>select_related(related: Union[List, str]) -&gt; QuerySet</code></p> <p>Allows to prefetch related models during the same query.</p> <p>With <code>select_related</code> always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>Note</p> <p>If you are coming from <code>django</code> note that <code>ormar</code> <code>select_related</code> differs -&gt; in <code>django</code> you can <code>select_related</code> only single relation types, while in <code>ormar</code> you can select related across <code>ForeignKey</code> relation, reverse side of <code>ForeignKey</code> (so virtual auto generated keys) and <code>ManyToMany</code> fields (so all relations as of current version).</p> <p>Tip</p> <p>To control which model fields to select use <code>fields()</code> and <code>exclude_fields()</code> <code>QuerySet</code> methods.</p> <p>Tip</p> <p>To control order of models (both main or nested) use <code>order_by()</code> method.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    title: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n    play_count: int = ormar.Integer(nullable=True)\n</code></pre> <pre><code># Django style\nalbum = await Album.objects.select_related(\"tracks\").all()\n\n# Python style\nalbum = await Album.objects.select_related(Album.tracks).all()\n\n# will return album with all columns tracks\n</code></pre> <p>You can provide a string or a list of strings (or a field/ list of fields)</p> <pre><code>class SchoolClass(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"schoolclasses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    department: Optional[Department] = ormar.ForeignKey(Department, nullable=False)\n\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Student(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    schoolclass: Optional[SchoolClass] = ormar.ForeignKey(SchoolClass)\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n\n\nclass Teacher(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    schoolclass: Optional[SchoolClass] = ormar.ForeignKey(SchoolClass)\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n</code></pre> <pre><code># Django style\nclasses = await SchoolClass.objects.select_related(\n    [\"teachers__category\", \"students\"]).all()\n\n# Python style\nclasses = await SchoolClass.objects.select_related(\n    [SchoolClass.teachers.category, SchoolClass.students]).all()\n\n# will return classes with teachers and teachers categories\n# as well as classes students\n</code></pre> <p>Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final <code>Models</code> are fetched for you.</p> <p>Warning</p> <p>If you set <code>ForeignKey</code> field as not nullable (so required) during all queries the not nullable <code>Models</code> will be auto prefetched, even if you do not include them in select_related.</p> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/joins-and-subqueries/#select_all","title":"select_all","text":"<p><code>select_all(follow: bool = False) -&gt; QuerySet</code></p> <p>By default when you select <code>all()</code> none of the relations are loaded, likewise,  when <code>select_related()</code> is used you need to explicitly specify all relations that should be loaded. If you want to include also nested relations this can be cumberstone.</p> <p>That's why <code>select_all()</code> was introduced, so by default load all relations of a model  (so kind of opposite as with <code>all()</code> approach).</p> <p>By default adds only directly related models of a parent model (from which the query is run).</p> <p>If <code>follow=True</code> is set it adds also related models of related models.</p> <p>Info</p> <p>To not get stuck in an infinite loop as related models also keep a relation to parent model visited models set is kept.</p> <p>That way already visited models that are nested are loaded, but the load do not follow them inside. So Model A -&gt; Model B -&gt; Model C -&gt; Model A -&gt; Model X will load second Model A but will never follow into Model X. Nested relations of those kind need to be loaded manually.</p> <p>With sample date like follow:</p> <pre><code>base_ormar_config = OrmarConfig(\n    database=databases.Database(DATABASE_URL, force_rollback=True),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Address(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"addresses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    street: str = ormar.String(max_length=100, nullable=False)\n    number: int = ormar.Integer(nullable=False)\n    post_code: str = ormar.String(max_length=20, nullable=False)\n\n\n\nclass Branch(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"branches\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, nullable=False)\n    address = ormar.ForeignKey(Address)\n\n\nclass Company(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"companies\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100, nullable=False, name=\"company_name\")\n    founded: int = ormar.Integer(nullable=True)\n    branches = ormar.ManyToMany(Branch)  \n</code></pre> <p>To select all <code>Companies</code> with all <code>Branches</code> and <code>Addresses</code> you can simply query:</p> <pre><code>companies = await Company.objects.select_all(follow=True).all()\n\n# which is equivalent to:\ncompanies = await Company.objects.select_related('branches__address').all()\n</code></pre> <p>Of course in this case it's quite easy to issue explicit relation names in <code>select_related</code>, but the benefit of <code>select_all()</code> shows when you have multiple relations. </p> <p>If for example <code>Company</code> would have 3 relations and all of those 3 relations have it's own  3 relations you would have to issue 9 relation strings to <code>select_related</code>, <code>select_all()</code> is also resistant to change in names of relations.</p> <p>Note</p> <p>Note that you can chain <code>select_all()</code> with other <code>QuerySet</code> methods like <code>filter</code>, <code>exclude_fields</code> etc. To exclude relations use <code>exclude_fields()</code> call with names of relations (also nested) to exclude.</p>"},{"location":"queries/joins-and-subqueries/#prefetch_related","title":"prefetch_related","text":"<p><code>prefetch_related(related: Union[List, str]) -&gt; QuerySet</code></p> <p>Allows to prefetch related models during query - but opposite to <code>select_related</code> each subsequent model is fetched in a separate database query.</p> <p>With <code>prefetch_related</code> always one query per Model is run against the database, meaning that you will have multiple queries executed one after another.</p> <p>To fetch related model use <code>ForeignKey</code> names.</p> <p>To chain related <code>Models</code> relation use double underscores between names.</p> <p>Tip</p> <p>To control which model fields to select use <code>fields()</code> and <code>exclude_fields()</code> <code>QuerySet</code> methods.</p> <p>Tip</p> <p>To control order of models (both main or nested) use <code>order_by()</code> method.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    is_best_seller: bool = ormar.Boolean(default=False)\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    title: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n    play_count: int = ormar.Integer(nullable=True)\n</code></pre> <pre><code># Django style\nalbum = await Album.objects.prefetch_related(\"tracks\").all()\n\n# Python style\nalbum = await Album.objects.prefetch_related(Album.tracks).all()\n\n\n# will return album will all columns tracks\n</code></pre> <p>You can provide a string, or a list of strings</p> <pre><code>class SchoolClass(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"schoolclasses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    department: Optional[Department] = ormar.ForeignKey(Department, nullable=False)\n\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Student(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    schoolclass: Optional[SchoolClass] = ormar.ForeignKey(SchoolClass)\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n\n\nclass Teacher(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    schoolclass: Optional[SchoolClass] = ormar.ForeignKey(SchoolClass)\n    category: Optional[Category] = ormar.ForeignKey(Category, nullable=True)\n</code></pre> <pre><code># Django style\nclasses = await SchoolClass.objects.prefetch_related(\n    [\"teachers__category\", \"students\"]).all()\n\n# Python style\nclasses = await SchoolClass.objects.prefetch_related(\n    [SchoolClass.teachers.category, SchoolClass.students]).all()\n# will return classes with teachers and teachers categories\n# as well as classes students\n</code></pre> <p>Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final <code>Models</code> are fetched for you.</p> <p>Warning</p> <p>If you set <code>ForeignKey</code> field as not nullable (so required) during all queries the not nullable <code>Models</code> will be auto prefetched, even if you do not include them in select_related.</p> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/joins-and-subqueries/#select_related-vs-prefetch_related","title":"select_related vs prefetch_related","text":"<p>Which should you use -&gt; <code>select_related</code> or <code>prefetch_related</code>?</p> <p>Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints.</p> <p>What to keep in mind:</p>"},{"location":"queries/joins-and-subqueries/#performance","title":"Performance","text":"<p>Number of queries: <code>select_related</code> always executes one query against the database, while <code>prefetch_related</code> executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be.</p> <p>Number of rows: Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this:</p> <pre><code>                     Model C\n                   /\n           Model B - Model C\n         / \nModel A  - Model B - Model C\n       \\           \\ \n        \\            Model C\n         \\\n           Model B - Model C\n                   \\ \n                     Model C\n</code></pre> <p>That means that <code>select_related</code> will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models.</p> <p>How many rows will return <code>prefetch_related</code>?</p> <p>Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query.</p> <p>In this case <code>select_related</code> seems like a better choice, not only it will run one query comparing to 3 of <code>prefetch_related</code> but will also return 60 000 rows comparing to 100 000 of <code>prefetch_related</code> (10+30+60k).</p> <p>But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? <code>select_related</code> will still return 60 000 rows, while <code>prefetch_related</code> will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) <code>prefetch_related</code> might be faster despite it needs to perform three separate queries instead of one.</p>"},{"location":"queries/joins-and-subqueries/#memory","title":"Memory","text":"<p><code>ormar</code> is does not keep a registry of already loaded models.</p> <p>That means that in <code>select_related</code> example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of <code>select_related</code> spawns  new child models for each parent model). And 60 000 Models C.</p> <p>If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again). That means that <code>select_related</code> will use more memory as each child is instantiated as a new object - obviously using it's own space.</p> <p>Note</p> <p>This might change in future versions if we decide to introduce caching.</p> <p>Warning</p> <p>By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db.</p> <p>They will evaluate to True when compared, so in example above: </p> <pre><code># will return True if child1 of both rows is the same child db row \nrow1.child1 == row100.child1\n\n# same here:\nmodel1 = await Model.get(pk=1)\nmodel2 = await Model.get(pk=1) # same pk = same row in db\n# will return `True`\nmodel1 == model2\n</code></pre> <p>but </p> <pre><code># will return False (note that id is a python `builtin` function not ormar one).\nid(row1.child1) == id(ro100.child1)\n\n# from above - will also return False\nid(model1) == id(model2)\n</code></pre> <p>On the contrary - with <code>prefetch_related</code> each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in <code>prefetch_related</code> example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object.</p>"},{"location":"queries/joins-and-subqueries/#model-methods","title":"Model methods","text":"<p>Each model instance have a set of methods to <code>save</code>, <code>update</code> or <code>load</code> itself.</p>"},{"location":"queries/joins-and-subqueries/#load","title":"load","text":"<p>You can load the <code>ForeignKey</code> related model by calling <code>load()</code> method.</p> <p><code>load()</code> can be used to refresh the model from the database (if it was changed by some other process).</p> <p>Tip</p> <p>Read more about <code>load()</code> method in models methods</p>"},{"location":"queries/joins-and-subqueries/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/joins-and-subqueries/#select_related_1","title":"select_related","text":"<p>Works exactly the same as select_related function above but allows you to fetch related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/joins-and-subqueries/#select_all_1","title":"select_all","text":"<p>Works exactly the same as select_all function above but allows you to fetch related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/joins-and-subqueries/#prefetch_related_1","title":"prefetch_related","text":"<p>Works exactly the same as prefetch_related function above but allows you to fetch related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/pagination-and-rows-number/","title":"Pagination and rows number","text":"<p>Following methods allow you to paginate and limit number of rows in queries. </p> <ul> <li><code>paginate(page: int) -&gt; QuerySet</code></li> <li><code>limit(limit_count: int) -&gt; QuerySet</code></li> <li><code>offset(offset: int) -&gt; QuerySet</code></li> <li><code>get() -&gt; Model</code></li> <li> <p><code>first() -&gt; Model</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.paginate(page: int)</code> method</li> <li><code>QuerysetProxy.limit(limit_count: int)</code> method</li> <li><code>QuerysetProxy.offset(offset: int)</code> method</li> </ul> </li> </ul>"},{"location":"queries/pagination-and-rows-number/#paginate","title":"paginate","text":"<p><code>paginate(page: int, page_size: int = 20) -&gt; QuerySet</code></p> <p>Combines the <code>offset</code> and <code>limit</code> methods based on page number and size</p> <pre><code>class Track(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=databases.Database(DATABASE_URL),\n        metadata=sqlalchemy.MetaData(),\n        tablename=\"track\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    name: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n</code></pre> <pre><code>tracks = await Track.objects.paginate(3).all()\n# will return 20 tracks starting at row 41 \n# (with default page size of 20)\n</code></pre> <p>Note that <code>paginate(2)</code> is equivalent to <code>offset(20).limit(20)</code></p>"},{"location":"queries/pagination-and-rows-number/#limit","title":"limit","text":"<p><code>limit(limit_count: int, limit_raw_sql: bool = None) -&gt; QuerySet</code></p> <p>You can limit the results to desired number of parent models.</p> <p>To limit the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <pre><code>class Track(ormar.Model):\n    ormar.OrmarConfig(\n        database=databases.Database(DATABASE_URL),\n        metadata=sqlalchemy.MetaData(),\n        tablename=\"track\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    name: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n</code></pre> <pre><code>tracks = await Track.objects.limit(1).all()\n# will return just one Track\n</code></pre> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/pagination-and-rows-number/#offset","title":"offset","text":"<p><code>offset(offset: int, limit_raw_sql: bool = None) -&gt; QuerySet</code></p> <p>You can also offset the results by desired number of main models.</p> <p>To offset the actual number of database query rows instead of number of main models use the <code>limit_raw_sql</code> parameter flag, and set it to <code>True</code>.</p> <pre><code>class Track(ormar.Model):\n    ormar.OrmarConfig(\n        database=databases.Database(DATABASE_URL),\n        metadata=sqlalchemy.MetaData(),\n        tablename=\"track\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    name: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n</code></pre> <pre><code>tracks = await Track.objects.offset(1).limit(1).all()\n# will return just one Track, but this time the second one\n</code></pre> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/pagination-and-rows-number/#get","title":"get","text":"<p><code>get(**kwargs) -&gt; Model</code> </p> <p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria is set it will return the last row in db sorted by pk. (The criteria cannot be set also with filter/exclude).</p> <p>Tip</p> <p>To read more about <code>get</code> visit read/get</p>"},{"location":"queries/pagination-and-rows-number/#first","title":"first","text":"<p><code>first() -&gt; Model</code> </p> <p>Gets the first row from the db ordered by primary key column ascending.</p> <p>Tip</p> <p>To read more about <code>first</code> visit read/first</p>"},{"location":"queries/pagination-and-rows-number/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/pagination-and-rows-number/#paginate_1","title":"paginate","text":"<p>Works exactly the same as paginate function above but allows you to paginate related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/pagination-and-rows-number/#limit_1","title":"limit","text":"<p>Works exactly the same as limit function above but allows you to paginate related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/pagination-and-rows-number/#offset_1","title":"offset","text":"<p>Works exactly the same as offset function above but allows you to paginate related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/raw-data/","title":"Return raw data","text":"<p>Following methods allow you to execute a query but instead of returning ormar models those will return list of dicts or tuples.</p> <ul> <li><code>values(fields = None, exclude_through = False) -&gt; List[Dict]</code></li> <li> <p><code>values_list(fields = None, exclude_through = False, flatten = False) -&gt; List</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.values(fields = None, exclude_through = False)</code> method</li> <li><code>QuerysetProxy.values_list(fields = None, exclude_through= False, flatten = False)</code> method</li> </ul> </li> </ul> <p>Danger</p> <p>Note that <code>values</code> and <code>values_list</code> skips parsing the result to ormar models so skips also the validation of the result!</p> <p>Warning</p> <p>Note that each entry in a result list is one to one reflection of a query result row.  Since rows are not parsed if you have one-to-many or many-to-many relation expect  duplicated columns values in result entries if one parent row have multiple related rows. </p>"},{"location":"queries/raw-data/#values","title":"values","text":"<p><code>values(fields: Union[List, str, Set, Dict] = None, exclude_through: bool = False) -&gt; List[Dict]</code></p> <p>Return a list of dictionaries representing the values of the columns coming from the database.</p> <p>You can select a subset of fields with fields parameter, that accepts the same set of parameters as <code>fields()</code> method.</p> <p>Note that passing fields to <code>values(fields)</code> is actually a shortcut for calling <code>fields(fields).values()</code>.</p> <p>Tip</p> <p>To read more about what you can pass to fields and how to select nested models fields read selecting columns docs</p> <p>You can limit the number of rows by providing conditions in <code>filter()</code> and <code>exclude()</code>, but note that even if only one row (or no rows!) match your criteria you will return a list in response.</p> <p>Example:</p> <pre><code># declared models\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n    sort_order: int = ormar.Integer(nullable=True)\n\n\nclass Post(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=200)\n    category: Optional[Category] = ormar.ForeignKey(Category)\n\n# sample data\nnews = await Category(name=\"News\", sort_order=0).save()\nawait Post(name=\"Ormar strikes again!\", category=news).save()\nawait Post(name=\"Why don't you use ormar yet?\", category=news).save()\nawait Post(name=\"Check this out, ormar now for free\", category=news).save()\n</code></pre> <p>Access Post models:</p> <pre><code>posts = await Post.objects.values()\nassert posts == [\n    {\"id\": 1, \"name\": \"Ormar strikes again!\", \"category\": 1},\n    {\"id\": 2, \"name\": \"Why don't you use ormar yet?\", \"category\": 1},\n    {\"id\": 3, \"name\": \"Check this out, ormar now for free\", \"category\": 1},\n]\n</code></pre> <p>To select also related models use <code>select_related</code> or <code>prefetch_related</code>.</p> <p>Note how nested models columns will be prefixed with full relation path coming from the main model (the one used in a query).</p> <pre><code># declare models\n\nclass User(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Role(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    users: List[User] = ormar.ManyToMany(User)\n\n# sample data\ncreator = await User(name=\"Anonymous\").save()\nadmin = await Role(name=\"admin\").save()\neditor = await Role(name=\"editor\").save()\nawait creator.roles.add(admin)\nawait creator.roles.add(editor)\n</code></pre> <p>Select user with roles</p> <pre><code>user = await User.objects.select_related(\"roles\").values()\n# note nested prefixes: roleuser and roles\nassert user == [\n    {\n        \"id\": 1,\n        \"name\": \"Anonymous\",\n        \"roleuser__id\": 1,\n        \"roleuser__role\": 1,\n        \"roleuser__user\": 1,\n        \"roles__id\": 1,\n        \"roles__name\": \"admin\",\n    },\n    {\n        \"id\": 1,\n        \"name\": \"Anonymous\",\n        \"roleuser__id\": 2,\n        \"roleuser__role\": 2,\n        \"roleuser__user\": 1,\n        \"roles__id\": 2,\n        \"roles__name\": \"editor\",\n    },\n]\n</code></pre> <p>Note</p> <p>Note how role to users relation is a <code>ManyToMany</code> relation so by default you also get through model columns.</p> <p>Combine select related and fields to select only 3 fields.</p> <p>Note that we also exclude through model as by definition every model included in a join but without any reference in fields is assumed to be selected in full (all fields included).</p> <p>Note</p> <p>Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models.</p> <p>So in relation category -&gt; category_x_post -&gt; post -&gt; user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model from category model).</p> <pre><code>user = (\n        await Role.objects.select_related(\"users__categories\")\n        .filter(name=\"admin\")\n        .fields({\"name\": ..., \"users\": {\"name\": ..., \"categories\": {\"name\"}}})\n        .exclude_fields(\"roleuser\")\n        .values()\n    )\nassert user == [\n    {\n        \"name\": \"admin\",\n        \"users__name\": \"Anonymous\",\n        \"users__categories__name\": \"News\",\n    }\n]\n</code></pre> <p>If you have multiple ManyToMany models in your query you would have to exclude each through model manually.</p> <p>To avoid this burden <code>ormar</code> provides you with <code>exclude_through=False</code> parameter.  If you set this flag to True all through models will be fully excluded.</p> <pre><code># equivalent to query above, note lack of exclude_fields call\nuser = (\n    await Role.objects.select_related(\"users__categories\")\n    .filter(name=\"admin\")\n    .fields({\"name\": ..., \"users\": {\"name\": ..., \"categories\": {\"name\"}}})\n    .values(exclude_through=True)\n)\nassert user == [\n    {\n        \"name\": \"admin\",\n        \"users__name\": \"Anonymous\",\n        \"users__categories__name\": \"News\",\n    }\n]\n</code></pre>"},{"location":"queries/raw-data/#values_list","title":"values_list","text":"<p><code>values_list(fields: Union[List, str, Set, Dict] = None, flatten: bool = False, exclude_through: bool = False) -&gt; List</code></p> <p>Return a list of tuples representing the values of the columns coming from the database.</p> <p>You can select a subset of fields with fields parameter, that accepts the same set of parameters as <code>fields()</code> method.</p> <p>Note that passing fields to <code>values_list(fields)</code> is actually a shortcut for calling <code>fields(fields).values_list()</code>.</p> <p>Tip</p> <p>To read more about what you can pass to fields and how to select nested models fields read selecting columns docs</p> <p>If you select only one column/field you can pass <code>flatten=True</code> which will return you a list of values instead of list of one element tuples.</p> <p>Warning</p> <p>Setting <code>flatten=True</code> if more than one (or none which means all) fields are selected will raise <code>QueryDefinitionError</code> exception.</p> <p>You can limit the number of rows by providing conditions in <code>filter()</code> and <code>exclude()</code>, but note that even if only one row (or no rows!) match your criteria you will return a list in response.</p> <p>Example:</p> <pre><code># declared models\n\nclass Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n    sort_order: int = ormar.Integer(nullable=True)\n\n\nclass Post(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=200)\n    category: Optional[Category] = ormar.ForeignKey(Category)\n\n# sample data\nnews = await Category(name=\"News\", sort_order=0).save()\nawait Post(name=\"Ormar strikes again!\", category=news).save()\nawait Post(name=\"Why don't you use ormar yet?\", category=news).save()\nawait Post(name=\"Check this out, ormar now for free\", category=news).save()\n</code></pre> <p>Access Post models:</p> <pre><code>posts = await Post.objects.values_list()\n# note how columns refer to id, name and category (fk)\nassert posts == [\n    (1, \"Ormar strikes again!\", 1),\n    (2, \"Why don't you use ormar yet?\", 1),\n    (3, \"Check this out, ormar now for free\", 1),\n]\n</code></pre> <p>To select also related models use <code>select_related</code> or <code>prefetch_related</code>.</p> <p>Let's complicate the relation and modify the previously mentioned Category model to refer to User model.</p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n    sort_order: int = ormar.Integer(nullable=True)\n    # new column below\n    created_by: Optional[User] = ormar.ForeignKey(User, related_name=\"categories\")\n</code></pre> <p>Now create the sample data with link to user.</p> <pre><code>creator = await User(name=\"Anonymous\").save()\nadmin = await Role(name=\"admin\").save()\neditor = await Role(name=\"editor\").save()\nawait creator.roles.add(admin)\nawait creator.roles.add(editor)\nnews = await Category(name=\"News\", sort_order=0, created_by=creator).save()\n</code></pre> <p>Combine select related and fields to select only 3 fields.</p> <p>Note that we also exclude through model as by definition every model included in a join but without any reference in fields is assumed to be selected in full (all fields included).</p> <p>Note</p> <p>Note that in contrary to other queryset methods here you can exclude the in-between models but keep the end columns, which does not make sense when parsing the raw data into models.</p> <p>So in relation category -&gt; category_x_post -&gt; post -&gt; user you can exclude category_x_post and post models but can keep the user one. (in ormar model context that is not possible as if you would exclude through and post model there would be no way to reach user model from category model).</p> <pre><code>user = (\n        await Role.objects.select_related(\"users__categories\")\n        .filter(name=\"admin\")\n        .fields({\"name\": ..., \"users\": {\"name\": ..., \"categories\": {\"name\"}}})\n        .exclude_fields(\"roleuser\")\n        .values_list()\n    )\nassert user == [(\"admin\", \"Anonymous\", \"News\")]\n</code></pre> <p>If you have multiple ManyToMany models in your query you would have to exclude each through model manually.</p> <p>To avoid this burden <code>ormar</code> provides you with <code>exclude_through=False</code> parameter.  If you set this flag to True all through models will be fully excluded.</p> <pre><code># equivalent to query above, note lack of exclude_fields call\nuser = (\n        await Role.objects.select_related(\"users__categories\")\n        .filter(name=\"admin\")\n        .fields({\"name\": ..., \"users\": {\"name\": ..., \"categories\": {\"name\"}}})\n        .values_list(exclude_through=True)\n    )\nassert user == [(\"admin\", \"Anonymous\", \"News\")]\n</code></pre> <p>Use flatten to get list of values.</p> <pre><code># using flatten with more than one field will raise exception!\nawait Role.objects.fields({\"name\", \"id\"}).values_list(flatten=True)\n\n# proper usage\nroles = await Role.objects.fields(\"name\").values_list(flatten=True)\nassert roles == [\"admin\", \"editor\"]\n</code></pre>"},{"location":"queries/raw-data/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p> <p>Warning</p> <p>Because using <code>values</code> and <code>values_list</code> skips parsing of the models and validation, in contrast to all other read methods in querysetproxy those 2 does not clear currently loaded related models and does not overwrite the currently loaded models with result of own call!</p>"},{"location":"queries/raw-data/#values_1","title":"values","text":"<p>Works exactly the same as values function above but allows you to fetch related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/raw-data/#values_list_1","title":"values_list","text":"<p>Works exactly the same as values_list function above but allows you to query or create related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/read/","title":"Read data from database","text":"<p>Following methods allow you to load data from the database.</p> <ul> <li><code>get(*args, **kwargs) -&gt; Model</code></li> <li><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs) -&gt; Tuple[Model, bool]</code></li> <li><code>first(*args, **kwargs) -&gt; Model</code></li> <li><code>all(*args, **kwargs) -&gt; List[Optional[Model]]</code></li> <li> <p><code>iterate(*args, **kwargs) -&gt; AsyncGenerator[Model]</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.load()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.get(*args, **kwargs)</code> method</li> <li><code>QuerysetProxy.get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs)</code> method</li> <li><code>QuerysetProxy.first(*args, **kwargs)</code> method</li> <li><code>QuerysetProxy.all(*args, **kwargs)</code> method</li> </ul> </li> </ul>"},{"location":"queries/read/#get","title":"get","text":"<p><code>get(*args, **kwargs) -&gt; Model</code></p> <p>Gets the first row from the db meeting the criteria set by kwargs.</p> <p>If no criteria set it will return the last row in db sorted by pk column.</p> <p>Passing a criteria is actually calling filter(args, *kwargs) method described below.</p> <pre><code>class Track(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"track\"\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    name: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n</code></pre> <pre><code>track = await Track.objects.get(name='The Bird')\n# note that above is equivalent to await Track.objects.filter(name='The Bird').get()\ntrack2 = track = await Track.objects.get()\ntrack == track2\n# True since it's the only row in db in our example\n# and get without arguments return first row by pk column desc \n</code></pre> <p>Warning</p> <p>If no row meets the criteria <code>NoMatch</code> exception is raised.</p> <p>If there are multiple rows meeting the criteria the <code>MultipleMatches</code> exception is raised.</p>"},{"location":"queries/read/#get_or_none","title":"get_or_none","text":"<p><code>get_or_none(*args, **kwargs) -&gt; Model</code></p> <p>Exact equivalent of get described above but instead of raising the exception returns <code>None</code> if no db record matching the criteria is found.</p>"},{"location":"queries/read/#get_or_create","title":"get_or_create","text":"<p><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, *args, **kwargs) -&gt; Tuple[Model, bool]</code></p> <p>Combination of create and get methods.</p> <p>Tries to get a row meeting the criteria and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"album\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    year: int = ormar.Integer()\n</code></pre> <pre><code>album, created = await Album.objects.get_or_create(name='The Cat', _defaults={\"year\": 1999})\nassert created is True\nassert album.name == \"The Cat\"\nassert album.year == 1999\n# object is created as it does not exist\nalbum2, created = await Album.objects.get_or_create(name='The Cat')\nassert created is False\nassert album == album2\n# return True as the same db row is returned\n</code></pre> <p>Warning</p> <p>Despite being an equivalent row from database the <code>album</code> and <code>album2</code> in example above are 2 different python objects! Updating one of them will not refresh the second one until you explicitly load() the fresh data from db.</p> <p>Note</p> <p>Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement</p>"},{"location":"queries/read/#first","title":"first","text":"<p><code>first(*args, **kwargs) -&gt; Model</code></p> <p>Gets the first row from the db ordered by primary key column ascending.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"album\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre> <pre><code>await Album.objects.create(name='The Cat')\nawait Album.objects.create(name='The Dog')\nalbum = await Album.objects.first()\n# first row by primary_key column asc\nassert album.name == 'The Cat'\n</code></pre>"},{"location":"queries/read/#all","title":"all","text":"<p><code>all(*args, **kwargs) -&gt; List[Optional[\"Model\"]]</code></p> <p>Returns all rows from a database for given model for set filter options.</p> <p>Passing kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).all()</code>.</p> <p>If there are no rows meeting the criteria an empty list is returned.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"album\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Track(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"track\")\n\n    id: int = ormar.Integer(primary_key=True)\n    album: Optional[Album] = ormar.ForeignKey(Album)\n    title: str = ormar.String(max_length=100)\n    position: int = ormar.Integer()\n</code></pre> <pre><code>tracks = await Track.objects.select_related(\"album\").all(album__title='Sample')\n# will return a list of all Tracks for album Sample\n# for more on joins visit joining and subqueries section\n\ntracks = await Track.objects.all()\n# will return a list of all Tracks in database\n</code></pre>"},{"location":"queries/read/#iterate","title":"iterate","text":"<p><code>iterate(*args, **kwargs) -&gt; AsyncGenerator[\"Model\"]</code></p> <p>Return async iterable generator for all rows from a database for given model.</p> <p>Passing args and/or kwargs is a shortcut and equals to calling <code>filter(*args, **kwargs).iterate()</code>.</p> <p>If there are no rows meeting the criteria an empty async generator is returned.</p> <pre><code>class Album(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"album\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n</code></pre> <pre><code>await Album.objects.create(name='The Cat')\nawait Album.objects.create(name='The Dog')\n# will asynchronously iterate all Album models yielding one main model at a time from the generator\nasync for album in Album.objects.iterate():\n    print(album.name)\n\n# The Cat\n# The Dog\n</code></pre> <p>Warning</p> <p>Use of <code>iterate()</code> causes previous <code>prefetch_related()</code> calls to be ignored; since these two optimizations do not make sense together.</p> <p>If <code>iterate()</code> &amp; <code>prefetch_related()</code> are used together the <code>QueryDefinitionError</code> exception is raised.</p>"},{"location":"queries/read/#model-methods","title":"Model methods","text":"<p>Each model instance have a set of methods to <code>save</code>, <code>update</code> or <code>load</code> itself.</p>"},{"location":"queries/read/#load","title":"load","text":"<p>You can load the <code>ForeignKey</code> related model by calling <code>load()</code> method.</p> <p><code>load()</code> can be used to refresh the model from the database (if it was changed by some other process).</p> <p>Tip</p> <p>Read more about <code>load()</code> method in models methods</p>"},{"location":"queries/read/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/read/#get_1","title":"get","text":"<p>Works exactly the same as get function above but allows you to fetch related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/read/#get_or_none_1","title":"get_or_none","text":"<p>Exact equivalent of get described above but instead of raising the exception returns <code>None</code> if no db record matching the criteria is found.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/read/#get_or_create_1","title":"get_or_create","text":"<p>Works exactly the same as get_or_create function above but allows you to query or create related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/read/#first_1","title":"first","text":"<p>Works exactly the same as first function above but allows you to query related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/read/#all_1","title":"all","text":"<p>Works exactly the same as all function above but allows you to query related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/select-columns/","title":"Selecting subset of columns","text":"<p>To select only chosen columns of your model you can use following functions.</p> <ul> <li><code>fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></li> <li> <p><code>exclude_fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></p> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.fields(columns: Union[List, str, set, dict])</code> method</li> <li><code>QuerysetProxy.exclude_fields(columns: Union[List, str, set, dict])</code> method</li> </ul> </li> </ul>"},{"location":"queries/select-columns/#fields","title":"fields","text":"<p><code>fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></p> <p>With <code>fields()</code> you can select subset of model columns to limit the data load.</p> <p>Note</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>Given a sample data like following:</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\nfrom tests.settings import DATABASE_URL\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL, force_rollback=True),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Company(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"companies\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    founded: int = ormar.Integer(nullable=True)\n\n\nclass Car(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    manufacturer = ormar.ForeignKey(Company)\n    name: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    gearbox_type: str = ormar.String(max_length=20, nullable=True)\n    gears: int = ormar.Integer(nullable=True)\n    aircon_type: str = ormar.String(max_length=20, nullable=True)\n\n\n@create_drop_database(base_config=base_ormar_config)\nasync def sample_data():\n    # build some sample data\n    toyota = await Company.objects.create(name=\"Toyota\", founded=1937)\n    await Car.objects.create(\n        manufacturer=toyota,\n        name=\"Corolla\",\n        year=2020,\n        gearbox_type=\"Manual\",\n        gears=5,\n        aircon_type=\"Manual\",\n    )\n    await Car.objects.create(\n        manufacturer=toyota,\n        name=\"Yaris\",\n        year=2019,\n        gearbox_type=\"Manual\",\n        gears=5,\n        aircon_type=\"Manual\",\n    )\n    await Car.objects.create(\n        manufacturer=toyota,\n        name=\"Supreme\",\n        year=2020,\n        gearbox_type=\"Auto\",\n        gears=6,\n        aircon_type=\"Auto\",\n    )\n\n\nasyncio.run(sample_data())\n</code></pre> <p>You can select specified fields by passing a <code>str, List[str], Set[str] or dict</code> with nested definition.</p> <p>To include related models use notation <code>{related_name}__{column}[__{optional_next} etc.]</code>.</p> <pre><code>all_cars = await (\n    Car.objects\n    .select_related('manufacturer')\n    .fields(['id', 'name', 'manufacturer__name'])\n    .all()\n)\nfor car in all_cars:\n    # excluded columns will yield None\n    assert all(getattr(car, x) is None for x in ['year', 'gearbox_type', 'gears', 'aircon_type'])\n    # included column on related models will be available, pk column is always included\n    # even if you do not include it in fields list\n    assert car.manufacturer.name == 'Toyota'\n    # also in the nested related models - you cannot exclude pk - it's always auto added\n    assert car.manufacturer.founded is None\n</code></pre> <p><code>fields()</code> can be called several times, building up the columns to select.</p> <p>If you include related models into <code>select_related()</code> call but you won't specify columns for those models in fields</p> <ul> <li>implies a list of all fields for those nested models.</li> </ul> <pre><code>all_cars = await (\n    Car.objects\n    .select_related('manufacturer')\n    .fields('id')\n    .fields(['name'])\n    .all()\n)\n# all fields from company model are selected\nassert all_cars[0].manufacturer.name == 'Toyota'\nassert all_cars[0].manufacturer.founded == 1937\n</code></pre> <p>Warning</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>The <code>values()</code> method can be used to exclude mandatory fields, though data will be returned as a <code>dict</code>.</p> <p>You cannot exclude mandatory model columns - <code>manufacturer__name</code> in this example.</p> <pre><code>await (\n    Car.objects\n    .select_related('manufacturer')\n    .fields(['id', 'name', 'manufacturer__founded'])\n    .all()\n)\n# will raise pydantic ValidationError as company.name is required\n</code></pre> <p>Tip</p> <p>Pk column cannot be excluded - it's always auto added even if not explicitly included.</p> <p>You can also pass fields to include as dictionary or set.</p> <p>To mark a field as included in a dictionary use it's name as key and ellipsis as value.</p> <p>To traverse nested models use nested dictionaries.</p> <p>To include fields at last level instead of nested dictionary a set can be used.</p> <p>To include whole nested model specify model related field name and ellipsis.</p> <p>Below you can see examples that are equivalent:</p> <pre><code># 1. like in example above\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .fields(['id', 'name', 'manufacturer__name'])\n    .all()\n)\n\n# 2. to mark a field as required use ellipsis\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .fields({'id': ...,\n             'name': ...,\n             'manufacturer': {\n                 'name': ...\n                }\n             })\n    .all()\n)\n\n# 3. to include whole nested model use ellipsis\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .fields({'id': ...,\n             'name': ...,\n             'manufacturer': ...\n             })\n    .all()\n)\n\n# 4. to specify fields at last nesting level \n# you can also use set - equivalent to 2. above\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .fields({'id': ...,\n             'name': ...,\n             'manufacturer': {'name'}\n             })\n    .all()\n)\n\n# 5. of course set can have multiple fields\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .fields({'id': ...,\n             'name': ...,\n             'manufacturer': {'name', 'founded'}\n             })\n    .all()\n)\n\n# 6. you can include all nested fields, \n# but it will be equivalent of 3. above which is shorter\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .fields({'id': ...,\n             'name': ...,\n             'manufacturer': {'id', 'name', 'founded'}\n             })\n    .all()\n)\n</code></pre> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.objects.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/select-columns/#exclude_fields","title":"exclude_fields","text":"<p><code>exclude_fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></p> <p>With <code>exclude_fields()</code> you can select subset of model columns that will be excluded to limit the data load.</p> <p>It's the opposite of <code>fields()</code> method so check documentation above to see what options are available.</p> <p>Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy.</p> <p>Note</p> <p>Note that <code>fields()</code> and <code>exclude_fields()</code> works both for main models (on normal queries like <code>get</code>, <code>all</code> etc.) as well as <code>select_related</code> and <code>prefetch_related</code> models (with nested notation).</p> <p>Below you can find few simple examples:</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\nfrom tests.settings import DATABASE_URL\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL, force_rollback=True),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Company(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"companies\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    founded: int = ormar.Integer(nullable=True)\n\n\nclass Car(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    manufacturer = ormar.ForeignKey(Company)\n    name: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    gearbox_type: str = ormar.String(max_length=20, nullable=True)\n    gears: int = ormar.Integer(nullable=True)\n    aircon_type: str = ormar.String(max_length=20, nullable=True)\n\n\n@create_drop_database(base_config=base_ormar_config)\nasync def sample_data():\n    # build some sample data\n    toyota = await Company.objects.create(name=\"Toyota\", founded=1937)\n    await Car.objects.create(\n        manufacturer=toyota,\n        name=\"Corolla\",\n        year=2020,\n        gearbox_type=\"Manual\",\n        gears=5,\n        aircon_type=\"Manual\",\n    )\n    await Car.objects.create(\n        manufacturer=toyota,\n        name=\"Yaris\",\n        year=2019,\n        gearbox_type=\"Manual\",\n        gears=5,\n        aircon_type=\"Manual\",\n    )\n    await Car.objects.create(\n        manufacturer=toyota,\n        name=\"Supreme\",\n        year=2020,\n        gearbox_type=\"Auto\",\n        gears=6,\n        aircon_type=\"Auto\",\n    )\n\n\nasyncio.run(sample_data())\n</code></pre> <pre><code># select manufacturer but only name,\n# to include related models use notation {model_name}__{column}\nall_cars = await (\n    Car.objects\n    .select_related('manufacturer')\n    .exclude_fields([\n        'year',\n        'gearbox_type',\n        'gears',\n        'aircon_type',\n        'company__founded'\n    ])\n    .all()\n)\nfor car in all_cars:\n    # excluded columns will yield None\n    assert all(getattr(car, x) is None\n               for x in [\n                   'year',\n                   'gearbox_type',\n                   'gears',\n                   'aircon_type'\n               ])\n    # included column on related models will be available,\n    # pk column is always included\n    # even if you do not include it in fields list\n    assert car.manufacturer.name == 'Toyota'\n    # also in the nested related models,\n    # you cannot exclude pk - it's always auto added\n    assert car.manufacturer.founded is None\n\n# fields() can be called several times,\n# building up the columns to select\n# models included in select_related \n# but with no columns in fields list implies all fields\nall_cars = await (\n    Car.objects\n    .select_related('manufacturer')\n    .exclude_fields('year')\n    .exclude_fields(['gear', 'gearbox_type'])\n    .all()\n)\n# all fields from company model are selected\nassert all_cars[0].manufacturer.name == 'Toyota'\nassert all_cars[0].manufacturer.founded == 1937\n\n# cannot exclude mandatory model columns,\n# company__name in this example - note usage of dict/set this time\nawait (\n    Car.objects\n    .select_related('manufacturer')\n    .exclude_fields([{'company': {'name'}}])\n    .all()\n)\n# will raise pydantic ValidationError as company.name is required\n</code></pre> <p>Warning</p> <p>Mandatory fields cannot be excluded as it will raise <code>ValidationError</code>, to exclude a field it has to be nullable.</p> <p>The <code>values()</code> method can be used to exclude mandatory fields, though data will be returned as a <code>dict</code>.</p> <p>Tip</p> <p>Pk column cannot be excluded - it's always auto added even if explicitly excluded.</p> <p>Note</p> <p>All methods that do not return the rows explicitly returns a QuerySet instance so you can chain them together</p> <p>So operations like <code>filter()</code>, <code>select_related()</code>, <code>limit()</code> and <code>offset()</code> etc. can be chained.</p> <p>Something like <code>Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()</code></p>"},{"location":"queries/select-columns/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/select-columns/#fields_1","title":"fields","text":"<p>Works exactly the same as fields function above but allows you to select columns from related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/select-columns/#exclude_fields_1","title":"exclude_fields","text":"<p>Works exactly the same as exclude_fields function above but allows you to select columns from related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"queries/update/","title":"Update data in database","text":"<p>Following methods and functions allow updating existing data in the database.</p> <ul> <li><code>update(each: bool = False, **kwargs) -&gt; int</code></li> <li><code>update_or_create(**kwargs) -&gt; Model</code></li> <li> <p><code>bulk_update(objects: List[Model], columns: List[str] = None) -&gt; None</code></p> </li> <li> <p><code>Model</code></p> <ul> <li><code>Model.update()</code> method</li> <li><code>Model.upsert()</code> method</li> <li><code>Model.save_related()</code> method</li> </ul> </li> <li> <p><code>QuerysetProxy</code></p> <ul> <li><code>QuerysetProxy.update_or_create(**kwargs)</code> method</li> </ul> </li> </ul>"},{"location":"queries/update/#update","title":"update","text":"<p><code>update(each: bool = False, **kwargs) -&gt; int</code></p> <p>QuerySet level update is used to update multiple records with the same value at once.</p> <p>You either have to filter the QuerySet first or provide a <code>each=True</code> flag to update whole table.</p> <p>If you do not provide this flag or a filter a <code>QueryDefinitionError</code> will be raised.</p> <p>Return number of rows updated.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Book(ormar.Model):\n    ormar_config = ormar_base_config.copy(\n        tablename=\"books\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: str = ormar.String(max_length=100)\n    genre: str = ormar.String(\n        max_length=100,\n        default=\"Fiction\",\n    )\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    await Book.objects.create(\n        title=\"Tom Sawyer\", author=\"Twain, Mark\", genre=\"Adventure\"\n    )\n    await Book.objects.create(\n        title=\"War and Peace\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n    await Book.objects.create(\n        title=\"Anna Karenina\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n\n    await Book.objects.update(each=True, genre=\"Fiction\")\n    all_books = await Book.objects.filter(genre=\"Fiction\").all()\n    assert len(all_books) == 3\n\n\nasyncio.run(run_query())\n</code></pre> <p>Warning</p> <p>Queryset needs to be filtered before updating to prevent accidental overwrite.</p> <p>To update whole database table <code>each=True</code> needs to be provided as a safety switch</p>"},{"location":"queries/update/#update_or_create","title":"update_or_create","text":"<p><code>update_or_create(**kwargs) -&gt; Model</code></p> <p>Updates the model, or in case there is no match in database creates a new one.</p> <pre><code>import asyncio\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Book(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: str = ormar.String(max_length=100)\n    genre: str = ormar.String(\n        max_length=100,\n        default=\"Fiction\",\n    )\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def run_query():\n    await Book.objects.create(\n        title=\"Tom Sawyer\", author=\"Twain, Mark\", genre=\"Adventure\"\n    )\n    await Book.objects.create(\n        title=\"War and Peace\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n    await Book.objects.create(\n        title=\"Anna Karenina\", author=\"Tolstoy, Leo\", genre=\"Fiction\"\n    )\n\n    # if not exist the instance will be persisted in db\n    vol2 = await Book.objects.update_or_create(\n        title=\"Volume II\", author=\"Anonymous\", genre=\"Fiction\"\n    )\n    assert await Book.objects.count() == 4\n\n    # if pk or pkname passed in kwargs (like id here) the object will be updated\n    assert await Book.objects.update_or_create(id=vol2.id, genre=\"Historic\")\n    assert await Book.objects.count() == 4\n\n\nasyncio.run(run_query())\n</code></pre> <p>Note</p> <p>Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement</p>"},{"location":"queries/update/#bulk_update","title":"bulk_update","text":"<p><code>bulk_update(objects: List[\"Model\"], columns: List[str] = None) -&gt; None</code></p> <p>Allows to update multiple instance at once.</p> <p>All <code>Models</code> passed need to have primary key column populated.</p> <p>You can also select which fields to update by passing <code>columns</code> list as a list of string names.</p> <pre><code># continuing the example from bulk_create\n# update objects\nfor todo in todoes:\n    todo.completed = False\n\n# perform update of all objects at once\n# objects need to have pk column set, otherwise exception is raised\nawait ToDo.objects.bulk_update(todoes)\n\ncompleted = await ToDo.objects.filter(completed=False).all()\nassert len(completed) == 3\n</code></pre>"},{"location":"queries/update/#model-methods","title":"Model methods","text":"<p>Each model instance have a set of methods to <code>save</code>, <code>update</code> or <code>load</code> itself.</p>"},{"location":"queries/update/#update_1","title":"update","text":"<p>You can update models by updating your model attributes (fields) and calling <code>update()</code> method.</p> <p>If you try to update a model without a primary key set a <code>ModelPersistenceError</code> exception will be thrown.</p> <p>Tip</p> <p>Read more about <code>update()</code> method in models-update</p>"},{"location":"queries/update/#upsert","title":"upsert","text":"<p>It's a proxy to either <code>save()</code> or <code>update(**kwargs)</code> methods of a Model. If the pk is set the <code>update()</code> method will be called.</p> <p>Tip</p> <p>Read more about <code>upsert()</code> method in models-upsert</p>"},{"location":"queries/update/#save_related","title":"save_related","text":"<p>Method goes through all relations of the <code>Model</code> on which the method is called,  and calls <code>upsert()</code> method on each model that is not saved. </p> <p>Tip</p> <p>Read more about <code>save_related()</code> method in models-save-related</p>"},{"location":"queries/update/#querysetproxy-methods","title":"QuerysetProxy methods","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p>"},{"location":"queries/update/#update_or_create_1","title":"update_or_create","text":"<p>Works exactly the same as update_or_create function above but allows you to update or create related objects from other side of the relation.</p> <p>Tip</p> <p>To read more about <code>QuerysetProxy</code> visit querysetproxy section</p>"},{"location":"relations/","title":"Relations","text":"<p>Currently <code>ormar</code> supports two types of relations:</p> <ul> <li>One-to-many (and many-to-one) with <code>ForeignKey</code> field</li> <li>Many-to-many with <code>ManyToMany</code> field</li> </ul> <p>Below you can find a very basic examples of definitions for each of those relations.</p> <p>To read more about methods, possibilities, definition etc. please read the subsequent section of the documentation. </p>"},{"location":"relations/#foreignkey","title":"ForeignKey","text":"<p>To define many-to-one relation use <code>ForeignKey</code> field.</p> <pre><code>from typing import Dict, Optional, Union\n\nimport databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    department: Optional[Union[Department, Dict]] = ormar.ForeignKey(Department)\n</code></pre> <p>Tip</p> <p>To read more about one-to-many relations visit foreign-keys section</p>"},{"location":"relations/#reverse-foreignkey","title":"Reverse ForeignKey","text":"<p>The definition of one-to-many relation also uses <code>ForeignKey</code>, and it's registered for you automatically.</p> <p>So in relation to example above.</p> <pre><code>class Department(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    # there is a virtual field here like follows\n    courses: Optional[List[Course]] = ormar.ForeignKey(Course, virtual=True)\n    # note that you DO NOT define it yourself, ormar does it for you.\n</code></pre> <p>Tip</p> <p>To read more about many-to-one relations (i.e changing the name of generated field) visit foreign-keys section</p> <p>Tip</p> <p>Reverse ForeignKey allows you to query the related models with queryset-proxy.</p> <p>It allows you to use <code>await department.courses.all()</code> to fetch data related only to specific department etc. </p>"},{"location":"relations/#manytomany","title":"ManyToMany","text":"<p>To define many-to-many relation use <code>ManyToMany</code> field.</p> <pre><code>class Category(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"categories\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n\nclass Post(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories: Optional[List[Category]] = ormar.ManyToMany(Category)\n</code></pre> <p>Tip</p> <p>To read more about many-to-many relations visit many-to-many section</p> <p>Tip</p> <p>ManyToMany allows you to query the related models with queryset-proxy.</p> <p>It allows you to use <code>await post.categories.all()</code> but also <code>await category.posts.all()</code> to fetch data related only to specific post, category etc.</p>"},{"location":"relations/#through-fields","title":"Through fields","text":"<p>As part of the <code>ManyToMany</code> relation you can define a through model, that can contain additional  fields that you can use to filter, order etc. Fields defined like this are exposed on the reverse side of the current query for m2m models. </p> <p>So if you query from model <code>A</code> to model <code>B</code>, only model <code>B</code> has through field exposed. Which kind of make sense, since it's a one through model/field for each of related models.</p> <pre><code>class Category(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"categories\",\n    )\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n# you can specify additional fields on through model\nclass PostCategory(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n        tablename=\"posts_x_categories\",\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    sort_order: int = ormar.Integer(nullable=True)\n    param_name: str = ormar.String(default=\"Name\", max_length=200)\n\n\nclass Post(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories = ormar.ManyToMany(Category, through=PostCategory)\n</code></pre> <p>Tip</p> <p>To read more about many-to-many relations and through fields visit many-to-many section</p> <p>Tip</p> <p>ManyToMany allows you to query the related models with queryset-proxy.</p> <p>It allows you to use <code>await post.categories.all()</code> but also <code>await category.posts.all()</code> to fetch data related only to specific post, category etc.</p>"},{"location":"relations/#relationship-default-sort-order","title":"Relationship default sort order","text":"<p>By default relations follow model default sort order so <code>primary_key</code> column ascending, or any sort order se in <code>ormar_config</code> object.</p> <p>Tip</p> <p>To read more about models sort order visit models section of documentation</p> <p>But you can modify the order in which related models are loaded during query by providing <code>orders_by</code> and <code>related_orders_by</code> parameters to relations.</p> <p>In relations you can sort only by directly related model columns or for <code>ManyToMany</code>  columns also <code>Through</code> model columns <code>{through_field_name}__{column_name}</code></p> <p>Sample configuration might look like this:</p> <pre><code>database = databases.Database(DATABASE_URL)\nmetadata = sqlalchemy.MetaData()\n\n\nbase_ormar_config = ormar.OrmarConfig(\n    database=database,\n    metadata=metadata,\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Book(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    author: Optional[Author] = ormar.ForeignKey(\n        Author, orders_by=[\"name\"], related_orders_by=[\"-year\"]\n    )\n    title: str = ormar.String(max_length=100)\n    year: int = ormar.Integer(nullable=True)\n    ranking: int = ormar.Integer(nullable=True)\n</code></pre> <p>Now calls:</p> <p><code>await Author.objects.select_related(\"books\").get()</code> - the books will be sorted by the book year descending</p> <p><code>await Book.objects.select_related(\"author\").all()</code> - the authors will be sorted by author name ascending</p>"},{"location":"relations/#self-reference-and-postponed-references","title":"Self-reference and postponed references","text":"<p>In order to create auto-relation or create two models that reference each other in at least two different relations (remember the reverse side is auto-registered for you), you need to use <code>ForwardRef</code> from <code>typing</code> module.</p> <pre><code>PersonRef = ForwardRef(\"Person\")\n\n\nclass Person(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    supervisor: PersonRef = ormar.ForeignKey(PersonRef, related_name=\"employees\")\n\n\nPerson.update_forward_refs()\n</code></pre> <p>Tip</p> <p>To read more about self-reference and postponed relations visit postponed-annotations section</p>"},{"location":"relations/foreign-key/","title":"ForeignKey","text":"<p><code>ForeignKey(to: Model, *, name: str = None, unique: bool = False, nullable: bool = True, related_name: str = None, virtual: bool = False, onupdate: Union[ReferentialAction, str] = None, ondelete: Union[ReferentialAction, str] = None, **kwargs: Any)</code> has required parameters <code>to</code> that takes target <code>Model</code> class.  </p> <p>Sqlalchemy column and Type are automatically taken from target <code>Model</code>.</p> <ul> <li>Sqlalchemy column: class of a target <code>Model</code> primary key column  </li> <li>Type (used for pydantic): type of a target <code>Model</code> </li> </ul>"},{"location":"relations/foreign-key/#defining-models","title":"Defining Models","text":"<p>To define a relation add <code>ForeignKey</code> field that points to related <code>Model</code>.</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Department] = ormar.ForeignKey(Department)\n</code></pre>"},{"location":"relations/foreign-key/#reverse-relation","title":"Reverse Relation","text":"<p><code>ForeignKey</code> fields are automatically registering reverse side of the relation.</p> <p>By default it's child (source) <code>Model</code> name + s, like courses in snippet below: </p> <pre><code>import asyncio\nfrom typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\nfrom examples import create_drop_database\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"departments\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Department] = ormar.ForeignKey(Department)\n\n\n@create_drop_database(base_config=ormar_base_config)\nasync def verify():\n    department = await Department(name=\"Science\").save()\n    course = Course(name=\"Math\", completed=False, department=department)\n    print(department.courses[0])\n    # Will produce:\n    # Course(id=None,\n    #        name='Math',\n    #        completed=False,\n    #        department=Department(id=None, name='Science'))\n    await course.save()\n\n\nasyncio.run(verify())\n</code></pre> <p>Reverse relation exposes API to manage related objects also from parent side.</p>"},{"location":"relations/foreign-key/#skipping-reverse-relation","title":"Skipping reverse relation","text":"<p>If you are sure you don't want the reverse relation you can use <code>skip_reverse=True</code> flag of the <code>ForeignKey</code>.</p> <p>If you set <code>skip_reverse</code> flag internally the field is still registered on the other side of the relationship so you can:</p> <ul> <li><code>filter</code> by related models fields from reverse model</li> <li><code>order_by</code> by related models fields from reverse model</li> </ul> <p>But you cannot:</p> <ul> <li>Access the related field from reverse model with <code>related_name</code></li> <li>Even if you <code>select_related</code> from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can <code>filter</code> and <code>order_by</code> over the relation)</li> <li>The relation won't be populated in <code>model_dump()</code> and <code>model_dump_json()</code></li> <li>You cannot pass the nested related objects when populating from dictionary or json (also through <code>fastapi</code>). It will be either ignored or error will be raised depending on <code>extra</code> setting in pydantic <code>Config</code>.</li> </ul> <p>Example:</p> <pre><code>class Author(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=80)\n    last_name: str = ormar.String(max_length=80)\n\n\nclass Post(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    author: Optional[Author] = ormar.ForeignKey(Author, skip_reverse=True)\n\n# create sample data\nauthor = Author(first_name=\"Test\", last_name=\"Author\")\npost = Post(title=\"Test Post\", author=author)\n\nassert post.author == author  # ok\nassert author.posts  # Attribute error!\n\n# but still can use in order_by\nauthors = (\n    await Author.objects.select_related(\"posts\").order_by(\"posts__title\").all()\n)\nassert authors[0].first_name == \"Test\"\n\n# note that posts are not populated for author even if explicitly\n# included in select_related - note no posts in model_dump()\nassert author.model_dump(exclude={\"id\"}) == {\"first_name\": \"Test\", \"last_name\": \"Author\"}\n\n# still can filter through fields of related model\nauthors = await Author.objects.filter(posts__title=\"Test Post\").all()\nassert authors[0].first_name == \"Test\"\nassert len(authors) == 1\n</code></pre>"},{"location":"relations/foreign-key/#add","title":"add","text":"<p>Adding child model from parent side causes adding related model to currently loaded parent relation,  as well as sets child's model foreign key value and updates the model.</p> <pre><code>department = await Department(name=\"Science\").save()\ncourse = Course(name=\"Math\", completed=False) # note - not saved\n\nawait department.courses.add(course)\nassert course.pk is not None # child model was saved\n# relation on child model is set and FK column saved in db\nassert course.department == department\n# relation on parent model is also set\nassert department.courses[0] == course \n</code></pre> <p>Warning</p> <p>If you want to add child model on related model the primary key value for parent model has to exist in database.</p> <p>Otherwise ormar will raise <code>RelationshipInstanceError</code> as it cannot set child's ForeignKey column value  if parent model has no primary key value.</p> <p>That means that in example above the department has to be saved before you can call <code>department.courses.add()</code>.</p> <p>Warning</p> <p>This method will not work on <code>ManyToMany</code> relations - there, both sides of the relation have to be saved before adding to relation.</p>"},{"location":"relations/foreign-key/#remove","title":"remove","text":"<p>Removal of the related model one by one.</p> <p>In reverse relation calling <code>remove()</code> does not remove the child model, but instead nulls it ForeignKey value.</p> <pre><code># continuing from above\nawait department.courses.remove(course)\nassert len(department.courses) == 0\n# course still exists and was saved in remove\nassert course.pk is not None\nassert course.department is None\n\n# to remove child from db\nawait course.delete()\n</code></pre> <p>But if you want to clear the relation and delete the child at the same time you can issue:</p> <pre><code># this will not only clear the relation \n# but also delete related course from db\nawait department.courses.remove(course, keep_reversed=False)\n</code></pre>"},{"location":"relations/foreign-key/#clear","title":"clear","text":"<p>Removal of all related models in one call.</p> <p>Like with remove, by default, <code>clear()</code> nulls the ForeigKey column on child model (all, not matter if they are loaded or not).</p> <pre><code># nulls department column on all courses related to this department\nawait department.courses.clear()\n</code></pre> <p>If you want to remove the children altogether from the database, set <code>keep_reversed=False</code></p> <pre><code># deletes from db all courses related to this department \nawait department.courses.clear(keep_reversed=False)\n</code></pre>"},{"location":"relations/foreign-key/#querysetproxy","title":"QuerysetProxy","text":"<p>Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query.</p> <p>To read which methods of QuerySet are available read below querysetproxy</p>"},{"location":"relations/foreign-key/#related_name","title":"related_name","text":"<p>You can overwrite related model field name by providing <code>related_name</code> parameter like below:</p> <pre><code>from typing import Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Department] = ormar.ForeignKey(\n        Department, related_name=\"my_courses\"\n    )\n\n\ndepartment = Department(name=\"Science\")\ncourse = Course(name=\"Math\", completed=False, department=department)\n\nprint(department.my_courses[0])\n# Will produce:\n# Course(id=None,\n#        name='Math',\n#        completed=False,\n#        department=Department(id=None, name='Science'))\n</code></pre> <p>Tip</p> <p>The reverse relation on access returns list of <code>wekref.proxy</code> to avoid circular references.</p> <p>Warning</p> <p>When you provide multiple relations to the same model <code>ormar</code> can no longer auto generate the <code>related_name</code> for you. Therefore, in that situation you have to provide <code>related_name</code> for all but one (one can be default and generated) or all related fields.</p>"},{"location":"relations/foreign-key/#referential-actions","title":"Referential Actions","text":"<p>When an object referenced by a ForeignKey is changed (deleted or updated), ormar will set the SQL constraint specified by the <code>ondelete</code> and <code>onupdate</code> argument.</p> <p>The possible values for <code>ondelete</code> and <code>onupdate</code> are found in <code>ormar.ReferentialAction</code>:</p> <p>Note</p> <p>Instead of <code>ormar.ReferentialAction</code>, you can directly pass string values to these two arguments, but this is not recommended because it will break the integrity.</p>"},{"location":"relations/foreign-key/#cascade","title":"CASCADE","text":"<p>Whenever rows in the parent (referenced) table are deleted (or updated), the respective rows of the child (referencing) table with a matching foreign key column will be deleted (or updated) as well. This is called a cascade delete (or update).</p>"},{"location":"relations/foreign-key/#restrict","title":"RESTRICT","text":"<p>A value cannot be updated or deleted when a row exists in a referencing or child table that references the value in the referenced table.</p> <p>Similarly, a row cannot be deleted as long as there is a reference to it from a referencing or child table.</p>"},{"location":"relations/foreign-key/#set_null","title":"SET_NULL","text":"<p>Set the ForeignKey to <code>None</code>; this is only possible if <code>nullable</code> is True.</p>"},{"location":"relations/foreign-key/#set_default","title":"SET_DEFAULT","text":"<p>Set the ForeignKey to its default value; a <code>server_default</code> for the ForeignKey must be set.</p> <p>Note</p> <p>Note that the <code>default</code> value is not allowed and you must do this through <code>server_default</code>, which you can read about in this section.</p>"},{"location":"relations/foreign-key/#do_nothing","title":"DO_NOTHING","text":"<p>Take <code>NO ACTION</code>; NO ACTION and RESTRICT are very much alike. The main difference between NO ACTION and RESTRICT is that with NO ACTION the referential integrity check is done after trying to alter the table. RESTRICT does the check before trying to execute the UPDATE or DELETE statement. Both referential actions act the same if the referential integrity check fails: the UPDATE or DELETE statement will result in an error.</p>"},{"location":"relations/foreign-key/#relation-setup","title":"Relation Setup","text":"<p>You have several ways to set-up a relationship connection.</p>"},{"location":"relations/foreign-key/#model-instance","title":"<code>Model</code> instance","text":"<p>The most obvious one is to pass a related <code>Model</code> instance to the constructor.</p> <pre><code>from typing import Dict, Optional, Union\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Union[Department, Dict]] = ormar.ForeignKey(Department)\n\n\ndepartment = Department(name=\"Science\")\n\n# set up a relation with actual Model instance\ncourse = Course(name=\"Math\", completed=False, department=department)\n\n# set up  relation with only related model pk value\ncourse2 = Course(name=\"Math II\", completed=False, department=department.pk)\n\n# set up a relation with dictionary corresponding to related model\ncourse3 = Course(name=\"Math III\", completed=False, department=department.model_dump())\n\n# explicitly set up None\ncourse4 = Course(name=\"Math III\", completed=False, department=None)\n</code></pre>"},{"location":"relations/foreign-key/#primary-key-value","title":"Primary key value","text":"<p>You can setup the relation also with just the pk column value of the related model.</p> <pre><code>from typing import Dict, Optional, Union\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Union[Department, Dict]] = ormar.ForeignKey(Department)\n\n\ndepartment = Department(name=\"Science\")\n\n# set up a relation with actual Model instance\ncourse = Course(name=\"Math\", completed=False, department=department)\n\n# set up  relation with only related model pk value\ncourse2 = Course(name=\"Math II\", completed=False, department=department.pk)\n\n# set up a relation with dictionary corresponding to related model\ncourse3 = Course(name=\"Math III\", completed=False, department=department.model_dump())\n\n# explicitly set up None\ncourse4 = Course(name=\"Math III\", completed=False, department=None)\n</code></pre>"},{"location":"relations/foreign-key/#dictionary","title":"Dictionary","text":"<p>Next option is with a dictionary of key-values of the related model.</p> <p>You can build the dictionary yourself or get it from existing model with <code>model_dump()</code> method.</p> <pre><code>from typing import Dict, Optional, Union\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Union[Department, Dict]] = ormar.ForeignKey(Department)\n\n\ndepartment = Department(name=\"Science\")\n\n# set up a relation with actual Model instance\ncourse = Course(name=\"Math\", completed=False, department=department)\n\n# set up  relation with only related model pk value\ncourse2 = Course(name=\"Math II\", completed=False, department=department.pk)\n\n# set up a relation with dictionary corresponding to related model\ncourse3 = Course(name=\"Math III\", completed=False, department=department.model_dump())\n\n# explicitly set up None\ncourse4 = Course(name=\"Math III\", completed=False, department=None)\n</code></pre>"},{"location":"relations/foreign-key/#none","title":"None","text":"<p>Finally you can explicitly set it to None (default behavior if no value passed).</p> <pre><code>from typing import Dict, Optional, Union\n\nimport databases\nimport ormar\nimport sqlalchemy\n\ndatabase = databases.Database(\"sqlite:///db.sqlite\")\nmetadata = sqlalchemy.MetaData()\n\n\nclass Department(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n\n\nclass Course(ormar.Model):\n    ormar_config = ormar.OrmarConfig(\n        database=database,\n        metadata=metadata,\n    )\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    completed: bool = ormar.Boolean(default=False)\n    department: Optional[Union[Department, Dict]] = ormar.ForeignKey(Department)\n\n\ndepartment = Department(name=\"Science\")\n\n# set up a relation with actual Model instance\ncourse = Course(name=\"Math\", completed=False, department=department)\n\n# set up  relation with only related model pk value\ncourse2 = Course(name=\"Math II\", completed=False, department=department.pk)\n\n# set up a relation with dictionary corresponding to related model\ncourse3 = Course(name=\"Math III\", completed=False, department=department.model_dump())\n\n# explicitly set up None\ncourse4 = Course(name=\"Math III\", completed=False, department=None)\n</code></pre> <p>Warning</p> <p>In all not None cases the primary key value for related model has to exist in database.</p> <p>Otherwise an IntegrityError will be raised by your database driver library.</p>"},{"location":"relations/many-to-many/","title":"ManyToMany","text":"<p><code>ManyToMany(to, through)</code> has required parameters <code>to</code> and optional <code>through</code> that takes target and relation <code>Model</code> classes.  </p> <p>Sqlalchemy column and Type are automatically taken from target <code>Model</code>.</p> <ul> <li>Sqlalchemy column: class of a target <code>Model</code> primary key column  </li> <li>Type (used for pydantic): type of a target <code>Model</code> </li> </ul>"},{"location":"relations/many-to-many/#defining-models","title":"Defining Models","text":"<pre><code>from typing import List, Optional\n\nimport databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Author(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"authors\")\n\n    id: int = ormar.Integer(primary_key=True)\n    first_name: str = ormar.String(max_length=80)\n    last_name: str = ormar.String(max_length=80)\n\n\nclass Category(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n\n\nclass Post(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"posts\")\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories: Optional[List[Category]] = ormar.ManyToMany(Category)\n    author: Optional[Author] = ormar.ForeignKey(Author)\n</code></pre> <p>Create sample data: <pre><code>guido = await Author.objects.create(first_name=\"Guido\", last_name=\"Van Rossum\")\npost = await Post.objects.create(title=\"Hello, M2M\", author=guido)\nnews = await Category.objects.create(name=\"News\")\n</code></pre></p>"},{"location":"relations/many-to-many/#reverse-relation","title":"Reverse relation","text":"<p><code>ForeignKey</code> fields are automatically registering reverse side of the relation.</p> <p>By default it's child (source) <code>Model</code> name + s, like <code>posts</code> in snippet below: </p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n\n\nclass Post(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories: Optional[List[Category]] = ormar.ManyToMany(Category)\n\n# create some sample data\npost = await Post.objects.create(title=\"Hello, M2M\")\nnews = await Category.objects.create(name=\"News\")\nawait post.categories.add(news)\n\n# now you can query and access from both sides:\npost_check = Post.objects.select_related(\"categories\").get()\nassert post_check.categories[0] == news\n\n# query through auto registered reverse side\ncategory_check = Category.objects.select_related(\"posts\").get()\nassert category_check.posts[0] == post\n</code></pre> <p>Reverse relation exposes API to manage related objects also from parent side.</p>"},{"location":"relations/many-to-many/#related_name","title":"related_name","text":"<p>By default, the related_name is generated in the same way as for the <code>ForeignKey</code> relation (class.name.lower()+'s'),  but in the same way you can overwrite this name by providing <code>related_name</code> parameter like below:</p> <pre><code>categories: Optional[Union[Category, List[Category]]] = ormar.ManyToMany(\n        Category, through=PostCategory, related_name=\"new_categories\"\n    )\n</code></pre> <p>Warning</p> <p>When you provide multiple relations to the same model <code>ormar</code> can no longer auto generate the <code>related_name</code> for you. Therefore, in that situation you have to provide <code>related_name</code> for all but one (one can be default and generated) or all related fields.</p>"},{"location":"relations/many-to-many/#skipping-reverse-relation","title":"Skipping reverse relation","text":"<p>If you are sure you don't want the reverse relation you can use <code>skip_reverse=True</code>  flag of the <code>ManyToMany</code>.</p> <p>If you set <code>skip_reverse</code> flag internally the field is still registered on the other  side of the relationship so you can:</p> <ul> <li><code>filter</code> by related models fields from reverse model</li> <li><code>order_by</code> by related models fields from reverse model </li> </ul> <p>But you cannot:</p> <ul> <li>access the related field from reverse model with <code>related_name</code></li> <li>even if you <code>select_related</code> from reverse side of the model the returned models won't be populated in reversed instance (the join is not prevented so you still can <code>filter</code> and <code>order_by</code> over the relation)</li> <li>the relation won't be populated in <code>model_dump()</code> and <code>json()</code></li> <li>you cannot pass the nested related objects when populating from dictionary or json (also through <code>fastapi</code>). It will be either ignored or error will be raised depending on <code>extra</code> setting in pydantic <code>Config</code>.</li> </ul> <p>Example:</p> <pre><code>class Category(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=40)\n\n\nclass Post(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories: Optional[List[Category]] = ormar.ManyToMany(Category, skip_reverse=True)\n\n# create some sample data\npost = await Post.objects.create(title=\"Hello, M2M\")\nnews = await Category.objects.create(name=\"News\")\nawait post.categories.add(news)\n\nassert post.categories[0] == news  # ok\nassert news.posts  # Attribute error!\n\n# but still can use in order_by\ncategories = (\n    await Category.objects.select_related(\"posts\").order_by(\"posts__title\").all()\n)\nassert categories[0].first_name == \"Test\"\n\n# note that posts are not populated for author even if explicitly\n# included in select_related - note no posts in model_dump()\nassert news.model_dump(exclude={\"id\"}) == {\"name\": \"News\"}\n\n# still can filter through fields of related model\ncategories = await Category.objects.filter(posts__title=\"Hello, M2M\").all()\nassert categories[0].name == \"News\"\nassert len(categories) == 1\n</code></pre>"},{"location":"relations/many-to-many/#through-model","title":"Through Model","text":"<p>Optionally if you want to add additional fields you can explicitly create and pass the through model class.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Category(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"categories\")\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n\nclass PostCategory(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"posts_x_categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    sort_order: int = ormar.Integer(nullable=True)\n    param_name: str = ormar.String(default=\"Name\", max_length=200)\n\n\nclass Post(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories = ormar.ManyToMany(Category, through=PostCategory)\n</code></pre> <p>Warning</p> <p>Note that even of you do not provide through model it's going to be created for you automatically and  still has to be included in example in <code>alembic</code> migrations. </p> <p>Tip</p> <p>Note that you need to provide <code>through</code> model if you want to    customize the <code>Through</code> model name or the database table name of this model.</p> <p>If you do not provide the Through field it will be generated for you. </p> <p>The default naming convention is:</p> <ul> <li>for class name it's union of both classes name (parent+other) so in example above     it would be <code>PostCategory</code></li> <li>for table name it similar but with underscore in between and s in the end of class     lowercase name, in example above would be <code>posts_categorys</code></li> </ul>"},{"location":"relations/many-to-many/#customizing-through-relation-names","title":"Customizing Through relation names","text":"<p>By default <code>Through</code> model relation names default to related model name in lowercase.</p> <p>So in example like this: <pre><code>... # course declaration omitted\nclass Student(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    courses = ormar.ManyToMany(Course)\n\n# will produce default Through model like follows (example simplified)\nclass StudentCourse(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"students_courses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    student = ormar.ForeignKey(Student) # default name\n    course = ormar.ForeignKey(Course)  # default name\n</code></pre></p> <p>To customize the names of fields/relation in Through model now you can use new parameters to <code>ManyToMany</code>:</p> <ul> <li><code>through_relation_name</code> - name of the field leading to the model in which <code>ManyToMany</code> is declared</li> <li><code>through_reverse_relation_name</code> - name of the field leading to the model to which <code>ManyToMany</code> leads to</li> </ul> <p>Example:</p> <pre><code>... # course declaration omitted\nbase_ormar_config = ormar.OrmarConfig(\n    database=databases.Database(\"sqlite:///db.sqlite\"),\n    metadata=sqlalchemy.MetaData(),\n)\n\n\nclass Student(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    courses = ormar.ManyToMany(Course,\n                               through_relation_name=\"student_id\",\n                               through_reverse_relation_name=\"course_id\")\n\n# will produce Through model like follows (example simplified)\nclass StudentCourse(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename=\"student_courses\")\n\n    id: int = ormar.Integer(primary_key=True)\n    student_id = ormar.ForeignKey(Student) # set by through_relation_name\n    course_id = ormar.ForeignKey(Course)  # set by through_reverse_relation_name\n</code></pre> <p>Note</p> <p>Note that explicitly declaring relations in Through model is forbidden, so even if you provide your own custom Through model you cannot change the names there and you need to use same <code>through_relation_name</code> and <code>through_reverse_relation_name</code> parameters.</p>"},{"location":"relations/many-to-many/#through-fields","title":"Through Fields","text":"<p>The through field is auto added to the reverse side of the relation. </p> <p>The exposed field is named as lowercase <code>Through</code> class name.</p> <p>The exposed field explicitly has no relations loaded as the relation is already populated in <code>ManyToMany</code> field, so it's useful only when additional fields are provided on <code>Through</code> model.</p> <p>In a sample model setup as following:</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Category(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"categories\")\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n\nclass PostCategory(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"posts_x_categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    sort_order: int = ormar.Integer(nullable=True)\n    param_name: str = ormar.String(default=\"Name\", max_length=200)\n\n\nclass Post(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories = ormar.ManyToMany(Category, through=PostCategory)\n</code></pre> <p>the through field can be used as a normal model field in most of the QuerySet operations.</p> <p>Note that through field is attached only to related side of the query so:</p> <pre><code>post = await Post.objects.select_related(\"categories\").get()\n# source model has no through field\nassert post.postcategory is None\n# related models have through field\nassert post.categories[0].postcategory is not None\n\n# same is applicable for reversed query\ncategory = await Category.objects.select_related(\"posts\").get()\nassert category.postcategory is None\nassert category.posts[0].postcategory is not None\n</code></pre> <p>Through field can be used for filtering the data. <pre><code>post = (\n        await Post.objects.select_related(\"categories\")\n        .filter(postcategory__sort_order__gt=1)\n        .get()\n        )\n</code></pre></p> <p>Tip</p> <p>Note that despite that the actual instance is not populated on source model, in queries, order by statements etc you can access through model from both sides. So below query has exactly the same effect (note access through <code>categories</code>)</p> <pre><code>post = (\n    await Post.objects.select_related(\"categories\")\n    .filter(categories__postcategory__sort_order__gt=1)\n    .get()\n    )\n</code></pre> <p>Through model can be used in order by queries. <pre><code>post = (\n        await Post.objects.select_related(\"categories\")\n        .order_by(\"-postcategory__sort_order\")\n        .get()\n    )\n</code></pre></p> <p>You can also select subset of the columns in a normal <code>QuerySet</code> way with <code>fields</code>  and <code>exclude_fields</code>.</p> <pre><code>post2 = (\n        await Post.objects.select_related(\"categories\")\n        .exclude_fields(\"postcategory__param_name\")\n        .get()\n        )\n</code></pre> <p>Warning</p> <p>Note that because through fields explicitly nullifies all relation fields, as relation is populated in ManyToMany field, you should not use the standard model methods like <code>save()</code> and <code>update()</code> before re-loading the field from database.</p> <p>If you want to modify the through field in place remember to reload it from database. Otherwise you will set relations to None so effectively make the field useless!</p> <p><pre><code># always reload the field before modification\nawait post2.categories[0].postcategory.load()\n# only then update the field\nawait post2.categories[0].postcategory.update(sort_order=3)\n</code></pre> Note that reloading the model effectively reloads the relations as <code>pk_only</code> models  (only primary key is set) so they are not fully populated, but it's enough to preserve  the relation on update.</p> <p>Warning</p> <p>If you use i.e. <code>fastapi</code> the partially loaded related models on through field might cause <code>pydantic</code> validation errors (that's the primary reason why they are not populated by default). So either you need to exclude the related fields in your response, or fully load the related models. In example above it would mean: <pre><code>await post2.categories[0].postcategory.post.load()\nawait post2.categories[0].postcategory.category.load()\n</code></pre> Alternatively you can use <code>load_all()</code>: <pre><code>await post2.categories[0].postcategory.load_all()\n</code></pre></p> <p>Preferred way of update is through queryset proxy <code>update()</code> method</p> <pre><code># filter the desired related model with through field and update only through field params\nawait post2.categories.filter(name='Test category').update(postcategory={\"sort_order\": 3})\n</code></pre>"},{"location":"relations/many-to-many/#relation-methods","title":"Relation methods","text":""},{"location":"relations/many-to-many/#add","title":"add","text":"<p><code>add(item: Model, **kwargs)</code></p> <p>Allows you to add model to ManyToMany relation. </p> <pre><code># Add a category to a post.\nawait post.categories.add(news)\n# or from the other end:\nawait news.posts.add(post)\n</code></pre> <p>Warning</p> <p>In all not <code>None</code> cases the primary key value for related model has to exist in database.</p> <p>Otherwise an IntegrityError will be raised by your database driver library.</p> <p>If you declare your models with a Through model with additional fields, you can populate them during adding child model to relation.</p> <p>In order to do so, pass keyword arguments with field names and values to <code>add()</code> call.</p> <p>Note that this works only for <code>ManyToMany</code> relations.</p> <pre><code>post = await Post(title=\"Test post\").save()\ncategory = await Category(name=\"Test category\").save()\n# apart from model pass arguments referencing through model fields\nawait post.categories.add(category, sort_order=1, param_name='test')\n</code></pre>"},{"location":"relations/many-to-many/#remove","title":"remove","text":"<p>Removal of the related model one by one.</p> <p>Removes also the relation in the database.</p> <pre><code>await news.posts.remove(post)\n</code></pre>"},{"location":"relations/many-to-many/#clear","title":"clear","text":"<p>Removal of all related models in one call.</p> <p>Removes also the relation in the database.</p> <pre><code>await news.posts.clear()\n</code></pre>"},{"location":"relations/many-to-many/#querysetproxy","title":"QuerysetProxy","text":"<p>Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query.</p> <p>To read which methods of QuerySet are available read below querysetproxy</p>"},{"location":"relations/postponed-annotations/","title":"Postponed annotations","text":""},{"location":"relations/postponed-annotations/#self-referencing-models","title":"Self-referencing Models","text":"<p>When you want to reference the same model during declaration to create a  relation you need to declare the referenced model as a <code>ForwardRef</code>, as during the declaration the class is not yet ready and python by default won't let you reference it.</p> <p>Although you might be tempted to use future annotations or simply quote the name with <code>\"\"</code> it won't work as <code>ormar</code> is designed to work with explicitly declared <code>ForwardRef</code>.</p> <p>First, you need to import the required ref from typing. <pre><code>from typing import ForwardRef\n</code></pre></p> <p>Now we need a sample model and a reference to the same model,  which will be used to create a self referencing relation.</p> <pre><code># create the forwardref to model Person\nPersonRef = ForwardRef(\"Person\")\n\n\nclass Person(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    # use the forwardref as to parameter\n    supervisor: PersonRef = ormar.ForeignKey(PersonRef, related_name=\"employees\")\n</code></pre> <p>That's so simple. But before you can use the model you need to manually update the references so that they lead to the actual models.</p> <p>Warning</p> <p>If you try to use the model without updated references, <code>ModelError</code> exception will be raised. So in our example above any call like following will cause exception <pre><code># creation of model - exception\nawait Person.objects.create(name=\"Test\")\n# initialization of model - exception\nPerson2(name=\"Test\")\n# usage of model's QuerySet - exception\nawait Person2.objects.get()\n</code></pre></p> <p>To update the references call the <code>update_forward_refs</code> method on each model  with forward references, only after all related models were declared.</p> <p>So in order to make our previous example work we need just one extra line.</p> <pre><code>PersonRef = ForwardRef(\"Person\")\n\n\nclass Person(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    supervisor: PersonRef = ormar.ForeignKey(PersonRef, related_name=\"employees\")\n\n\nPerson.update_forward_refs()\n</code></pre> <p>Of course the same can be done with ManyToMany relations in exactly same way, both for to and through parameters.</p> <pre><code># declare the reference\nChildRef = ForwardRef(\"Child\")\n\nclass ChildFriend(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\nclass Child(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    # use it in relation\n    friends = ormar.ManyToMany(ChildRef, through=ChildFriend,\n                               related_name=\"also_friends\")\n\n\nChild.update_forward_refs()\n</code></pre>"},{"location":"relations/postponed-annotations/#cross-model-relations","title":"Cross model relations","text":"<p>The same mechanism and logic as for self-reference model can be used to link multiple different models between each other.</p> <p>Of course <code>ormar</code> links both sides of relation for you,  creating a reverse relation with specified (or default) <code>related_name</code>.</p> <p>But if you need two (or more) relations between any two models, that for whatever reason should be stored on both sides (so one relation is declared on one model,  and other on the second model), you need to use <code>ForwardRef</code> to achieve that.</p> <p>Look at the following simple example.</p> <pre><code># teacher is not yet defined\nTeacherRef = ForwardRef(\"Teacher\")\n\n\nclass Student(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    # so we use reference instead of actual model\n    primary_teacher: TeacherRef = ormar.ForeignKey(TeacherRef,\n                                                   related_name=\"own_students\")\n\n\nclass StudentTeacher(ormar.Model):\n    ormar_config = base_ormar_config.copy(tablename='students_x_teachers')\n\n\nclass Teacher(ormar.Model):\n    ormar_config = base_ormar_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    name: str = ormar.String(max_length=100)\n    # we need students for other relation hence the order\n    students = ormar.ManyToMany(Student, through=StudentTeacher,\n                                related_name=\"teachers\")\n\n# now the Teacher model is already defined we can update references\nStudent.update_forward_refs()\n</code></pre> <p>Warning</p> <p>Remember that <code>related_name</code> needs to be unique across related models regardless  of how many relations are defined. </p>"},{"location":"relations/queryset-proxy/","title":"QuerySetProxy","text":"<p>When access directly the related <code>ManyToMany</code> field as well as <code>ReverseForeignKey</code> returns the list of related models.</p> <p>But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model.</p> <p>Note</p> <p>By default exposed QuerySet is already filtered to return only <code>Models</code> related to parent <code>Model</code>.</p> <p>So if you issue <code>post.categories.all()</code> you will get all categories related to that post, not all in table.</p> <p>Note</p> <p>Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use <code>objects</code> attribute like in normal queries.</p> <p>So note that it's <code>post.categories.all()</code> and not <code>post.categories.objects.all()</code>.</p> <p>To learn more about available QuerySet methods visit queries</p> <p>Warning</p> <p>Querying related models from ManyToMany cleans list of related models loaded on parent model:</p> <p>Example: <code>post.categories.first()</code> will set post.categories to list of 1 related model -&gt; the one returned by first()</p> <p>Example 2: if post has 4 categories so <code>len(post.categories) == 4</code> calling <code>post.categories.limit(2).all()</code> -&gt; will load only 2 children and now <code>assert len(post.categories) == 2</code></p> <p>This happens for all QuerysetProxy methods returning data: <code>get</code>, <code>all</code> and <code>first</code> and in <code>get_or_create</code> if model already exists.</p> <p>Note that value returned by <code>create</code> or created in <code>get_or_create</code> and <code>update_or_create</code> if model does not exist will be added to relation list (not clearing it).</p>"},{"location":"relations/queryset-proxy/#read-data-from-database","title":"Read data from database","text":""},{"location":"relations/queryset-proxy/#get","title":"get","text":"<p><code>get(**kwargs): -&gt; Model</code></p> <p>To grab just one of related models filtered by name you can use <code>get(**kwargs)</code> method.</p> <pre><code># grab one category\nassert news == await post.categories.get(name=\"News\")\n\n# note that method returns the category so you can grab this value\n# but it also modifies list of related models in place\n# so regardless of what was previously loaded on parent model\n# now it has only one value -&gt; just loaded with get() call\nassert len(post.categories) == 1\nassert post.categories[0] == news\n</code></pre> <p>Tip</p> <p>Read more in queries documentation get</p>"},{"location":"relations/queryset-proxy/#get_or_create","title":"get_or_create","text":"<p><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></p> <p>Tries to get a row meeting the criteria and if <code>NoMatch</code> exception is raised it creates a new one with given kwargs and _defaults.</p> <p>Tip</p> <p>Read more in queries documentation get_or_create</p>"},{"location":"relations/queryset-proxy/#all","title":"all","text":"<p><code>all(**kwargs) -&gt; List[Optional[\"Model\"]]</code></p> <p>To get a list of related models use <code>all()</code> method.</p> <p>Note that you can filter the queryset, select related, exclude fields etc. like in normal query.</p> <pre><code># with all Queryset methods - filtering, selecting columns, counting etc.\nawait news.posts.filter(title__contains=\"M2M\").all()\nawait Category.objects.filter(posts__author=guido).get()\n\n# columns models of many to many relation can be prefetched\nnews_posts = await news.posts.select_related(\"author\").all()\nassert news_posts[0].author == guido\n</code></pre> <p>Tip</p> <p>Read more in queries documentation all</p>"},{"location":"relations/queryset-proxy/#iterate","title":"iterate","text":"<p><code>iterate(**kwargs) -&gt; AsyncGenerator[\"Model\"]</code></p> <p>To iterate on related models use <code>iterate()</code> method.</p> <p>Note that you can filter the queryset, select related, exclude fields etc. like in normal query.</p> <pre><code># iterate on categories of this post with an async generator\nasync for category in post.categories.iterate():\n    print(category.name)\n</code></pre> <p>Tip</p> <p>Read more in queries documentation iterate</p>"},{"location":"relations/queryset-proxy/#insert-update-data-into-database","title":"Insert/ update data into database","text":""},{"location":"relations/queryset-proxy/#create","title":"create","text":"<p><code>create(**kwargs): -&gt; Model</code></p> <p>Create related <code>Model</code> directly from parent <code>Model</code>.</p> <p>The link table is automatically populated, as well as relation ids in the database.</p> <pre><code># Creating columns object from instance:\nawait post.categories.create(name=\"Tips\")\nassert len(await post.categories.all()) == 2\n# newly created instance already have relation persisted in the database\n</code></pre> <p>Tip</p> <p>Read more in queries documentation create</p> <p>For <code>ManyToMany</code> relations there is an additional functionality of passing parameters that will be used to create a through model if you declared additional fields on explicitly provided Through model.</p> <p>Given sample like this:</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Category(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"categories\")\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n\nclass PostCategory(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"posts_x_categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    sort_order: int = ormar.Integer(nullable=True)\n    param_name: str = ormar.String(default=\"Name\", max_length=200)\n\n\nclass Post(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories = ormar.ManyToMany(Category, through=PostCategory)\n</code></pre> <p>You can populate fields on through model in the <code>create()</code> call in a following way:</p> <pre><code>post = await Post(title=\"Test post\").save()\nawait post.categories.create(\n    name=\"Test category1\",\n    # in arguments pass a dictionary with name of the through field and keys\n    # corresponding to through model fields\n    postcategory={\"sort_order\": 1, \"param_name\": \"volume\"},\n)\n</code></pre>"},{"location":"relations/queryset-proxy/#get_or_create_1","title":"get_or_create","text":"<p><code>get_or_create(_defaults: Optional[Dict[str, Any]] = None, **kwargs) -&gt; Tuple[Model, bool]</code></p> <p>Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs.</p> <p>Tip</p> <p>Read more in queries documentation get_or_create</p>"},{"location":"relations/queryset-proxy/#update_or_create","title":"update_or_create","text":"<p><code>update_or_create(**kwargs) -&gt; Model</code></p> <p>Updates the model, or in case there is no match in database creates a new one.</p> <p>Tip</p> <p>Read more in queries documentation update_or_create</p>"},{"location":"relations/queryset-proxy/#update","title":"update","text":"<p><code>update(**kwargs, each:bool = False) -&gt; int</code></p> <p>Updates the related model with provided keyword arguments, return number of updated rows.</p> <p>Tip</p> <p>Read more in queries documentation update</p> <p>Note that for <code>ManyToMany</code> relations update can also accept an argument with through field name and a dictionary of fields.</p> <pre><code>import databases\nimport ormar\nimport sqlalchemy\n\nDATABASE_URL = \"sqlite:///test.db\"\n\normar_base_config = ormar.OrmarConfig(\n    database=databases.Database(DATABASE_URL), metadata=sqlalchemy.MetaData()\n)\n\n\nclass Category(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"categories\")\n\n    id = ormar.Integer(primary_key=True)\n    name = ormar.String(max_length=40)\n\n\nclass PostCategory(ormar.Model):\n    ormar_config = ormar_base_config.copy(tablename=\"posts_x_categories\")\n\n    id: int = ormar.Integer(primary_key=True)\n    sort_order: int = ormar.Integer(nullable=True)\n    param_name: str = ormar.String(default=\"Name\", max_length=200)\n\n\nclass Post(ormar.Model):\n    ormar_config = ormar_base_config.copy()\n\n    id: int = ormar.Integer(primary_key=True)\n    title: str = ormar.String(max_length=200)\n    categories = ormar.ManyToMany(Category, through=PostCategory)\n</code></pre> <p>In example above you can update attributes of <code>postcategory</code> in a following call: <pre><code>await post.categories.filter(name=\"Test category3\").update(\n            postcategory={\"sort_order\": 4}\n        )\n</code></pre></p>"},{"location":"relations/queryset-proxy/#filtering-and-sorting","title":"Filtering and sorting","text":""},{"location":"relations/queryset-proxy/#filter","title":"filter","text":"<p><code>filter(*args, **kwargs) -&gt; QuerySet</code></p> <p>Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship.</p> <p>Tip</p> <p>Read more in queries documentation filter</p>"},{"location":"relations/queryset-proxy/#exclude","title":"exclude","text":"<p><code>exclude(*args, **kwargs) -&gt; QuerySet</code></p> <p>Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition.</p> <p>Tip</p> <p>Read more in queries documentation exclude</p>"},{"location":"relations/queryset-proxy/#order_by","title":"order_by","text":"<p><code>order_by(columns:Union[List, str]) -&gt; QuerySet</code></p> <p>With order_by() you can order the results from database based on your choice of fields.</p> <p>Tip</p> <p>Read more in queries documentation order_by</p>"},{"location":"relations/queryset-proxy/#joins-and-subqueries","title":"Joins and subqueries","text":""},{"location":"relations/queryset-proxy/#select_related","title":"select_related","text":"<p><code>select_related(related: Union[List, str]) -&gt; QuerySet</code></p> <p>Allows to prefetch related models during the same query.</p> <p>With select_related always only one query is run against the database, meaning that one (sometimes complicated) join is generated and later nested models are processed in python.</p> <p>Tip</p> <p>Read more in queries documentation select_related</p>"},{"location":"relations/queryset-proxy/#prefetch_related","title":"prefetch_related","text":"<p><code>prefetch_related(related: Union[List, str]) -&gt; QuerySet</code></p> <p>Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query.</p> <p>With prefetch_related always one query per Model is run against the database, meaning that you will have multiple queries executed one after another.</p> <p>Tip</p> <p>Read more in queries documentation prefetch_related</p>"},{"location":"relations/queryset-proxy/#pagination-and-rows-number","title":"Pagination and rows number","text":""},{"location":"relations/queryset-proxy/#paginate","title":"paginate","text":"<p><code>paginate(page: int, page_size: int = 20) -&gt; QuerySet</code></p> <p>Combines the offset and limit methods based on page number and size.</p> <p>Tip</p> <p>Read more in queries documentation paginate</p>"},{"location":"relations/queryset-proxy/#limit","title":"limit","text":"<p><code>limit(limit_count: int) -&gt; QuerySet</code></p> <p>You can limit the results to desired number of parent models.</p> <p>Tip</p> <p>Read more in queries documentation limit</p>"},{"location":"relations/queryset-proxy/#offset","title":"offset","text":"<p><code>offset(offset: int) -&gt; QuerySet</code></p> <p>You can offset the results by desired number of main models.</p> <p>Tip</p> <p>Read more in queries documentation offset</p>"},{"location":"relations/queryset-proxy/#selecting-subset-of-columns","title":"Selecting subset of columns","text":""},{"location":"relations/queryset-proxy/#fields","title":"fields","text":"<p><code>fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></p> <p>With fields() you can select subset of model columns to limit the data load.</p> <p>Tip</p> <p>Read more in queries documentation fields</p>"},{"location":"relations/queryset-proxy/#exclude_fields","title":"exclude_fields","text":"<p><code>exclude_fields(columns: Union[List, str, set, dict]) -&gt; QuerySet</code></p> <p>With exclude_fields() you can select subset of model columns that will be excluded to limit the data load.</p> <p>Tip</p> <p>Read more in queries documentation exclude_fields</p>"},{"location":"relations/queryset-proxy/#aggregated-functions","title":"Aggregated functions","text":""},{"location":"relations/queryset-proxy/#count","title":"count","text":"<p><code>count(distinct: bool = True) -&gt; int</code></p> <p>Returns number of rows matching the given criteria (i.e. applied with filter and exclude)</p> <p>Tip</p> <p>Read more in queries documentation count</p>"},{"location":"relations/queryset-proxy/#exists","title":"exists","text":"<p><code>exists() -&gt; bool</code></p> <p>Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude)</p> <p>Tip</p> <p>Read more in queries documentation exists</p>"}]}